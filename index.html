<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><title>Instant Clojure Cheatsheet</title><link href="css/bootstrap.min.css" rel="stylesheet" type="text/css"><link href="css/application.css" rel="stylesheet" type="text/css"></head><body><div class="container"><div class="row"><span class="span9"><div class="navbar"><div class="navbar-inner"><div class="container"><div class="nav-collapse collapse"><ul class="nav"><li><a>Instant Clojure Cheatsheet</a></li></ul></div></div></div></div></span><input class="span10" id="filter" placeholder="filter" type="text"></div><div><div class="span4"><div><div class="row"><div class="namespace"><h4>G__8127</h4></div></div><div class="row"><div class="namespace"><h4>clj-stacktrace.core</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.core&lt;/i&gt;&lt;b&gt;parse-exception&lt;/b&gt; ([e])&lt;br&gt; Returns a Clojure map providing usefull informaiton about the exception.&lt;br&gt;  The map has keys&lt;br&gt;  :class        Class of the exception.&lt;br&gt;  :message      Regular exception message string.&lt;br&gt;  :trace-elems  Parsed stack trace elems, see parse-trace-elem.&lt;br&gt;  :cause        See parse-cause-exception.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-exception&amp;lt;br&amp;gt;  &amp;quot;Returns a Clojure map providing usefull informaiton about the exception.&amp;lt;br&amp;gt;  The map has keys&amp;lt;br&amp;gt;  :class        Class of the exception.&amp;lt;br&amp;gt;  :message      Regular exception message string.&amp;lt;br&amp;gt;  :trace-elems  Parsed stack trace elems, see parse-trace-elem.&amp;lt;br&amp;gt;  :cause        See parse-cause-exception.&amp;quot;&amp;lt;br&amp;gt;  [^Throwable e]&amp;lt;br&amp;gt;  (let [parsed-elems (parse-trace-elems (.getStackTrace e))&amp;lt;br&amp;gt;        base {:class       (class e)&amp;lt;br&amp;gt;              :message     (.getMessage e)&amp;lt;br&amp;gt;              :trace-elems parsed-elems}]&amp;lt;br&amp;gt;    (if-let [cause (.getCause e)]&amp;lt;br&amp;gt;      (assoc base :cause (parse-cause-exception cause parsed-elems))&amp;lt;br&amp;gt;      base)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-exception</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.core&lt;/i&gt;&lt;b&gt;parse-trace-elem&lt;/b&gt; ([elem])&lt;br&gt; Returns a map of information about the java trace element.&lt;br&gt;  All returned maps have the keys:&lt;br&gt;  :file      String of source file name.&lt;br&gt;  :line      Number of source line number of the enclosing form.&lt;br&gt;  Additionally for elements from Java code:&lt;br&gt;  :java      true, to indicate a Java elem.&lt;br&gt;  :class     String of the name of the class to which the method belongs.&lt;br&gt;  Additionally for elements from Clojure code:&lt;br&gt;  :clojure   true, to inidcate a Clojure elem.&lt;br&gt;  :ns        String representing the namespace of the function.&lt;br&gt;  :fn        String representing the name of the enclosing var for the function.&lt;br&gt;  :anon-fn   true iff the function is an anonymous inner fn.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-trace-elem&amp;lt;br&amp;gt;  &amp;quot;Returns a map of information about the java trace element.&amp;lt;br&amp;gt;  All returned maps have the keys:&amp;lt;br&amp;gt;  :file      String of source file name.&amp;lt;br&amp;gt;  :line      Number of source line number of the enclosing form.&amp;lt;br&amp;gt;  Additionally for elements from Java code:&amp;lt;br&amp;gt;  :java      true, to indicate a Java elem.&amp;lt;br&amp;gt;  :class     String of the name of the class to which the method belongs.&amp;lt;br&amp;gt;  Additionally for elements from Clojure code:&amp;lt;br&amp;gt;  :clojure   true, to inidcate a Clojure elem.&amp;lt;br&amp;gt;  :ns        String representing the namespace of the function.&amp;lt;br&amp;gt;  :fn        String representing the name of the enclosing var for the function.&amp;lt;br&amp;gt;  :anon-fn   true iff the function is an anonymous inner fn.&amp;quot;&amp;lt;br&amp;gt;  [^StackTraceElement elem]&amp;lt;br&amp;gt;  (let [class-name (.getClassName elem)&amp;lt;br&amp;gt;        file       (.getFileName  elem)&amp;lt;br&amp;gt;        line       (let [l (.getLineNumber elem)] (if (pos? l) l))&amp;lt;br&amp;gt;        parsed     {:file file :line line}]&amp;lt;br&amp;gt;    (if (clojure-code? class-name file)&amp;lt;br&amp;gt;      (assoc parsed&amp;lt;br&amp;gt;        :clojure true&amp;lt;br&amp;gt;        :ns      (clojure-ns class-name)&amp;lt;br&amp;gt;        :fn      (clojure-fn class-name)&amp;lt;br&amp;gt;        :anon-fn (clojure-anon-fn? class-name))&amp;lt;br&amp;gt;      (assoc parsed&amp;lt;br&amp;gt;        :java true&amp;lt;br&amp;gt;        :class class-name&amp;lt;br&amp;gt;        :method (.getMethodName elem)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-trace-elem</a>[elem]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.core&lt;/i&gt;&lt;b&gt;parse-trace-elems&lt;/b&gt; ([elems])&lt;br&gt; Returns a seq of maps providing usefull information about the java stack&lt;br&gt;  trace elements. See parse-trace-elem.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-trace-elems&amp;lt;br&amp;gt;  &amp;quot;Returns a seq of maps providing usefull information about the java stack&amp;lt;br&amp;gt;  trace elements. See parse-trace-elem.&amp;quot;&amp;lt;br&amp;gt;  [elems]&amp;lt;br&amp;gt;  (map parse-trace-elem elems))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-trace-elems</a>[elems]</div></div></div><div class="row"><div class="namespace"><h4>clj-stacktrace.repl</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;clojure-method-str&lt;/b&gt; ([parsed])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn clojure-method-str [parsed]&amp;lt;br&amp;gt;  (str (:ns parsed) &amp;quot;/&amp;quot; (:fn parsed) (if (:anon-fn parsed) &amp;quot;[fn]&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">clojure-method-str</a>[parsed]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;elem-color&lt;/b&gt; ([elem])&lt;br&gt; Returns a symbol identifying the color appropriate for the given trace elem.&lt;br&gt;  :green   All Java elems&lt;br&gt;  :yellow  Any fn in the user or repl* namespaces (i.e. entered at REPL)&lt;br&gt;  :blue    Any fn in clojure.* (e.g. clojure.core, clojure.contrib.*)&lt;br&gt;  :magenta Anything else - i.e. Clojure libraries and app code.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn elem-color&amp;lt;br&amp;gt;  &amp;quot;Returns a symbol identifying the color appropriate for the given trace elem.&amp;lt;br&amp;gt;  :green   All Java elems&amp;lt;br&amp;gt;  :yellow  Any fn in the user or repl* namespaces (i.e. entered at REPL)&amp;lt;br&amp;gt;  :blue    Any fn in clojure.* (e.g. clojure.core, clojure.contrib.*)&amp;lt;br&amp;gt;  :magenta Anything else - i.e. Clojure libraries and app code.&amp;quot;&amp;lt;br&amp;gt;  [elem]&amp;lt;br&amp;gt;  (if (:java elem)&amp;lt;br&amp;gt;    (if (re-find #&amp;quot;^clojure\.&amp;quot; (:class elem))&amp;lt;br&amp;gt;      :cyan&amp;lt;br&amp;gt;      :blue)&amp;lt;br&amp;gt;    (cond (nil? (:ns elem)) :yellow&amp;lt;br&amp;gt;          (re-find #&amp;quot;^(user|repl)&amp;quot; (:ns elem)) :yellow&amp;lt;br&amp;gt;          (re-find #&amp;quot;^clojure\.&amp;quot; (:ns elem)) :magenta&amp;lt;br&amp;gt;          :user-code :green)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">elem-color</a>[elem]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;find-source-width&lt;/b&gt; ([excp])&lt;br&gt; Returns the width of the longest source-string among all trace elems of the&lt;br&gt;  excp and its causes.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-source-width&amp;lt;br&amp;gt;  &amp;quot;Returns the width of the longest source-string among all trace elems of the&amp;lt;br&amp;gt;  excp and its causes.&amp;quot;&amp;lt;br&amp;gt;  [excp]&amp;lt;br&amp;gt;  (let [this-source-width (-&amp;gt;&amp;gt; (:trace-elems excp)&amp;lt;br&amp;gt;                               (map (comp count source-str))&amp;lt;br&amp;gt;                               (sort)&amp;lt;br&amp;gt;                               (utils/fence))]&amp;lt;br&amp;gt;    (if-let [cause (:cause excp)]&amp;lt;br&amp;gt;      (max this-source-width (find-source-width cause))&amp;lt;br&amp;gt;      this-source-width)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-source-width</a>[excp]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;java-method-str&lt;/b&gt; ([parsed])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn java-method-str [parsed]&amp;lt;br&amp;gt;  (str (:class parsed) &amp;quot;.&amp;quot; (:method parsed)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">java-method-str</a>[parsed]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;method-str&lt;/b&gt; ([parsed])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn method-str [parsed]&amp;lt;br&amp;gt;  (if (:java parsed) (java-method-str parsed) (clojure-method-str parsed)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">method-str</a>[parsed]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;pst&lt;/b&gt; ([&amp; [e]])&lt;br&gt; Print to *out* a pretty stack trace for an exception, by default *e.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pst&amp;lt;br&amp;gt;  &amp;quot;Print to *out* a pretty stack trace for an exception, by default *e.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; [e]]&amp;lt;br&amp;gt;  (pst-on *out* false (or e *e)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pst</a>[& [e]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;pst+&lt;/b&gt; ([&amp; [e]])&lt;br&gt; Like pst, but with ANSI terminal color coding.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pst+&amp;lt;br&amp;gt;  &amp;quot;Like pst, but with ANSI terminal color coding.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; [e]]&amp;lt;br&amp;gt;  (pst-on *out* true (or e *e)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pst+</a>[& [e]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;pst-caused-by-on&lt;/b&gt; ([on color?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pst-caused-by-on&amp;lt;br&amp;gt;  [^java.io.Writer on color?]&amp;lt;br&amp;gt;  (.append on ^String (colored color? :red &amp;quot;Caused by: &amp;quot;))&amp;lt;br&amp;gt;  (.flush on))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pst-caused-by-on</a>[on color?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;pst-class-on&lt;/b&gt; ([on color? class])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pst-class-on [^java.io.Writer on color? ^Class class]&amp;lt;br&amp;gt;  (.append on ^String (colored color? :red (str (.getName class) &amp;quot;: &amp;quot;)))&amp;lt;br&amp;gt;  (.flush on))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pst-class-on</a>[on color? class]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;pst-elem-str&lt;/b&gt; ([color? parsed-elem print-width])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pst-elem-str&amp;lt;br&amp;gt;  [color? parsed-elem print-width]&amp;lt;br&amp;gt;  (colored color? (elem-color parsed-elem)&amp;lt;br&amp;gt;           (str (utils/rjust print-width (source-str parsed-elem))&amp;lt;br&amp;gt;                &amp;quot; &amp;quot; (method-str parsed-elem))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pst-elem-str</a>[color? parsed-elem print-width]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;pst-elems-on&lt;/b&gt; ([on color? parsed-elems &amp; [source-width]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pst-elems-on&amp;lt;br&amp;gt;  [^java.io.Writer on color? parsed-elems &amp;amp; [source-width]]&amp;lt;br&amp;gt;  (let [print-width (+ 6 (or source-width&amp;lt;br&amp;gt;                             (utils/fence&amp;lt;br&amp;gt;                              (sort&amp;lt;br&amp;gt;                               (map #(.length ^String %)&amp;lt;br&amp;gt;                                    (map source-str parsed-elems))))))]&amp;lt;br&amp;gt;    (doseq [parsed-elem parsed-elems]&amp;lt;br&amp;gt;      (.append on ^String (pst-elem-str color? parsed-elem print-width))&amp;lt;br&amp;gt;      (.append on &amp;quot;\n&amp;quot;)&amp;lt;br&amp;gt;      (.flush on))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pst-elems-on</a>[on color? parsed-elems & [source-width]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;pst-message-on&lt;/b&gt; ([on color? message])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pst-message-on [^java.io.Writer on color? message]&amp;lt;br&amp;gt;  (.append on ^String (colored color? :red message))&amp;lt;br&amp;gt;  (.append on &amp;quot;\n&amp;quot;)&amp;lt;br&amp;gt;  (.flush on))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pst-message-on</a>[on color? message]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;pst-on&lt;/b&gt; ([on color? e])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pst-on [on color? e]&amp;lt;br&amp;gt;  &amp;quot;Prints to the given Writer on a pretty stack trace for the given exception e,&amp;lt;br&amp;gt;  ANSI colored if color? is true.&amp;quot;&amp;lt;br&amp;gt;  (let [exec         (parse-exception e)&amp;lt;br&amp;gt;        source-width (find-source-width exec)]&amp;lt;br&amp;gt;    (pst-class-on on color? (:class exec))&amp;lt;br&amp;gt;    (pst-message-on on color? (:message exec))&amp;lt;br&amp;gt;    (pst-elems-on on color? (:trace-elems exec) source-width)&amp;lt;br&amp;gt;    (if-let [cause (:cause exec)]&amp;lt;br&amp;gt;      (pst-cause-on on color? cause source-width))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pst-on</a>[on color? e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;pst-str&lt;/b&gt; ([&amp; [e]])&lt;br&gt; Like pst, but returns a string instead of printing that string to *out*&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pst-str&amp;lt;br&amp;gt;  &amp;quot;Like pst, but returns a string instead of printing that string to *out*&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; [e]]&amp;lt;br&amp;gt;  (let [sw (java.io.StringWriter.)]&amp;lt;br&amp;gt;    (pst-on sw false (or e *e))&amp;lt;br&amp;gt;    (str sw)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pst-str</a>[& [e]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.repl&lt;/i&gt;&lt;b&gt;source-str&lt;/b&gt; ([parsed])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn source-str [parsed]&amp;lt;br&amp;gt;  (if (and (:file parsed) (:line parsed))&amp;lt;br&amp;gt;    (str (:file parsed) &amp;quot;:&amp;quot; (:line parsed))&amp;lt;br&amp;gt;    &amp;quot;(Unknown Source)&amp;quot;))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">source-str</a>[parsed]</div></div></div><div class="row"><div class="namespace"><h4>clj-stacktrace.utils</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.utils&lt;/i&gt;&lt;b&gt;fence&lt;/b&gt; ([coll])&lt;br&gt; Compute the upper outer fence for the given coll. coll must be sorted.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fence&amp;lt;br&amp;gt;  &amp;quot;Compute the upper outer fence for the given coll. coll must be sorted.&amp;quot;&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;  (let [q1  (quartile1 coll)&amp;lt;br&amp;gt;        q3  (quartile3 coll)&amp;lt;br&amp;gt;        iqr (- q3 q1)]&amp;lt;br&amp;gt;    (int (+ q3 (/ (* 3 iqr) 2)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fence</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.utils&lt;/i&gt;&lt;b&gt;quartile1&lt;/b&gt; ([coll])&lt;br&gt; Compute the first quartile for the given collection according to&lt;br&gt;  Tukey (Hoaglin et al. 1983). coll must be sorted.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn quartile1&amp;lt;br&amp;gt;  &amp;quot;Compute the first quartile for the given collection according to&amp;lt;br&amp;gt;  Tukey (Hoaglin et al. 1983). coll must be sorted.&amp;quot;&amp;lt;br&amp;gt;  ;; Hoaglin, D.; Mosteller, F.; and Tukey, J. (Ed.).&amp;lt;br&amp;gt;  ;; Understanding Robust and Exploratory Data Analysis.&amp;lt;br&amp;gt;  ;; New York: Wiley, pp. 39, 54, 62, 223, 1983.&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;  (let [c (count coll)]&amp;lt;br&amp;gt;    (nth coll (if (even? c)&amp;lt;br&amp;gt;                (/ (+ c 2) 4)&amp;lt;br&amp;gt;                (/ (+ c 3) 4)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">quartile1</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.utils&lt;/i&gt;&lt;b&gt;quartile3&lt;/b&gt; ([coll])&lt;br&gt; Compute the third quartile for the given collection according to&lt;br&gt;  Tukey (Hoaglin et al. 1983). coll must be sorted.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn quartile3&amp;lt;br&amp;gt;  &amp;quot;Compute the third quartile for the given collection according to&amp;lt;br&amp;gt;  Tukey (Hoaglin et al. 1983). coll must be sorted.&amp;quot;&amp;lt;br&amp;gt;  ;; Hoaglin, D.; Mosteller, F.; and Tukey, J. (Ed.).&amp;lt;br&amp;gt;  ;; Understanding Robust and Exploratory Data Analysis.&amp;lt;br&amp;gt;  ;; New York: Wiley, pp. 39, 54, 62, 223, 1983.&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;  (let [c (count coll)]&amp;lt;br&amp;gt;    (nth coll (if (even? c)&amp;lt;br&amp;gt;                (/ (+ (* 3 c) 2) 4)&amp;lt;br&amp;gt;                (/ (inc (* 3 c)) 4)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">quartile3</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-stacktrace.utils&lt;/i&gt;&lt;b&gt;rjust&lt;/b&gt; ([width s])&lt;br&gt; If width is greater than the length of s, returns a new string&lt;br&gt;  of length width with s right justified within it, otherwise returns s.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rjust&amp;lt;br&amp;gt;  &amp;quot;If width is greater than the length of s, returns a new string&amp;lt;br&amp;gt;  of length width with s right justified within it, otherwise returns s.&amp;quot;&amp;lt;br&amp;gt;  [width s]&amp;lt;br&amp;gt;  (format (str &amp;quot;%&amp;quot; width &amp;quot;s&amp;quot;) s))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rjust</a>[width s]</div></div></div><div class="row"><div class="namespace"><h4>clj-time.core</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;abuts?&lt;/b&gt; ([i-a i-b])&lt;br&gt; Returns true if Interval i-a abuts i-b, i.e. then end of i-a is exactly the&lt;br&gt;   beginning of i-b.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn abuts?&amp;lt;br&amp;gt;  &amp;quot;Returns true if Interval i-a abuts i-b, i.e. then end of i-a is exactly the&amp;lt;br&amp;gt;   beginning of i-b.&amp;quot;&amp;lt;br&amp;gt;  [#^Interval i-a #^Interval i-b]&amp;lt;br&amp;gt;  (.abuts i-a i-b))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">abuts?</a>[i-a i-b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;after?&lt;/b&gt; ([dt-a dt-b])&lt;br&gt; Returns true if ReadableDateTime dt-a is strictly after ReadableDateTime dt-b.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn after?&amp;lt;br&amp;gt;  &amp;quot;Returns true if ReadableDateTime dt-a is strictly after ReadableDateTime dt-b.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt-a #^ReadableDateTime dt-b]&amp;lt;br&amp;gt;  (.isAfter dt-a dt-b))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">after?</a>[dt-a dt-b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;ago&lt;/b&gt; ([period])&lt;br&gt; Returns a DateTime a supplied period before the present.&lt;br&gt;  e.g. (-&gt; 5 years ago)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ago&amp;lt;br&amp;gt;  &amp;quot;Returns a DateTime a supplied period before the present.&amp;lt;br&amp;gt;  e.g. (-&amp;gt; 5 years ago)&amp;quot;&amp;lt;br&amp;gt;  [#^Period period]&amp;lt;br&amp;gt;  (minus (now) period))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ago</a>[period]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;before?&lt;/b&gt; ([dt-a dt-b])&lt;br&gt; Returns true if ReadableDateTime dt-a is strictly before ReadableDateTime dt-b.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn before?&amp;lt;br&amp;gt;  &amp;quot;Returns true if ReadableDateTime dt-a is strictly before ReadableDateTime dt-b.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt-a #^ReadableDateTime dt-b]&amp;lt;br&amp;gt;  (.isBefore dt-a dt-b))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">before?</a>[dt-a dt-b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;date-midnight&lt;/b&gt; ([year] [year month] [year month day])&lt;br&gt; Constructs and returns a new DateMidnight in UTC.&lt;br&gt;   Specify the year, month of year, day of month. Note that month and day are&lt;br&gt;   1-indexed. Any number of least-significant components can be ommited, in which case&lt;br&gt;   they will default to 1.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn date-midnight&amp;lt;br&amp;gt;  &amp;quot;Constructs and returns a new DateMidnight in UTC.&amp;lt;br&amp;gt;   Specify the year, month of year, day of month. Note that month and day are&amp;lt;br&amp;gt;   1-indexed. Any number of least-significant components can be ommited, in which case&amp;lt;br&amp;gt;   they will default to 1.&amp;quot;&amp;lt;br&amp;gt;  ([year]&amp;lt;br&amp;gt;    (date-midnight year 1 1))&amp;lt;br&amp;gt;  ([year month]&amp;lt;br&amp;gt;    (date-midnight year month 1))&amp;lt;br&amp;gt;  ([year month day]&amp;lt;br&amp;gt;    (DateMidnight. year month day #^DateTimeZone utc)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">date-midnight</a>[year] [year month] [year month day]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;date-time&lt;/b&gt; ([year] [year month] [year month day] [year month day hour] [year month day hour minute] [year month day hour minute second] [year month day hour minute second millis])&lt;br&gt; Constructs and returns a new DateTime in UTC.&lt;br&gt;   Specify the year, month of year, day of month, hour of day, minute if hour,&lt;br&gt;   second of minute, and millisecond of second. Note that month and day are&lt;br&gt;   1-indexed while hour, second, minute, and millis are 0-indexed.&lt;br&gt;   Any number of least-significant components can be ommited, in which case&lt;br&gt;   they will default to 1 or 0 as appropriate.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn date-time&amp;lt;br&amp;gt;  &amp;quot;Constructs and returns a new DateTime in UTC.&amp;lt;br&amp;gt;   Specify the year, month of year, day of month, hour of day, minute if hour,&amp;lt;br&amp;gt;   second of minute, and millisecond of second. Note that month and day are&amp;lt;br&amp;gt;   1-indexed while hour, second, minute, and millis are 0-indexed.&amp;lt;br&amp;gt;   Any number of least-significant components can be ommited, in which case&amp;lt;br&amp;gt;   they will default to 1 or 0 as appropriate.&amp;quot;&amp;lt;br&amp;gt;  ([year]&amp;lt;br&amp;gt;   (date-time year 1 1 0 0 0 0))&amp;lt;br&amp;gt;  ([year month]&amp;lt;br&amp;gt;   (date-time year month 1 0 0 0 0))&amp;lt;br&amp;gt;  ([year month day]&amp;lt;br&amp;gt;   (date-time year month day 0 0 0 0))&amp;lt;br&amp;gt;  ([year month day hour]&amp;lt;br&amp;gt;   (date-time year month day hour 0 0 0))&amp;lt;br&amp;gt;  ([year month day hour minute]&amp;lt;br&amp;gt;   (date-time year month day hour minute 0 0))&amp;lt;br&amp;gt;  ([year month day hour minute second]&amp;lt;br&amp;gt;   (date-time year month day hour minute second 0))&amp;lt;br&amp;gt;  ([#^Integer year #^Integer month #^Integer day #^Integer hour&amp;lt;br&amp;gt;    #^Integer minute #^Integer second #^Integer millis]&amp;lt;br&amp;gt;   (DateTime. year month day hour minute second millis #^DateTimeZone utc)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">date-time</a>[year] [year month] [year month day] [year month day hour] [year month day hour minute] [year month day hour minute second] [year month day hour minute second millis]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;day&lt;/b&gt; ([dt])&lt;br&gt; Return the day of month component of the given ReadableDateTime.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn day&amp;lt;br&amp;gt;  &amp;quot;Return the day of month component of the given ReadableDateTime.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt]&amp;lt;br&amp;gt;  (.getDayOfMonth dt))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">day</a>[dt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;day-of-week&lt;/b&gt; ([dt])&lt;br&gt; Return the day of week component of the given ReadableDateTime. Monday is 1 and&lt;br&gt;   Sunday is 7.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn day-of-week&amp;lt;br&amp;gt;  &amp;quot;Return the day of week component of the given ReadableDateTime. Monday is 1 and&amp;lt;br&amp;gt;   Sunday is 7.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt]&amp;lt;br&amp;gt;  (.getDayOfWeek dt))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">day-of-week</a>[dt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;days&lt;/b&gt; ([] [n])&lt;br&gt; Given a number, returns a Period representing that many days.&lt;br&gt;   Without an argument, returns a PeriodType representing only days.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn days&amp;lt;br&amp;gt;  &amp;quot;Given a number, returns a Period representing that many days.&amp;lt;br&amp;gt;   Without an argument, returns a PeriodType representing only days.&amp;quot;&amp;lt;br&amp;gt;  ([]&amp;lt;br&amp;gt;     (PeriodType/days))&amp;lt;br&amp;gt;  ([#^Integer n]&amp;lt;br&amp;gt;     (Days/days n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">days</a>[] [n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;days?&lt;/b&gt; ([val])&lt;br&gt; Returns true if the given value is an instance of Days&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn days?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the given value is an instance of Days&amp;quot;&amp;lt;br&amp;gt;  [val]&amp;lt;br&amp;gt;  (instance? Days val))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">days?</a>[val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;default-time-zone&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn default-time-zone []&amp;lt;br&amp;gt;  &amp;quot;Returns the default DateTimeZone for the current environment.&amp;quot;&amp;lt;br&amp;gt;  (DateTimeZone/getDefault))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">default-time-zone</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;end&lt;/b&gt; ([in])&lt;br&gt; Returns the end DateTime of an Interval.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn end&amp;lt;br&amp;gt;  &amp;quot;Returns the end DateTime of an Interval.&amp;quot;&amp;lt;br&amp;gt;  [#^Interval in]&amp;lt;br&amp;gt;  (.getEnd in))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">end</a>[in]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;epoch&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn epoch []&amp;lt;br&amp;gt;  &amp;quot;Returns a DateTime for the begining of the Unix epoch in the UTC time zone.&amp;quot;&amp;lt;br&amp;gt;  (DateTime. (long 0) #^DateTimeZone utc))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">epoch</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;extend&lt;/b&gt; ([in &amp; by])&lt;br&gt; Returns an Interval with an end ReadableDateTime the specified Period after the end&lt;br&gt;   of the given Interval&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn extend&amp;lt;br&amp;gt;  &amp;quot;Returns an Interval with an end ReadableDateTime the specified Period after the end&amp;lt;br&amp;gt;   of the given Interval&amp;quot;&amp;lt;br&amp;gt;  [#^Interval in &amp;amp; by]&amp;lt;br&amp;gt;  (.withEnd in (apply plus (end in) by)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">extend</a>[in & by]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;from-now&lt;/b&gt; ([period])&lt;br&gt; Returns a DateTime a supplied period after the present.&lt;br&gt;  e.g. (-&gt; 30 minutes from-now)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn from-now&amp;lt;br&amp;gt;  &amp;quot;Returns a DateTime a supplied period after the present.&amp;lt;br&amp;gt;  e.g. (-&amp;gt; 30 minutes from-now)&amp;quot;&amp;lt;br&amp;gt;  [#^Period period]&amp;lt;br&amp;gt;  (plus (now) period))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">from-now</a>[period]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;from-time-zone&lt;/b&gt; ([dt tz])&lt;br&gt; Returns a new ReadableDateTime corresponding to the same point in calendar time as&lt;br&gt;   the given ReadableDateTime, but for a correspondingly different absolute instant in&lt;br&gt;   time.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn from-time-zone&amp;lt;br&amp;gt;  &amp;quot;Returns a new ReadableDateTime corresponding to the same point in calendar time as&amp;lt;br&amp;gt;   the given ReadableDateTime, but for a correspondingly different absolute instant in&amp;lt;br&amp;gt;   time.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt #^DateTimeZone tz]&amp;lt;br&amp;gt;  (.withZoneRetainFields dt tz))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">from-time-zone</a>[dt tz]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;hour&lt;/b&gt; ([dt])&lt;br&gt; Return the hour of day component of the given ReadableDateTime. A time of 12:01am&lt;br&gt;   will have an hour component of 0.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hour&amp;lt;br&amp;gt;  &amp;quot;Return the hour of day component of the given ReadableDateTime. A time of 12:01am&amp;lt;br&amp;gt;   will have an hour component of 0.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt]&amp;lt;br&amp;gt;  (.getHourOfDay dt))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hour</a>[dt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;hours&lt;/b&gt; ([] [n])&lt;br&gt; Given a number, returns a Period representing that many hours.&lt;br&gt;   Without an argument, returns a PeriodType representing only hours.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hours&amp;lt;br&amp;gt;  &amp;quot;Given a number, returns a Period representing that many hours.&amp;lt;br&amp;gt;   Without an argument, returns a PeriodType representing only hours.&amp;quot;&amp;lt;br&amp;gt;  ([]&amp;lt;br&amp;gt;     (PeriodType/hours))&amp;lt;br&amp;gt;  ([#^Integer n]&amp;lt;br&amp;gt;     (Hours/hours n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hours</a>[] [n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;hours?&lt;/b&gt; ([val])&lt;br&gt; Returns true if the given value is an instance of Hours&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hours?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the given value is an instance of Hours&amp;quot;&amp;lt;br&amp;gt;  [val]&amp;lt;br&amp;gt;  (instance? Hours val))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hours?</a>[val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;in-days&lt;/b&gt; ([in])&lt;br&gt; Returns the number of standard days in the given Interval.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn in-days&amp;lt;br&amp;gt;  &amp;quot;Returns the number of standard days in the given Interval.&amp;quot;&amp;lt;br&amp;gt;  [#^Interval in]&amp;lt;br&amp;gt;  (.getDays (.toPeriod in (days))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">in-days</a>[in]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;in-hours&lt;/b&gt; ([in])&lt;br&gt; Returns the number of standard hours in the given Interval.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn in-hours&amp;lt;br&amp;gt;  &amp;quot;Returns the number of standard hours in the given Interval.&amp;quot;&amp;lt;br&amp;gt;  [#^Interval in]&amp;lt;br&amp;gt;  (.getHours (.toPeriod in (hours))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">in-hours</a>[in]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;in-minutes&lt;/b&gt; ([in])&lt;br&gt; Returns the number of standard minutes in the given Interval.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn in-minutes&amp;lt;br&amp;gt;  &amp;quot;Returns the number of standard minutes in the given Interval.&amp;quot;&amp;lt;br&amp;gt;  [#^Interval in]&amp;lt;br&amp;gt;  (.getMinutes (.toPeriod in (minutes))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">in-minutes</a>[in]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;in-months&lt;/b&gt; ([in])&lt;br&gt; Returns the number of standard years in the given Interval.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn in-months&amp;lt;br&amp;gt;  &amp;quot;Returns the number of standard years in the given Interval.&amp;quot;&amp;lt;br&amp;gt;  [#^Interval in]&amp;lt;br&amp;gt;  (.getMonths (.toPeriod in (months))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">in-months</a>[in]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;in-msecs&lt;/b&gt; ([in])&lt;br&gt; Returns the number of milliseconds in the given Interval.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn in-msecs&amp;lt;br&amp;gt;  &amp;quot;Returns the number of milliseconds in the given Interval.&amp;quot;&amp;lt;br&amp;gt;  [#^Interval in]&amp;lt;br&amp;gt;  (.toDurationMillis in))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">in-msecs</a>[in]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;in-secs&lt;/b&gt; ([in])&lt;br&gt; Returns the number of standard seconds in the given Interval.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn in-secs&amp;lt;br&amp;gt;  &amp;quot;Returns the number of standard seconds in the given Interval.&amp;quot;&amp;lt;br&amp;gt;  [#^Interval in]&amp;lt;br&amp;gt;  (.getSeconds (.toPeriod in (secs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">in-secs</a>[in]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;in-weeks&lt;/b&gt; ([in])&lt;br&gt; Returns the number of standard weeks in the given Interval.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn in-weeks&amp;lt;br&amp;gt;  &amp;quot;Returns the number of standard weeks in the given Interval.&amp;quot;&amp;lt;br&amp;gt;  [#^Interval in]&amp;lt;br&amp;gt;  (.getWeeks (.toPeriod in (weeks))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">in-weeks</a>[in]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;in-years&lt;/b&gt; ([in])&lt;br&gt; Returns the number of standard years in the given Interval.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn in-years&amp;lt;br&amp;gt;  &amp;quot;Returns the number of standard years in the given Interval.&amp;quot;&amp;lt;br&amp;gt;  [#^Interval in]&amp;lt;br&amp;gt;  (.getYears (.toPeriod in (years))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">in-years</a>[in]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;interval&lt;/b&gt; ([dt-a dt-b])&lt;br&gt; Returns an interval representing the span between the two given ReadableDateTimes.&lt;br&gt;   Note that intervals are closed on the left and open on the right.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn interval&amp;lt;br&amp;gt;  &amp;quot;Returns an interval representing the span between the two given ReadableDateTimes.&amp;lt;br&amp;gt;   Note that intervals are closed on the left and open on the right.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt-a #^ReadableDateTime dt-b]&amp;lt;br&amp;gt;  (Interval. dt-a dt-b))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">interval</a>[dt-a dt-b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;milli&lt;/b&gt; ([dt])&lt;br&gt; Return the millisecond-of-second component of the given ReadableDateTime.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn milli&amp;lt;br&amp;gt;  &amp;quot;Return the millisecond-of-second component of the given ReadableDateTime.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt]&amp;lt;br&amp;gt;  (.getMillisOfSecond dt))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">milli</a>[dt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;millis&lt;/b&gt; ([] [n])&lt;br&gt; Given a number, returns a Period representing that many milliseconds.&lt;br&gt;   Without an argument, returns a PeriodType representing only milliseconds.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn millis&amp;lt;br&amp;gt;  &amp;quot;Given a number, returns a Period representing that many milliseconds.&amp;lt;br&amp;gt;   Without an argument, returns a PeriodType representing only milliseconds.&amp;quot;&amp;lt;br&amp;gt;  ([]&amp;lt;br&amp;gt;     (PeriodType/millis))&amp;lt;br&amp;gt;  ([#^Integer n]&amp;lt;br&amp;gt;     (Period/millis n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">millis</a>[] [n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;mins-ago&lt;/b&gt; ([d])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mins-ago [d]&amp;lt;br&amp;gt;  (in-minutes (interval d (now))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mins-ago</a>[d]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;minus&lt;/b&gt; ([dt p] [dt p &amp; ps])&lt;br&gt; Returns a new ReadableDateTime corresponding to the given ReadableDateTime moved backwards by&lt;br&gt;   the given Period(s).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn minus&amp;lt;br&amp;gt;  &amp;quot;Returns a new ReadableDateTime corresponding to the given ReadableDateTime moved backwards by&amp;lt;br&amp;gt;   the given Period(s).&amp;quot;&amp;lt;br&amp;gt;  ([#^ReadableDateTime dt #^Period p]&amp;lt;br&amp;gt;   (.minus dt p))&amp;lt;br&amp;gt;  ([dt p &amp;amp; ps]&amp;lt;br&amp;gt;   (reduce #(minus %1 %2) (minus dt p) ps)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">minus</a>[dt p] [dt p & ps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;minute&lt;/b&gt; ([dt])&lt;br&gt; Return the minute of hour component of the given ReadableDateTime.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn minute&amp;lt;br&amp;gt;  &amp;quot;Return the minute of hour component of the given ReadableDateTime.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt]&amp;lt;br&amp;gt;  (.getMinuteOfHour dt))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">minute</a>[dt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;minutes&lt;/b&gt; ([] [n])&lt;br&gt; Given a number, returns a Period representing that many minutes.&lt;br&gt;   Without an argument, returns a PeriodType representing only minutes.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn minutes&amp;lt;br&amp;gt;  &amp;quot;Given a number, returns a Period representing that many minutes.&amp;lt;br&amp;gt;   Without an argument, returns a PeriodType representing only minutes.&amp;quot;&amp;lt;br&amp;gt;  ([]&amp;lt;br&amp;gt;     (PeriodType/minutes))&amp;lt;br&amp;gt;  ([#^Integer n]&amp;lt;br&amp;gt;     (Minutes/minutes n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">minutes</a>[] [n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;minutes?&lt;/b&gt; ([val])&lt;br&gt; Returns true if the given value is an instance of Minutes&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn minutes?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the given value is an instance of Minutes&amp;quot;&amp;lt;br&amp;gt;  [val]&amp;lt;br&amp;gt;  (instance? Minutes val))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">minutes?</a>[val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;month&lt;/b&gt; ([dt])&lt;br&gt; Return the month-of-year component of the given ReadableDateTime. January is 1.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn month&amp;lt;br&amp;gt;  &amp;quot;Return the month-of-year component of the given ReadableDateTime. January is 1.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt]&amp;lt;br&amp;gt;  (.getMonthOfYear dt))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">month</a>[dt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;months&lt;/b&gt; ([] [n])&lt;br&gt; Given a number, returns a Period representing that many months.&lt;br&gt;   Without an argument, returns a PeriodType representing only months.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn months&amp;lt;br&amp;gt;  &amp;quot;Given a number, returns a Period representing that many months.&amp;lt;br&amp;gt;   Without an argument, returns a PeriodType representing only months.&amp;quot;&amp;lt;br&amp;gt;  ([]&amp;lt;br&amp;gt;     (PeriodType/months))&amp;lt;br&amp;gt;  ([#^Integer n]&amp;lt;br&amp;gt;     (Months/months n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">months</a>[] [n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;months?&lt;/b&gt; ([val])&lt;br&gt; Returns true if the given value is an instance of Months&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn months?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the given value is an instance of Months&amp;quot;&amp;lt;br&amp;gt;  [val]&amp;lt;br&amp;gt;  (instance? Months val))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">months?</a>[val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;now&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn now []&amp;lt;br&amp;gt;  &amp;quot;Returns a DateTime for the current instant in the UTC time zone.&amp;quot;&amp;lt;br&amp;gt;  (DateTime. #^DateTimeZone utc))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">now</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;overlaps?&lt;/b&gt; ([i-a i-b])&lt;br&gt; Returns true of the two given Intervals overlap. Note that intervals that&lt;br&gt;   satisfy abuts? do not satisfy overlaps?&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn overlaps?&amp;lt;br&amp;gt;  &amp;quot;Returns true of the two given Intervals overlap. Note that intervals that&amp;lt;br&amp;gt;   satisfy abuts? do not satisfy overlaps?&amp;quot;&amp;lt;br&amp;gt;  [#^Interval i-a #^Interval i-b]&amp;lt;br&amp;gt;  (.overlaps i-a i-b))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">overlaps?</a>[i-a i-b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;plus&lt;/b&gt; ([dt p] [dt p &amp; ps])&lt;br&gt; Returns a new ReadableDateTime corresponding to the given ReadableDateTime moved forwards by&lt;br&gt;   the given Period(s).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn plus&amp;lt;br&amp;gt;  &amp;quot;Returns a new ReadableDateTime corresponding to the given ReadableDateTime moved forwards by&amp;lt;br&amp;gt;   the given Period(s).&amp;quot;&amp;lt;br&amp;gt;  ([#^ReadableDateTime dt #^Period p]&amp;lt;br&amp;gt;   (.plus dt p))&amp;lt;br&amp;gt;  ([dt p &amp;amp; ps]&amp;lt;br&amp;gt;   (reduce #(plus %1 %2) (plus dt p) ps)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">plus</a>[dt p] [dt p & ps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;sec&lt;/b&gt; ([dt])&lt;br&gt; Return the second-of-minute component of the given ReadableDateTime.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sec&amp;lt;br&amp;gt;  &amp;quot;Return the second-of-minute component of the given ReadableDateTime.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt]&amp;lt;br&amp;gt;  (.getSecondOfMinute dt))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sec</a>[dt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;secs&lt;/b&gt; ([] [n])&lt;br&gt; Given a number, returns a Period representing that many seconds.&lt;br&gt;   Without an argument, returns a PeriodType representing only seconds.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn secs&amp;lt;br&amp;gt;  &amp;quot;Given a number, returns a Period representing that many seconds.&amp;lt;br&amp;gt;   Without an argument, returns a PeriodType representing only seconds.&amp;quot;&amp;lt;br&amp;gt;  ([]&amp;lt;br&amp;gt;     (PeriodType/seconds))&amp;lt;br&amp;gt;  ([#^Integer n]&amp;lt;br&amp;gt;     (Seconds/seconds n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">secs</a>[] [n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;secs?&lt;/b&gt; ([val])&lt;br&gt; Returns true if the given value is an instance of Seconds&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn secs?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the given value is an instance of Seconds&amp;quot;&amp;lt;br&amp;gt;  [val]&amp;lt;br&amp;gt;  (instance? Seconds val))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">secs?</a>[val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;start&lt;/b&gt; ([in])&lt;br&gt; Returns the start DateTime of an Interval.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn start&amp;lt;br&amp;gt;  &amp;quot;Returns the start DateTime of an Interval.&amp;quot;&amp;lt;br&amp;gt;  [#^Interval in]&amp;lt;br&amp;gt;  (.getStart in))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">start</a>[in]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;time-zone-for-id&lt;/b&gt; ([id])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn time-zone-for-id [#^String id]&amp;lt;br&amp;gt;  &amp;quot;Returns a DateTimeZone for the given ID, which must be in long form, e.g.&amp;lt;br&amp;gt;   'America/Matamoros'.&amp;quot;&amp;lt;br&amp;gt;  (DateTimeZone/forID id))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">time-zone-for-id</a>[id]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;time-zone-for-offset&lt;/b&gt; ([hours] [hours minutes])&lt;br&gt; Returns a DateTimeZone for the given offset, specified either in hours or&lt;br&gt;   hours and minutes.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn time-zone-for-offset&amp;lt;br&amp;gt;  &amp;quot;Returns a DateTimeZone for the given offset, specified either in hours or&amp;lt;br&amp;gt;   hours and minutes.&amp;quot;&amp;lt;br&amp;gt;  ([hours]&amp;lt;br&amp;gt;   (DateTimeZone/forOffsetHours hours))&amp;lt;br&amp;gt;  ([hours minutes]&amp;lt;br&amp;gt;   (DateTimeZone/forOffsetHoursMinutes hours minutes)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">time-zone-for-offset</a>[hours] [hours minutes]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;to-time-zone&lt;/b&gt; ([dt tz])&lt;br&gt; Returns a new ReadableDateTime corresponding to the same absolute instant in time as&lt;br&gt;   the given ReadableDateTime, but with calendar fields corresponding to the given&lt;br&gt;   TimeZone.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn to-time-zone&amp;lt;br&amp;gt;  &amp;quot;Returns a new ReadableDateTime corresponding to the same absolute instant in time as&amp;lt;br&amp;gt;   the given ReadableDateTime, but with calendar fields corresponding to the given&amp;lt;br&amp;gt;   TimeZone.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt #^DateTimeZone tz]&amp;lt;br&amp;gt;  (.withZone dt tz))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">to-time-zone</a>[dt tz]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;today-at-midnight&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn today-at-midnight []&amp;lt;br&amp;gt;  &amp;quot;Returns a DateMidnight for today at midnight in the UTC time zone.&amp;quot;&amp;lt;br&amp;gt;  (DateMidnight. #^DateTimeZone utc))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">today-at-midnight</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;weeks&lt;/b&gt; ([] [n])&lt;br&gt; Given a number, returns a Period representing that many weeks.&lt;br&gt;   Without an argument, returns a PeriodType representing only weeks.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn weeks&amp;lt;br&amp;gt;  &amp;quot;Given a number, returns a Period representing that many weeks.&amp;lt;br&amp;gt;   Without an argument, returns a PeriodType representing only weeks.&amp;quot;&amp;lt;br&amp;gt;  ([]&amp;lt;br&amp;gt;     (PeriodType/weeks))&amp;lt;br&amp;gt;  ([#^Integer n]&amp;lt;br&amp;gt;     (Weeks/weeks n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">weeks</a>[] [n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;weeks?&lt;/b&gt; ([val])&lt;br&gt; Returns true if the given value is an instance of Weeks&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn weeks?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the given value is an instance of Weeks&amp;quot;&amp;lt;br&amp;gt;  [val]&amp;lt;br&amp;gt;  (instance? Weeks val))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">weeks?</a>[val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;within?&lt;/b&gt; ([i dt])&lt;br&gt; Returns true if the given Interval contains the given ReadableDateTime. Note that&lt;br&gt;   if the ReadableDateTime is exactly equal to the end of the interval, this function&lt;br&gt;   returns false.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn within?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the given Interval contains the given ReadableDateTime. Note that&amp;lt;br&amp;gt;   if the ReadableDateTime is exactly equal to the end of the interval, this function&amp;lt;br&amp;gt;   returns false.&amp;quot;&amp;lt;br&amp;gt;  [#^Interval i #^ReadableDateTime dt]&amp;lt;br&amp;gt;  (.contains i dt))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">within?</a>[i dt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;year&lt;/b&gt; ([dt])&lt;br&gt; Return the year component of the given ReadableDateTime.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn year&amp;lt;br&amp;gt;  &amp;quot;Return the year component of the given ReadableDateTime.&amp;quot;&amp;lt;br&amp;gt;  [#^ReadableDateTime dt]&amp;lt;br&amp;gt;  (.getYear dt))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">year</a>[dt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;years&lt;/b&gt; ([] [n])&lt;br&gt; Given a number, returns a Period representing that many years.&lt;br&gt;   Without an argument, returns a PeriodType representing only years.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn years&amp;lt;br&amp;gt;  &amp;quot;Given a number, returns a Period representing that many years.&amp;lt;br&amp;gt;   Without an argument, returns a PeriodType representing only years.&amp;quot;&amp;lt;br&amp;gt;  ([]&amp;lt;br&amp;gt;     (PeriodType/years))&amp;lt;br&amp;gt;  ([#^Integer n]&amp;lt;br&amp;gt;     (Years/years n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">years</a>[] [n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.core&lt;/i&gt;&lt;b&gt;years?&lt;/b&gt; ([val])&lt;br&gt; Returns true if the given value is an instance of Years&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn years?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the given value is an instance of Years&amp;quot;&amp;lt;br&amp;gt;  [val]&amp;lt;br&amp;gt;  (instance? Years val))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">years?</a>[val]</div></div></div><div class="row"><div class="namespace"><h4>clj-time.format</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.format&lt;/i&gt;&lt;b&gt;formatter&lt;/b&gt; ([fmts] [fmts dtz] [dtz fmts &amp; more])&lt;br&gt; Returns a custom formatter for the given date-time pattern.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn formatter&amp;lt;br&amp;gt;  &amp;quot;Returns a custom formatter for the given date-time pattern.&amp;quot;&amp;lt;br&amp;gt;  ([#^String fmts]&amp;lt;br&amp;gt;     (formatter fmts utc))&amp;lt;br&amp;gt;  ([#^String fmts #^DateTimeZone dtz]&amp;lt;br&amp;gt;     (.withZone (DateTimeFormat/forPattern fmts) dtz))&amp;lt;br&amp;gt;  ([#^DateTimeZone dtz fmts &amp;amp; more]&amp;lt;br&amp;gt;    (let [printer (.getPrinter (formatter fmts dtz))&amp;lt;br&amp;gt;          parsers (map #(.getParser (formatter % dtz)) (cons fmts more))]&amp;lt;br&amp;gt;      (-&amp;gt; (DateTimeFormatterBuilder.)&amp;lt;br&amp;gt;        (.append printer (into-array DateTimeParser parsers))&amp;lt;br&amp;gt;        (.toFormatter)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">formatter</a>[fmts] [fmts dtz] [dtz fmts & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.format&lt;/i&gt;&lt;b&gt;parse&lt;/b&gt; ([fmt s] [s])&lt;br&gt; Returns a DateTime instance in the UTC time zone obtained by parsing the&lt;br&gt;   given string according to the given formatter.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse&amp;lt;br&amp;gt;  &amp;quot;Returns a DateTime instance in the UTC time zone obtained by parsing the&amp;lt;br&amp;gt;   given string according to the given formatter.&amp;quot;&amp;lt;br&amp;gt;  ([#^DateTimeFormatter fmt #^String s]&amp;lt;br&amp;gt;     (.parseDateTime fmt s))&amp;lt;br&amp;gt;  ([#^String s]&amp;lt;br&amp;gt;     (first&amp;lt;br&amp;gt;      (for [f (vals formatters)&amp;lt;br&amp;gt;	    :let [d (try (parse f s) (catch Exception _ nil))]&amp;lt;br&amp;gt;	    :when d] d))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse</a>[fmt s] [s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.format&lt;/i&gt;&lt;b&gt;show-formatters&lt;/b&gt; ([] [dt])&lt;br&gt; Shows how a given DateTime, or by default the current time, would be&lt;br&gt;  formatted with each of the available printing formatters.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn show-formatters&amp;lt;br&amp;gt;  &amp;quot;Shows how a given DateTime, or by default the current time, would be&amp;lt;br&amp;gt;  formatted with each of the available printing formatters.&amp;quot;&amp;lt;br&amp;gt;  ([] (show-formatters (now)))&amp;lt;br&amp;gt;  ([#^DateTime dt]&amp;lt;br&amp;gt;    (doseq [p (sort printers)]&amp;lt;br&amp;gt;      (let [fmt (formatters p)]&amp;lt;br&amp;gt;        (printf &amp;quot;%-40s%s\n&amp;quot; p (unparse fmt dt))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">show-formatters</a>[] [dt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.format&lt;/i&gt;&lt;b&gt;unparse&lt;/b&gt; ([fmt dt])&lt;br&gt; Returns a string representing the given DateTime instance in UTC and in the&lt;br&gt;  form determined by the given formatter.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unparse&amp;lt;br&amp;gt;  &amp;quot;Returns a string representing the given DateTime instance in UTC and in the&amp;lt;br&amp;gt;  form determined by the given formatter.&amp;quot;&amp;lt;br&amp;gt;  [#^DateTimeFormatter fmt #^DateTime dt]&amp;lt;br&amp;gt;  (.print fmt dt))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unparse</a>[fmt dt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.format&lt;/i&gt;&lt;b&gt;with-chronology&lt;/b&gt; ([f c])&lt;br&gt; Return a copy of a formatter that uses the given Chronology.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn with-chronology&amp;lt;br&amp;gt;  &amp;quot;Return a copy of a formatter that uses the given Chronology.&amp;quot;&amp;lt;br&amp;gt;  [#^DateTimeFormatter f #^Chronology c]&amp;lt;br&amp;gt;  (.withChronology f c))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-chronology</a>[f c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.format&lt;/i&gt;&lt;b&gt;with-locale&lt;/b&gt; ([f l])&lt;br&gt; Return a copy of a formatter that uses the given Locale.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn with-locale&amp;lt;br&amp;gt;  &amp;quot;Return a copy of a formatter that uses the given Locale.&amp;quot;&amp;lt;br&amp;gt;  [#^DateTimeFormatter f #^Locale l]&amp;lt;br&amp;gt;  (.withLocale f l))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-locale</a>[f l]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.format&lt;/i&gt;&lt;b&gt;with-pivot-year&lt;/b&gt; ([f pivot-year])&lt;br&gt; Return a copy of a formatter that uses the given pivot year.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn with-pivot-year&amp;lt;br&amp;gt;  &amp;quot;Return a copy of a formatter that uses the given pivot year.&amp;quot;&amp;lt;br&amp;gt;  [#^DateTimeFormatter f #^Long pivot-year]&amp;lt;br&amp;gt;  (.withPivotYear f pivot-year))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-pivot-year</a>[f pivot-year]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clj-time.format&lt;/i&gt;&lt;b&gt;with-zone&lt;/b&gt; ([f dtz])&lt;br&gt; Return a copy of a formatter that uses the given DateTimeZone.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn with-zone&amp;lt;br&amp;gt;  &amp;quot;Return a copy of a formatter that uses the given DateTimeZone.&amp;quot;&amp;lt;br&amp;gt;  [#^DateTimeFormatter f #^DateTimeZone dtz]&amp;lt;br&amp;gt;  (.withZone f dtz))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-zone</a>[f dtz]</div></div></div><div class="row"><div class="namespace"><h4>cljs.analyzer</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;analyze&lt;/b&gt; ([env form] [env form name])&lt;br&gt; Given an environment, a map containing {:locals (mapping of names to bindings), :context&lt;br&gt;  (one of :statement, :expr, :return), :ns (a symbol naming the&lt;br&gt;  compilation ns)}, and form, returns an expression object (a map&lt;br&gt;  containing at least :form, :op and :env keys). If expr has any (immediately)&lt;br&gt;  nested exprs, must have :children [exprs...] entry. This will&lt;br&gt;  facilitate code walking without knowing the details of the op set.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze&amp;lt;br&amp;gt;  &amp;quot;Given an environment, a map containing {:locals (mapping of names to bindings), :context&amp;lt;br&amp;gt;  (one of :statement, :expr, :return), :ns (a symbol naming the&amp;lt;br&amp;gt;  compilation ns)}, and form, returns an expression object (a map&amp;lt;br&amp;gt;  containing at least :form, :op and :env keys). If expr has any (immediately)&amp;lt;br&amp;gt;  nested exprs, must have :children [exprs...] entry. This will&amp;lt;br&amp;gt;  facilitate code walking without knowing the details of the op set.&amp;quot;&amp;lt;br&amp;gt;  ([env form] (analyze env form nil))&amp;lt;br&amp;gt;  ([env form name]&amp;lt;br&amp;gt;     (let [form (if (instance? clojure.lang.LazySeq form)&amp;lt;br&amp;gt;                  (or (seq form) ())&amp;lt;br&amp;gt;                  form)]&amp;lt;br&amp;gt;       (load-core)&amp;lt;br&amp;gt;       (cond&amp;lt;br&amp;gt;        (symbol? form) (analyze-symbol env form)&amp;lt;br&amp;gt;        (and (seq? form) (seq form)) (analyze-seq env form name)&amp;lt;br&amp;gt;        (map? form) (analyze-map env form name)&amp;lt;br&amp;gt;        (vector? form) (analyze-vector env form name)&amp;lt;br&amp;gt;        (set? form) (analyze-set env form name)&amp;lt;br&amp;gt;        (keyword? form) (analyze-keyword env form)&amp;lt;br&amp;gt;        :else {:op :constant :env env :form form}))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze</a>[env form] [env form name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;analyze-block&lt;/b&gt; ([env exprs])&lt;br&gt; returns {:statements .. :ret ..}&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-block&amp;lt;br&amp;gt;  &amp;quot;returns {:statements .. :ret ..}&amp;quot;&amp;lt;br&amp;gt;  [env exprs]&amp;lt;br&amp;gt;  (let [statements (disallowing-recur&amp;lt;br&amp;gt;                     (seq (map #(analyze (assoc env :context :statement) %) (butlast exprs))))&amp;lt;br&amp;gt;        ret (if (&amp;lt;= (count exprs) 1)&amp;lt;br&amp;gt;              (analyze env (first exprs))&amp;lt;br&amp;gt;              (analyze (assoc env :context (if (= :statement (:context env)) :statement :return)) (last exprs)))]&amp;lt;br&amp;gt;    {:statements statements :ret ret}))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-block</a>[env exprs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;analyze-deps&lt;/b&gt; ([deps])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-deps [deps]&amp;lt;br&amp;gt;  (doseq [dep deps]&amp;lt;br&amp;gt;    (when-not (:defs (@namespaces dep))&amp;lt;br&amp;gt;      (let [relpath (ns-&amp;gt;relpath dep)]&amp;lt;br&amp;gt;        (when (io/resource relpath)&amp;lt;br&amp;gt;          (analyze-file relpath))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-deps</a>[deps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;analyze-file&lt;/b&gt; ([f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-file&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (let [res (if (= \/ (first f)) f (io/resource f))]&amp;lt;br&amp;gt;    (assert res (str &amp;quot;Can't find &amp;quot; f &amp;quot; in classpath&amp;quot;))&amp;lt;br&amp;gt;    (binding [*cljs-ns* 'cljs.user&amp;lt;br&amp;gt;              *cljs-file* (.getPath ^java.net.URL res)&amp;lt;br&amp;gt;              *ns* *reader-ns*]&amp;lt;br&amp;gt;      (with-open [r (io/reader res)]&amp;lt;br&amp;gt;        (let [env (empty-env)&amp;lt;br&amp;gt;              pbr (clojure.lang.LineNumberingPushbackReader. r)&amp;lt;br&amp;gt;              eof (Object.)]&amp;lt;br&amp;gt;          (loop [r (read pbr false eof false)]&amp;lt;br&amp;gt;            (let [env (assoc env :ns (get-namespace *cljs-ns*))]&amp;lt;br&amp;gt;              (when-not (identical? eof r)&amp;lt;br&amp;gt;                (analyze env r)&amp;lt;br&amp;gt;                (recur (read pbr false eof false))))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-file</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;analyze-keyword&lt;/b&gt; ([env sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-keyword&amp;lt;br&amp;gt;    [env sym]&amp;lt;br&amp;gt;    {:op :constant :env env&amp;lt;br&amp;gt;     :form (if (= (namespace sym) (name *reader-ns-name*))&amp;lt;br&amp;gt;               (keyword (-&amp;gt; env :ns :name name) (name sym))&amp;lt;br&amp;gt;               sym)})&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-keyword</a>[env sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;analyze-let&lt;/b&gt; ([encl-env [_ bindings &amp; exprs :as form] is-loop])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-let&amp;lt;br&amp;gt;  [encl-env [_ bindings &amp;amp; exprs :as form] is-loop]&amp;lt;br&amp;gt;  (assert (and (vector? bindings) (even? (count bindings))) &amp;quot;bindings must be vector of even number of elements&amp;quot;)&amp;lt;br&amp;gt;  (let [context (:context encl-env)&amp;lt;br&amp;gt;        [bes env]&amp;lt;br&amp;gt;        (disallowing-recur&amp;lt;br&amp;gt;         (loop [bes []&amp;lt;br&amp;gt;                env (assoc encl-env :context :expr)&amp;lt;br&amp;gt;                bindings (seq (partition 2 bindings))]&amp;lt;br&amp;gt;           (if-let [[name init] (first bindings)]&amp;lt;br&amp;gt;             (do&amp;lt;br&amp;gt;               (assert (not (or (namespace name) (.contains (str name) &amp;quot;.&amp;quot;))) (str &amp;quot;Invalid local name: &amp;quot; name))&amp;lt;br&amp;gt;               (let [init-expr (analyze env init)&amp;lt;br&amp;gt;                     be {:name (gensym (str name &amp;quot;__&amp;quot;))&amp;lt;br&amp;gt;                         :init init-expr&amp;lt;br&amp;gt;                         :tag (or (-&amp;gt; name meta :tag)&amp;lt;br&amp;gt;                                  (-&amp;gt; init-expr :tag)&amp;lt;br&amp;gt;                                  (-&amp;gt; init-expr :info :tag))&amp;lt;br&amp;gt;                         :local true}]&amp;lt;br&amp;gt;                 (recur (conj bes be)&amp;lt;br&amp;gt;                        (assoc-in env [:locals name] be)&amp;lt;br&amp;gt;                        (next bindings))))&amp;lt;br&amp;gt;             [bes env])))&amp;lt;br&amp;gt;        recur-frame (when is-loop {:names (vec (map :name bes)) :flag (atom nil)})&amp;lt;br&amp;gt;        {:keys [statements ret]}&amp;lt;br&amp;gt;        (binding [*recur-frames* (if recur-frame (cons recur-frame *recur-frames*) *recur-frames*)&amp;lt;br&amp;gt;                  *loop-lets* (cond&amp;lt;br&amp;gt;                               is-loop (or *loop-lets* ())&amp;lt;br&amp;gt;                               *loop-lets* (cons {:names (vec (map :name bes))} *loop-lets*))]&amp;lt;br&amp;gt;          (analyze-block (assoc env :context (if (= :expr context) :return context)) exprs))]&amp;lt;br&amp;gt;    {:env encl-env :op :let :loop is-loop&amp;lt;br&amp;gt;     :bindings bes :statements statements :ret ret :form form&amp;lt;br&amp;gt;     :children (into (vec (map :init bes))&amp;lt;br&amp;gt;                     (conj (vec statements) ret))}))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-let</a>[encl-env [_ bindings & exprs :as form] is-loop]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;analyze-map&lt;/b&gt; ([env form name])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-map&amp;lt;br&amp;gt;  [env form name]&amp;lt;br&amp;gt;  (let [expr-env (assoc env :context :expr)&amp;lt;br&amp;gt;        simple-keys? (every? #(or (string? %) (keyword? %))&amp;lt;br&amp;gt;                             (keys form))&amp;lt;br&amp;gt;        ks (disallowing-recur (vec (map #(analyze expr-env % name) (keys form))))&amp;lt;br&amp;gt;        vs (disallowing-recur (vec (map #(analyze expr-env % name) (vals form))))]&amp;lt;br&amp;gt;    (analyze-wrap-meta {:op :map :env env :form form&amp;lt;br&amp;gt;                        :keys ks :vals vs :simple-keys? simple-keys?&amp;lt;br&amp;gt;                        :children (vec (interleave ks vs))}&amp;lt;br&amp;gt;                       name)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-map</a>[env form name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;analyze-seq&lt;/b&gt; ([env form name])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-seq&amp;lt;br&amp;gt;  [env form name]&amp;lt;br&amp;gt;  (let [env (assoc env :line&amp;lt;br&amp;gt;                   (or (-&amp;gt; form meta :line)&amp;lt;br&amp;gt;                       (:line env)))]&amp;lt;br&amp;gt;    (let [op (first form)]&amp;lt;br&amp;gt;      (assert (not (nil? op)) &amp;quot;Can't call nil&amp;quot;)&amp;lt;br&amp;gt;      (let [mform (macroexpand-1 env form)]&amp;lt;br&amp;gt;        (if (identical? form mform)&amp;lt;br&amp;gt;          (if (specials op)&amp;lt;br&amp;gt;            (parse op env form name)&amp;lt;br&amp;gt;            (parse-invoke env form))&amp;lt;br&amp;gt;          (analyze env mform name))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-seq</a>[env form name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;analyze-set&lt;/b&gt; ([env form name])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-set&amp;lt;br&amp;gt;  [env form name]&amp;lt;br&amp;gt;  (let [expr-env (assoc env :context :expr)&amp;lt;br&amp;gt;        items (disallowing-recur (vec (map #(analyze expr-env % name) form)))]&amp;lt;br&amp;gt;    (analyze-wrap-meta {:op :set :env env :form form :items items :children items} name)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-set</a>[env form name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;analyze-symbol&lt;/b&gt; ([env sym])&lt;br&gt; Finds the var associated with sym&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-symbol&amp;lt;br&amp;gt;  &amp;quot;Finds the var associated with sym&amp;quot;&amp;lt;br&amp;gt;  [env sym]&amp;lt;br&amp;gt;  (let [ret {:env env :form sym}&amp;lt;br&amp;gt;        lb (-&amp;gt; env :locals sym)]&amp;lt;br&amp;gt;    (if lb&amp;lt;br&amp;gt;      (assoc ret :op :var :info lb)&amp;lt;br&amp;gt;      (assoc ret :op :var :info (resolve-existing-var env sym)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-symbol</a>[env sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;analyze-vector&lt;/b&gt; ([env form name])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-vector&amp;lt;br&amp;gt;  [env form name]&amp;lt;br&amp;gt;  (let [expr-env (assoc env :context :expr)&amp;lt;br&amp;gt;        items (disallowing-recur (vec (map #(analyze expr-env % name) form)))]&amp;lt;br&amp;gt;    (analyze-wrap-meta {:op :vector :env env :form form :items items :children items} name)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-vector</a>[env form name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;analyze-wrap-meta&lt;/b&gt; ([expr name])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-wrap-meta [expr name]&amp;lt;br&amp;gt;  (let [form (:form expr)]&amp;lt;br&amp;gt;    (if (meta form)&amp;lt;br&amp;gt;      (let [env (:env expr) ; take on expr's context ourselves&amp;lt;br&amp;gt;            expr (assoc-in expr [:env :context] :expr) ; change expr to :expr&amp;lt;br&amp;gt;            meta-expr (analyze-map (:env expr) (meta form) name)]&amp;lt;br&amp;gt;        {:op :meta :env env :form form&amp;lt;br&amp;gt;         :meta meta-expr :expr expr :children [meta-expr expr]})&amp;lt;br&amp;gt;      expr)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-wrap-meta</a>[expr name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;confirm-bindings&lt;/b&gt; ([env names])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn confirm-bindings [env names]&amp;lt;br&amp;gt;  (doseq [name names]&amp;lt;br&amp;gt;    (let [env (merge env {:ns (@namespaces *cljs-ns*)})&amp;lt;br&amp;gt;          ev (resolve-existing-var env name)]&amp;lt;br&amp;gt;      (when (and *cljs-warn-on-dynamic*&amp;lt;br&amp;gt;                 ev (not (-&amp;gt; ev :dynamic)))&amp;lt;br&amp;gt;        (warning env&amp;lt;br&amp;gt;          (str &amp;quot;WARNING: &amp;quot; (:name ev) &amp;quot; not declared ^:dynamic&amp;quot;))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">confirm-bindings</a>[env names]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;confirm-var-exists&lt;/b&gt; ([env prefix suffix])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn confirm-var-exists [env prefix suffix]&amp;lt;br&amp;gt;  (when *cljs-warn-on-undeclared*&amp;lt;br&amp;gt;    (let [crnt-ns (-&amp;gt; env :ns :name)]&amp;lt;br&amp;gt;      (when (= prefix crnt-ns)&amp;lt;br&amp;gt;        (when-not (-&amp;gt; @namespaces crnt-ns :defs suffix)&amp;lt;br&amp;gt;          (warning env&amp;lt;br&amp;gt;            (str &amp;quot;WARNING: Use of undeclared Var &amp;quot; prefix &amp;quot;/&amp;quot; suffix)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">confirm-var-exists</a>[env prefix suffix]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;core-name?&lt;/b&gt; ([env sym])&lt;br&gt; Is sym visible from core in the current compilation namespace?&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn core-name?&amp;lt;br&amp;gt;  &amp;quot;Is sym visible from core in the current compilation namespace?&amp;quot;&amp;lt;br&amp;gt;  [env sym]&amp;lt;br&amp;gt;  (and (get (:defs (@namespaces 'cljs.core)) sym)&amp;lt;br&amp;gt;       (not (contains? (-&amp;gt; env :ns :excludes) sym))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">core-name?</a>[env sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;disallowing-recur&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro disallowing-recur [&amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*recur-frames* (cons nil *recur-frames*)] ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">disallowing-recur</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;empty-env&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn empty-env []&amp;lt;br&amp;gt;  {:ns (@namespaces *cljs-ns*) :context :statement :locals {}})&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">empty-env</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;get-expander&lt;/b&gt; ([sym env])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-expander [sym env]&amp;lt;br&amp;gt;  (let [mvar&amp;lt;br&amp;gt;        (when-not (or (-&amp;gt; env :locals sym)        ;locals hide macros&amp;lt;br&amp;gt;                      (and (or (-&amp;gt; env :ns :excludes sym)&amp;lt;br&amp;gt;                               (get-in @namespaces [(-&amp;gt; env :ns :name) :excludes sym]))&amp;lt;br&amp;gt;                           (not (or (-&amp;gt; env :ns :uses-macros sym)&amp;lt;br&amp;gt;                                    (get-in @namespaces [(-&amp;gt; env :ns :name) :uses-macros sym])))))&amp;lt;br&amp;gt;          (if-let [nstr (namespace sym)]&amp;lt;br&amp;gt;            (when-let [ns (cond&amp;lt;br&amp;gt;                           (= &amp;quot;clojure.core&amp;quot; nstr) (find-ns 'cljs.core)&amp;lt;br&amp;gt;                           (.contains nstr &amp;quot;.&amp;quot;) (find-ns (symbol nstr))&amp;lt;br&amp;gt;                           :else&amp;lt;br&amp;gt;                           (-&amp;gt; env :ns :requires-macros (get (symbol nstr))))]&amp;lt;br&amp;gt;              (.findInternedVar ^clojure.lang.Namespace ns (symbol (name sym))))&amp;lt;br&amp;gt;            (if-let [nsym (-&amp;gt; env :ns :uses-macros sym)]&amp;lt;br&amp;gt;              (.findInternedVar ^clojure.lang.Namespace (find-ns nsym) sym)&amp;lt;br&amp;gt;              (.findInternedVar ^clojure.lang.Namespace (find-ns 'cljs.core) sym))))]&amp;lt;br&amp;gt;    (when (and mvar (.isMacro ^clojure.lang.Var mvar))&amp;lt;br&amp;gt;      @mvar)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-expander</a>[sym env]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;get-namespace&lt;/b&gt; ([key])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-namespace [key]&amp;lt;br&amp;gt;  (@namespaces key))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-namespace</a>[key]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;load-core&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn load-core []&amp;lt;br&amp;gt;  (when (not @-cljs-macros-loaded)&amp;lt;br&amp;gt;    (reset! -cljs-macros-loaded true)&amp;lt;br&amp;gt;    (if *cljs-macros-is-classpath*&amp;lt;br&amp;gt;      (load *cljs-macros-path*)&amp;lt;br&amp;gt;      (load-file *cljs-macros-path*))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">load-core</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;macroexpand-1&lt;/b&gt; ([env form])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn macroexpand-1 [env form]&amp;lt;br&amp;gt;  (let [op (first form)]&amp;lt;br&amp;gt;    (if (specials op)&amp;lt;br&amp;gt;      form&amp;lt;br&amp;gt;      (if-let [mac (and (symbol? op) (get-expander op env))]&amp;lt;br&amp;gt;        (binding [*ns* (create-ns *cljs-ns*)]&amp;lt;br&amp;gt;          (apply mac form env (rest form)))&amp;lt;br&amp;gt;        (if (symbol? op)&amp;lt;br&amp;gt;          (let [opname (str op)]&amp;lt;br&amp;gt;            (cond&amp;lt;br&amp;gt;             (= (first opname) \.) (let [[target &amp;amp; args] (next form)]&amp;lt;br&amp;gt;                                     (with-meta (list* '. target (symbol (subs opname 1)) args)&amp;lt;br&amp;gt;                                       (meta form)))&amp;lt;br&amp;gt;             (= (last opname) \.) (with-meta&amp;lt;br&amp;gt;                                    (list* 'new (symbol (subs opname 0 (dec (count opname)))) (next form))&amp;lt;br&amp;gt;                                    (meta form))&amp;lt;br&amp;gt;             :else form))&amp;lt;br&amp;gt;          form)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">macroexpand-1</a>[env form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;munge-path&lt;/b&gt; ([ss])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn munge-path [ss]&amp;lt;br&amp;gt;  (clojure.lang.Compiler/munge (str ss)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">munge-path</a>[ss]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;ns-&gt;relpath&lt;/b&gt; ([s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-&amp;gt;relpath [s]&amp;lt;br&amp;gt;  (str (string/replace (munge-path s) \. \/) &amp;quot;.cljs&amp;quot;))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns->relpath</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;parse-invoke&lt;/b&gt; ([env [f &amp; args :as form]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-invoke&amp;lt;br&amp;gt;  [env [f &amp;amp; args :as form]]&amp;lt;br&amp;gt;  (disallowing-recur&amp;lt;br&amp;gt;   (let [enve (assoc env :context :expr)&amp;lt;br&amp;gt;         fexpr (analyze enve f)&amp;lt;br&amp;gt;         argexprs (vec (map #(analyze enve %) args))&amp;lt;br&amp;gt;         argc (count args)]&amp;lt;br&amp;gt;     (if (and *cljs-warn-fn-arity* (-&amp;gt; fexpr :info :fn-var))&amp;lt;br&amp;gt;       (let [{:keys [variadic max-fixed-arity method-params name]} (:info fexpr)]&amp;lt;br&amp;gt;         (when (and (not (some #{argc} (map count method-params)))&amp;lt;br&amp;gt;                    (or (not variadic)&amp;lt;br&amp;gt;                        (and variadic (&amp;lt; argc max-fixed-arity))))&amp;lt;br&amp;gt;           (warning env&amp;lt;br&amp;gt;             (str &amp;quot;WARNING: Wrong number of args (&amp;quot; argc &amp;quot;) passed to &amp;quot; name)))))&amp;lt;br&amp;gt;     {:env env :op :invoke :form form :f fexpr :args argexprs&amp;lt;br&amp;gt;      :tag (or (-&amp;gt; fexpr :info :tag) (-&amp;gt; form meta :tag)) :children (into [fexpr] argexprs)})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-invoke</a>[env [f & args :as form]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;reset-namespaces!&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reset-namespaces! []&amp;lt;br&amp;gt;  (reset! namespaces&amp;lt;br&amp;gt;    '{cljs.core {:name cljs.core}&amp;lt;br&amp;gt;      cljs.user {:name cljs.user}}))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reset-namespaces!</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;resolve-existing-var&lt;/b&gt; ([env sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve-existing-var [env sym]&amp;lt;br&amp;gt;  (if (= (namespace sym) &amp;quot;js&amp;quot;)&amp;lt;br&amp;gt;    {:name sym :ns 'js}&amp;lt;br&amp;gt;    (let [s (str sym)&amp;lt;br&amp;gt;          lb (-&amp;gt; env :locals sym)]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;       lb lb&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (namespace sym)&amp;lt;br&amp;gt;       (let [ns (namespace sym)&amp;lt;br&amp;gt;             ns (if (= &amp;quot;clojure.core&amp;quot; ns) &amp;quot;cljs.core&amp;quot; ns)&amp;lt;br&amp;gt;             full-ns (resolve-ns-alias env ns)]&amp;lt;br&amp;gt;         (confirm-var-exists env full-ns (symbol (name sym)))&amp;lt;br&amp;gt;         (merge (get-in @namespaces [full-ns :defs (symbol (name sym))])&amp;lt;br&amp;gt;           {:name (symbol (str full-ns) (str (name sym)))&amp;lt;br&amp;gt;            :ns full-ns}))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (.contains s &amp;quot;.&amp;quot;)&amp;lt;br&amp;gt;       (let [idx (.indexOf s &amp;quot;.&amp;quot;)&amp;lt;br&amp;gt;             prefix (symbol (subs s 0 idx))&amp;lt;br&amp;gt;             suffix (subs s (inc idx))&amp;lt;br&amp;gt;             lb (-&amp;gt; env :locals prefix)]&amp;lt;br&amp;gt;         (if lb&amp;lt;br&amp;gt;           {:name (symbol (str (:name lb) suffix))}&amp;lt;br&amp;gt;           (do&amp;lt;br&amp;gt;             (confirm-var-exists env prefix (symbol suffix))&amp;lt;br&amp;gt;             (merge (get-in @namespaces [prefix :defs (symbol suffix)])&amp;lt;br&amp;gt;              {:name (if (= &amp;quot;&amp;quot; prefix) (symbol suffix) (symbol (str prefix) suffix))&amp;lt;br&amp;gt;               :ns prefix}))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (get-in @namespaces [(-&amp;gt; env :ns :name) :uses sym])&amp;lt;br&amp;gt;       (let [full-ns (get-in @namespaces [(-&amp;gt; env :ns :name) :uses sym])]&amp;lt;br&amp;gt;         (merge&amp;lt;br&amp;gt;          (get-in @namespaces [full-ns :defs sym])&amp;lt;br&amp;gt;          {:name (symbol (str full-ns) (str sym))&amp;lt;br&amp;gt;           :ns (-&amp;gt; env :ns :name)}))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       :else&amp;lt;br&amp;gt;       (let [full-ns (if (core-name? env sym)&amp;lt;br&amp;gt;                       'cljs.core&amp;lt;br&amp;gt;                       (-&amp;gt; env :ns :name))]&amp;lt;br&amp;gt;         (confirm-var-exists env full-ns sym)&amp;lt;br&amp;gt;         (merge (get-in @namespaces [full-ns :defs sym])&amp;lt;br&amp;gt;           {:name (symbol (str full-ns) (str sym))&amp;lt;br&amp;gt;            :ns full-ns}))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve-existing-var</a>[env sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;resolve-ns-alias&lt;/b&gt; ([env name])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve-ns-alias [env name]&amp;lt;br&amp;gt;  (let [sym (symbol name)]&amp;lt;br&amp;gt;    (get (:requires (:ns env)) sym sym)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve-ns-alias</a>[env name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;resolve-var&lt;/b&gt; ([env sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve-var [env sym]&amp;lt;br&amp;gt;  (if (= (namespace sym) &amp;quot;js&amp;quot;)&amp;lt;br&amp;gt;    {:name sym}&amp;lt;br&amp;gt;    (let [s (str sym)&amp;lt;br&amp;gt;          lb (-&amp;gt; env :locals sym)]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;       lb lb&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (namespace sym)&amp;lt;br&amp;gt;       (let [ns (namespace sym)&amp;lt;br&amp;gt;             ns (if (= &amp;quot;clojure.core&amp;quot; ns) &amp;quot;cljs.core&amp;quot; ns)]&amp;lt;br&amp;gt;         {:name (symbol (str (resolve-ns-alias env ns)) (name sym))})&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (.contains s &amp;quot;.&amp;quot;)&amp;lt;br&amp;gt;       (let [idx (.indexOf s &amp;quot;.&amp;quot;)&amp;lt;br&amp;gt;             prefix (symbol (subs s 0 idx))&amp;lt;br&amp;gt;             suffix (subs s idx)&amp;lt;br&amp;gt;             lb (-&amp;gt; env :locals prefix)]&amp;lt;br&amp;gt;         (if lb&amp;lt;br&amp;gt;           {:name (symbol (str (:name lb) suffix))}&amp;lt;br&amp;gt;           {:name sym}))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (get-in @namespaces [(-&amp;gt; env :ns :name) :uses sym])&amp;lt;br&amp;gt;       (let [full-ns (get-in @namespaces [(-&amp;gt; env :ns :name) :uses sym])]&amp;lt;br&amp;gt;         (merge&amp;lt;br&amp;gt;          (get-in @namespaces [full-ns :defs sym])&amp;lt;br&amp;gt;          {:name (symbol (str full-ns) (name sym))}))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       :else&amp;lt;br&amp;gt;       (let [ns (if (core-name? env sym)&amp;lt;br&amp;gt;                  'cljs.core&amp;lt;br&amp;gt;                  (-&amp;gt; env :ns :name))]&amp;lt;br&amp;gt;         {:name (symbol (str ns) (name sym))})))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve-var</a>[env sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;set-namespace&lt;/b&gt; ([key val])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-namespace [key val]&amp;lt;br&amp;gt;  (swap! namespaces assoc key val))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-namespace</a>[key val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;warning&lt;/b&gt; ([env s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn warning [env s]&amp;lt;br&amp;gt;  (binding [*out* *err*]&amp;lt;br&amp;gt;    (println&amp;lt;br&amp;gt;     (str s (when (:line env)&amp;lt;br&amp;gt;       (str &amp;quot; at line &amp;quot; (:line env) &amp;quot; &amp;quot; *cljs-file*))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">warning</a>[env s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;with-core-macros&lt;/b&gt; ([path &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-core-macros&amp;lt;br&amp;gt;  [path &amp;amp; body]&amp;lt;br&amp;gt;  `(do&amp;lt;br&amp;gt;     (when (not= *cljs-macros-path* ~path)&amp;lt;br&amp;gt;       (reset! -cljs-macros-loaded false))&amp;lt;br&amp;gt;     (binding [*cljs-macros-path* ~path]&amp;lt;br&amp;gt;       ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-core-macros</a>[path & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.analyzer&lt;/i&gt;&lt;b&gt;with-core-macros-file&lt;/b&gt; ([path &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-core-macros-file&amp;lt;br&amp;gt;  [path &amp;amp; body]&amp;lt;br&amp;gt;  `(do&amp;lt;br&amp;gt;     (when (not= *cljs-macros-path* ~path)&amp;lt;br&amp;gt;       (reset! -cljs-macros-loaded false))&amp;lt;br&amp;gt;     (binding [*cljs-macros-path* ~path&amp;lt;br&amp;gt;               *cljs-macros-is-classpath* false]&amp;lt;br&amp;gt;       ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-core-macros-file</a>[path & body]</div></div></div><div class="row"><div class="namespace"><h4>cljs.compiler</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;cljs-files-in&lt;/b&gt; ([dir])&lt;br&gt; Return a sequence of all .cljs files in the given directory.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cljs-files-in&amp;lt;br&amp;gt;  &amp;quot;Return a sequence of all .cljs files in the given directory.&amp;quot;&amp;lt;br&amp;gt;  [dir]&amp;lt;br&amp;gt;  (filter #(let [name (.getName ^java.io.File %)]&amp;lt;br&amp;gt;             (and (.endsWith name &amp;quot;.cljs&amp;quot;)&amp;lt;br&amp;gt;                  (not= \. (first name))&amp;lt;br&amp;gt;                  (not (contains? cljs-reserved-file-names name))))&amp;lt;br&amp;gt;          (file-seq dir)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cljs-files-in</a>[dir]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;compile-file&lt;/b&gt; ([src] [src dest])&lt;br&gt; Compiles src to a file of the same name, but with a .js extension,&lt;br&gt;   in the src file's directory.&lt;br&gt;&lt;br&gt;   With dest argument, write file to provided location. If the dest&lt;br&gt;   argument is a file outside the source tree, missing parent&lt;br&gt;   directories will be created. The src file will only be compiled if&lt;br&gt;   the dest file has an older modification time.&lt;br&gt;&lt;br&gt;   Both src and dest may be either a String or a File.&lt;br&gt;&lt;br&gt;   Returns a map containing {:ns .. :provides .. :requires .. :file ..}.&lt;br&gt;   If the file was not compiled returns only {:file ...}&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn compile-file&amp;lt;br&amp;gt;  &amp;quot;Compiles src to a file of the same name, but with a .js extension,&amp;lt;br&amp;gt;   in the src file's directory.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   With dest argument, write file to provided location. If the dest&amp;lt;br&amp;gt;   argument is a file outside the source tree, missing parent&amp;lt;br&amp;gt;   directories will be created. The src file will only be compiled if&amp;lt;br&amp;gt;   the dest file has an older modification time.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Both src and dest may be either a String or a File.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Returns a map containing {:ns .. :provides .. :requires .. :file ..}.&amp;lt;br&amp;gt;   If the file was not compiled returns only {:file ...}&amp;quot;&amp;lt;br&amp;gt;  ([src]&amp;lt;br&amp;gt;     (let [dest (rename-to-js src)]&amp;lt;br&amp;gt;       (compile-file src dest)))&amp;lt;br&amp;gt;  ([src dest]&amp;lt;br&amp;gt;     (let [src-file (io/file src)&amp;lt;br&amp;gt;           dest-file (io/file dest)]&amp;lt;br&amp;gt;       (if (.exists src-file)&amp;lt;br&amp;gt;         (if (requires-compilation? src-file dest-file)&amp;lt;br&amp;gt;           (do (mkdirs dest-file)&amp;lt;br&amp;gt;               (compile-file* src-file dest-file))&amp;lt;br&amp;gt;           {:file dest-file})&amp;lt;br&amp;gt;         (throw (java.io.FileNotFoundException. (str &amp;quot;The file &amp;quot; src &amp;quot; does not exist.&amp;quot;)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">compile-file</a>[src] [src dest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;compile-file*&lt;/b&gt; ([src dest])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn compile-file* [src dest]&amp;lt;br&amp;gt;  (with-core-cljs&amp;lt;br&amp;gt;    (with-open [out ^java.io.Writer (io/make-writer dest {})]&amp;lt;br&amp;gt;      (binding [*out* out&amp;lt;br&amp;gt;                ana/*cljs-ns* 'cljs.user&amp;lt;br&amp;gt;                ana/*cljs-file* (.getPath ^java.io.File src)&amp;lt;br&amp;gt;                *data-readers* tags/*cljs-data-readers*&amp;lt;br&amp;gt;                *position* (atom [0 0])]&amp;lt;br&amp;gt;        (loop [forms (forms-seq src)&amp;lt;br&amp;gt;               ns-name nil&amp;lt;br&amp;gt;               deps nil]&amp;lt;br&amp;gt;          (if (seq forms)&amp;lt;br&amp;gt;            (let [env (ana/empty-env)&amp;lt;br&amp;gt;                  ast (ana/analyze env (first forms))]&amp;lt;br&amp;gt;              (do (emit ast)&amp;lt;br&amp;gt;                  (if (= (:op ast) :ns)&amp;lt;br&amp;gt;                    (recur (rest forms) (:name ast) (merge (:uses ast) (:requires ast)))&amp;lt;br&amp;gt;                    (recur (rest forms) ns-name deps))))&amp;lt;br&amp;gt;            {:ns (or ns-name 'cljs.user)&amp;lt;br&amp;gt;             :provides [ns-name]&amp;lt;br&amp;gt;             :requires (if (= ns-name 'cljs.core) (set (vals deps)) (conj (set (vals deps)) 'cljs.core))&amp;lt;br&amp;gt;             :file dest}))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">compile-file*</a>[src dest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;compile-root&lt;/b&gt; ([src-dir] [src-dir target-dir])&lt;br&gt; Looks recursively in src-dir for .cljs files and compiles them to&lt;br&gt;   .js files. If target-dir is provided, output will go into this&lt;br&gt;   directory mirroring the source directory structure. Returns a list&lt;br&gt;   of maps containing information about each file which was compiled&lt;br&gt;   in dependency order.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn compile-root&amp;lt;br&amp;gt;  &amp;quot;Looks recursively in src-dir for .cljs files and compiles them to&amp;lt;br&amp;gt;   .js files. If target-dir is provided, output will go into this&amp;lt;br&amp;gt;   directory mirroring the source directory structure. Returns a list&amp;lt;br&amp;gt;   of maps containing information about each file which was compiled&amp;lt;br&amp;gt;   in dependency order.&amp;quot;&amp;lt;br&amp;gt;  ([src-dir]&amp;lt;br&amp;gt;     (compile-root src-dir &amp;quot;out&amp;quot;))&amp;lt;br&amp;gt;  ([src-dir target-dir]&amp;lt;br&amp;gt;     (let [src-dir-file (io/file src-dir)]&amp;lt;br&amp;gt;       (loop [cljs-files (cljs-files-in src-dir-file)&amp;lt;br&amp;gt;              output-files []]&amp;lt;br&amp;gt;         (if (seq cljs-files)&amp;lt;br&amp;gt;           (let [cljs-file (first cljs-files)&amp;lt;br&amp;gt;                 output-file ^java.io.File (to-target-file src-dir-file target-dir cljs-file)&amp;lt;br&amp;gt;                 ns-info (compile-file cljs-file output-file)]&amp;lt;br&amp;gt;             (recur (rest cljs-files) (conj output-files (assoc ns-info :file-name (.getPath output-file)))))&amp;lt;br&amp;gt;           output-files)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">compile-root</a>[src-dir] [src-dir target-dir]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;emit-apply-to&lt;/b&gt; ([{:keys [name params env]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-apply-to&amp;lt;br&amp;gt;  [{:keys [name params env]}]&amp;lt;br&amp;gt;  (let [arglist (gensym &amp;quot;arglist__&amp;quot;)&amp;lt;br&amp;gt;        delegate-name (str (munge name) &amp;quot;__delegate&amp;quot;)&amp;lt;br&amp;gt;        params (map munge params)]&amp;lt;br&amp;gt;    (emitln &amp;quot;(function (&amp;quot; arglist &amp;quot;){&amp;quot;)&amp;lt;br&amp;gt;    (doseq [[i param] (map-indexed vector (butlast params))]&amp;lt;br&amp;gt;      (emits &amp;quot;var &amp;quot; param &amp;quot; = cljs.core.first(&amp;quot;)&amp;lt;br&amp;gt;      (dotimes [_ i] (emits &amp;quot;cljs.core.next(&amp;quot;))&amp;lt;br&amp;gt;      (emits arglist &amp;quot;)&amp;quot;)&amp;lt;br&amp;gt;      (dotimes [_ i] (emits &amp;quot;)&amp;quot;))&amp;lt;br&amp;gt;      (emitln &amp;quot;;&amp;quot;))&amp;lt;br&amp;gt;    (if (&amp;lt; 1 (count params))&amp;lt;br&amp;gt;      (do&amp;lt;br&amp;gt;        (emits &amp;quot;var &amp;quot; (last params) &amp;quot; = cljs.core.rest(&amp;quot;)&amp;lt;br&amp;gt;        (dotimes [_ (- (count params) 2)] (emits &amp;quot;cljs.core.next(&amp;quot;))&amp;lt;br&amp;gt;        (emits arglist)&amp;lt;br&amp;gt;        (dotimes [_ (- (count params) 2)] (emits &amp;quot;)&amp;quot;))&amp;lt;br&amp;gt;        (emitln &amp;quot;);&amp;quot;)&amp;lt;br&amp;gt;        (emitln &amp;quot;return &amp;quot; delegate-name &amp;quot;(&amp;quot; (string/join &amp;quot;, &amp;quot; params) &amp;quot;);&amp;quot;))&amp;lt;br&amp;gt;      (do&amp;lt;br&amp;gt;        (emits &amp;quot;var &amp;quot; (last params) &amp;quot; = &amp;quot;)&amp;lt;br&amp;gt;        (emits &amp;quot;cljs.core.seq(&amp;quot; arglist &amp;quot;);&amp;quot;)&amp;lt;br&amp;gt;        (emitln &amp;quot;;&amp;quot;)&amp;lt;br&amp;gt;        (emitln &amp;quot;return &amp;quot; delegate-name &amp;quot;(&amp;quot; (string/join &amp;quot;, &amp;quot; params) &amp;quot;);&amp;quot;)))&amp;lt;br&amp;gt;    (emits &amp;quot;})&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-apply-to</a>[{:keys [name params env]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;emit-block&lt;/b&gt; ([context statements ret])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-block&amp;lt;br&amp;gt;  [context statements ret]&amp;lt;br&amp;gt;  (when statements&amp;lt;br&amp;gt;    (emits statements))&amp;lt;br&amp;gt;  (emit ret))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-block</a>[context statements ret]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;emit-comment&lt;/b&gt; ([doc jsdoc])&lt;br&gt; Emit a nicely formatted comment string.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-comment&amp;lt;br&amp;gt;  &amp;quot;Emit a nicely formatted comment string.&amp;quot;&amp;lt;br&amp;gt;  [doc jsdoc]&amp;lt;br&amp;gt;  (let [docs (when doc [doc])&amp;lt;br&amp;gt;        docs (if jsdoc (concat docs jsdoc) docs)&amp;lt;br&amp;gt;        docs (remove nil? docs)]&amp;lt;br&amp;gt;    (letfn [(print-comment-lines [e] (doseq [next-line (string/split-lines e)]&amp;lt;br&amp;gt;                                       (emitln &amp;quot;* &amp;quot; (string/trim next-line))))]&amp;lt;br&amp;gt;      (when (seq docs)&amp;lt;br&amp;gt;        (emitln &amp;quot;/**&amp;quot;)&amp;lt;br&amp;gt;        (doseq [e docs]&amp;lt;br&amp;gt;          (when e&amp;lt;br&amp;gt;            (print-comment-lines e)))&amp;lt;br&amp;gt;        (emitln &amp;quot;*/&amp;quot;)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-comment</a>[doc jsdoc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;emit-fn-method&lt;/b&gt; ([{:keys [gthis name variadic params statements ret env recurs max-fixed-arity]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-fn-method&amp;lt;br&amp;gt;  [{:keys [gthis name variadic params statements ret env recurs max-fixed-arity]}]&amp;lt;br&amp;gt;  (emit-wrap env&amp;lt;br&amp;gt;             (emitln &amp;quot;(function &amp;quot; (munge name) &amp;quot;(&amp;quot; (comma-sep (map munge params)) &amp;quot;){&amp;quot;)&amp;lt;br&amp;gt;             (when gthis&amp;lt;br&amp;gt;               (emitln &amp;quot;var &amp;quot; gthis &amp;quot; = this;&amp;quot;))&amp;lt;br&amp;gt;             (when recurs (emitln &amp;quot;while(true){&amp;quot;))&amp;lt;br&amp;gt;             (emit-block :return statements ret)&amp;lt;br&amp;gt;             (when recurs&amp;lt;br&amp;gt;               (emitln &amp;quot;break;&amp;quot;)&amp;lt;br&amp;gt;               (emitln &amp;quot;}&amp;quot;))&amp;lt;br&amp;gt;             (emits &amp;quot;})&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-fn-method</a>[{:keys [gthis name variadic params statements ret env recurs max-fixed-arity]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;emit-str&lt;/b&gt; ([expr])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String emit-str [expr]&amp;lt;br&amp;gt;  (with-out-str (emit expr)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-str</a>[expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;emit-variadic-fn-method&lt;/b&gt; ([{:keys [gthis name variadic params statements ret env recurs max-fixed-arity], :as f}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-variadic-fn-method&amp;lt;br&amp;gt;  [{:keys [gthis name variadic params statements ret env recurs max-fixed-arity] :as f}]&amp;lt;br&amp;gt;  (emit-wrap env&amp;lt;br&amp;gt;             (let [name (or name (gensym))&amp;lt;br&amp;gt;                   mname (munge name)&amp;lt;br&amp;gt;                   params (map munge params)&amp;lt;br&amp;gt;                   delegate-name (str mname &amp;quot;__delegate&amp;quot;)]&amp;lt;br&amp;gt;               (emitln &amp;quot;(function() { &amp;quot;)&amp;lt;br&amp;gt;               (emitln &amp;quot;var &amp;quot; delegate-name &amp;quot; = function (&amp;quot; (comma-sep params) &amp;quot;){&amp;quot;)&amp;lt;br&amp;gt;               (when recurs (emitln &amp;quot;while(true){&amp;quot;))&amp;lt;br&amp;gt;               (emit-block :return statements ret)&amp;lt;br&amp;gt;               (when recurs&amp;lt;br&amp;gt;                 (emitln &amp;quot;break;&amp;quot;)&amp;lt;br&amp;gt;                 (emitln &amp;quot;}&amp;quot;))&amp;lt;br&amp;gt;               (emitln &amp;quot;};&amp;quot;)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;               (emitln &amp;quot;var &amp;quot; mname &amp;quot; = function (&amp;quot; (comma-sep&amp;lt;br&amp;gt;                                                      (if variadic&amp;lt;br&amp;gt;                                                        (concat (butlast params) ['var_args])&amp;lt;br&amp;gt;                                                        params)) &amp;quot;){&amp;quot;)&amp;lt;br&amp;gt;               (when gthis&amp;lt;br&amp;gt;                 (emitln &amp;quot;var &amp;quot; gthis &amp;quot; = this;&amp;quot;))&amp;lt;br&amp;gt;               (when variadic&amp;lt;br&amp;gt;                 (emitln &amp;quot;var &amp;quot; (last params) &amp;quot; = null;&amp;quot;)&amp;lt;br&amp;gt;                 (emitln &amp;quot;if (goog.isDef(var_args)) {&amp;quot;)&amp;lt;br&amp;gt;                 (emitln &amp;quot;  &amp;quot; (last params) &amp;quot; = cljs.core.array_seq(Array.prototype.slice.call(arguments, &amp;quot; (dec (count params)) &amp;quot;),0);&amp;quot;)&amp;lt;br&amp;gt;                 (emitln &amp;quot;} &amp;quot;))&amp;lt;br&amp;gt;               (emitln &amp;quot;return &amp;quot; delegate-name &amp;quot;.call(&amp;quot; (string/join &amp;quot;, &amp;quot; (cons &amp;quot;this&amp;quot; params)) &amp;quot;);&amp;quot;)&amp;lt;br&amp;gt;               (emitln &amp;quot;};&amp;quot;)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;               (emitln mname &amp;quot;.cljs$lang$maxFixedArity = &amp;quot; max-fixed-arity &amp;quot;;&amp;quot;)&amp;lt;br&amp;gt;               (emits mname &amp;quot;.cljs$lang$applyTo = &amp;quot;)&amp;lt;br&amp;gt;               (emit-apply-to (assoc f :name name))&amp;lt;br&amp;gt;               (emitln &amp;quot;;&amp;quot;)&amp;lt;br&amp;gt;               (emitln mname &amp;quot;.cljs$lang$arity$variadic = &amp;quot; delegate-name &amp;quot;;&amp;quot;)&amp;lt;br&amp;gt;               (emitln &amp;quot;return &amp;quot; mname &amp;quot;;&amp;quot;)&amp;lt;br&amp;gt;               (emitln &amp;quot;})()&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-variadic-fn-method</a>[{:keys [gthis name variadic params statements ret env recurs max-fixed-arity], :as f}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;emit-wrap&lt;/b&gt; ([env &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro emit-wrap [env &amp;amp; body]&amp;lt;br&amp;gt;  `(let [env# ~env]&amp;lt;br&amp;gt;     (when (= :return (:context env#)) (emits &amp;quot;return &amp;quot;))&amp;lt;br&amp;gt;     ~@body&amp;lt;br&amp;gt;     (when-not (= :expr (:context env#)) (emitln &amp;quot;;&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-wrap</a>[env & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;emitln&lt;/b&gt; ([&amp; xs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emitln [&amp;amp; xs]&amp;lt;br&amp;gt;  (apply emits xs)&amp;lt;br&amp;gt;  ;; Prints column-aligned line number comments; good test of *position*.&amp;lt;br&amp;gt;  ;(when *position*&amp;lt;br&amp;gt;  ;  (let [[line column] @*position*]&amp;lt;br&amp;gt;  ;    (print (apply str (concat (repeat (- 120 column) \space) [&amp;quot;// &amp;quot; (inc line)])))))&amp;lt;br&amp;gt;  (println)&amp;lt;br&amp;gt;  (when *position*&amp;lt;br&amp;gt;    (swap! *position* (fn [[line column]]&amp;lt;br&amp;gt;                        [(inc line) 0])))&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emitln</a>[& xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;emits&lt;/b&gt; ([&amp; xs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emits [&amp;amp; xs]&amp;lt;br&amp;gt;  (doseq [x xs]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (nil? x) nil&amp;lt;br&amp;gt;      (map? x) (emit x)&amp;lt;br&amp;gt;      (seq? x) (apply emits x)&amp;lt;br&amp;gt;      (fn? x)  (x)&amp;lt;br&amp;gt;      :else (do&amp;lt;br&amp;gt;              (let [s (print-str x)]&amp;lt;br&amp;gt;                (when *position*&amp;lt;br&amp;gt;                  (swap! *position* (fn [[line column]]&amp;lt;br&amp;gt;                                      [line (+ column (count s))])))&amp;lt;br&amp;gt;                (print s)))))&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emits</a>[& xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;forms-seq&lt;/b&gt; ([f] [f rdr])&lt;br&gt; Seq of forms in a Clojure or ClojureScript file.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn forms-seq&amp;lt;br&amp;gt;  &amp;quot;Seq of forms in a Clojure or ClojureScript file.&amp;quot;&amp;lt;br&amp;gt;  ([f]&amp;lt;br&amp;gt;     (forms-seq f (clojure.lang.LineNumberingPushbackReader. (io/reader f))))&amp;lt;br&amp;gt;  ([f ^java.io.PushbackReader rdr]&amp;lt;br&amp;gt;     (if-let [form (binding [*ns* ana/*reader-ns*] (read rdr nil nil))]&amp;lt;br&amp;gt;       (lazy-seq (cons form (forms-seq f rdr)))&amp;lt;br&amp;gt;       (.close rdr))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">forms-seq</a>[f] [f rdr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;get-tag&lt;/b&gt; ([e])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-tag [e]&amp;lt;br&amp;gt;  (or (-&amp;gt; e :tag)&amp;lt;br&amp;gt;      (-&amp;gt; e :info :tag)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-tag</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;infer-tag&lt;/b&gt; ([e])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn infer-tag [e]&amp;lt;br&amp;gt;  (if-let [tag (get-tag e)]&amp;lt;br&amp;gt;    tag&amp;lt;br&amp;gt;    (case (:op e)&amp;lt;br&amp;gt;      :let (infer-tag (:ret e))&amp;lt;br&amp;gt;      :if (let [then-tag (infer-tag (:then e))&amp;lt;br&amp;gt;                else-tag (infer-tag (:else e))]&amp;lt;br&amp;gt;            (when (= then-tag else-tag)&amp;lt;br&amp;gt;              then-tag))&amp;lt;br&amp;gt;      :constant (case (:form e)&amp;lt;br&amp;gt;                  true 'boolean&amp;lt;br&amp;gt;                  false 'boolean&amp;lt;br&amp;gt;                  nil)&amp;lt;br&amp;gt;      nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">infer-tag</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;mkdirs&lt;/b&gt; ([f])&lt;br&gt; Create all parent directories for the passed file.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mkdirs&amp;lt;br&amp;gt;  &amp;quot;Create all parent directories for the passed file.&amp;quot;&amp;lt;br&amp;gt;  [^java.io.File f]&amp;lt;br&amp;gt;  (.mkdirs (.getParentFile (.getCanonicalFile f))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mkdirs</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;munge&lt;/b&gt; ([s] [s reserved])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn munge&amp;lt;br&amp;gt;  ([s] (munge s js-reserved))&amp;lt;br&amp;gt;  ([s reserved]&amp;lt;br&amp;gt;    (let [ss (string/replace (str s) #&amp;quot;\/(.)&amp;quot; &amp;quot;.$1&amp;quot;) ; Division is special&amp;lt;br&amp;gt;          ss (apply str (map #(if (reserved %) (str % &amp;quot;$&amp;quot;) %)&amp;lt;br&amp;gt;                             (string/split ss #&amp;quot;(?&amp;lt;=\.)|(?=\.)&amp;quot;)))&amp;lt;br&amp;gt;          ms (clojure.lang.Compiler/munge ss)]&amp;lt;br&amp;gt;      (if (symbol? s)&amp;lt;br&amp;gt;        (symbol ms)&amp;lt;br&amp;gt;        ms))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">munge</a>[s] [s reserved]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;path-seq&lt;/b&gt; ([file-str])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn path-seq&amp;lt;br&amp;gt;  [file-str]&amp;lt;br&amp;gt;  (-&amp;gt;&amp;gt; java.io.File/separator&amp;lt;br&amp;gt;       java.util.regex.Pattern/quote&amp;lt;br&amp;gt;       re-pattern&amp;lt;br&amp;gt;       (string/split file-str)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">path-seq</a>[file-str]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;protocol-prefix&lt;/b&gt; ([psym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn protocol-prefix [psym]&amp;lt;br&amp;gt;  (str (-&amp;gt; (str psym) (.replace \. \$) (.replace \/ \$)) &amp;quot;$&amp;quot;))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">protocol-prefix</a>[psym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;rename-to-js&lt;/b&gt; ([file-str])&lt;br&gt; Change the file extension from .cljs to .js. Takes a File or a&lt;br&gt;  String. Always returns a String.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rename-to-js&amp;lt;br&amp;gt;  &amp;quot;Change the file extension from .cljs to .js. Takes a File or a&amp;lt;br&amp;gt;  String. Always returns a String.&amp;quot;&amp;lt;br&amp;gt;  [file-str]&amp;lt;br&amp;gt;  (clojure.string/replace file-str #&amp;quot;\.cljs$&amp;quot; &amp;quot;.js&amp;quot;))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rename-to-js</a>[file-str]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;requires-compilation?&lt;/b&gt; ([src dest])&lt;br&gt; Return true if the src file requires compilation.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn requires-compilation?&amp;lt;br&amp;gt;  &amp;quot;Return true if the src file requires compilation.&amp;quot;&amp;lt;br&amp;gt;  [^java.io.File src ^java.io.File dest]&amp;lt;br&amp;gt;  (or (not (.exists dest))&amp;lt;br&amp;gt;      (&amp;gt; (.lastModified src) (.lastModified dest))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">requires-compilation?</a>[src dest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;safe-test?&lt;/b&gt; ([e])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn safe-test? [e]&amp;lt;br&amp;gt;  (let [tag (infer-tag e)]&amp;lt;br&amp;gt;    (or (#{'boolean 'seq} tag)&amp;lt;br&amp;gt;        (when (= (:op e) :constant)&amp;lt;br&amp;gt;          (let [form (:form e)]&amp;lt;br&amp;gt;            (not (or (and (string? form) (= form &amp;quot;&amp;quot;))&amp;lt;br&amp;gt;                     (and (number? form) (zero? form)))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">safe-test?</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;to-path&lt;/b&gt; ([parts] [parts sep])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn to-path&amp;lt;br&amp;gt;  ([parts]&amp;lt;br&amp;gt;     (to-path parts java.io.File/separator))&amp;lt;br&amp;gt;  ([parts sep]&amp;lt;br&amp;gt;     (apply str (interpose sep parts))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">to-path</a>[parts] [parts sep]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;to-target-file&lt;/b&gt; ([dir target file])&lt;br&gt; Given the source root directory, the output target directory and&lt;br&gt;  file under the source root, produce the target file.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn to-target-file&amp;lt;br&amp;gt;  &amp;quot;Given the source root directory, the output target directory and&amp;lt;br&amp;gt;  file under the source root, produce the target file.&amp;quot;&amp;lt;br&amp;gt;  [^java.io.File dir ^String target ^java.io.File file]&amp;lt;br&amp;gt;  (let [dir-path (path-seq (.getAbsolutePath dir))&amp;lt;br&amp;gt;        file-path (path-seq (.getAbsolutePath file))&amp;lt;br&amp;gt;        relative-path (drop (count dir-path) file-path)&amp;lt;br&amp;gt;        parents (butlast relative-path)&amp;lt;br&amp;gt;        parent-file (java.io.File. ^String (to-path (cons target parents)))]&amp;lt;br&amp;gt;    (java.io.File. parent-file ^String (rename-to-js (last relative-path)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">to-target-file</a>[dir target file]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.compiler&lt;/i&gt;&lt;b&gt;with-core-cljs&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Ensure that core.cljs has been loaded.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-core-cljs&amp;lt;br&amp;gt;  &amp;quot;Ensure that core.cljs has been loaded.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;  `(do (when-not (:defs (get @ana/namespaces 'cljs.core))&amp;lt;br&amp;gt;         (ana/analyze-file &amp;quot;cljs/core.cljs&amp;quot;))&amp;lt;br&amp;gt;       ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-core-cljs</a>[& body]</div></div></div><div class="row"><div class="namespace"><h4>cljs.tagged-literals</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.tagged-literals&lt;/i&gt;&lt;b&gt;read-inst&lt;/b&gt; ([form])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-inst&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (assert (string? form) &amp;quot;Instance literal expects a string for its timestamp.&amp;quot;)&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;    (let [^java.util.Date d (inst/read-instant-date form)]&amp;lt;br&amp;gt;      (list (symbol &amp;quot;js/Date.&amp;quot;) (.getTime d)))&amp;lt;br&amp;gt;    (catch Throwable e&amp;lt;br&amp;gt;      (throw (RuntimeException. (.getMessage e))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-inst</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.tagged-literals&lt;/i&gt;&lt;b&gt;read-queue&lt;/b&gt; ([form])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-queue&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (assert (vector? form) &amp;quot;Queue literal expects a vector for its elements.&amp;quot;)&amp;lt;br&amp;gt;  (list 'cljs.core/into 'cljs.core.PersistentQueue/EMPTY form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-queue</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;cljs.tagged-literals&lt;/i&gt;&lt;b&gt;read-uuid&lt;/b&gt; ([form])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-uuid&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (assert (string? form) &amp;quot;UUID literal expects a string as its representation.&amp;quot;)&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;    (let [uuid (java.util.UUID/fromString form)]&amp;lt;br&amp;gt;      (list (symbol &amp;quot;UUID.&amp;quot;) form))&amp;lt;br&amp;gt;    (catch Throwable e&amp;lt;br&amp;gt;      (throw (RuntimeException. (.getMessage e))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-uuid</a>[form]</div></div></div><div class="row"><div class="namespace"><h4>clojure.algo.generic</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.generic&lt;/i&gt;&lt;b&gt;nary-dispatch&lt;/b&gt; ([] [x] [x y] [x y &amp; more])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn nary-dispatch&amp;lt;br&amp;gt;  ([] ::nulary)&amp;lt;br&amp;gt;  ([x] (type x))&amp;lt;br&amp;gt;  ([x y]&amp;lt;br&amp;gt;     [(type x) (type y)])&amp;lt;br&amp;gt;  ([x y &amp;amp; more] ::nary))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nary-dispatch</a>[] [x] [x y] [x y & more]</div></div></div><div class="row"><div class="namespace"><h4>clojure.algo.monads</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;call-cc&lt;/b&gt; ([f])&lt;br&gt; A computation in the cont monad that calls function f with a single&lt;br&gt;   argument representing the current continuation. The function f should&lt;br&gt;   return a continuation (which becomes the return value of call-cc),&lt;br&gt;   or call the passed-in current continuation to terminate.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn call-cc&amp;lt;br&amp;gt;  &amp;quot;A computation in the cont monad that calls function f with a single&amp;lt;br&amp;gt;   argument representing the current continuation. The function f should&amp;lt;br&amp;gt;   return a continuation (which becomes the return value of call-cc),&amp;lt;br&amp;gt;   or call the passed-in current continuation to terminate.&amp;quot;&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (fn [c]&amp;lt;br&amp;gt;    (let [cc (fn cc [a] (fn [_] (c a)))&amp;lt;br&amp;gt;          rc (f cc)]&amp;lt;br&amp;gt;      (rc c))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">call-cc</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;censor&lt;/b&gt; ([f mv])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn censor [f mv]&amp;lt;br&amp;gt;  (let [[v a] mv] [v (f a)]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">censor</a>[f mv]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;cond-statement&lt;/b&gt; ([expr mexpr continuation])&lt;br&gt; Process a :cond steps when adding a new monadic step to the mexrp.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cond-statement&amp;lt;br&amp;gt;  &amp;quot;Process a :cond steps when adding a new monadic step to the mexrp.&amp;quot;&amp;lt;br&amp;gt;  [expr mexpr continuation]&amp;lt;br&amp;gt;  (let [cond-sexps (partition 2 expr)&amp;lt;br&amp;gt;        result (for [[cond-sexp monadic-sexp] cond-sexps]&amp;lt;br&amp;gt;                     (list cond-sexp&amp;lt;br&amp;gt;                           (reduce continuation&amp;lt;br&amp;gt;                                   mexpr&amp;lt;br&amp;gt;                                   (prepare-monadic-steps monadic-sexp))))]&amp;lt;br&amp;gt;      `(cond ~@(merge-cond-branches result))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cond-statement</a>[expr mexpr continuation]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;defmonad&lt;/b&gt; ([name doc-string operations] [name operations])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a named monad by defining the monad operations. The definitions&lt;br&gt;   are written like bindings to the monad operations m-bind and&lt;br&gt;   m-result (required) and m-zero and m-plus (optional).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defmonad&amp;lt;br&amp;gt;  &amp;quot;Define a named monad by defining the monad operations. The definitions&amp;lt;br&amp;gt;   are written like bindings to the monad operations m-bind and&amp;lt;br&amp;gt;   m-result (required) and m-zero and m-plus (optional).&amp;quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  ([name doc-string operations]&amp;lt;br&amp;gt;   (let [doc-name (with-meta name {:doc doc-string})]&amp;lt;br&amp;gt;     `(defmonad ~doc-name ~operations)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  ([name operations]&amp;lt;br&amp;gt;   `(def ~name (monad ~operations))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defmonad</a>[name doc-string operations] [name operations]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;defmonadfn&lt;/b&gt; ([name docstring? attr-map? args expr] [name docstring? attr-map? (args expr) ...])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Like defn, but for functions that use monad operations and are used inside&lt;br&gt;   a with-monad block.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defmonadfn&amp;lt;br&amp;gt;  &amp;quot;Like defn, but for functions that use monad operations and are used inside&amp;lt;br&amp;gt;   a with-monad block.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([name docstring? attr-map? args expr]&amp;lt;br&amp;gt;               [name docstring? attr-map? (args expr) ...])}&amp;lt;br&amp;gt;  [name &amp;amp; options]&amp;lt;br&amp;gt;  (let [[name options]  (name-with-attributes name options)&amp;lt;br&amp;gt;        fn-name (symbol (str *ns*) (format &amp;quot;m+%s+m&amp;quot; (str name)))&amp;lt;br&amp;gt;        make-fn-body    (fn [args expr]&amp;lt;br&amp;gt;                          (list (vec (concat ['m-bind 'm-result&amp;lt;br&amp;gt;                                              'm-zero 'm-plus] args))&amp;lt;br&amp;gt;                                (list `with-symbol-macros expr)))]&amp;lt;br&amp;gt;    (if (list? (first options))&amp;lt;br&amp;gt;      ; multiple arities&amp;lt;br&amp;gt;      (let [arglists        (map first options)&amp;lt;br&amp;gt;            exprs           (map second options)&amp;lt;br&amp;gt;            ]&amp;lt;br&amp;gt;        `(do&amp;lt;br&amp;gt;           (defsymbolmacro ~name (partial ~fn-name ~'m-bind ~'m-result &amp;lt;br&amp;gt;                                                   ~'m-zero ~'m-plus))&amp;lt;br&amp;gt;           (defn ~fn-name ~@(map make-fn-body arglists exprs))))&amp;lt;br&amp;gt;      ; single arity&amp;lt;br&amp;gt;      (let [[args expr] options]&amp;lt;br&amp;gt;        `(do&amp;lt;br&amp;gt;           (defsymbolmacro ~name (partial ~fn-name ~'m-bind ~'m-result &amp;lt;br&amp;gt;                                                   ~'m-zero ~'m-plus))&amp;lt;br&amp;gt;           (defn ~fn-name ~@(make-fn-body args expr)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defmonadfn</a>[name docstring? attr-map? args expr] [name docstring? attr-map? (args expr) ...]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;domonad&lt;/b&gt; ([steps expr] [name steps expr])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Monad comprehension. Takes the name of a monad, a vector of steps&lt;br&gt;   given as binding-form/monadic-expression pairs, and a result value&lt;br&gt;   specified by expr. The monadic-expression terms can use the binding&lt;br&gt;   variables of the previous steps.&lt;br&gt;   If the monad contains a definition of m-zero, the step list can also&lt;br&gt;   contain conditions of the form :when p, where the predicate p can&lt;br&gt;   contain the binding variables from all previous steps.&lt;br&gt;   A clause of the form :let [binding-form expr ...], where the bindings&lt;br&gt;   are given as a vector as for the use in let, establishes additional&lt;br&gt;   bindings that can be used in the following steps.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro domonad&amp;lt;br&amp;gt;  &amp;quot;Monad comprehension. Takes the name of a monad, a vector of steps&amp;lt;br&amp;gt;   given as binding-form/monadic-expression pairs, and a result value&amp;lt;br&amp;gt;   specified by expr. The monadic-expression terms can use the binding&amp;lt;br&amp;gt;   variables of the previous steps.&amp;lt;br&amp;gt;   If the monad contains a definition of m-zero, the step list can also&amp;lt;br&amp;gt;   contain conditions of the form :when p, where the predicate p can&amp;lt;br&amp;gt;   contain the binding variables from all previous steps.&amp;lt;br&amp;gt;   A clause of the form :let [binding-form expr ...], where the bindings&amp;lt;br&amp;gt;   are given as a vector as for the use in let, establishes additional&amp;lt;br&amp;gt;   bindings that can be used in the following steps.&amp;quot;&amp;lt;br&amp;gt;  ([steps expr]&amp;lt;br&amp;gt;    (monad-expr steps expr))&amp;lt;br&amp;gt;  ([name steps expr]&amp;lt;br&amp;gt;    (let [mexpr (monad-expr steps expr)]&amp;lt;br&amp;gt;      `(with-monad ~name ~mexpr))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">domonad</a>[steps expr] [name steps expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;fetch-state&lt;/b&gt; ([])&lt;br&gt; Return a state-monad function that returns the current state and does not&lt;br&gt;   modify it.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fetch-state&amp;lt;br&amp;gt;  &amp;quot;Return a state-monad function that returns the current state and does not&amp;lt;br&amp;gt;   modify it.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (update-state identity))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fetch-state</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;fetch-val&lt;/b&gt; ([key])&lt;br&gt; Return a state-monad function that assumes the state to be a map and&lt;br&gt;   returns the value corresponding to the given key. The state is not modified.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fetch-val&amp;lt;br&amp;gt;  &amp;quot;Return a state-monad function that assumes the state to be a map and&amp;lt;br&amp;gt;   returns the value corresponding to the given key. The state is not modified.&amp;quot;&amp;lt;br&amp;gt;  [key]&amp;lt;br&amp;gt;  (fn [s] [(get s key ) s]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fetch-val</a>[key]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;listen&lt;/b&gt; ([mv])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn listen [mv]&amp;lt;br&amp;gt;  (let [[v a] mv] [[v a] a]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">listen</a>[mv]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;m+m-chain+m&lt;/b&gt; ([m-bind m-result m-zero m-plus steps])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmonadfn m-chain&amp;lt;br&amp;gt;  &amp;quot;Chains together monadic computation steps that are each functions&amp;lt;br&amp;gt;   of one parameter. Each step is called with the result of the previous&amp;lt;br&amp;gt;   step as its argument. (m-chain (step1 step2)) is equivalent to&amp;lt;br&amp;gt;   (fn [x] (domonad [r1 (step1 x) r2 (step2 r1)] r2)).&amp;quot;&amp;lt;br&amp;gt;  [steps]&amp;lt;br&amp;gt;  (reduce (fn m-chain-link [chain-expr step]&amp;lt;br&amp;gt;            (fn [v] (m-bind (chain-expr v) step)))&amp;lt;br&amp;gt;          m-result&amp;lt;br&amp;gt;          steps))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">m+m-chain+m</a>[m-bind m-result m-zero m-plus steps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;m+m-fmap+m&lt;/b&gt; ([m-bind m-result m-zero m-plus f m])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmonadfn m-fmap&amp;lt;br&amp;gt;  &amp;quot;Bind the monadic value m to the function returning (f x) for argument x&amp;quot;&amp;lt;br&amp;gt;  [f m]&amp;lt;br&amp;gt;  (m-bind m (fn [x] (m-result (f x)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">m+m-fmap+m</a>[m-bind m-result m-zero m-plus f m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;m+m-join+m&lt;/b&gt; ([m-bind m-result m-zero m-plus m])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmonadfn m-join&amp;lt;br&amp;gt;  &amp;quot;Converts a monadic value containing a monadic value into a 'simple'&amp;lt;br&amp;gt;   monadic value.&amp;quot;&amp;lt;br&amp;gt;  [m]&amp;lt;br&amp;gt;  (m-bind m identity))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">m+m-join+m</a>[m-bind m-result m-zero m-plus m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;m+m-map+m&lt;/b&gt; ([m-bind m-result m-zero m-plus f xs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmonadfn m-map&amp;lt;br&amp;gt;  &amp;quot;'Executes' the sequence of monadic values resulting from mapping&amp;lt;br&amp;gt;   f onto the values xs. f must return a monadic value.&amp;quot;&amp;lt;br&amp;gt;  [f xs]&amp;lt;br&amp;gt;  (m-seq (map f xs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">m+m-map+m</a>[m-bind m-result m-zero m-plus f xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;m+m-reduce+m&lt;/b&gt; ([m-bind m-result m-zero m-plus f mvs] [m-bind m-result m-zero m-plus f val mvs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmonadfn m-reduce&amp;lt;br&amp;gt;  &amp;quot;Return the reduction of (m-lift 2 f) over the list of monadic values mvs&amp;lt;br&amp;gt;   with initial value (m-result val).&amp;quot;&amp;lt;br&amp;gt;  ([f mvs]&amp;lt;br&amp;gt;   (if (empty? mvs)&amp;lt;br&amp;gt;     (m-result (f))&amp;lt;br&amp;gt;     (let [m-f (m-lift 2 f)]&amp;lt;br&amp;gt;       (reduce m-f mvs))))&amp;lt;br&amp;gt;  ([f val mvs]&amp;lt;br&amp;gt;   (let [m-f    (m-lift 2 f)&amp;lt;br&amp;gt;         m-val  (m-result val)]&amp;lt;br&amp;gt;     (reduce m-f m-val mvs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">m+m-reduce+m</a>[m-bind m-result m-zero m-plus f mvs] [m-bind m-result m-zero m-plus f val mvs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;m+m-seq+m&lt;/b&gt; ([m-bind m-result m-zero m-plus ms])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmonadfn m-seq&amp;lt;br&amp;gt;  &amp;quot;'Executes' the monadic values in ms and returns a sequence of the&amp;lt;br&amp;gt;   basic values contained in them.&amp;quot;&amp;lt;br&amp;gt;  [ms]&amp;lt;br&amp;gt;  (reduce (fn [q p]&amp;lt;br&amp;gt;            (m-bind p (fn [x]&amp;lt;br&amp;gt;                        (m-bind q (fn [y]&amp;lt;br&amp;gt;                                    (m-result (cons x y)))) )))&amp;lt;br&amp;gt;          (m-result '())&amp;lt;br&amp;gt;          (reverse ms)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">m+m-seq+m</a>[m-bind m-result m-zero m-plus ms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;m+m-until+m&lt;/b&gt; ([m-bind m-result m-zero m-plus p f x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmonadfn m-until&amp;lt;br&amp;gt;  &amp;quot;While (p x) is false, replace x by the value returned by the&amp;lt;br&amp;gt;   monadic computation (f x). Return (m-result x) for the first&amp;lt;br&amp;gt;   x for which (p x) is true.&amp;quot;&amp;lt;br&amp;gt;  [p f x]&amp;lt;br&amp;gt;  (if (p x)&amp;lt;br&amp;gt;    (m-result x)&amp;lt;br&amp;gt;    (domonad&amp;lt;br&amp;gt;      [y (f x)&amp;lt;br&amp;gt;       z (m-until p f y)]&amp;lt;br&amp;gt;      z)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">m+m-until+m</a>[m-bind m-result m-zero m-plus p f x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;m+write+m&lt;/b&gt; ([m-bind m-result m-zero m-plus v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmonadfn write [v]&amp;lt;br&amp;gt;  (let [[_ a] (m-result nil)]&amp;lt;br&amp;gt;    [nil (writer-m-add a v)]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">m+write+m</a>[m-bind m-result m-zero m-plus v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;m-lift&lt;/b&gt; ([n f])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Converts a function f of n arguments into a function of n&lt;br&gt;  monadic arguments returning a monadic value.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro m-lift&amp;lt;br&amp;gt;  &amp;quot;Converts a function f of n arguments into a function of n&amp;lt;br&amp;gt;  monadic arguments returning a monadic value.&amp;quot;&amp;lt;br&amp;gt;  [n f]&amp;lt;br&amp;gt;  (let [expr (take n (repeatedly #(gensym &amp;quot;x_&amp;quot;)))&amp;lt;br&amp;gt;        vars (vec (take n (repeatedly #(gensym &amp;quot;mv_&amp;quot;))))&amp;lt;br&amp;gt;        steps (vec (interleave expr vars))]&amp;lt;br&amp;gt;    (list `fn vars (monad-expr steps (cons f expr)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">m-lift</a>[n f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;m-when&lt;/b&gt; ([test m-expr])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; If test is logical true, return monadic value m-expr, else return&lt;br&gt;   (m-result nil).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro m-when&amp;lt;br&amp;gt;  &amp;quot;If test is logical true, return monadic value m-expr, else return&amp;lt;br&amp;gt;   (m-result nil).&amp;quot;&amp;lt;br&amp;gt;  [test m-expr]&amp;lt;br&amp;gt;  `(if ~test ~m-expr (~'m-result nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">m-when</a>[test m-expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;m-when-not&lt;/b&gt; ([test m-expr])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; If test if logical false, return monadic value m-expr, else return&lt;br&gt;   (m-result nil).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro m-when-not&amp;lt;br&amp;gt;  &amp;quot;If test if logical false, return monadic value m-expr, else return&amp;lt;br&amp;gt;   (m-result nil).&amp;quot;&amp;lt;br&amp;gt;  [test m-expr]&amp;lt;br&amp;gt;  `(if ~test (~'m-result nil) ~m-expr))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">m-when-not</a>[test m-expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;maybe-t&lt;/b&gt; ([m] [m nothing] [m nothing which-m-plus])&lt;br&gt; Monad transformer that transforms a monad m into a monad in which&lt;br&gt;   the base values can be invalid (represented by nothing, which defaults&lt;br&gt;   to nil). The third argument chooses if m-zero and m-plus are inherited&lt;br&gt;   from the base monad (use :m-plus-from-base) or adopt maybe-like&lt;br&gt;   behaviour (use :m-plus-from-transformer). The default is :m-plus-from-base&lt;br&gt;   if the base monad m has a definition for m-plus, and&lt;br&gt;   :m-plus-from-transformer otherwise.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn maybe-t&amp;lt;br&amp;gt;  &amp;quot;Monad transformer that transforms a monad m into a monad in which&amp;lt;br&amp;gt;   the base values can be invalid (represented by nothing, which defaults&amp;lt;br&amp;gt;   to nil). The third argument chooses if m-zero and m-plus are inherited&amp;lt;br&amp;gt;   from the base monad (use :m-plus-from-base) or adopt maybe-like&amp;lt;br&amp;gt;   behaviour (use :m-plus-from-transformer). The default is :m-plus-from-base&amp;lt;br&amp;gt;   if the base monad m has a definition for m-plus, and&amp;lt;br&amp;gt;   :m-plus-from-transformer otherwise.&amp;quot;&amp;lt;br&amp;gt;  ([m] (maybe-t m nil :m-plus-default))&amp;lt;br&amp;gt;  ([m nothing] (maybe-t m nothing :m-plus-default))&amp;lt;br&amp;gt;  ([m nothing which-m-plus]&amp;lt;br&amp;gt;   (monad-transformer m which-m-plus&amp;lt;br&amp;gt;     [m-result (with-monad m m-result)&amp;lt;br&amp;gt;      m-bind   (with-monad m&amp;lt;br&amp;gt;                 (fn m-bind-maybe-t [mv f]&amp;lt;br&amp;gt;                   (m-bind mv&amp;lt;br&amp;gt;                           (fn [x]&amp;lt;br&amp;gt;                             (if (identical? x nothing)&amp;lt;br&amp;gt;                               (m-result nothing)&amp;lt;br&amp;gt;                               (f x))))))&amp;lt;br&amp;gt;      m-zero   (with-monad m (m-result nothing))&amp;lt;br&amp;gt;      m-plus   (with-monad m&amp;lt;br&amp;gt;                 (fn m-plus-maybe-t [&amp;amp; mvs]&amp;lt;br&amp;gt;                   (if (empty? mvs)&amp;lt;br&amp;gt;                     (m-result nothing)&amp;lt;br&amp;gt;                     (m-bind (first mvs)&amp;lt;br&amp;gt;                             (fn [v]&amp;lt;br&amp;gt;                               (if (= v nothing)&amp;lt;br&amp;gt;                                 (apply m-plus-maybe-t (rest mvs))&amp;lt;br&amp;gt;                                 (m-result v)))))))&amp;lt;br&amp;gt;      ])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">maybe-t</a>[m] [m nothing] [m nothing which-m-plus]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;monad&lt;/b&gt; ([operations])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a monad by defining the monad operations. The definitions&lt;br&gt;   are written like bindings to the monad operations m-bind and&lt;br&gt;   m-result (required) and m-zero and m-plus (optional).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro monad&amp;lt;br&amp;gt;  &amp;quot;Define a monad by defining the monad operations. The definitions&amp;lt;br&amp;gt;   are written like bindings to the monad operations m-bind and&amp;lt;br&amp;gt;   m-result (required) and m-zero and m-plus (optional).&amp;quot;&amp;lt;br&amp;gt;  [operations]&amp;lt;br&amp;gt;  `(let [~'m-bind   ::undefined&amp;lt;br&amp;gt;         ~'m-result ::undefined&amp;lt;br&amp;gt;         ~'m-zero   ::undefined&amp;lt;br&amp;gt;         ~'m-plus   ::undefined&amp;lt;br&amp;gt;         ~@operations]&amp;lt;br&amp;gt;     {:m-result ~'m-result&amp;lt;br&amp;gt;      :m-bind ~'m-bind &amp;lt;br&amp;gt;      :m-zero ~'m-zero&amp;lt;br&amp;gt;      :m-plus ~'m-plus}))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">monad</a>[operations]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;monad-transformer&lt;/b&gt; ([base which-m-plus operations])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a monad transforer in terms of the monad operations and the base&lt;br&gt;   monad. The argument which-m-plus chooses if m-zero and m-plus are taken&lt;br&gt;   from the base monad or from the transformer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro monad-transformer&amp;lt;br&amp;gt;  &amp;quot;Define a monad transforer in terms of the monad operations and the base&amp;lt;br&amp;gt;   monad. The argument which-m-plus chooses if m-zero and m-plus are taken&amp;lt;br&amp;gt;   from the base monad or from the transformer.&amp;quot;&amp;lt;br&amp;gt;  [base which-m-plus operations]&amp;lt;br&amp;gt;  `(let [which-m-plus# (cond (= ~which-m-plus :m-plus-default)&amp;lt;br&amp;gt;                               (if (= ::undefined (with-monad ~base ~'m-plus))&amp;lt;br&amp;gt;                                 :m-plus-from-transformer&amp;lt;br&amp;gt;                                 :m-plus-from-base)&amp;lt;br&amp;gt;                             (or (= ~which-m-plus :m-plus-from-base)&amp;lt;br&amp;gt;                                 (= ~which-m-plus :m-plus-from-transformer))&amp;lt;br&amp;gt;                               ~which-m-plus&amp;lt;br&amp;gt;                             :else&amp;lt;br&amp;gt;                               (throw (java.lang.IllegalArgumentException.&amp;lt;br&amp;gt;                                       &amp;quot;undefined m-plus choice&amp;quot;)))&amp;lt;br&amp;gt;         combined-monad# (monad ~operations)]&amp;lt;br&amp;gt;    (if (= which-m-plus# :m-plus-from-base)&amp;lt;br&amp;gt;      (assoc combined-monad#&amp;lt;br&amp;gt;        :m-zero (with-monad ~base ~'m-zero)&amp;lt;br&amp;gt;        :m-plus (with-monad ~base ~'m-plus))&amp;lt;br&amp;gt;      combined-monad#)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">monad-transformer</a>[base which-m-plus operations]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;run-cont&lt;/b&gt; ([c])&lt;br&gt; Execute the computation c in the cont monad and return its result.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn run-cont&amp;lt;br&amp;gt;  &amp;quot;Execute the computation c in the cont monad and return its result.&amp;quot;&amp;lt;br&amp;gt;  [c]&amp;lt;br&amp;gt;  (c identity))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-cont</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;sequence-t&lt;/b&gt; ([m] [m which-m-plus])&lt;br&gt; Monad transformer that transforms a monad m into a monad in which&lt;br&gt;   the base values are sequences. The argument which-m-plus chooses&lt;br&gt;   if m-zero and m-plus are inherited from the base monad&lt;br&gt;   (use :m-plus-from-base) or adopt sequence-like&lt;br&gt;   behaviour (use :m-plus-from-transformer). The default is :m-plus-from-base&lt;br&gt;   if the base monad m has a definition for m-plus, and&lt;br&gt;   :m-plus-from-transformer otherwise.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sequence-t&amp;lt;br&amp;gt;  &amp;quot;Monad transformer that transforms a monad m into a monad in which&amp;lt;br&amp;gt;   the base values are sequences. The argument which-m-plus chooses&amp;lt;br&amp;gt;   if m-zero and m-plus are inherited from the base monad&amp;lt;br&amp;gt;   (use :m-plus-from-base) or adopt sequence-like&amp;lt;br&amp;gt;   behaviour (use :m-plus-from-transformer). The default is :m-plus-from-base&amp;lt;br&amp;gt;   if the base monad m has a definition for m-plus, and&amp;lt;br&amp;gt;   :m-plus-from-transformer otherwise.&amp;quot;&amp;lt;br&amp;gt;  ([m] (sequence-t m :m-plus-default))&amp;lt;br&amp;gt;  ([m which-m-plus]&amp;lt;br&amp;gt;   (monad-transformer m which-m-plus&amp;lt;br&amp;gt;     [m-result (with-monad m&amp;lt;br&amp;gt;                 (fn m-result-sequence-t [v]&amp;lt;br&amp;gt;                   (m-result (list v))))&amp;lt;br&amp;gt;      m-bind   (with-monad m&amp;lt;br&amp;gt;                 (fn m-bind-sequence-t [mv f]&amp;lt;br&amp;gt;                   (m-bind mv&amp;lt;br&amp;gt;                           (fn [xs]&amp;lt;br&amp;gt;                             (m-fmap flatten*&amp;lt;br&amp;gt;                                     (m-map f xs))))))&amp;lt;br&amp;gt;      m-zero   (with-monad m (m-result (list)))&amp;lt;br&amp;gt;      m-plus   (with-monad m&amp;lt;br&amp;gt;                 (fn m-plus-sequence-t [&amp;amp; mvs]&amp;lt;br&amp;gt;                   (m-reduce concat (list) mvs)))&amp;lt;br&amp;gt;      ])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sequence-t</a>[m] [m which-m-plus]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;set-state&lt;/b&gt; ([s])&lt;br&gt; Return a state-monad function that replaces the current state by s and&lt;br&gt;   returns the previous state.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-state&amp;lt;br&amp;gt;  &amp;quot;Return a state-monad function that replaces the current state by s and&amp;lt;br&amp;gt;   returns the previous state.&amp;quot;&amp;lt;br&amp;gt;  [s]&amp;lt;br&amp;gt;  (update-state (fn [_] s)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-state</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;set-val&lt;/b&gt; ([key val])&lt;br&gt; Return a state-monad function that assumes the state to be a map and&lt;br&gt;   replaces the value associated with key by val. The old value is returned.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-val&amp;lt;br&amp;gt;  &amp;quot;Return a state-monad function that assumes the state to be a map and&amp;lt;br&amp;gt;   replaces the value associated with key by val. The old value is returned.&amp;quot;&amp;lt;br&amp;gt;  [key val]&amp;lt;br&amp;gt;  (update-val key (fn [_] val)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-val</a>[key val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;state-m-until&lt;/b&gt; ([p f x])&lt;br&gt; An optimized implementation of m-until for the state monad that&lt;br&gt;   replaces recursion by a loop.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn state-m-until&amp;lt;br&amp;gt;  &amp;quot;An optimized implementation of m-until for the state monad that&amp;lt;br&amp;gt;   replaces recursion by a loop.&amp;quot;&amp;lt;br&amp;gt;  [p f x]&amp;lt;br&amp;gt;  (letfn [(until [p f x s]&amp;lt;br&amp;gt;            (if (p x)&amp;lt;br&amp;gt;              [x s]&amp;lt;br&amp;gt;              (let [[x s] ((f x) s)]&amp;lt;br&amp;gt;                (recur p f x s))))]&amp;lt;br&amp;gt;    (fn [s] (until p f x s))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">state-m-until</a>[p f x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;state-t&lt;/b&gt; ([m])&lt;br&gt; Monad transformer that transforms a monad m into a monad of stateful&lt;br&gt;  computations that have the base monad type as their result.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn state-t&amp;lt;br&amp;gt;  &amp;quot;Monad transformer that transforms a monad m into a monad of stateful&amp;lt;br&amp;gt;  computations that have the base monad type as their result.&amp;quot;&amp;lt;br&amp;gt;  [m]&amp;lt;br&amp;gt;  (monad [m-result (with-monad m&amp;lt;br&amp;gt;                     (fn m-result-state-t [v]&amp;lt;br&amp;gt;                       (fn [s]&amp;lt;br&amp;gt;                         (m-result [v s]))))&amp;lt;br&amp;gt;          m-bind   (with-monad m&amp;lt;br&amp;gt;                     (fn m-bind-state-t [stm f]&amp;lt;br&amp;gt;                       (fn [s]&amp;lt;br&amp;gt;                         (m-bind (stm s)&amp;lt;br&amp;gt;                                 (fn [[v ss]]&amp;lt;br&amp;gt;                                   ((f v) ss))))))&amp;lt;br&amp;gt;          m-zero   (with-monad m&amp;lt;br&amp;gt;                     (if (= ::undefined m-zero)&amp;lt;br&amp;gt;                       ::undefined&amp;lt;br&amp;gt;                       (fn [s]&amp;lt;br&amp;gt;                         m-zero)))&amp;lt;br&amp;gt;          m-plus   (with-monad m&amp;lt;br&amp;gt;                     (if (= ::undefined m-plus)&amp;lt;br&amp;gt;                       ::undefined&amp;lt;br&amp;gt;                       (fn [&amp;amp; stms]&amp;lt;br&amp;gt;                         (fn [s]&amp;lt;br&amp;gt;                           (apply m-plus (map #(% s) stms))))))&amp;lt;br&amp;gt;          ]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">state-t</a>[m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;update-state&lt;/b&gt; ([f])&lt;br&gt; Return a state-monad function that replaces the current state by the&lt;br&gt;   result of f applied to the current state and that returns the old state.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn update-state&amp;lt;br&amp;gt;  &amp;quot;Return a state-monad function that replaces the current state by the&amp;lt;br&amp;gt;   result of f applied to the current state and that returns the old state.&amp;quot;&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (fn [s] [s (f s)]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">update-state</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;update-val&lt;/b&gt; ([key f])&lt;br&gt; Return a state-monad function that assumes the state to be a map and&lt;br&gt;   replaces the value associated with the given key by the return value&lt;br&gt;   of f applied to the old value. The old value is returned.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn update-val&amp;lt;br&amp;gt;  &amp;quot;Return a state-monad function that assumes the state to be a map and&amp;lt;br&amp;gt;   replaces the value associated with the given key by the return value&amp;lt;br&amp;gt;   of f applied to the old value. The old value is returned.&amp;quot;&amp;lt;br&amp;gt;  [key f]&amp;lt;br&amp;gt;  (fn [s]&amp;lt;br&amp;gt;    (let [old-val (get s key)&amp;lt;br&amp;gt;          new-s   (assoc s key (f old-val))]&amp;lt;br&amp;gt;      [old-val new-s])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">update-val</a>[key f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;with-monad&lt;/b&gt; ([monad &amp; exprs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates an expression after replacing the keywords defining the&lt;br&gt;   monad operations by the functions associated with these keywords&lt;br&gt;   in the monad definition given by name.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-monad&amp;lt;br&amp;gt;  &amp;quot;Evaluates an expression after replacing the keywords defining the&amp;lt;br&amp;gt;   monad operations by the functions associated with these keywords&amp;lt;br&amp;gt;   in the monad definition given by name.&amp;quot;&amp;lt;br&amp;gt;  [monad &amp;amp; exprs]&amp;lt;br&amp;gt;  `(let [name#      ~monad&amp;lt;br&amp;gt;         ~'m-bind   (:m-bind name#)&amp;lt;br&amp;gt;         ~'m-result (:m-result name#)&amp;lt;br&amp;gt;         ~'m-zero   (:m-zero name#)&amp;lt;br&amp;gt;         ~'m-plus   (:m-plus name#)]&amp;lt;br&amp;gt;     (with-symbol-macros ~@exprs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-monad</a>[monad & exprs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;with-state-field&lt;/b&gt; ([key statement])&lt;br&gt; Returns a state-monad function that expects a map as its state and&lt;br&gt;   runs statement (another state-monad function) on the state defined by&lt;br&gt;   the map entry corresponding to key. The map entry is updated with the&lt;br&gt;   new state returned by statement.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn with-state-field&amp;lt;br&amp;gt;  &amp;quot;Returns a state-monad function that expects a map as its state and&amp;lt;br&amp;gt;   runs statement (another state-monad function) on the state defined by&amp;lt;br&amp;gt;   the map entry corresponding to key. The map entry is updated with the&amp;lt;br&amp;gt;   new state returned by statement.&amp;quot;&amp;lt;br&amp;gt;  [key statement]&amp;lt;br&amp;gt;  (fn [s]&amp;lt;br&amp;gt;    (let [substate (get s key nil)&amp;lt;br&amp;gt;          [result new-substate] (statement substate)&amp;lt;br&amp;gt;          new-state (assoc s key new-substate)]&amp;lt;br&amp;gt;      [result new-state])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-state-field</a>[key statement]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;writer-m&lt;/b&gt; ([empty-accumulator])&lt;br&gt; Monad describing computations that accumulate data on the side, e.g. for&lt;br&gt;   logging. The monadic values have the structure [value log]. Any of the&lt;br&gt;   accumulators from clojure.contrib.accumulators can be used for storing the&lt;br&gt;   log data. Its empty value is passed as a parameter.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn writer-m&amp;lt;br&amp;gt;  &amp;quot;Monad describing computations that accumulate data on the side, e.g. for&amp;lt;br&amp;gt;   logging. The monadic values have the structure [value log]. Any of the&amp;lt;br&amp;gt;   accumulators from clojure.contrib.accumulators can be used for storing the&amp;lt;br&amp;gt;   log data. Its empty value is passed as a parameter.&amp;quot;&amp;lt;br&amp;gt;  [empty-accumulator]&amp;lt;br&amp;gt;  (monad&amp;lt;br&amp;gt;   [m-result  (fn m-result-writer [v]&amp;lt;br&amp;gt;                [v empty-accumulator])&amp;lt;br&amp;gt;    m-bind    (fn m-bind-writer [mv f]&amp;lt;br&amp;gt;                (let [[v1 a1] mv&amp;lt;br&amp;gt;                      [v2 a2] (f v1)]&amp;lt;br&amp;gt;                  [v2 (writer-m-combine a1 a2)]))&amp;lt;br&amp;gt;    ]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">writer-m</a>[empty-accumulator]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;writer-m-add&lt;/b&gt; ([container value])&lt;br&gt; add value to container, return new container&lt;/div&gt;" data-placement="right">writer-m-add</a>[container value]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.algo.monads&lt;/i&gt;&lt;b&gt;writer-m-combine&lt;/b&gt; ([container1 container2])&lt;br&gt; combine two containers, return new container&lt;/div&gt;" data-placement="right">writer-m-combine</a>[container1 container2]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;*&lt;/b&gt; ([] [x] [x y] [x y &amp; more])&lt;br&gt; Returns the product of nums. (*) returns 1. Does not auto-promote&lt;br&gt;  longs, will throw on overflow. See also: *'&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn *&amp;lt;br&amp;gt;  &amp;quot;Returns the product of nums. (*) returns 1. Does not auto-promote&amp;lt;br&amp;gt;  longs, will throw on overflow. See also: *'&amp;quot;&amp;lt;br&amp;gt;  {:inline (nary-inline 'multiply 'unchecked_multiply)&amp;lt;br&amp;gt;   :inline-arities &amp;gt;1?&amp;lt;br&amp;gt;   :added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  ([] 1)&amp;lt;br&amp;gt;  ([x] (cast Number x))&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (multiply x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;     (reduce1 * (* x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">*</a>[] [x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;*'&lt;/b&gt; ([] [x] [x y] [x y &amp; more])&lt;br&gt; Returns the product of nums. (*) returns 1. Supports arbitrary precision.&lt;br&gt;  See also: *&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn *'&amp;lt;br&amp;gt;  &amp;quot;Returns the product of nums. (*) returns 1. Supports arbitrary precision.&amp;lt;br&amp;gt;  See also: *&amp;quot;&amp;lt;br&amp;gt;  {:inline (nary-inline 'multiplyP)&amp;lt;br&amp;gt;   :inline-arities &amp;gt;1?&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([] 1)&amp;lt;br&amp;gt;  ([x] (cast Number x))&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (multiplyP x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (reduce1 *' (*' x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">*'</a>[] [x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;+&lt;/b&gt; ([] [x] [x y] [x y &amp; more])&lt;br&gt; Returns the sum of nums. (+) returns 0. Does not auto-promote&lt;br&gt;  longs, will throw on overflow. See also: +'&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn +&amp;lt;br&amp;gt;  &amp;quot;Returns the sum of nums. (+) returns 0. Does not auto-promote&amp;lt;br&amp;gt;  longs, will throw on overflow. See also: +'&amp;quot;&amp;lt;br&amp;gt;  {:inline (nary-inline 'add 'unchecked_add)&amp;lt;br&amp;gt;   :inline-arities &amp;gt;1?&amp;lt;br&amp;gt;   :added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  ([] 0)&amp;lt;br&amp;gt;  ([x] (cast Number x))&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (add x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;     (reduce1 + (+ x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">+</a>[] [x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;+'&lt;/b&gt; ([] [x] [x y] [x y &amp; more])&lt;br&gt; Returns the sum of nums. (+) returns 0. Supports arbitrary precision.&lt;br&gt;  See also: +&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn +'&amp;lt;br&amp;gt;  &amp;quot;Returns the sum of nums. (+) returns 0. Supports arbitrary precision.&amp;lt;br&amp;gt;  See also: +&amp;quot;&amp;lt;br&amp;gt;  {:inline (nary-inline 'addP)&amp;lt;br&amp;gt;   :inline-arities &amp;gt;1?&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([] 0)&amp;lt;br&amp;gt;  ([x] (cast Number x))&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (addP x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (reduce1 +' (+' x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">+'</a>[] [x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;-&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; If no ys are supplied, returns the negation of x, else subtracts&lt;br&gt;  the ys from x and returns the result. Does not auto-promote&lt;br&gt;  longs, will throw on overflow. See also: -'&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -&amp;lt;br&amp;gt;  &amp;quot;If no ys are supplied, returns the negation of x, else subtracts&amp;lt;br&amp;gt;  the ys from x and returns the result. Does not auto-promote&amp;lt;br&amp;gt;  longs, will throw on overflow. See also: -'&amp;quot;&amp;lt;br&amp;gt;  {:inline (nary-inline 'minus 'unchecked_minus)&amp;lt;br&amp;gt;   :inline-arities &amp;gt;0?&amp;lt;br&amp;gt;   :added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  ([x] (. clojure.lang.Numbers (minus x)))&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (minus x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;     (reduce1 - (- x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-</a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;-'&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; If no ys are supplied, returns the negation of x, else subtracts&lt;br&gt;  the ys from x and returns the result. Supports arbitrary precision.&lt;br&gt;  See also: -&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -'&amp;lt;br&amp;gt;  &amp;quot;If no ys are supplied, returns the negation of x, else subtracts&amp;lt;br&amp;gt;  the ys from x and returns the result. Supports arbitrary precision.&amp;lt;br&amp;gt;  See also: -&amp;quot;&amp;lt;br&amp;gt;  {:inline (nary-inline 'minusP)&amp;lt;br&amp;gt;   :inline-arities &amp;gt;0?&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x] (. clojure.lang.Numbers (minusP x)))&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (minusP x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (reduce1 -' (-' x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-'</a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;-&gt;&lt;/b&gt; ([x] [x form] [x form &amp; more])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Threads the expr through the forms. Inserts x as the&lt;br&gt;  second item in the first form, making a list of it if it is not a&lt;br&gt;  list already. If there are more forms, inserts the first form as the&lt;br&gt;  second item in second form, etc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro -&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;Threads the expr through the forms. Inserts x as the&amp;lt;br&amp;gt;  second item in the first form, making a list of it if it is not a&amp;lt;br&amp;gt;  list already. If there are more forms, inserts the first form as the&amp;lt;br&amp;gt;  second item in second form, etc.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x] x)&amp;lt;br&amp;gt;  ([x form] (if (seq? form)&amp;lt;br&amp;gt;              (with-meta `(~(first form) ~x ~@(next form)) (meta form))&amp;lt;br&amp;gt;              (list form x)))&amp;lt;br&amp;gt;  ([x form &amp;amp; more] `(-&amp;gt; (-&amp;gt; ~x ~form) ~@more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-></a>[x] [x form] [x form & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;-&gt;&gt;&lt;/b&gt; ([x form] [x form &amp; more])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Threads the expr through the forms. Inserts x as the&lt;br&gt;  last item in the first form, making a list of it if it is not a&lt;br&gt;  list already. If there are more forms, inserts the first form as the&lt;br&gt;  last item in second form, etc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro -&amp;gt;&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;Threads the expr through the forms. Inserts x as the&amp;lt;br&amp;gt;  last item in the first form, making a list of it if it is not a&amp;lt;br&amp;gt;  list already. If there are more forms, inserts the first form as the&amp;lt;br&amp;gt;  last item in second form, etc.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;} &amp;lt;br&amp;gt;  ([x form] (if (seq? form)&amp;lt;br&amp;gt;              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))&amp;lt;br&amp;gt;              (list form x)))&amp;lt;br&amp;gt;  ([x form &amp;amp; more] `(-&amp;gt;&amp;gt; (-&amp;gt;&amp;gt; ~x ~form) ~@more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->></a>[x form] [x form & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;-&gt;ArrayChunk&lt;/b&gt; ([am arr off end])&lt;br&gt; Positional factory function for class clojure.core.ArrayChunk.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype ArrayChunk [^clojure.core.ArrayManager am arr ^int off ^int end]&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  clojure.lang.Indexed&amp;lt;br&amp;gt;  (nth [_ i] (.aget am arr (+ off i)))&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  (count [_] (- end off))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IChunk&amp;lt;br&amp;gt;  (dropFirst [_]&amp;lt;br&amp;gt;    (if (= off end)&amp;lt;br&amp;gt;      (throw (IllegalStateException. &amp;quot;dropFirst of empty chunk&amp;quot;))&amp;lt;br&amp;gt;      (new ArrayChunk am arr (inc off) end)))&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  (reduce [_ f init]&amp;lt;br&amp;gt;    (loop [ret init i off]&amp;lt;br&amp;gt;      (if (&amp;lt; i end)&amp;lt;br&amp;gt;        (recur (f ret (.aget am arr i)) (inc i))&amp;lt;br&amp;gt;        ret)))&amp;lt;br&amp;gt;  )&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->ArrayChunk</a>[am arr off end]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;-&gt;Vec&lt;/b&gt; ([am cnt shift root tail _meta])&lt;br&gt; Positional factory function for class clojure.core.Vec.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype Vec [^clojure.core.ArrayManager am ^int cnt ^int shift ^clojure.core.VecNode root tail _meta]&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (equals [this o]&amp;lt;br&amp;gt;    (cond &amp;lt;br&amp;gt;     (identical? this o) true&amp;lt;br&amp;gt;     (or (instance? clojure.lang.IPersistentVector o) (instance? java.util.RandomAccess o))&amp;lt;br&amp;gt;       (and (= cnt (count o))&amp;lt;br&amp;gt;            (loop [i (int 0)]&amp;lt;br&amp;gt;              (cond&amp;lt;br&amp;gt;               (= i cnt) true&amp;lt;br&amp;gt;               (.equals (.nth this i) (nth o i)) (recur (inc i))&amp;lt;br&amp;gt;               :else false)))&amp;lt;br&amp;gt;     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))&amp;lt;br&amp;gt;       (.equals (seq this) (seq o))&amp;lt;br&amp;gt;     :else false))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  ;todo - cache&amp;lt;br&amp;gt;  (hashCode [this]&amp;lt;br&amp;gt;    (loop [hash (int 1) i (int 0)]&amp;lt;br&amp;gt;      (if (= i cnt)&amp;lt;br&amp;gt;        hash&amp;lt;br&amp;gt;        (let [val (.nth this i)]&amp;lt;br&amp;gt;          (recur (unchecked-add-int (unchecked-multiply-int 31 hash) &amp;lt;br&amp;gt;                                (clojure.lang.Util/hash val)) &amp;lt;br&amp;gt;                 (inc i))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.Counted&amp;lt;br&amp;gt;  (count [_] cnt)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IMeta&amp;lt;br&amp;gt;  (meta [_] _meta)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (withMeta [_ m] (new Vec am cnt shift root tail m))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.Indexed&amp;lt;br&amp;gt;  (nth [this i]&amp;lt;br&amp;gt;    (let [a (.arrayFor this i)]&amp;lt;br&amp;gt;      (.aget am a (bit-and i (int 0x1f)))))&amp;lt;br&amp;gt;  (nth [this i not-found]&amp;lt;br&amp;gt;       (let [z (int 0)]&amp;lt;br&amp;gt;         (if (and (&amp;gt;= i z) (&amp;lt; i (.count this)))&amp;lt;br&amp;gt;           (.nth this i)&amp;lt;br&amp;gt;           not-found)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IPersistentCollection&amp;lt;br&amp;gt;  (cons [this val]&amp;lt;br&amp;gt;     (if (&amp;lt; (- cnt (.tailoff this)) (int 32))&amp;lt;br&amp;gt;      (let [new-tail (.array am (inc (.alength am tail)))]&amp;lt;br&amp;gt;        (System/arraycopy tail 0 new-tail 0 (.alength am tail))&amp;lt;br&amp;gt;        (.aset am new-tail (.alength am tail) val)&amp;lt;br&amp;gt;        (new Vec am (inc cnt) shift root new-tail (meta this)))&amp;lt;br&amp;gt;      (let [tail-node (VecNode. (.edit root) tail)] &amp;lt;br&amp;gt;        (if (&amp;gt; (bit-shift-right cnt (int 5)) (bit-shift-left (int 1) shift)) ;overflow root?&amp;lt;br&amp;gt;          (let [new-root (VecNode. (.edit root) (object-array 32))]&amp;lt;br&amp;gt;            (doto ^objects (.arr new-root)&amp;lt;br&amp;gt;              (aset 0 root)&amp;lt;br&amp;gt;              (aset 1 (.newPath this (.edit root) shift tail-node)))&amp;lt;br&amp;gt;            (new Vec am (inc cnt) (+ shift (int 5)) new-root (let [tl (.array am 1)] (.aset am  tl 0 val) tl) (meta this)))&amp;lt;br&amp;gt;          (new Vec am (inc cnt) shift (.pushTail this shift root tail-node) &amp;lt;br&amp;gt;                 (let [tl (.array am 1)] (.aset am  tl 0 val) tl) (meta this))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (empty [_] (new Vec am 0 5 EMPTY-NODE (.array am 0) nil))                             &amp;lt;br&amp;gt;  (equiv [this o]&amp;lt;br&amp;gt;    (cond &amp;lt;br&amp;gt;     (or (instance? clojure.lang.IPersistentVector o) (instance? java.util.RandomAccess o))&amp;lt;br&amp;gt;       (and (= cnt (count o))&amp;lt;br&amp;gt;            (loop [i (int 0)]&amp;lt;br&amp;gt;              (cond&amp;lt;br&amp;gt;               (= i cnt) true&amp;lt;br&amp;gt;               (= (.nth this i) (nth o i)) (recur (inc i))&amp;lt;br&amp;gt;               :else false)))&amp;lt;br&amp;gt;     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))&amp;lt;br&amp;gt;       (clojure.lang.Util/equiv (seq this) (seq o))&amp;lt;br&amp;gt;     :else false))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IPersistentStack&amp;lt;br&amp;gt;  (peek [this]&amp;lt;br&amp;gt;    (when (&amp;gt; cnt (int 0)) &amp;lt;br&amp;gt;      (.nth this (dec cnt))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (pop [this]&amp;lt;br&amp;gt;   (cond&amp;lt;br&amp;gt;    (zero? cnt) &amp;lt;br&amp;gt;      (throw (IllegalStateException. &amp;quot;Can't pop empty vector&amp;quot;))&amp;lt;br&amp;gt;    (= 1 cnt) &amp;lt;br&amp;gt;      (new Vec am 0 5 EMPTY-NODE (.array am 0) (meta this))&amp;lt;br&amp;gt;    (&amp;gt; (- cnt (.tailoff this)) 1)&amp;lt;br&amp;gt;      (let [new-tail (.array am (dec (.alength am tail)))]&amp;lt;br&amp;gt;        (System/arraycopy tail 0 new-tail 0 (.alength am new-tail))&amp;lt;br&amp;gt;        (new Vec am (dec cnt) shift root new-tail (meta this)))&amp;lt;br&amp;gt;    :else&amp;lt;br&amp;gt;      (let [new-tail (.arrayFor this (- cnt 2))&amp;lt;br&amp;gt;            new-root ^clojure.core.VecNode (.popTail this shift root)]&amp;lt;br&amp;gt;        (cond&amp;lt;br&amp;gt;         (nil? new-root) &amp;lt;br&amp;gt;           (new Vec am (dec cnt) shift EMPTY-NODE new-tail (meta this))&amp;lt;br&amp;gt;         (and (&amp;gt; shift 5) (nil? (aget ^objects (.arr new-root) 1)))&amp;lt;br&amp;gt;           (new Vec am (dec cnt) (- shift 5) (aget ^objects (.arr new-root) 0) new-tail (meta this))&amp;lt;br&amp;gt;         :else&amp;lt;br&amp;gt;           (new Vec am (dec cnt) shift new-root new-tail (meta this))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IPersistentVector&amp;lt;br&amp;gt;  (assocN [this i val]&amp;lt;br&amp;gt;    (cond &amp;lt;br&amp;gt;     (and (&amp;lt;= (int 0) i) (&amp;lt; i cnt))&amp;lt;br&amp;gt;       (if (&amp;gt;= i (.tailoff this))&amp;lt;br&amp;gt;         (let [new-tail (.array am (.alength am tail))]&amp;lt;br&amp;gt;           (System/arraycopy tail 0 new-tail 0 (.alength am tail))&amp;lt;br&amp;gt;           (.aset am new-tail (bit-and i (int 0x1f)) val)&amp;lt;br&amp;gt;           (new Vec am cnt shift root new-tail (meta this)))&amp;lt;br&amp;gt;         (new Vec am cnt shift (.doAssoc this shift root i val) tail (meta this)))&amp;lt;br&amp;gt;     (= i cnt) (.cons this val)&amp;lt;br&amp;gt;     :else (throw (IndexOutOfBoundsException.))))&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  clojure.lang.Reversible&amp;lt;br&amp;gt;  (rseq [this]&amp;lt;br&amp;gt;        (if (&amp;gt; (.count this) 0)&amp;lt;br&amp;gt;          (clojure.lang.APersistentVector$RSeq. this (dec (.count this)))&amp;lt;br&amp;gt;          nil))&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  clojure.lang.Associative&amp;lt;br&amp;gt;  (assoc [this k v]&amp;lt;br&amp;gt;    (if (clojure.lang.Util/isInteger k)&amp;lt;br&amp;gt;      (.assocN this k v)&amp;lt;br&amp;gt;      (throw (IllegalArgumentException. &amp;quot;Key must be integer&amp;quot;))))&amp;lt;br&amp;gt;  (containsKey [this k]&amp;lt;br&amp;gt;    (and (clojure.lang.Util/isInteger k)&amp;lt;br&amp;gt;         (&amp;lt;= 0 (int k))&amp;lt;br&amp;gt;         (&amp;lt; (int k) cnt)))&amp;lt;br&amp;gt;  (entryAt [this k]&amp;lt;br&amp;gt;    (if (.containsKey this k)&amp;lt;br&amp;gt;      (clojure.lang.MapEntry. k (.nth this (int k)))&amp;lt;br&amp;gt;      nil))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.ILookup&amp;lt;br&amp;gt;  (valAt [this k not-found]&amp;lt;br&amp;gt;    (if (clojure.lang.Util/isInteger k)&amp;lt;br&amp;gt;      (let [i (int k)]&amp;lt;br&amp;gt;        (if (and (&amp;gt;= i 0) (&amp;lt; i cnt))&amp;lt;br&amp;gt;          (.nth this i)&amp;lt;br&amp;gt;          not-found))&amp;lt;br&amp;gt;      not-found))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (valAt [this k] (.valAt this k nil))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IFn&amp;lt;br&amp;gt;  (invoke [this k]&amp;lt;br&amp;gt;    (if (clojure.lang.Util/isInteger k)&amp;lt;br&amp;gt;      (let [i (int k)]&amp;lt;br&amp;gt;        (if (and (&amp;gt;= i 0) (&amp;lt; i cnt))&amp;lt;br&amp;gt;          (.nth this i)&amp;lt;br&amp;gt;          (throw (IndexOutOfBoundsException.))))&amp;lt;br&amp;gt;      (throw (IllegalArgumentException. &amp;quot;Key must be integer&amp;quot;))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  clojure.lang.Seqable&amp;lt;br&amp;gt;  (seq [this] &amp;lt;br&amp;gt;    (if (zero? cnt) &amp;lt;br&amp;gt;      nil&amp;lt;br&amp;gt;      (VecSeq. am this (.arrayFor this 0) 0 0)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.Sequential ;marker, no methods&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.core.IVecImpl&amp;lt;br&amp;gt;  (tailoff [_] &amp;lt;br&amp;gt;    (- cnt (.alength am tail)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (arrayFor [this i]&amp;lt;br&amp;gt;    (if (and  (&amp;lt;= (int 0) i) (&amp;lt; i cnt))&amp;lt;br&amp;gt;      (if (&amp;gt;= i (.tailoff this))&amp;lt;br&amp;gt;        tail&amp;lt;br&amp;gt;        (loop [node root level shift]&amp;lt;br&amp;gt;          (if (zero? level)&amp;lt;br&amp;gt;            (.arr node)&amp;lt;br&amp;gt;            (recur (aget ^objects (.arr node) (bit-and (bit-shift-right i level) (int 0x1f))) &amp;lt;br&amp;gt;                   (- level (int 5))))))&amp;lt;br&amp;gt;      (throw (IndexOutOfBoundsException.))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (pushTail [this level parent tailnode]&amp;lt;br&amp;gt;    (let [subidx (bit-and (bit-shift-right (dec cnt) level) (int 0x1f))&amp;lt;br&amp;gt;          parent ^clojure.core.VecNode parent&amp;lt;br&amp;gt;          ret (VecNode. (.edit parent) (aclone ^objects (.arr parent)))&amp;lt;br&amp;gt;          node-to-insert (if (= level (int 5))&amp;lt;br&amp;gt;                           tailnode&amp;lt;br&amp;gt;                           (let [child (aget ^objects (.arr parent) subidx)]&amp;lt;br&amp;gt;                             (if child&amp;lt;br&amp;gt;                               (.pushTail this (- level (int 5)) child tailnode)&amp;lt;br&amp;gt;                               (.newPath this (.edit root) (- level (int 5)) tailnode))))]&amp;lt;br&amp;gt;      (aset ^objects (.arr ret) subidx node-to-insert)&amp;lt;br&amp;gt;      ret))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (popTail [this level node]&amp;lt;br&amp;gt;    (let [node ^clojure.core.VecNode node&amp;lt;br&amp;gt;          subidx (bit-and (bit-shift-right (- cnt (int 2)) level) (int 0x1f))]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;       (&amp;gt; level 5) &amp;lt;br&amp;gt;         (let [new-child (.popTail this (- level 5) (aget ^objects (.arr node) subidx))]&amp;lt;br&amp;gt;           (if (and (nil? new-child) (zero? subidx))&amp;lt;br&amp;gt;             nil&amp;lt;br&amp;gt;             (let [arr (aclone ^objects (.arr node))]&amp;lt;br&amp;gt;               (aset arr subidx new-child)&amp;lt;br&amp;gt;               (VecNode. (.edit root) arr))))&amp;lt;br&amp;gt;       (zero? subidx) nil&amp;lt;br&amp;gt;       :else (let [arr (aclone ^objects (.arr node))]&amp;lt;br&amp;gt;               (aset arr subidx nil)&amp;lt;br&amp;gt;               (VecNode. (.edit root) arr)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (newPath [this edit ^int level node]&amp;lt;br&amp;gt;    (if (zero? level)&amp;lt;br&amp;gt;      node&amp;lt;br&amp;gt;      (let [ret (VecNode. edit (object-array 32))]&amp;lt;br&amp;gt;        (aset ^objects (.arr ret) 0 (.newPath this edit (- level (int 5)) node))&amp;lt;br&amp;gt;        ret)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (doAssoc [this level node i val]&amp;lt;br&amp;gt;    (let [node ^clojure.core.VecNode node]       &amp;lt;br&amp;gt;      (if (zero? level)&amp;lt;br&amp;gt;        ;on this branch, array will need val type&amp;lt;br&amp;gt;        (let [arr (.aclone am (.arr node))]&amp;lt;br&amp;gt;          (.aset am arr (bit-and i (int 0x1f)) val)&amp;lt;br&amp;gt;          (VecNode. (.edit node) arr))&amp;lt;br&amp;gt;        (let [arr (aclone ^objects (.arr node))&amp;lt;br&amp;gt;              subidx (bit-and (bit-shift-right i level) (int 0x1f))]&amp;lt;br&amp;gt;          (aset arr subidx (.doAssoc this (- level (int 5)) (aget arr subidx) i val))&amp;lt;br&amp;gt;          (VecNode. (.edit node) arr)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  java.lang.Comparable&amp;lt;br&amp;gt;  (compareTo [this o]&amp;lt;br&amp;gt;    (if (identical? this o)&amp;lt;br&amp;gt;      0&amp;lt;br&amp;gt;      (let [#^clojure.lang.IPersistentVector v (cast clojure.lang.IPersistentVector o)&amp;lt;br&amp;gt;            vcnt (.count v)]&amp;lt;br&amp;gt;        (cond&amp;lt;br&amp;gt;          (&amp;lt; cnt vcnt) -1&amp;lt;br&amp;gt;          (&amp;gt; cnt vcnt) 1&amp;lt;br&amp;gt;          :else&amp;lt;br&amp;gt;            (loop [i (int 0)]&amp;lt;br&amp;gt;              (if (= i cnt)&amp;lt;br&amp;gt;                0&amp;lt;br&amp;gt;                (let [comp (clojure.lang.Util/compare (.nth this i) (.nth v i))]&amp;lt;br&amp;gt;                  (if (= 0 comp)&amp;lt;br&amp;gt;                    (recur (inc i))&amp;lt;br&amp;gt;                    comp))))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  java.lang.Iterable&amp;lt;br&amp;gt;  (iterator [this]&amp;lt;br&amp;gt;    (let [i (java.util.concurrent.atomic.AtomicInteger. 0)]&amp;lt;br&amp;gt;      (reify java.util.Iterator&amp;lt;br&amp;gt;        (hasNext [_] (&amp;lt; (.get i) cnt))&amp;lt;br&amp;gt;        (next [_] (.nth this (dec (.incrementAndGet i))))&amp;lt;br&amp;gt;        (remove [_] (throw (UnsupportedOperationException.))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  java.util.Collection&amp;lt;br&amp;gt;  (contains [this o] (boolean (some #(= % o) this)))&amp;lt;br&amp;gt;  (containsAll [this c] (every? #(.contains this %) c))&amp;lt;br&amp;gt;  (isEmpty [_] (zero? cnt))&amp;lt;br&amp;gt;  (toArray [this] (into-array Object this))&amp;lt;br&amp;gt;  (toArray [this arr]&amp;lt;br&amp;gt;    (if (&amp;gt;= (count arr) cnt)&amp;lt;br&amp;gt;      (do&amp;lt;br&amp;gt;        (dotimes [i cnt]&amp;lt;br&amp;gt;          (aset arr i (.nth this i)))&amp;lt;br&amp;gt;        arr)&amp;lt;br&amp;gt;      (into-array Object this)))&amp;lt;br&amp;gt;  (size [_] cnt)&amp;lt;br&amp;gt;  (add [_ o] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;  (addAll [_ c] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;  (clear [_] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;  (^boolean remove [_ o] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;  (removeAll [_ c] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;  (retainAll [_ c] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  java.util.List&amp;lt;br&amp;gt;  (get [this i] (.nth this i))&amp;lt;br&amp;gt;  (indexOf [this o]&amp;lt;br&amp;gt;    (loop [i (int 0)]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;        (== i cnt) -1&amp;lt;br&amp;gt;        (= o (.nth this i)) i&amp;lt;br&amp;gt;        :else (recur (inc i)))))&amp;lt;br&amp;gt;  (lastIndexOf [this o]&amp;lt;br&amp;gt;    (loop [i (dec cnt)]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;        (&amp;lt; i 0) -1&amp;lt;br&amp;gt;        (= o (.nth this i)) i&amp;lt;br&amp;gt;        :else (recur (dec i)))))&amp;lt;br&amp;gt;  (listIterator [this] (.listIterator this 0))&amp;lt;br&amp;gt;  (listIterator [this i]&amp;lt;br&amp;gt;    (let [i (java.util.concurrent.atomic.AtomicInteger. i)]&amp;lt;br&amp;gt;      (reify java.util.ListIterator&amp;lt;br&amp;gt;        (hasNext [_] (&amp;lt; (.get i) cnt))&amp;lt;br&amp;gt;        (hasPrevious [_] (pos? i))&amp;lt;br&amp;gt;        (next [_] (.nth this (dec (.incrementAndGet i))))&amp;lt;br&amp;gt;        (nextIndex [_] (.get i))&amp;lt;br&amp;gt;        (previous [_] (.nth this (.decrementAndGet i)))&amp;lt;br&amp;gt;        (previousIndex [_] (dec (.get i)))&amp;lt;br&amp;gt;        (add [_ e] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;        (remove [_] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;        (set [_ e] (throw (UnsupportedOperationException.))))))&amp;lt;br&amp;gt;  (subList [this a z] (subvec this a z))&amp;lt;br&amp;gt;  (add [_ i o] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;  (addAll [_ i c] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;  (^Object remove [_ ^int i] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;  (set [_ i e] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Vec</a>[am cnt shift root tail _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;-&gt;VecNode&lt;/b&gt; ([edit arr])&lt;br&gt; Positional factory function for class clojure.core.VecNode.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype VecNode [edit arr])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->VecNode</a>[edit arr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;-&gt;VecSeq&lt;/b&gt; ([am vec anode i offset])&lt;br&gt; Positional factory function for class clojure.core.VecSeq.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype VecSeq [^clojure.core.ArrayManager am ^clojure.core.IVecImpl vec anode ^int i ^int offset] &amp;lt;br&amp;gt;  :no-print true&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.core.protocols.InternalReduce&amp;lt;br&amp;gt;  (internal-reduce&amp;lt;br&amp;gt;   [_ f val]&amp;lt;br&amp;gt;   (loop [result val&amp;lt;br&amp;gt;          aidx offset]&amp;lt;br&amp;gt;     (if (&amp;lt; aidx (count vec))&amp;lt;br&amp;gt;       (let [node (.arrayFor vec aidx)&amp;lt;br&amp;gt;             result (loop [result result&amp;lt;br&amp;gt;                           node-idx (bit-and 0x1f aidx)]&amp;lt;br&amp;gt;                      (if (&amp;lt; node-idx (.alength am node))&amp;lt;br&amp;gt;                        (recur (f result (.aget am node node-idx)) (inc node-idx))&amp;lt;br&amp;gt;                        result))]&amp;lt;br&amp;gt;         (recur result (bit-and 0xffe0 (+ aidx 32))))&amp;lt;br&amp;gt;       result)))&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  clojure.lang.ISeq&amp;lt;br&amp;gt;  (first [_] (.aget am anode offset))&amp;lt;br&amp;gt;  (next [this] &amp;lt;br&amp;gt;    (if (&amp;lt; (inc offset) (.alength am anode))&amp;lt;br&amp;gt;      (new VecSeq am vec anode i (inc offset))&amp;lt;br&amp;gt;      (.chunkedNext this)))&amp;lt;br&amp;gt;  (more [this]&amp;lt;br&amp;gt;    (let [s (.next this)]&amp;lt;br&amp;gt;      (or s (clojure.lang.PersistentList/EMPTY))))&amp;lt;br&amp;gt;  (cons [this o]&amp;lt;br&amp;gt;    (clojure.lang.Cons. o this))&amp;lt;br&amp;gt;  (count [this]&amp;lt;br&amp;gt;    (loop [i 1&amp;lt;br&amp;gt;           s (next this)]&amp;lt;br&amp;gt;      (if s&amp;lt;br&amp;gt;        (if (instance? clojure.lang.Counted s)&amp;lt;br&amp;gt;          (+ i (.count s))&amp;lt;br&amp;gt;          (recur (inc i) (next s)))&amp;lt;br&amp;gt;        i)))&amp;lt;br&amp;gt;  (equiv [this o]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;     (identical? this o) true&amp;lt;br&amp;gt;     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))&amp;lt;br&amp;gt;     (loop [me this&amp;lt;br&amp;gt;            you (seq o)]&amp;lt;br&amp;gt;       (if (nil? me)&amp;lt;br&amp;gt;         (nil? you)&amp;lt;br&amp;gt;         (and (clojure.lang.Util/equiv (first me) (first you))&amp;lt;br&amp;gt;              (recur (next me) (next you)))))&amp;lt;br&amp;gt;     :else false))&amp;lt;br&amp;gt;  (empty [_]&amp;lt;br&amp;gt;    clojure.lang.PersistentList/EMPTY)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.Seqable&amp;lt;br&amp;gt;  (seq [this] this)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IChunkedSeq&amp;lt;br&amp;gt;  (chunkedFirst [_] (ArrayChunk. am anode offset (.alength am anode)))&amp;lt;br&amp;gt;  (chunkedNext [_] &amp;lt;br&amp;gt;   (let [nexti (+ i (.alength am anode))]&amp;lt;br&amp;gt;     (when (&amp;lt; nexti (count vec))&amp;lt;br&amp;gt;       (new VecSeq am vec (.arrayFor vec nexti) nexti 0))))&amp;lt;br&amp;gt;  (chunkedMore [this]&amp;lt;br&amp;gt;    (let [s (.chunkedNext this)]&amp;lt;br&amp;gt;      (or s (clojure.lang.PersistentList/EMPTY)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->VecSeq</a>[am vec anode i offset]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;-cache-protocol-fn&lt;/b&gt; ([pf x c interf])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -cache-protocol-fn [^clojure.lang.AFunction pf x ^Class c ^clojure.lang.IFn interf]&amp;lt;br&amp;gt;  (let [cache  (.__methodImplCache pf)&amp;lt;br&amp;gt;        f (if (.isInstance c x)&amp;lt;br&amp;gt;            interf &amp;lt;br&amp;gt;            (find-protocol-method (.protocol cache) (.methodk cache) x))]&amp;lt;br&amp;gt;    (when-not f&amp;lt;br&amp;gt;      (throw (IllegalArgumentException. (str &amp;quot;No implementation of method: &amp;quot; (.methodk cache) &amp;lt;br&amp;gt;                                             &amp;quot; of protocol: &amp;quot; (:var (.protocol cache)) &amp;lt;br&amp;gt;                                             &amp;quot; found for class: &amp;quot; (if (nil? x) &amp;quot;nil&amp;quot; (.getName (class x)))))))&amp;lt;br&amp;gt;    (set! (.__methodImplCache pf) (expand-method-impl-cache cache (class x) f))&amp;lt;br&amp;gt;    f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-cache-protocol-fn</a>[pf x c interf]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;-reset-methods&lt;/b&gt; ([protocol])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -reset-methods [protocol]&amp;lt;br&amp;gt;  (doseq [[^clojure.lang.Var v build] (:method-builders protocol)]&amp;lt;br&amp;gt;    (let [cache (clojure.lang.MethodImplCache. protocol (keyword (.sym v)))]&amp;lt;br&amp;gt;      (.bindRoot v (build cache)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-reset-methods</a>[protocol]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;..&lt;/b&gt; ([x form] [x form &amp; more])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; form =&gt; fieldName-symbol or (instanceMethodName-symbol args*)&lt;br&gt;&lt;br&gt;  Expands into a member access (.) of the first member on the first&lt;br&gt;  argument, followed by the next member on the result, etc. For&lt;br&gt;  instance:&lt;br&gt;&lt;br&gt;  (.. System (getProperties) (get &quot;os.name&quot;))&lt;br&gt;&lt;br&gt;  expands to:&lt;br&gt;&lt;br&gt;  (. (. System (getProperties)) (get &quot;os.name&quot;))&lt;br&gt;&lt;br&gt;  but is easier to write, read, and understand.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ..&amp;lt;br&amp;gt;  &amp;quot;form =&amp;gt; fieldName-symbol or (instanceMethodName-symbol args*)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Expands into a member access (.) of the first member on the first&amp;lt;br&amp;gt;  argument, followed by the next member on the result, etc. For&amp;lt;br&amp;gt;  instance:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (.. System (getProperties) (get \&amp;quot;os.name\&amp;quot;))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  expands to:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (. (. System (getProperties)) (get \&amp;quot;os.name\&amp;quot;))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  but is easier to write, read, and understand.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x form] `(. ~x ~form))&amp;lt;br&amp;gt;  ([x form &amp;amp; more] `(.. (. ~x ~form) ~@more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">..</a>[x form] [x form & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;/&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; If no denominators are supplied, returns 1/numerator,&lt;br&gt;  else returns numerator divided by all of the denominators.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn /&amp;lt;br&amp;gt;  &amp;quot;If no denominators are supplied, returns 1/numerator,&amp;lt;br&amp;gt;  else returns numerator divided by all of the denominators.&amp;quot;&amp;lt;br&amp;gt;  {:inline (nary-inline 'divide)&amp;lt;br&amp;gt;   :inline-arities &amp;gt;1?&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x] (/ 1 x))&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (divide x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (reduce1 / (/ x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">/</a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;&lt;&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; Returns non-nil if nums are in monotonically increasing order,&lt;br&gt;  otherwise false.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn &amp;lt;&amp;lt;br&amp;gt;  &amp;quot;Returns non-nil if nums are in monotonically increasing order,&amp;lt;br&amp;gt;  otherwise false.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (lt ~x ~y)))&amp;lt;br&amp;gt;   :inline-arities #{2}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x] true)&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (lt x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (if (&amp;lt; x y)&amp;lt;br&amp;gt;     (if (next more)&amp;lt;br&amp;gt;       (recur y (first more) (next more))&amp;lt;br&amp;gt;       (&amp;lt; y (first more)))&amp;lt;br&amp;gt;     false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;"><</a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;&lt;=&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; Returns non-nil if nums are in monotonically non-decreasing order,&lt;br&gt;  otherwise false.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn &amp;lt;=&amp;lt;br&amp;gt;  &amp;quot;Returns non-nil if nums are in monotonically non-decreasing order,&amp;lt;br&amp;gt;  otherwise false.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (lte ~x ~y)))&amp;lt;br&amp;gt;   :inline-arities #{2}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x] true)&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (lte x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (if (&amp;lt;= x y)&amp;lt;br&amp;gt;     (if (next more)&amp;lt;br&amp;gt;       (recur y (first more) (next more))&amp;lt;br&amp;gt;       (&amp;lt;= y (first more)))&amp;lt;br&amp;gt;     false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;"><=</a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;=&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; Equality. Returns true if x equals y, false if not. Same as&lt;br&gt;  Java x.equals(y) except it also works for nil, and compares&lt;br&gt;  numbers and collections in a type-independent manner.  Clojure's immutable data&lt;br&gt;  structures define equals() (and thus =) as a value, not an identity,&lt;br&gt;  comparison.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn =&amp;lt;br&amp;gt;  &amp;quot;Equality. Returns true if x equals y, false if not. Same as&amp;lt;br&amp;gt;  Java x.equals(y) except it also works for nil, and compares&amp;lt;br&amp;gt;  numbers and collections in a type-independent manner.  Clojure's immutable data&amp;lt;br&amp;gt;  structures define equals() (and thus =) as a value, not an identity,&amp;lt;br&amp;gt;  comparison.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Util equiv ~x ~y))&amp;lt;br&amp;gt;   :inline-arities #{2}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x] true)&amp;lt;br&amp;gt;  ([x y] (clojure.lang.Util/equiv x y))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (if (clojure.lang.Util/equiv x y)&amp;lt;br&amp;gt;     (if (next more)&amp;lt;br&amp;gt;       (recur y (first more) (next more))&amp;lt;br&amp;gt;       (clojure.lang.Util/equiv y (first more)))&amp;lt;br&amp;gt;     false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">=</a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;==&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; Returns non-nil if nums all have the equivalent&lt;br&gt;  value (type-independent), otherwise false&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ==&amp;lt;br&amp;gt;  &amp;quot;Returns non-nil if nums all have the equivalent&amp;lt;br&amp;gt;  value (type-independent), otherwise false&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (equiv ~x ~y)))&amp;lt;br&amp;gt;   :inline-arities #{2}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x] true)&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (equiv x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (if (== x y)&amp;lt;br&amp;gt;     (if (next more)&amp;lt;br&amp;gt;       (recur y (first more) (next more))&amp;lt;br&amp;gt;       (== y (first more)))&amp;lt;br&amp;gt;     false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">==</a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;&gt;&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; Returns non-nil if nums are in monotonically decreasing order,&lt;br&gt;  otherwise false.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn &amp;gt;&amp;lt;br&amp;gt;  &amp;quot;Returns non-nil if nums are in monotonically decreasing order,&amp;lt;br&amp;gt;  otherwise false.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (gt ~x ~y)))&amp;lt;br&amp;gt;   :inline-arities #{2}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x] true)&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (gt x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (if (&amp;gt; x y)&amp;lt;br&amp;gt;     (if (next more)&amp;lt;br&amp;gt;       (recur y (first more) (next more))&amp;lt;br&amp;gt;       (&amp;gt; y (first more)))&amp;lt;br&amp;gt;     false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">></a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;&gt;=&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; Returns non-nil if nums are in monotonically non-increasing order,&lt;br&gt;  otherwise false.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn &amp;gt;=&amp;lt;br&amp;gt;  &amp;quot;Returns non-nil if nums are in monotonically non-increasing order,&amp;lt;br&amp;gt;  otherwise false.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (gte ~x ~y)))&amp;lt;br&amp;gt;   :inline-arities #{2}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x] true)&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (gte x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (if (&amp;gt;= x y)&amp;lt;br&amp;gt;     (if (next more)&amp;lt;br&amp;gt;       (recur y (first more) (next more))&amp;lt;br&amp;gt;       (&amp;gt;= y (first more)))&amp;lt;br&amp;gt;     false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">>=</a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;accessor&lt;/b&gt; ([s key])&lt;br&gt; Returns a fn that, given an instance of a structmap with the basis,&lt;br&gt;  returns the value at the key.  The key must be in the basis. The&lt;br&gt;  returned function should be (slightly) more efficient than using&lt;br&gt;  get, but such use of accessors should be limited to known&lt;br&gt;  performance-critical areas.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn accessor&amp;lt;br&amp;gt;  &amp;quot;Returns a fn that, given an instance of a structmap with the basis,&amp;lt;br&amp;gt;  returns the value at the key.  The key must be in the basis. The&amp;lt;br&amp;gt;  returned function should be (slightly) more efficient than using&amp;lt;br&amp;gt;  get, but such use of accessors should be limited to known&amp;lt;br&amp;gt;  performance-critical areas.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [s key]&amp;lt;br&amp;gt;    (. clojure.lang.PersistentStructMap (getAccessor s key)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">accessor</a>[s key]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;aclone&lt;/b&gt; ([array])&lt;br&gt; Returns a clone of the Java array. Works on arrays of known&lt;br&gt;  types.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn aclone&amp;lt;br&amp;gt;  &amp;quot;Returns a clone of the Java array. Works on arrays of known&amp;lt;br&amp;gt;  types.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [a] `(. clojure.lang.RT (aclone ~a)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [array] (. clojure.lang.RT (aclone array)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">aclone</a>[array]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;add-classpath&lt;/b&gt; ([url])&lt;br&gt; DEPRECATED &lt;br&gt;&lt;br&gt;  Adds the url (String or URL object) to the classpath per&lt;br&gt;  URLClassLoader.addURL&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-classpath&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Adds the url (String or URL object) to the classpath per&amp;lt;br&amp;gt;  URLClassLoader.addURL&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :deprecated &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [url]&amp;lt;br&amp;gt;  (println &amp;quot;WARNING: add-classpath is deprecated&amp;quot;)&amp;lt;br&amp;gt;  (clojure.lang.RT/addURL url))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-classpath</a>[url]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;add-watch&lt;/b&gt; ([reference key fn])&lt;br&gt; Alpha - subject to change.&lt;br&gt;  Adds a watch function to an agent/atom/var/ref reference. The watch&lt;br&gt;  fn must be a fn of 4 args: a key, the reference, its old-state, its&lt;br&gt;  new-state. Whenever the reference's state might have been changed,&lt;br&gt;  any registered watches will have their functions called. The watch fn&lt;br&gt;  will be called synchronously, on the agent's thread if an agent,&lt;br&gt;  before any pending sends if agent or ref. Note that an atom's or&lt;br&gt;  ref's state may have changed again prior to the fn call, so use&lt;br&gt;  old/new-state rather than derefing the reference. Note also that watch&lt;br&gt;  fns may be called from multiple threads simultaneously. Var watchers&lt;br&gt;  are triggered only by root binding changes, not thread-local&lt;br&gt;  set!s. Keys must be unique per reference, and can be used to remove&lt;br&gt;  the watch with remove-watch, but are otherwise considered opaque by&lt;br&gt;  the watch mechanism.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-watch&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;  Adds a watch function to an agent/atom/var/ref reference. The watch&amp;lt;br&amp;gt;  fn must be a fn of 4 args: a key, the reference, its old-state, its&amp;lt;br&amp;gt;  new-state. Whenever the reference's state might have been changed,&amp;lt;br&amp;gt;  any registered watches will have their functions called. The watch fn&amp;lt;br&amp;gt;  will be called synchronously, on the agent's thread if an agent,&amp;lt;br&amp;gt;  before any pending sends if agent or ref. Note that an atom's or&amp;lt;br&amp;gt;  ref's state may have changed again prior to the fn call, so use&amp;lt;br&amp;gt;  old/new-state rather than derefing the reference. Note also that watch&amp;lt;br&amp;gt;  fns may be called from multiple threads simultaneously. Var watchers&amp;lt;br&amp;gt;  are triggered only by root binding changes, not thread-local&amp;lt;br&amp;gt;  set!s. Keys must be unique per reference, and can be used to remove&amp;lt;br&amp;gt;  the watch with remove-watch, but are otherwise considered opaque by&amp;lt;br&amp;gt;  the watch mechanism.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.IRef reference key fn] (.addWatch reference key fn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-watch</a>[reference key fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;agent&lt;/b&gt; ([state &amp; options])&lt;br&gt; Creates and returns an agent with an initial value of state and&lt;br&gt;  zero or more options (in any order):&lt;br&gt;&lt;br&gt;  :meta metadata-map&lt;br&gt;&lt;br&gt;  :validator validate-fn&lt;br&gt;&lt;br&gt;  :error-handler handler-fn&lt;br&gt;&lt;br&gt;  :error-mode mode-keyword&lt;br&gt;&lt;br&gt;  If metadata-map is supplied, it will become the metadata on the&lt;br&gt;  agent. validate-fn must be nil or a side-effect-free fn of one&lt;br&gt;  argument, which will be passed the intended new state on any state&lt;br&gt;  change. If the new state is unacceptable, the validate-fn should&lt;br&gt;  return false or throw an exception.  handler-fn is called if an&lt;br&gt;  action throws an exception or if validate-fn rejects a new state --&lt;br&gt;  see set-error-handler! for details.  The mode-keyword may be either&lt;br&gt;  :continue (the default if an error-handler is given) or :fail (the&lt;br&gt;  default if no error-handler is given) -- see set-error-mode! for&lt;br&gt;  details.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn agent&amp;lt;br&amp;gt;  &amp;quot;Creates and returns an agent with an initial value of state and&amp;lt;br&amp;gt;  zero or more options (in any order):&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :meta metadata-map&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :validator validate-fn&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :error-handler handler-fn&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :error-mode mode-keyword&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  If metadata-map is supplied, it will become the metadata on the&amp;lt;br&amp;gt;  agent. validate-fn must be nil or a side-effect-free fn of one&amp;lt;br&amp;gt;  argument, which will be passed the intended new state on any state&amp;lt;br&amp;gt;  change. If the new state is unacceptable, the validate-fn should&amp;lt;br&amp;gt;  return false or throw an exception.  handler-fn is called if an&amp;lt;br&amp;gt;  action throws an exception or if validate-fn rejects a new state --&amp;lt;br&amp;gt;  see set-error-handler! for details.  The mode-keyword may be either&amp;lt;br&amp;gt;  :continue (the default if an error-handler is given) or :fail (the&amp;lt;br&amp;gt;  default if no error-handler is given) -- see set-error-mode! for&amp;lt;br&amp;gt;  details.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true&amp;lt;br&amp;gt;   }&amp;lt;br&amp;gt;  ([state &amp;amp; options]&amp;lt;br&amp;gt;     (let [a (new clojure.lang.Agent state)&amp;lt;br&amp;gt;           opts (apply hash-map options)]&amp;lt;br&amp;gt;       (setup-reference a options)&amp;lt;br&amp;gt;       (when (:error-handler opts)&amp;lt;br&amp;gt;         (.setErrorHandler a (:error-handler opts)))&amp;lt;br&amp;gt;       (.setErrorMode a (or (:error-mode opts)&amp;lt;br&amp;gt;                            (if (:error-handler opts) :continue :fail)))&amp;lt;br&amp;gt;       a)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">agent</a>[state & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;agent-error&lt;/b&gt; ([a])&lt;br&gt; Returns the exception thrown during an asynchronous action of the&lt;br&gt;  agent if the agent is failed.  Returns nil if the agent is not&lt;br&gt;  failed.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn agent-error&amp;lt;br&amp;gt;  &amp;quot;Returns the exception thrown during an asynchronous action of the&amp;lt;br&amp;gt;  agent if the agent is failed.  Returns nil if the agent is not&amp;lt;br&amp;gt;  failed.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Agent a] (.getError a))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">agent-error</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;agent-errors&lt;/b&gt; ([a])&lt;br&gt; DEPRECATED: Use 'agent-error' instead.&lt;br&gt;  Returns a sequence of the exceptions thrown during asynchronous&lt;br&gt;  actions of the agent.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn agent-errors&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED: Use 'agent-error' instead.&amp;lt;br&amp;gt;  Returns a sequence of the exceptions thrown during asynchronous&amp;lt;br&amp;gt;  actions of the agent.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :deprecated &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [a]&amp;lt;br&amp;gt;  (when-let [e (agent-error a)]&amp;lt;br&amp;gt;    (list e)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">agent-errors</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;aget&lt;/b&gt; ([array idx] [array idx &amp; idxs])&lt;br&gt; Returns the value at the index/indices. Works on Java arrays of all&lt;br&gt;  types.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn aget&amp;lt;br&amp;gt;  &amp;quot;Returns the value at the index/indices. Works on Java arrays of all&amp;lt;br&amp;gt;  types.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [a i] `(. clojure.lang.RT (aget ~a (int ~i))))&amp;lt;br&amp;gt;   :inline-arities #{2}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([array idx]&amp;lt;br&amp;gt;   (clojure.lang.Reflector/prepRet (.getComponentType (class array)) (. Array (get array idx))))&amp;lt;br&amp;gt;  ([array idx &amp;amp; idxs]&amp;lt;br&amp;gt;   (apply aget (aget array idx) idxs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">aget</a>[array idx] [array idx & idxs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;alength&lt;/b&gt; ([array])&lt;br&gt; Returns the length of the Java array. Works on arrays of all&lt;br&gt;  types.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn alength&amp;lt;br&amp;gt;  &amp;quot;Returns the length of the Java array. Works on arrays of all&amp;lt;br&amp;gt;  types.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [a] `(. clojure.lang.RT (alength ~a)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [array] (. clojure.lang.RT (alength array)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">alength</a>[array]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;alias&lt;/b&gt; ([alias namespace-sym])&lt;br&gt; Add an alias in the current namespace to another&lt;br&gt;  namespace. Arguments are two symbols: the alias to be used, and&lt;br&gt;  the symbolic name of the target namespace. Use :as in the ns macro in preference&lt;br&gt;  to calling this directly.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn alias&amp;lt;br&amp;gt;  &amp;quot;Add an alias in the current namespace to another&amp;lt;br&amp;gt;  namespace. Arguments are two symbols: the alias to be used, and&amp;lt;br&amp;gt;  the symbolic name of the target namespace. Use :as in the ns macro in preference&amp;lt;br&amp;gt;  to calling this directly.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [alias namespace-sym]&amp;lt;br&amp;gt;  (.addAlias *ns* alias (the-ns namespace-sym)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">alias</a>[alias namespace-sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;all-ns&lt;/b&gt; ([])&lt;br&gt; Returns a sequence of all namespaces.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn all-ns&amp;lt;br&amp;gt;  &amp;quot;Returns a sequence of all namespaces.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [] (clojure.lang.Namespace/all))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">all-ns</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;alter&lt;/b&gt; ([ref fun &amp; args])&lt;br&gt; Must be called in a transaction. Sets the in-transaction-value of&lt;br&gt;  ref to:&lt;br&gt;&lt;br&gt;  (apply fun in-transaction-value-of-ref args)&lt;br&gt;&lt;br&gt;  and returns the in-transaction-value of ref.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn alter&amp;lt;br&amp;gt;  &amp;quot;Must be called in a transaction. Sets the in-transaction-value of&amp;lt;br&amp;gt;  ref to:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (apply fun in-transaction-value-of-ref args)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  and returns the in-transaction-value of ref.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Ref ref fun &amp;amp; args]&amp;lt;br&amp;gt;    (. ref (alter fun args)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">alter</a>[ref fun & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;alter-meta!&lt;/b&gt; ([iref f &amp; args])&lt;br&gt; Atomically sets the metadata for a namespace/var/ref/agent/atom to be:&lt;br&gt;&lt;br&gt;  (apply f its-current-meta args)&lt;br&gt;&lt;br&gt;  f must be free of side-effects&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn alter-meta!&amp;lt;br&amp;gt;  &amp;quot;Atomically sets the metadata for a namespace/var/ref/agent/atom to be:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (apply f its-current-meta args)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  f must be free of side-effects&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; [^clojure.lang.IReference iref f &amp;amp; args] (.alterMeta iref f args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">alter-meta!</a>[iref f & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;alter-var-root&lt;/b&gt; ([v f &amp; args])&lt;br&gt; Atomically alters the root binding of var v by applying f to its&lt;br&gt;  current value plus any args&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn alter-var-root&amp;lt;br&amp;gt;  &amp;quot;Atomically alters the root binding of var v by applying f to its&amp;lt;br&amp;gt;  current value plus any args&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Var v f &amp;amp; args] (.alterRoot v f args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">alter-var-root</a>[v f & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;amap&lt;/b&gt; ([a idx ret expr])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Maps an expression across an array a, using an index named idx, and&lt;br&gt;  return value named ret, initialized to a clone of a, then setting &lt;br&gt;  each element of ret to the evaluation of expr, returning the new &lt;br&gt;  array ret.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro amap&amp;lt;br&amp;gt;  &amp;quot;Maps an expression across an array a, using an index named idx, and&amp;lt;br&amp;gt;  return value named ret, initialized to a clone of a, then setting &amp;lt;br&amp;gt;  each element of ret to the evaluation of expr, returning the new &amp;lt;br&amp;gt;  array ret.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [a idx ret expr]&amp;lt;br&amp;gt;  `(let [a# ~a&amp;lt;br&amp;gt;         ~ret (aclone a#)]&amp;lt;br&amp;gt;     (loop  [~idx 0]&amp;lt;br&amp;gt;       (if (&amp;lt; ~idx  (alength a#))&amp;lt;br&amp;gt;         (do&amp;lt;br&amp;gt;           (aset ~ret ~idx ~expr)&amp;lt;br&amp;gt;           (recur (unchecked-inc ~idx)))&amp;lt;br&amp;gt;         ~ret))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">amap</a>[a idx ret expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ancestors&lt;/b&gt; ([tag] [h tag])&lt;br&gt; Returns the immediate and indirect parents of tag, either via a Java type&lt;br&gt;  inheritance relationship or a relationship established via derive. h&lt;br&gt;  must be a hierarchy obtained from make-hierarchy, if not supplied&lt;br&gt;  defaults to the global hierarchy&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ancestors&amp;lt;br&amp;gt;  &amp;quot;Returns the immediate and indirect parents of tag, either via a Java type&amp;lt;br&amp;gt;  inheritance relationship or a relationship established via derive. h&amp;lt;br&amp;gt;  must be a hierarchy obtained from make-hierarchy, if not supplied&amp;lt;br&amp;gt;  defaults to the global hierarchy&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([tag] (ancestors global-hierarchy tag))&amp;lt;br&amp;gt;  ([h tag] (not-empty&amp;lt;br&amp;gt;            (let [ta (get (:ancestors h) tag)]&amp;lt;br&amp;gt;              (if (class? tag)&amp;lt;br&amp;gt;                (let [superclasses (set (supers tag))]&amp;lt;br&amp;gt;                  (reduce1 into1 superclasses&amp;lt;br&amp;gt;                    (cons ta&amp;lt;br&amp;gt;                          (map #(get (:ancestors h) %) superclasses))))&amp;lt;br&amp;gt;                ta)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ancestors</a>[tag] [h tag]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;and&lt;/b&gt; ([] [x] [x &amp; next])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates exprs one at a time, from left to right. If a form&lt;br&gt;  returns logical false (nil or false), and returns that value and&lt;br&gt;  doesn't evaluate any of the other expressions, otherwise it returns&lt;br&gt;  the value of the last expr. (and) returns true.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro and&amp;lt;br&amp;gt;  &amp;quot;Evaluates exprs one at a time, from left to right. If a form&amp;lt;br&amp;gt;  returns logical false (nil or false), and returns that value and&amp;lt;br&amp;gt;  doesn't evaluate any of the other expressions, otherwise it returns&amp;lt;br&amp;gt;  the value of the last expr. (and) returns true.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([] true)&amp;lt;br&amp;gt;  ([x] x)&amp;lt;br&amp;gt;  ([x &amp;amp; next]&amp;lt;br&amp;gt;   `(let [and# ~x]&amp;lt;br&amp;gt;      (if and# (and ~@next) and#))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">and</a>[] [x] [x & next]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;apply&lt;/b&gt; ([f args] [f x args] [f x y args] [f x y z args] [f a b c d &amp; args])&lt;br&gt; Applies fn f to the argument list formed by prepending intervening arguments to args.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn apply&amp;lt;br&amp;gt;  &amp;quot;Applies fn f to the argument list formed by prepending intervening arguments to args.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([^clojure.lang.IFn f args]&amp;lt;br&amp;gt;     (. f (applyTo (seq args))))&amp;lt;br&amp;gt;  ([^clojure.lang.IFn f x args]&amp;lt;br&amp;gt;     (. f (applyTo (list* x args))))&amp;lt;br&amp;gt;  ([^clojure.lang.IFn f x y args]&amp;lt;br&amp;gt;     (. f (applyTo (list* x y args))))&amp;lt;br&amp;gt;  ([^clojure.lang.IFn f x y z args]&amp;lt;br&amp;gt;     (. f (applyTo (list* x y z args))))&amp;lt;br&amp;gt;  ([^clojure.lang.IFn f a b c d &amp;amp; args]&amp;lt;br&amp;gt;     (. f (applyTo (cons a (cons b (cons c (cons d (spread args)))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">apply</a>[f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;areduce&lt;/b&gt; ([a idx ret init expr])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Reduces an expression across an array a, using an index named idx,&lt;br&gt;  and return value named ret, initialized to init, setting ret to the &lt;br&gt;  evaluation of expr at each step, returning ret.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro areduce&amp;lt;br&amp;gt;  &amp;quot;Reduces an expression across an array a, using an index named idx,&amp;lt;br&amp;gt;  and return value named ret, initialized to init, setting ret to the &amp;lt;br&amp;gt;  evaluation of expr at each step, returning ret.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [a idx ret init expr]&amp;lt;br&amp;gt;  `(let [a# ~a]&amp;lt;br&amp;gt;     (loop  [~idx 0 ~ret ~init]&amp;lt;br&amp;gt;       (if (&amp;lt; ~idx  (alength a#))&amp;lt;br&amp;gt;         (recur (unchecked-inc ~idx) ~expr)&amp;lt;br&amp;gt;         ~ret))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">areduce</a>[a idx ret init expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;array-map&lt;/b&gt; ([] [&amp; keyvals])&lt;br&gt; Constructs an array-map. If any keys are equal, they are handled as&lt;br&gt;  if by repeated uses of assoc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn array-map&amp;lt;br&amp;gt;  &amp;quot;Constructs an array-map. If any keys are equal, they are handled as&amp;lt;br&amp;gt;  if by repeated uses of assoc.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([] (. clojure.lang.PersistentArrayMap EMPTY))&amp;lt;br&amp;gt;  ([&amp;amp; keyvals]&amp;lt;br&amp;gt;     (clojure.lang.PersistentArrayMap/createAsIfByAssoc (to-array keyvals))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">array-map</a>[] [& keyvals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;as-&gt;&lt;/b&gt; ([expr name &amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Binds name to expr, evaluates the first form in the lexical context&lt;br&gt;  of that binding, then binds name to that result, repeating for each&lt;br&gt;  successive form, returning the result of the last form.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro as-&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;Binds name to expr, evaluates the first form in the lexical context&amp;lt;br&amp;gt;  of that binding, then binds name to that result, repeating for each&amp;lt;br&amp;gt;  successive form, returning the result of the last form.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [expr name &amp;amp; forms]&amp;lt;br&amp;gt;  `(let [~name ~expr&amp;lt;br&amp;gt;         ~@(interleave (repeat name) forms)]&amp;lt;br&amp;gt;     ~name))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">as-></a>[expr name & forms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;aset&lt;/b&gt; ([array idx val] [array idx idx2 &amp; idxv])&lt;br&gt; Sets the value at the index/indices. Works on Java arrays of&lt;br&gt;  reference types. Returns val.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn aset&amp;lt;br&amp;gt;  &amp;quot;Sets the value at the index/indices. Works on Java arrays of&amp;lt;br&amp;gt;  reference types. Returns val.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [a i v] `(. clojure.lang.RT (aset ~a (int ~i) ~v)))&amp;lt;br&amp;gt;   :inline-arities #{3}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([array idx val]&amp;lt;br&amp;gt;   (. Array (set array idx val))&amp;lt;br&amp;gt;   val)&amp;lt;br&amp;gt;  ([array idx idx2 &amp;amp; idxv]&amp;lt;br&amp;gt;   (apply aset (aget array idx) idx2 idxv)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">aset</a>[array idx val] [array idx idx2 & idxv]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;aset-boolean&lt;/b&gt; ([array idx val] [array idx idx2 &amp; idxv])&lt;br&gt; Sets the value at the index/indices. Works on arrays of boolean. Returns val.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def-aset&amp;lt;br&amp;gt;  ^{:doc &amp;quot;Sets the value at the index/indices. Works on arrays of boolean. Returns val.&amp;quot;&amp;lt;br&amp;gt;    :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  aset-boolean setBoolean boolean)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">aset-boolean</a>[array idx val] [array idx idx2 & idxv]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;aset-byte&lt;/b&gt; ([array idx val] [array idx idx2 &amp; idxv])&lt;br&gt; Sets the value at the index/indices. Works on arrays of byte. Returns val.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def-aset&amp;lt;br&amp;gt;  ^{:doc &amp;quot;Sets the value at the index/indices. Works on arrays of byte. Returns val.&amp;quot;&amp;lt;br&amp;gt;    :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  aset-byte setByte byte)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">aset-byte</a>[array idx val] [array idx idx2 & idxv]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;aset-char&lt;/b&gt; ([array idx val] [array idx idx2 &amp; idxv])&lt;br&gt; Sets the value at the index/indices. Works on arrays of char. Returns val.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def-aset&amp;lt;br&amp;gt;  ^{:doc &amp;quot;Sets the value at the index/indices. Works on arrays of char. Returns val.&amp;quot;&amp;lt;br&amp;gt;    :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  aset-char setChar char)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">aset-char</a>[array idx val] [array idx idx2 & idxv]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;aset-double&lt;/b&gt; ([array idx val] [array idx idx2 &amp; idxv])&lt;br&gt; Sets the value at the index/indices. Works on arrays of double. Returns val.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def-aset&amp;lt;br&amp;gt;  ^{:doc &amp;quot;Sets the value at the index/indices. Works on arrays of double. Returns val.&amp;quot;&amp;lt;br&amp;gt;    :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  aset-double setDouble double)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">aset-double</a>[array idx val] [array idx idx2 & idxv]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;aset-float&lt;/b&gt; ([array idx val] [array idx idx2 &amp; idxv])&lt;br&gt; Sets the value at the index/indices. Works on arrays of float. Returns val.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def-aset&amp;lt;br&amp;gt;  ^{:doc &amp;quot;Sets the value at the index/indices. Works on arrays of float. Returns val.&amp;quot;&amp;lt;br&amp;gt;    :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  aset-float setFloat float)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">aset-float</a>[array idx val] [array idx idx2 & idxv]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;aset-int&lt;/b&gt; ([array idx val] [array idx idx2 &amp; idxv])&lt;br&gt; Sets the value at the index/indices. Works on arrays of int. Returns val.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def-aset&amp;lt;br&amp;gt;  ^{:doc &amp;quot;Sets the value at the index/indices. Works on arrays of int. Returns val.&amp;quot;&amp;lt;br&amp;gt;    :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  aset-int setInt int)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">aset-int</a>[array idx val] [array idx idx2 & idxv]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;aset-long&lt;/b&gt; ([array idx val] [array idx idx2 &amp; idxv])&lt;br&gt; Sets the value at the index/indices. Works on arrays of long. Returns val.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def-aset&amp;lt;br&amp;gt;  ^{:doc &amp;quot;Sets the value at the index/indices. Works on arrays of long. Returns val.&amp;quot;&amp;lt;br&amp;gt;    :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  aset-long setLong long)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">aset-long</a>[array idx val] [array idx idx2 & idxv]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;aset-short&lt;/b&gt; ([array idx val] [array idx idx2 &amp; idxv])&lt;br&gt; Sets the value at the index/indices. Works on arrays of short. Returns val.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def-aset&amp;lt;br&amp;gt;  ^{:doc &amp;quot;Sets the value at the index/indices. Works on arrays of short. Returns val.&amp;quot;&amp;lt;br&amp;gt;    :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  aset-short setShort short)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">aset-short</a>[array idx val] [array idx idx2 & idxv]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;assert&lt;/b&gt; ([x] [x message])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates expr and throws an exception if it does not evaluate to&lt;br&gt;  logical true.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro assert&amp;lt;br&amp;gt;  &amp;quot;Evaluates expr and throws an exception if it does not evaluate to&amp;lt;br&amp;gt;  logical true.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x]&amp;lt;br&amp;gt;     (when *assert*&amp;lt;br&amp;gt;       `(when-not ~x&amp;lt;br&amp;gt;          (throw (new AssertionError (str &amp;quot;Assert failed: &amp;quot; (pr-str '~x)))))))&amp;lt;br&amp;gt;  ([x message]&amp;lt;br&amp;gt;     (when *assert*&amp;lt;br&amp;gt;       `(when-not ~x&amp;lt;br&amp;gt;          (throw (new AssertionError (str &amp;quot;Assert failed: &amp;quot; ~message &amp;quot;\n&amp;quot; (pr-str '~x))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">assert</a>[x] [x message]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;assoc&lt;/b&gt; ([map key val] [map key val &amp; kvs])&lt;br&gt; assoc[iate]. When applied to a map, returns a new map of the&lt;br&gt;    same (hashed/sorted) type, that contains the mapping of key(s) to&lt;br&gt;    val(s). When applied to a vector, returns a new vector that&lt;br&gt;    contains val at index. Note - index must be &lt;= (count vector).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([map key val] [map key val &amp;amp; kvs])&amp;lt;br&amp;gt;   :doc &amp;quot;assoc[iate]. When applied to a map, returns a new map of the&amp;lt;br&amp;gt;    same (hashed/sorted) type, that contains the mapping of key(s) to&amp;lt;br&amp;gt;    val(s). When applied to a vector, returns a new vector that&amp;lt;br&amp;gt;    contains val at index. Note - index must be &amp;lt;= (count vector).&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; assoc&amp;lt;br&amp;gt; (fn ^:static assoc&amp;lt;br&amp;gt;   ([map key val] (. clojure.lang.RT (assoc map key val)))&amp;lt;br&amp;gt;   ([map key val &amp;amp; kvs]&amp;lt;br&amp;gt;    (let [ret (assoc map key val)]&amp;lt;br&amp;gt;      (if kvs&amp;lt;br&amp;gt;        (if (next kvs)&amp;lt;br&amp;gt;          (recur ret (first kvs) (second kvs) (nnext kvs))&amp;lt;br&amp;gt;          (throw (IllegalArgumentException.&amp;lt;br&amp;gt;                  &amp;quot;assoc expects even number of arguments after map/vector, found odd number&amp;quot;)))&amp;lt;br&amp;gt;        ret)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">assoc</a>[map key val] [map key val & kvs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;assoc!&lt;/b&gt; ([coll key val] [coll key val &amp; kvs])&lt;br&gt; Alpha - subject to change.&lt;br&gt;  When applied to a transient map, adds mapping of key(s) to&lt;br&gt;  val(s). When applied to a transient vector, sets the val at index.&lt;br&gt;  Note - index must be &lt;= (count vector). Returns coll.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn assoc!&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;  When applied to a transient map, adds mapping of key(s) to&amp;lt;br&amp;gt;  val(s). When applied to a transient vector, sets the val at index.&amp;lt;br&amp;gt;  Note - index must be &amp;lt;= (count vector). Returns coll.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([^clojure.lang.ITransientAssociative coll key val] (.assoc coll key val))&amp;lt;br&amp;gt;  ([^clojure.lang.ITransientAssociative coll key val &amp;amp; kvs]&amp;lt;br&amp;gt;   (let [ret (.assoc coll key val)]&amp;lt;br&amp;gt;     (if kvs&amp;lt;br&amp;gt;       (recur ret (first kvs) (second kvs) (nnext kvs))&amp;lt;br&amp;gt;       ret))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">assoc!</a>[coll key val] [coll key val & kvs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;assoc-in&lt;/b&gt; ([m [k &amp; ks] v])&lt;br&gt; Associates a value in a nested associative structure, where ks is a&lt;br&gt;  sequence of keys and v is the new value and returns a new nested structure.&lt;br&gt;  If any levels do not exist, hash-maps will be created.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn assoc-in&amp;lt;br&amp;gt;  &amp;quot;Associates a value in a nested associative structure, where ks is a&amp;lt;br&amp;gt;  sequence of keys and v is the new value and returns a new nested structure.&amp;lt;br&amp;gt;  If any levels do not exist, hash-maps will be created.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [m [k &amp;amp; ks] v]&amp;lt;br&amp;gt;  (if ks&amp;lt;br&amp;gt;    (assoc m k (assoc-in (get m k) ks v))&amp;lt;br&amp;gt;    (assoc m k v)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">assoc-in</a>[m [k & ks] v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;associative?&lt;/b&gt; ([coll])&lt;br&gt; Returns true if coll implements Associative&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn associative?&amp;lt;br&amp;gt; &amp;quot;Returns true if coll implements Associative&amp;quot;&amp;lt;br&amp;gt; {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;  :static true}&amp;lt;br&amp;gt;  [coll] (instance? clojure.lang.Associative coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">associative?</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;atom&lt;/b&gt; ([x] [x &amp; options])&lt;br&gt; Creates and returns an Atom with an initial value of x and zero or&lt;br&gt;  more options (in any order):&lt;br&gt;&lt;br&gt;  :meta metadata-map&lt;br&gt;&lt;br&gt;  :validator validate-fn&lt;br&gt;&lt;br&gt;  If metadata-map is supplied, it will become the metadata on the&lt;br&gt;  atom. validate-fn must be nil or a side-effect-free fn of one&lt;br&gt;  argument, which will be passed the intended new state on any state&lt;br&gt;  change. If the new state is unacceptable, the validate-fn should&lt;br&gt;  return false or throw an exception.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn atom&amp;lt;br&amp;gt;  &amp;quot;Creates and returns an Atom with an initial value of x and zero or&amp;lt;br&amp;gt;  more options (in any order):&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :meta metadata-map&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :validator validate-fn&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  If metadata-map is supplied, it will become the metadata on the&amp;lt;br&amp;gt;  atom. validate-fn must be nil or a side-effect-free fn of one&amp;lt;br&amp;gt;  argument, which will be passed the intended new state on any state&amp;lt;br&amp;gt;  change. If the new state is unacceptable, the validate-fn should&amp;lt;br&amp;gt;  return false or throw an exception.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([x] (new clojure.lang.Atom x))&amp;lt;br&amp;gt;  ([x &amp;amp; options] (setup-reference (atom x) options)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">atom</a>[x] [x & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;await&lt;/b&gt; ([&amp; agents])&lt;br&gt; Blocks the current thread (indefinitely!) until all actions&lt;br&gt;  dispatched thus far, from this thread or agent, to the agent(s) have&lt;br&gt;  occurred.  Will block on failed agents.  Will never return if&lt;br&gt;  a failed agent is restarted with :clear-actions true.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn await&amp;lt;br&amp;gt;  &amp;quot;Blocks the current thread (indefinitely!) until all actions&amp;lt;br&amp;gt;  dispatched thus far, from this thread or agent, to the agent(s) have&amp;lt;br&amp;gt;  occurred.  Will block on failed agents.  Will never return if&amp;lt;br&amp;gt;  a failed agent is restarted with :clear-actions true.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; agents]&amp;lt;br&amp;gt;  (io! &amp;quot;await in transaction&amp;quot;&amp;lt;br&amp;gt;    (when *agent*&amp;lt;br&amp;gt;      (throw (new Exception &amp;quot;Can't await in agent action&amp;quot;)))&amp;lt;br&amp;gt;    (let [latch (new java.util.concurrent.CountDownLatch (count agents))&amp;lt;br&amp;gt;          count-down (fn [agent] (. latch (countDown)) agent)]&amp;lt;br&amp;gt;      (doseq [agent agents]&amp;lt;br&amp;gt;        (send agent count-down))&amp;lt;br&amp;gt;      (. latch (await)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">await</a>[& agents]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;await-for&lt;/b&gt; ([timeout-ms &amp; agents])&lt;br&gt; Blocks the current thread until all actions dispatched thus&lt;br&gt;  far (from this thread or agent) to the agents have occurred, or the&lt;br&gt;  timeout (in milliseconds) has elapsed. Returns logical false if&lt;br&gt;  returning due to timeout, logical true otherwise.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn await-for&amp;lt;br&amp;gt;  &amp;quot;Blocks the current thread until all actions dispatched thus&amp;lt;br&amp;gt;  far (from this thread or agent) to the agents have occurred, or the&amp;lt;br&amp;gt;  timeout (in milliseconds) has elapsed. Returns logical false if&amp;lt;br&amp;gt;  returning due to timeout, logical true otherwise.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [timeout-ms &amp;amp; agents]&amp;lt;br&amp;gt;    (io! &amp;quot;await-for in transaction&amp;quot;&amp;lt;br&amp;gt;     (when *agent*&amp;lt;br&amp;gt;       (throw (new Exception &amp;quot;Can't await in agent action&amp;quot;)))&amp;lt;br&amp;gt;     (let [latch (new java.util.concurrent.CountDownLatch (count agents))&amp;lt;br&amp;gt;           count-down (fn [agent] (. latch (countDown)) agent)]&amp;lt;br&amp;gt;       (doseq [agent agents]&amp;lt;br&amp;gt;           (send agent count-down))&amp;lt;br&amp;gt;       (. latch (await  timeout-ms (. java.util.concurrent.TimeUnit MILLISECONDS))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">await-for</a>[timeout-ms & agents]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;await1&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static await1 [^clojure.lang.Agent a]&amp;lt;br&amp;gt;  (when (pos? (.getQueueCount a))&amp;lt;br&amp;gt;    (await a))&amp;lt;br&amp;gt;    a)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">await1</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bases&lt;/b&gt; ([c])&lt;br&gt; Returns the immediate superclass and direct interfaces of c, if any&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bases&amp;lt;br&amp;gt;  &amp;quot;Returns the immediate superclass and direct interfaces of c, if any&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^Class c]&amp;lt;br&amp;gt;  (when c&amp;lt;br&amp;gt;    (let [i (seq (.getInterfaces c))&amp;lt;br&amp;gt;          s (.getSuperclass c)]&amp;lt;br&amp;gt;      (if s (cons s i) i))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bases</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bean&lt;/b&gt; ([x])&lt;br&gt; Takes a Java object and returns a read-only implementation of the&lt;br&gt;  map abstraction based upon its JavaBean properties.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bean&amp;lt;br&amp;gt;  &amp;quot;Takes a Java object and returns a read-only implementation of the&amp;lt;br&amp;gt;  map abstraction based upon its JavaBean properties.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [^Object x]&amp;lt;br&amp;gt;  (let [c (. x (getClass))&amp;lt;br&amp;gt;	pmap (reduce1 (fn [m ^java.beans.PropertyDescriptor pd]&amp;lt;br&amp;gt;			 (let [name (. pd (getName))&amp;lt;br&amp;gt;			       method (. pd (getReadMethod))]&amp;lt;br&amp;gt;			   (if (and method (zero? (alength (. method (getParameterTypes)))))&amp;lt;br&amp;gt;			     (assoc m (keyword name) (fn [] (clojure.lang.Reflector/prepRet (.getPropertyType pd) (. method (invoke x nil)))))&amp;lt;br&amp;gt;			     m)))&amp;lt;br&amp;gt;		     {}&amp;lt;br&amp;gt;		     (seq (.. java.beans.Introspector&amp;lt;br&amp;gt;			      (getBeanInfo c)&amp;lt;br&amp;gt;			      (getPropertyDescriptors))))&amp;lt;br&amp;gt;	v (fn [k] ((pmap k)))&amp;lt;br&amp;gt;        snapshot (fn []&amp;lt;br&amp;gt;                   (reduce1 (fn [m e]&amp;lt;br&amp;gt;                             (assoc m (key e) ((val e))))&amp;lt;br&amp;gt;                           {} (seq pmap)))]&amp;lt;br&amp;gt;    (proxy [clojure.lang.APersistentMap]&amp;lt;br&amp;gt;           []&amp;lt;br&amp;gt;      (containsKey [k] (contains? pmap k))&amp;lt;br&amp;gt;      (entryAt [k] (when (contains? pmap k) (new clojure.lang.MapEntry k (v k))))&amp;lt;br&amp;gt;      (valAt ([k] (when (contains? pmap k) (v k)))&amp;lt;br&amp;gt;	     ([k default] (if (contains? pmap k) (v k) default)))&amp;lt;br&amp;gt;      (cons [m] (conj (snapshot) m))&amp;lt;br&amp;gt;      (count [] (count pmap))&amp;lt;br&amp;gt;      (assoc [k v] (assoc (snapshot) k v))&amp;lt;br&amp;gt;      (without [k] (dissoc (snapshot) k))&amp;lt;br&amp;gt;      (seq [] ((fn thisfn [plseq]&amp;lt;br&amp;gt;		  (lazy-seq&amp;lt;br&amp;gt;                   (when-let [pseq (seq plseq)]&amp;lt;br&amp;gt;                     (cons (new clojure.lang.MapEntry (first pseq) (v (first pseq)))&amp;lt;br&amp;gt;                           (thisfn (rest pseq)))))) (keys pmap))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bean</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bigdec&lt;/b&gt; ([x])&lt;br&gt; Coerce to BigDecimal&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bigdec&amp;lt;br&amp;gt;  &amp;quot;Coerce to BigDecimal&amp;quot;&amp;lt;br&amp;gt;  {:tag BigDecimal&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (cond&amp;lt;br&amp;gt;       (decimal? x) x&amp;lt;br&amp;gt;       (float? x) (. BigDecimal valueOf (double x))&amp;lt;br&amp;gt;       (ratio? x) (/ (BigDecimal. (.numerator ^clojure.lang.Ratio x)) (.denominator ^clojure.lang.Ratio x))&amp;lt;br&amp;gt;       (instance? clojure.lang.BigInt x) (.toBigDecimal ^clojure.lang.BigInt x)&amp;lt;br&amp;gt;       (instance? BigInteger x) (BigDecimal. ^BigInteger x)&amp;lt;br&amp;gt;       (number? x) (BigDecimal/valueOf (long x))&amp;lt;br&amp;gt;       :else (BigDecimal. x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bigdec</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bigint&lt;/b&gt; ([x])&lt;br&gt; Coerce to BigInt&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bigint&amp;lt;br&amp;gt;  &amp;quot;Coerce to BigInt&amp;quot;&amp;lt;br&amp;gt;  {:tag clojure.lang.BigInt&amp;lt;br&amp;gt;   :static true&amp;lt;br&amp;gt;   :added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [x] (cond&amp;lt;br&amp;gt;       (instance? clojure.lang.BigInt x) x&amp;lt;br&amp;gt;       (instance? BigInteger x) (clojure.lang.BigInt/fromBigInteger x)&amp;lt;br&amp;gt;       (decimal? x) (bigint (.toBigInteger ^BigDecimal x))&amp;lt;br&amp;gt;       (ratio? x) (bigint (.bigIntegerValue ^clojure.lang.Ratio x))&amp;lt;br&amp;gt;       (number? x) (clojure.lang.BigInt/valueOf (long x))&amp;lt;br&amp;gt;       :else (bigint (BigInteger. x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bigint</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;biginteger&lt;/b&gt; ([x])&lt;br&gt; Coerce to BigInteger&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn biginteger&amp;lt;br&amp;gt;  &amp;quot;Coerce to BigInteger&amp;quot;&amp;lt;br&amp;gt;  {:tag BigInteger&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (cond&amp;lt;br&amp;gt;       (instance? BigInteger x) x&amp;lt;br&amp;gt;       (instance? clojure.lang.BigInt x) (.toBigInteger ^clojure.lang.BigInt x)&amp;lt;br&amp;gt;       (decimal? x) (.toBigInteger ^BigDecimal x)&amp;lt;br&amp;gt;       (ratio? x) (.bigIntegerValue ^clojure.lang.Ratio x)&amp;lt;br&amp;gt;       (number? x) (BigInteger/valueOf (long x))&amp;lt;br&amp;gt;       :else (BigInteger. x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">biginteger</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;binding&lt;/b&gt; ([bindings &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; binding =&gt; var-symbol init-expr&lt;br&gt;&lt;br&gt;  Creates new bindings for the (already-existing) vars, with the&lt;br&gt;  supplied initial values, executes the exprs in an implicit do, then&lt;br&gt;  re-establishes the bindings that existed before.  The new bindings&lt;br&gt;  are made in parallel (unlike let); all init-exprs are evaluated&lt;br&gt;  before the vars are bound to their new values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro binding&amp;lt;br&amp;gt;  &amp;quot;binding =&amp;gt; var-symbol init-expr&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Creates new bindings for the (already-existing) vars, with the&amp;lt;br&amp;gt;  supplied initial values, executes the exprs in an implicit do, then&amp;lt;br&amp;gt;  re-establishes the bindings that existed before.  The new bindings&amp;lt;br&amp;gt;  are made in parallel (unlike let); all init-exprs are evaluated&amp;lt;br&amp;gt;  before the vars are bound to their new values.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [bindings &amp;amp; body]&amp;lt;br&amp;gt;  (assert-args&amp;lt;br&amp;gt;    (vector? bindings) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;    (even? (count bindings)) &amp;quot;an even number of forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;  (let [var-ize (fn [var-vals]&amp;lt;br&amp;gt;                  (loop [ret [] vvs (seq var-vals)]&amp;lt;br&amp;gt;                    (if vvs&amp;lt;br&amp;gt;                      (recur  (conj (conj ret `(var ~(first vvs))) (second vvs))&amp;lt;br&amp;gt;                             (next (next vvs)))&amp;lt;br&amp;gt;                      (seq ret))))]&amp;lt;br&amp;gt;    `(let []&amp;lt;br&amp;gt;       (push-thread-bindings (hash-map ~@(var-ize bindings)))&amp;lt;br&amp;gt;       (try&amp;lt;br&amp;gt;         ~@body&amp;lt;br&amp;gt;         (finally&amp;lt;br&amp;gt;           (pop-thread-bindings))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">binding</a>[bindings & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bit-and&lt;/b&gt; ([x y] [x y &amp; more])&lt;br&gt; Bitwise and&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bit-and&amp;lt;br&amp;gt;  &amp;quot;Bitwise and&amp;quot;&amp;lt;br&amp;gt;   {:inline (nary-inline 'and)&amp;lt;br&amp;gt;    :inline-arities &amp;gt;1?&amp;lt;br&amp;gt;    :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;   ([x y] (. clojure.lang.Numbers and x y))&amp;lt;br&amp;gt;   ([x y &amp;amp; more]&amp;lt;br&amp;gt;      (reduce1 bit-and (bit-and x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bit-and</a>[x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bit-and-not&lt;/b&gt; ([x y] [x y &amp; more])&lt;br&gt; Bitwise and with complement&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bit-and-not&amp;lt;br&amp;gt;  &amp;quot;Bitwise and with complement&amp;quot;&amp;lt;br&amp;gt;  {:inline (nary-inline 'andNot)&amp;lt;br&amp;gt;   :inline-arities &amp;gt;1?&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers andNot x y))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;    (reduce1 bit-and-not (bit-and-not x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bit-and-not</a>[x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bit-clear&lt;/b&gt; ([x n])&lt;br&gt; Clear bit at index n&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bit-clear&amp;lt;br&amp;gt;  &amp;quot;Clear bit at index n&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x n] (. clojure.lang.Numbers clearBit x n))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bit-clear</a>[x n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bit-flip&lt;/b&gt; ([x n])&lt;br&gt; Flip bit at index n&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bit-flip&amp;lt;br&amp;gt;  &amp;quot;Flip bit at index n&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x n] (. clojure.lang.Numbers flipBit x n))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bit-flip</a>[x n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bit-not&lt;/b&gt; ([x])&lt;br&gt; Bitwise complement&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bit-not&amp;lt;br&amp;gt;  &amp;quot;Bitwise complement&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x] `(. clojure.lang.Numbers (not ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers not x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bit-not</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bit-or&lt;/b&gt; ([x y] [x y &amp; more])&lt;br&gt; Bitwise or&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bit-or&amp;lt;br&amp;gt;  &amp;quot;Bitwise or&amp;quot;&amp;lt;br&amp;gt;  {:inline (nary-inline 'or)&amp;lt;br&amp;gt;   :inline-arities &amp;gt;1?&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers or x y))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;    (reduce1 bit-or (bit-or x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bit-or</a>[x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bit-set&lt;/b&gt; ([x n])&lt;br&gt; Set bit at index n&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bit-set&amp;lt;br&amp;gt;  &amp;quot;Set bit at index n&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x n] (. clojure.lang.Numbers setBit x n))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bit-set</a>[x n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bit-shift-left&lt;/b&gt; ([x n])&lt;br&gt; Bitwise shift left&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bit-shift-left&amp;lt;br&amp;gt;  &amp;quot;Bitwise shift left&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x n] `(. clojure.lang.Numbers (shiftLeft ~x ~n)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x n] (. clojure.lang.Numbers shiftLeft x n))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bit-shift-left</a>[x n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bit-shift-right&lt;/b&gt; ([x n])&lt;br&gt; Bitwise shift right&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bit-shift-right&amp;lt;br&amp;gt;  &amp;quot;Bitwise shift right&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x n] `(. clojure.lang.Numbers (shiftRight ~x ~n)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x n] (. clojure.lang.Numbers shiftRight x n))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bit-shift-right</a>[x n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bit-test&lt;/b&gt; ([x n])&lt;br&gt; Test bit at index n&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bit-test&amp;lt;br&amp;gt;  &amp;quot;Test bit at index n&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x n] (. clojure.lang.Numbers testBit x n))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bit-test</a>[x n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bit-xor&lt;/b&gt; ([x y] [x y &amp; more])&lt;br&gt; Bitwise exclusive or&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bit-xor&amp;lt;br&amp;gt;  &amp;quot;Bitwise exclusive or&amp;quot;&amp;lt;br&amp;gt;  {:inline (nary-inline 'xor)&amp;lt;br&amp;gt;   :inline-arities &amp;gt;1?&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers xor x y))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;    (reduce1 bit-xor (bit-xor x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bit-xor</a>[x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;boolean&lt;/b&gt; ([x])&lt;br&gt; Coerce to boolean&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn boolean&amp;lt;br&amp;gt;  &amp;quot;Coerce to boolean&amp;quot;&amp;lt;br&amp;gt;  {&amp;lt;br&amp;gt;   :inline (fn  [x] `(. clojure.lang.RT (booleanCast ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (clojure.lang.RT/booleanCast x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">boolean</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;boolean-array&lt;/b&gt; ([size-or-seq] [size init-val-or-seq])&lt;br&gt; Creates an array of booleans&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn boolean-array&amp;lt;br&amp;gt;  &amp;quot;Creates an array of booleans&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [&amp;amp; args] `(. clojure.lang.Numbers boolean_array ~@args))&amp;lt;br&amp;gt;   :inline-arities #{1 2}&amp;lt;br&amp;gt;   :added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  ([size-or-seq] (. clojure.lang.Numbers boolean_array size-or-seq))&amp;lt;br&amp;gt;  ([size init-val-or-seq] (. clojure.lang.Numbers boolean_array size init-val-or-seq)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">boolean-array</a>[size-or-seq] [size init-val-or-seq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;booleans&lt;/b&gt; ([xs])&lt;br&gt; Casts to boolean[]&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(definline booleans&amp;lt;br&amp;gt;  &amp;quot;Casts to boolean[]&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [xs] `(. clojure.lang.Numbers booleans ~xs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">booleans</a>[xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bound-fn&lt;/b&gt; ([&amp; fntail])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Returns a function defined by the given fntail, which will install the&lt;br&gt;  same bindings in effect as in the thread at the time bound-fn was called.&lt;br&gt;  This may be used to define a helper function which runs on a different&lt;br&gt;  thread, but needs the same bindings in place.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro bound-fn&amp;lt;br&amp;gt;  &amp;quot;Returns a function defined by the given fntail, which will install the&amp;lt;br&amp;gt;  same bindings in effect as in the thread at the time bound-fn was called.&amp;lt;br&amp;gt;  This may be used to define a helper function which runs on a different&amp;lt;br&amp;gt;  thread, but needs the same bindings in place.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; fntail]&amp;lt;br&amp;gt;  `(bound-fn* (fn ~@fntail)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bound-fn</a>[& fntail]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bound-fn*&lt;/b&gt; ([f])&lt;br&gt; Returns a function, which will install the same bindings in effect as in&lt;br&gt;  the thread at the time bound-fn* was called and then call f with any given&lt;br&gt;  arguments. This may be used to define a helper function which runs on a&lt;br&gt;  different thread, but needs the same bindings in place.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bound-fn*&amp;lt;br&amp;gt;  &amp;quot;Returns a function, which will install the same bindings in effect as in&amp;lt;br&amp;gt;  the thread at the time bound-fn* was called and then call f with any given&amp;lt;br&amp;gt;  arguments. This may be used to define a helper function which runs on a&amp;lt;br&amp;gt;  different thread, but needs the same bindings in place.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (let [bindings (get-thread-bindings)]&amp;lt;br&amp;gt;    (fn [&amp;amp; args]&amp;lt;br&amp;gt;      (apply with-bindings* bindings f args))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bound-fn*</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bound?&lt;/b&gt; ([&amp; vars])&lt;br&gt; Returns true if all of the vars provided as arguments have any bound value, root or thread-local.&lt;br&gt;   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bound?&amp;lt;br&amp;gt;  &amp;quot;Returns true if all of the vars provided as arguments have any bound value, root or thread-local.&amp;lt;br&amp;gt;   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; vars]&amp;lt;br&amp;gt;  (every? #(.isBound ^clojure.lang.Var %) vars))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bound?</a>[& vars]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;butlast&lt;/b&gt; ([coll])&lt;br&gt; Return a seq of all but the last item in coll, in linear time&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def &amp;lt;br&amp;gt; ^{:arglists '([coll])&amp;lt;br&amp;gt;   :doc &amp;quot;Return a seq of all but the last item in coll, in linear time&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; butlast (fn ^:static butlast [s]&amp;lt;br&amp;gt;           (loop [ret [] s s]&amp;lt;br&amp;gt;             (if (next s)&amp;lt;br&amp;gt;               (recur (conj ret (first s)) (next s))&amp;lt;br&amp;gt;               (seq ret)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">butlast</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;byte&lt;/b&gt; ([x])&lt;br&gt; Coerce to byte&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn byte&amp;lt;br&amp;gt;  &amp;quot;Coerce to byte&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedByteCast 'byteCast) ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [^Number x] (clojure.lang.RT/byteCast x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">byte</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;byte-array&lt;/b&gt; ([size-or-seq] [size init-val-or-seq])&lt;br&gt; Creates an array of bytes&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn byte-array&amp;lt;br&amp;gt;  &amp;quot;Creates an array of bytes&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [&amp;amp; args] `(. clojure.lang.Numbers byte_array ~@args))&amp;lt;br&amp;gt;   :inline-arities #{1 2}&amp;lt;br&amp;gt;   :added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  ([size-or-seq] (. clojure.lang.Numbers byte_array size-or-seq))&amp;lt;br&amp;gt;  ([size init-val-or-seq] (. clojure.lang.Numbers byte_array size init-val-or-seq)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">byte-array</a>[size-or-seq] [size init-val-or-seq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;bytes&lt;/b&gt; ([xs])&lt;br&gt; Casts to bytes[]&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(definline bytes&amp;lt;br&amp;gt;  &amp;quot;Casts to bytes[]&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [xs] `(. clojure.lang.Numbers bytes ~xs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bytes</a>[xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;case&lt;/b&gt; ([e &amp; clauses])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Takes an expression, and a set of clauses.&lt;br&gt;&lt;br&gt;  Each clause can take the form of either:&lt;br&gt;&lt;br&gt;  test-constant result-expr&lt;br&gt;&lt;br&gt;  (test-constant1 ... test-constantN)  result-expr&lt;br&gt;&lt;br&gt;  The test-constants are not evaluated. They must be compile-time&lt;br&gt;  literals, and need not be quoted.  If the expression is equal to a&lt;br&gt;  test-constant, the corresponding result-expr is returned. A single&lt;br&gt;  default expression can follow the clauses, and its value will be&lt;br&gt;  returned if no clause matches. If no default expression is provided&lt;br&gt;  and no clause matches, an IllegalArgumentException is thrown.&lt;br&gt;&lt;br&gt;  Unlike cond and condp, case does a constant-time dispatch, the&lt;br&gt;  clauses are not considered sequentially.  All manner of constant&lt;br&gt;  expressions are acceptable in case, including numbers, strings,&lt;br&gt;  symbols, keywords, and (Clojure) composites thereof. Note that since&lt;br&gt;  lists are used to group multiple constants that map to the same&lt;br&gt;  expression, a vector can be used to match a list if needed. The&lt;br&gt;  test-constants need not be all of the same type.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro case &amp;lt;br&amp;gt;  &amp;quot;Takes an expression, and a set of clauses.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Each clause can take the form of either:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  test-constant result-expr&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (test-constant1 ... test-constantN)  result-expr&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The test-constants are not evaluated. They must be compile-time&amp;lt;br&amp;gt;  literals, and need not be quoted.  If the expression is equal to a&amp;lt;br&amp;gt;  test-constant, the corresponding result-expr is returned. A single&amp;lt;br&amp;gt;  default expression can follow the clauses, and its value will be&amp;lt;br&amp;gt;  returned if no clause matches. If no default expression is provided&amp;lt;br&amp;gt;  and no clause matches, an IllegalArgumentException is thrown.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Unlike cond and condp, case does a constant-time dispatch, the&amp;lt;br&amp;gt;  clauses are not considered sequentially.  All manner of constant&amp;lt;br&amp;gt;  expressions are acceptable in case, including numbers, strings,&amp;lt;br&amp;gt;  symbols, keywords, and (Clojure) composites thereof. Note that since&amp;lt;br&amp;gt;  lists are used to group multiple constants that map to the same&amp;lt;br&amp;gt;  expression, a vector can be used to match a list if needed. The&amp;lt;br&amp;gt;  test-constants need not be all of the same type.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  [e &amp;amp; clauses]&amp;lt;br&amp;gt;  (let [ge (with-meta (gensym) {:tag Object})&amp;lt;br&amp;gt;        default (if (odd? (count clauses)) &amp;lt;br&amp;gt;                  (last clauses)&amp;lt;br&amp;gt;                  `(throw (IllegalArgumentException. (str &amp;quot;No matching clause: &amp;quot; ~ge))))]&amp;lt;br&amp;gt;    (if (&amp;gt; 2 (count clauses))&amp;lt;br&amp;gt;      `(let [~ge ~e] ~default)&amp;lt;br&amp;gt;      (let [pairs (partition 2 clauses)&amp;lt;br&amp;gt;            assoc-test (fn assoc-test [m test expr]&amp;lt;br&amp;gt;                         (if (contains? m test)&amp;lt;br&amp;gt;                           (throw (IllegalArgumentException. (str &amp;quot;Duplicate case test constant: &amp;quot; test)))&amp;lt;br&amp;gt;                           (assoc m test expr)))&amp;lt;br&amp;gt;            pairs (reduce1&amp;lt;br&amp;gt;                       (fn [m [test expr]]&amp;lt;br&amp;gt;                         (if (seq? test)&amp;lt;br&amp;gt;                           (reduce1 #(assoc-test %1 %2 expr) m test)&amp;lt;br&amp;gt;                           (assoc-test m test expr)))&amp;lt;br&amp;gt;                       {} pairs)&amp;lt;br&amp;gt;            tests (keys pairs)&amp;lt;br&amp;gt;            thens (vals pairs)&amp;lt;br&amp;gt;            mode (cond&amp;lt;br&amp;gt;                   (every? #(and (integer? %) (&amp;lt;= Integer/MIN_VALUE % Integer/MAX_VALUE)) tests)&amp;lt;br&amp;gt;                   :ints&amp;lt;br&amp;gt;                   (every? keyword? tests)&amp;lt;br&amp;gt;                   :identity&amp;lt;br&amp;gt;                   :else :hashes)]&amp;lt;br&amp;gt;        (condp = mode&amp;lt;br&amp;gt;          :ints&amp;lt;br&amp;gt;          (let [[shift mask imap switch-type] (prep-ints tests thens)]&amp;lt;br&amp;gt;            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :int)))&amp;lt;br&amp;gt;          :hashes&amp;lt;br&amp;gt;          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]&amp;lt;br&amp;gt;            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-equiv ~skip-check)))&amp;lt;br&amp;gt;          :identity&amp;lt;br&amp;gt;          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]&amp;lt;br&amp;gt;            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-identity ~skip-check))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">case</a>[e & clauses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;cast&lt;/b&gt; ([c x])&lt;br&gt; Throws a ClassCastException if x is not a c, else returns x.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cast&amp;lt;br&amp;gt;  &amp;quot;Throws a ClassCastException if x is not a c, else returns x.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^Class c x] &amp;lt;br&amp;gt;  (. c (cast x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cast</a>[c x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;char&lt;/b&gt; ([x])&lt;br&gt; Coerce to char&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn char&amp;lt;br&amp;gt;  &amp;quot;Coerce to char&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedCharCast 'charCast) ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.RT (charCast x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">char</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;char-array&lt;/b&gt; ([size-or-seq] [size init-val-or-seq])&lt;br&gt; Creates an array of chars&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn char-array&amp;lt;br&amp;gt;  &amp;quot;Creates an array of chars&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [&amp;amp; args] `(. clojure.lang.Numbers char_array ~@args))&amp;lt;br&amp;gt;   :inline-arities #{1 2}&amp;lt;br&amp;gt;   :added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  ([size-or-seq] (. clojure.lang.Numbers char_array size-or-seq))&amp;lt;br&amp;gt;  ([size init-val-or-seq] (. clojure.lang.Numbers char_array size init-val-or-seq)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">char-array</a>[size-or-seq] [size init-val-or-seq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;char?&lt;/b&gt; ([x])&lt;br&gt; Return true if x is a Character&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([x])&amp;lt;br&amp;gt;   :doc &amp;quot;Return true if x is a Character&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; char? (fn ^:static char? [x] (instance? Character x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">char?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;chars&lt;/b&gt; ([xs])&lt;br&gt; Casts to chars[]&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(definline chars&amp;lt;br&amp;gt;  &amp;quot;Casts to chars[]&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [xs] `(. clojure.lang.Numbers chars ~xs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">chars</a>[xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;chunk&lt;/b&gt; ([b])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static ^clojure.lang.IChunk chunk [^clojure.lang.ChunkBuffer b]&amp;lt;br&amp;gt;  (.chunk b))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">chunk</a>[b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;chunk-append&lt;/b&gt; ([b x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static chunk-append [^clojure.lang.ChunkBuffer b x]&amp;lt;br&amp;gt;  (.add b x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">chunk-append</a>[b x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;chunk-buffer&lt;/b&gt; ([capacity])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static ^clojure.lang.ChunkBuffer chunk-buffer ^clojure.lang.ChunkBuffer [capacity]&amp;lt;br&amp;gt;  (clojure.lang.ChunkBuffer. capacity))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">chunk-buffer</a>[capacity]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;chunk-cons&lt;/b&gt; ([chunk rest])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static chunk-cons [chunk rest]&amp;lt;br&amp;gt;  (if (clojure.lang.Numbers/isZero (clojure.lang.RT/count chunk))&amp;lt;br&amp;gt;    rest&amp;lt;br&amp;gt;    (clojure.lang.ChunkedCons. chunk rest)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">chunk-cons</a>[chunk rest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;chunk-first&lt;/b&gt; ([s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static  ^clojure.lang.IChunk chunk-first ^clojure.lang.IChunk [^clojure.lang.IChunkedSeq s]&amp;lt;br&amp;gt;  (.chunkedFirst s))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">chunk-first</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;chunk-next&lt;/b&gt; ([s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static ^clojure.lang.ISeq chunk-next ^clojure.lang.ISeq [^clojure.lang.IChunkedSeq s]&amp;lt;br&amp;gt;  (.chunkedNext s))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">chunk-next</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;chunk-rest&lt;/b&gt; ([s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static ^clojure.lang.ISeq chunk-rest ^clojure.lang.ISeq [^clojure.lang.IChunkedSeq s]&amp;lt;br&amp;gt;  (.chunkedMore s))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">chunk-rest</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;chunked-seq?&lt;/b&gt; ([s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static chunked-seq? [s]&amp;lt;br&amp;gt;  (instance? clojure.lang.IChunkedSeq s))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">chunked-seq?</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;class&lt;/b&gt; ([x])&lt;br&gt; Returns the Class of x&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn class&amp;lt;br&amp;gt;  &amp;quot;Returns the Class of x&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ^Class [^Object x] (if (nil? x) x (. x (getClass))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">class</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;class?&lt;/b&gt; ([x])&lt;br&gt; Returns true if x is an instance of Class&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn class?&amp;lt;br&amp;gt;  &amp;quot;Returns true if x is an instance of Class&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (instance? Class x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">class?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;clear-agent-errors&lt;/b&gt; ([a])&lt;br&gt; DEPRECATED: Use 'restart-agent' instead.&lt;br&gt;  Clears any exceptions thrown during asynchronous actions of the&lt;br&gt;  agent, allowing subsequent actions to occur.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn clear-agent-errors&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED: Use 'restart-agent' instead.&amp;lt;br&amp;gt;  Clears any exceptions thrown during asynchronous actions of the&amp;lt;br&amp;gt;  agent, allowing subsequent actions to occur.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :deprecated &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^clojure.lang.Agent a] (restart-agent a (.deref a)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">clear-agent-errors</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;clojure-version&lt;/b&gt; ([])&lt;br&gt; Returns clojure version as a printable string.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn&amp;lt;br&amp;gt;  clojure-version &amp;lt;br&amp;gt;  &amp;quot;Returns clojure version as a printable string.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (str (:major *clojure-version*)&amp;lt;br&amp;gt;       &amp;quot;.&amp;quot;&amp;lt;br&amp;gt;       (:minor *clojure-version*)&amp;lt;br&amp;gt;       (when-let [i (:incremental *clojure-version*)]&amp;lt;br&amp;gt;         (str &amp;quot;.&amp;quot; i))&amp;lt;br&amp;gt;       (when-let [q (:qualifier *clojure-version*)]&amp;lt;br&amp;gt;         (when (pos? (count q)) (str &amp;quot;-&amp;quot; q)))&amp;lt;br&amp;gt;       (when (:interim *clojure-version*)&amp;lt;br&amp;gt;         &amp;quot;-SNAPSHOT&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">clojure-version</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;coll?&lt;/b&gt; ([x])&lt;br&gt; Returns true if x implements IPersistentCollection&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn coll?&amp;lt;br&amp;gt;  &amp;quot;Returns true if x implements IPersistentCollection&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (instance? clojure.lang.IPersistentCollection x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">coll?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;comment&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Ignores body, yields nil&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro comment&amp;lt;br&amp;gt;  &amp;quot;Ignores body, yields nil&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; body])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">comment</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;commute&lt;/b&gt; ([ref fun &amp; args])&lt;br&gt; Must be called in a transaction. Sets the in-transaction-value of&lt;br&gt;  ref to:&lt;br&gt;&lt;br&gt;  (apply fun in-transaction-value-of-ref args)&lt;br&gt;&lt;br&gt;  and returns the in-transaction-value of ref.&lt;br&gt;&lt;br&gt;  At the commit point of the transaction, sets the value of ref to be:&lt;br&gt;&lt;br&gt;  (apply fun most-recently-committed-value-of-ref args)&lt;br&gt;&lt;br&gt;  Thus fun should be commutative, or, failing that, you must accept&lt;br&gt;  last-one-in-wins behavior.  commute allows for more concurrency than&lt;br&gt;  ref-set.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn commute&amp;lt;br&amp;gt;  &amp;quot;Must be called in a transaction. Sets the in-transaction-value of&amp;lt;br&amp;gt;  ref to:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (apply fun in-transaction-value-of-ref args)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  and returns the in-transaction-value of ref.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  At the commit point of the transaction, sets the value of ref to be:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (apply fun most-recently-committed-value-of-ref args)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Thus fun should be commutative, or, failing that, you must accept&amp;lt;br&amp;gt;  last-one-in-wins behavior.  commute allows for more concurrency than&amp;lt;br&amp;gt;  ref-set.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  [^clojure.lang.Ref ref fun &amp;amp; args]&amp;lt;br&amp;gt;    (. ref (commute fun args)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">commute</a>[ref fun & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;comp&lt;/b&gt; ([] [f] [f g] [f g h] [f1 f2 f3 &amp; fs])&lt;br&gt; Takes a set of functions and returns a fn that is the composition&lt;br&gt;  of those fns.  The returned fn takes a variable number of args,&lt;br&gt;  applies the rightmost of fns to the args, the next&lt;br&gt;  fn (right-to-left) to the result, etc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn comp&amp;lt;br&amp;gt;  &amp;quot;Takes a set of functions and returns a fn that is the composition&amp;lt;br&amp;gt;  of those fns.  The returned fn takes a variable number of args,&amp;lt;br&amp;gt;  applies the rightmost of fns to the args, the next&amp;lt;br&amp;gt;  fn (right-to-left) to the result, etc.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([] identity)&amp;lt;br&amp;gt;  ([f] f)&amp;lt;br&amp;gt;  ([f g] &amp;lt;br&amp;gt;     (fn &amp;lt;br&amp;gt;       ([] (f (g)))&amp;lt;br&amp;gt;       ([x] (f (g x)))&amp;lt;br&amp;gt;       ([x y] (f (g x y)))&amp;lt;br&amp;gt;       ([x y z] (f (g x y z)))&amp;lt;br&amp;gt;       ([x y z &amp;amp; args] (f (apply g x y z args)))))&amp;lt;br&amp;gt;  ([f g h] &amp;lt;br&amp;gt;     (fn &amp;lt;br&amp;gt;       ([] (f (g (h))))&amp;lt;br&amp;gt;       ([x] (f (g (h x))))&amp;lt;br&amp;gt;       ([x y] (f (g (h x y))))&amp;lt;br&amp;gt;       ([x y z] (f (g (h x y z))))&amp;lt;br&amp;gt;       ([x y z &amp;amp; args] (f (g (apply h x y z args))))))&amp;lt;br&amp;gt;  ([f1 f2 f3 &amp;amp; fs]&amp;lt;br&amp;gt;    (let [fs (reverse (list* f1 f2 f3 fs))]&amp;lt;br&amp;gt;      (fn [&amp;amp; args]&amp;lt;br&amp;gt;        (loop [ret (apply (first fs) args) fs (next fs)]&amp;lt;br&amp;gt;          (if fs&amp;lt;br&amp;gt;            (recur ((first fs) ret) (next fs))&amp;lt;br&amp;gt;            ret))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">comp</a>[] [f] [f g] [f g h] [f1 f2 f3 & fs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;comparator&lt;/b&gt; ([pred])&lt;br&gt; Returns an implementation of java.util.Comparator based upon pred.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn comparator&amp;lt;br&amp;gt;  &amp;quot;Returns an implementation of java.util.Comparator based upon pred.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [pred]&amp;lt;br&amp;gt;    (fn [x y]&amp;lt;br&amp;gt;      (cond (pred x y) -1 (pred y x) 1 :else 0)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">comparator</a>[pred]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;compare&lt;/b&gt; ([x y])&lt;br&gt; Comparator. Returns a negative number, zero, or a positive number&lt;br&gt;  when x is logically 'less than', 'equal to', or 'greater than'&lt;br&gt;  y. Same as Java x.compareTo(y) except it also works for nil, and&lt;br&gt;  compares numbers and collections in a type-independent manner. x&lt;br&gt;  must implement Comparable&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn compare&amp;lt;br&amp;gt;  &amp;quot;Comparator. Returns a negative number, zero, or a positive number&amp;lt;br&amp;gt;  when x is logically 'less than', 'equal to', or 'greater than'&amp;lt;br&amp;gt;  y. Same as Java x.compareTo(y) except it also works for nil, and&amp;lt;br&amp;gt;  compares numbers and collections in a type-independent manner. x&amp;lt;br&amp;gt;  must implement Comparable&amp;quot;&amp;lt;br&amp;gt;  {&amp;lt;br&amp;gt;   :inline (fn [x y] `(. clojure.lang.Util compare ~x ~y))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x y] (. clojure.lang.Util (compare x y)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">compare</a>[x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;compare-and-set!&lt;/b&gt; ([atom oldval newval])&lt;br&gt; Atomically sets the value of atom to newval if and only if the&lt;br&gt;  current value of the atom is identical to oldval. Returns true if&lt;br&gt;  set happened, else false&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn compare-and-set!&amp;lt;br&amp;gt;  &amp;quot;Atomically sets the value of atom to newval if and only if the&amp;lt;br&amp;gt;  current value of the atom is identical to oldval. Returns true if&amp;lt;br&amp;gt;  set happened, else false&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Atom atom oldval newval] (.compareAndSet atom oldval newval))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">compare-and-set!</a>[atom oldval newval]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;compile&lt;/b&gt; ([lib])&lt;br&gt; Compiles the namespace named by the symbol lib into a set of&lt;br&gt;  classfiles. The source for the lib must be in a proper&lt;br&gt;  classpath-relative directory. The output files will go into the&lt;br&gt;  directory specified by *compile-path*, and that directory too must&lt;br&gt;  be in the classpath.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn compile&amp;lt;br&amp;gt;  &amp;quot;Compiles the namespace named by the symbol lib into a set of&amp;lt;br&amp;gt;  classfiles. The source for the lib must be in a proper&amp;lt;br&amp;gt;  classpath-relative directory. The output files will go into the&amp;lt;br&amp;gt;  directory specified by *compile-path*, and that directory too must&amp;lt;br&amp;gt;  be in the classpath.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [lib]&amp;lt;br&amp;gt;  (binding [*compile-files* true]&amp;lt;br&amp;gt;    (load-one lib true true))&amp;lt;br&amp;gt;  lib)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">compile</a>[lib]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;complement&lt;/b&gt; ([f])&lt;br&gt; Takes a fn f and returns a fn that takes the same arguments as f,&lt;br&gt;  has the same effects, if any, and returns the opposite truth value.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn complement&amp;lt;br&amp;gt;  &amp;quot;Takes a fn f and returns a fn that takes the same arguments as f,&amp;lt;br&amp;gt;  has the same effects, if any, and returns the opposite truth value.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [f] &amp;lt;br&amp;gt;  (fn &amp;lt;br&amp;gt;    ([] (not (f)))&amp;lt;br&amp;gt;    ([x] (not (f x)))&amp;lt;br&amp;gt;    ([x y] (not (f x y)))&amp;lt;br&amp;gt;    ([x y &amp;amp; zs] (not (apply f x y zs)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">complement</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;concat&lt;/b&gt; ([] [x] [x y] [x y &amp; zs])&lt;br&gt; Returns a lazy seq representing the concatenation of the elements in the supplied colls.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn concat&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy seq representing the concatenation of the elements in the supplied colls.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([] (lazy-seq nil))&amp;lt;br&amp;gt;  ([x] (lazy-seq x))&amp;lt;br&amp;gt;  ([x y]&amp;lt;br&amp;gt;    (lazy-seq&amp;lt;br&amp;gt;      (let [s (seq x)]&amp;lt;br&amp;gt;        (if s&amp;lt;br&amp;gt;          (if (chunked-seq? s)&amp;lt;br&amp;gt;            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))&amp;lt;br&amp;gt;            (cons (first s) (concat (rest s) y)))&amp;lt;br&amp;gt;          y))))&amp;lt;br&amp;gt;  ([x y &amp;amp; zs]&amp;lt;br&amp;gt;     (let [cat (fn cat [xys zs]&amp;lt;br&amp;gt;                 (lazy-seq&amp;lt;br&amp;gt;                   (let [xys (seq xys)]&amp;lt;br&amp;gt;                     (if xys&amp;lt;br&amp;gt;                       (if (chunked-seq? xys)&amp;lt;br&amp;gt;                         (chunk-cons (chunk-first xys)&amp;lt;br&amp;gt;                                     (cat (chunk-rest xys) zs))&amp;lt;br&amp;gt;                         (cons (first xys) (cat (rest xys) zs)))&amp;lt;br&amp;gt;                       (when zs&amp;lt;br&amp;gt;                         (cat (first zs) (next zs)))))))]&amp;lt;br&amp;gt;       (cat (concat x y) zs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">concat</a>[] [x] [x y] [x y & zs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;cond&lt;/b&gt; ([&amp; clauses])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Takes a set of test/expr pairs. It evaluates each test one at a&lt;br&gt;  time.  If a test returns logical true, cond evaluates and returns&lt;br&gt;  the value of the corresponding expr and doesn't evaluate any of the&lt;br&gt;  other tests or exprs. (cond) returns nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro cond&amp;lt;br&amp;gt;  &amp;quot;Takes a set of test/expr pairs. It evaluates each test one at a&amp;lt;br&amp;gt;  time.  If a test returns logical true, cond evaluates and returns&amp;lt;br&amp;gt;  the value of the corresponding expr and doesn't evaluate any of the&amp;lt;br&amp;gt;  other tests or exprs. (cond) returns nil.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; clauses]&amp;lt;br&amp;gt;    (when clauses&amp;lt;br&amp;gt;      (list 'if (first clauses)&amp;lt;br&amp;gt;            (if (next clauses)&amp;lt;br&amp;gt;                (second clauses)&amp;lt;br&amp;gt;                (throw (IllegalArgumentException.&amp;lt;br&amp;gt;                         &amp;quot;cond requires an even number of forms&amp;quot;)))&amp;lt;br&amp;gt;            (cons 'clojure.core/cond (next (next clauses))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cond</a>[& clauses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;cond-&gt;&lt;/b&gt; ([expr &amp; clauses])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Takes an expression and a set of test/form pairs. Threads expr (via -&gt;)&lt;br&gt;  through each form for which the corresponding test&lt;br&gt;  expression is true. Note that, unlike cond branching, cond-&gt; threading does&lt;br&gt;  not short circuit after the first true test expression.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro cond-&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;Takes an expression and a set of test/form pairs. Threads expr (via -&amp;gt;)&amp;lt;br&amp;gt;  through each form for which the corresponding test&amp;lt;br&amp;gt;  expression is true. Note that, unlike cond branching, cond-&amp;gt; threading does&amp;lt;br&amp;gt;  not short circuit after the first true test expression.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [expr &amp;amp; clauses]&amp;lt;br&amp;gt;  (assert (even? (count clauses)))&amp;lt;br&amp;gt;  (let [g (gensym)&amp;lt;br&amp;gt;        pstep (fn [[test step]] `(if ~test (-&amp;gt; ~g ~step) ~g))]&amp;lt;br&amp;gt;    `(let [~g ~expr&amp;lt;br&amp;gt;           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]&amp;lt;br&amp;gt;       ~g)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cond-></a>[expr & clauses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;cond-&gt;&gt;&lt;/b&gt; ([expr &amp; clauses])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Takes an expression and a set of test/form pairs. Threads expr (via -&gt;&gt;)&lt;br&gt;  through each form for which the corresponding test expression&lt;br&gt;  is true.  Note that, unlike cond branching, cond-&gt;&gt; threading does not short circuit&lt;br&gt;  after the first true test expression.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro cond-&amp;gt;&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;Takes an expression and a set of test/form pairs. Threads expr (via -&amp;gt;&amp;gt;)&amp;lt;br&amp;gt;  through each form for which the corresponding test expression&amp;lt;br&amp;gt;  is true.  Note that, unlike cond branching, cond-&amp;gt;&amp;gt; threading does not short circuit&amp;lt;br&amp;gt;  after the first true test expression.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [expr &amp;amp; clauses]&amp;lt;br&amp;gt;  (assert (even? (count clauses)))&amp;lt;br&amp;gt;  (let [g (gensym)&amp;lt;br&amp;gt;        pstep (fn [[test step]] `(if ~test (-&amp;gt;&amp;gt; ~g ~step) ~g))]&amp;lt;br&amp;gt;    `(let [~g ~expr&amp;lt;br&amp;gt;           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]&amp;lt;br&amp;gt;       ~g)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cond->></a>[expr & clauses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;condp&lt;/b&gt; ([pred expr &amp; clauses])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Takes a binary predicate, an expression, and a set of clauses.&lt;br&gt;  Each clause can take the form of either:&lt;br&gt;&lt;br&gt;  test-expr result-expr&lt;br&gt;&lt;br&gt;  test-expr :&gt;&gt; result-fn&lt;br&gt;&lt;br&gt;  Note :&gt;&gt; is an ordinary keyword.&lt;br&gt;&lt;br&gt;  For each clause, (pred test-expr expr) is evaluated. If it returns&lt;br&gt;  logical true, the clause is a match. If a binary clause matches, the&lt;br&gt;  result-expr is returned, if a ternary clause matches, its result-fn,&lt;br&gt;  which must be a unary function, is called with the result of the&lt;br&gt;  predicate as its argument, the result of that call being the return&lt;br&gt;  value of condp. A single default expression can follow the clauses,&lt;br&gt;  and its value will be returned if no clause matches. If no default&lt;br&gt;  expression is provided and no clause matches, an&lt;br&gt;  IllegalArgumentException is thrown.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro condp&amp;lt;br&amp;gt;  &amp;quot;Takes a binary predicate, an expression, and a set of clauses.&amp;lt;br&amp;gt;  Each clause can take the form of either:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  test-expr result-expr&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  test-expr :&amp;gt;&amp;gt; result-fn&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Note :&amp;gt;&amp;gt; is an ordinary keyword.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  For each clause, (pred test-expr expr) is evaluated. If it returns&amp;lt;br&amp;gt;  logical true, the clause is a match. If a binary clause matches, the&amp;lt;br&amp;gt;  result-expr is returned, if a ternary clause matches, its result-fn,&amp;lt;br&amp;gt;  which must be a unary function, is called with the result of the&amp;lt;br&amp;gt;  predicate as its argument, the result of that call being the return&amp;lt;br&amp;gt;  value of condp. A single default expression can follow the clauses,&amp;lt;br&amp;gt;  and its value will be returned if no clause matches. If no default&amp;lt;br&amp;gt;  expression is provided and no clause matches, an&amp;lt;br&amp;gt;  IllegalArgumentException is thrown.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  [pred expr &amp;amp; clauses]&amp;lt;br&amp;gt;  (let [gpred (gensym &amp;quot;pred__&amp;quot;)&amp;lt;br&amp;gt;        gexpr (gensym &amp;quot;expr__&amp;quot;)&amp;lt;br&amp;gt;        emit (fn emit [pred expr args]&amp;lt;br&amp;gt;               (let [[[a b c :as clause] more]&amp;lt;br&amp;gt;                       (split-at (if (= :&amp;gt;&amp;gt; (second args)) 3 2) args)&amp;lt;br&amp;gt;                       n (count clause)]&amp;lt;br&amp;gt;                 (cond&amp;lt;br&amp;gt;                  (= 0 n) `(throw (IllegalArgumentException. (str &amp;quot;No matching clause: &amp;quot; ~expr)))&amp;lt;br&amp;gt;                  (= 1 n) a&amp;lt;br&amp;gt;                  (= 2 n) `(if (~pred ~a ~expr)&amp;lt;br&amp;gt;                             ~b&amp;lt;br&amp;gt;                             ~(emit pred expr more))&amp;lt;br&amp;gt;                  :else `(if-let [p# (~pred ~a ~expr)]&amp;lt;br&amp;gt;                           (~c p#)&amp;lt;br&amp;gt;                           ~(emit pred expr more)))))&amp;lt;br&amp;gt;        gres (gensym &amp;quot;res__&amp;quot;)]&amp;lt;br&amp;gt;    `(let [~gpred ~pred&amp;lt;br&amp;gt;           ~gexpr ~expr]&amp;lt;br&amp;gt;       ~(emit gpred gexpr clauses))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">condp</a>[pred expr & clauses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;conj&lt;/b&gt; ([coll x] [coll x &amp; xs])&lt;br&gt; conj[oin]. Returns a new collection with the xs&lt;br&gt;    'added'. (conj nil item) returns (item).  The 'addition' may&lt;br&gt;    happen at different 'places' depending on the concrete type.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([coll x] [coll x &amp;amp; xs])&amp;lt;br&amp;gt;   :doc &amp;quot;conj[oin]. Returns a new collection with the xs&amp;lt;br&amp;gt;    'added'. (conj nil item) returns (item).  The 'addition' may&amp;lt;br&amp;gt;    happen at different 'places' depending on the concrete type.&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; conj (fn ^:static conj &amp;lt;br&amp;gt;        ([coll x] (. clojure.lang.RT (conj coll x)))&amp;lt;br&amp;gt;        ([coll x &amp;amp; xs]&amp;lt;br&amp;gt;         (if xs&amp;lt;br&amp;gt;           (recur (conj coll x) (first xs) (next xs))&amp;lt;br&amp;gt;           (conj coll x)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">conj</a>[coll x] [coll x & xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;conj!&lt;/b&gt; ([coll x])&lt;br&gt; Alpha - subject to change.&lt;br&gt;  Adds x to the transient collection, and return coll. The 'addition'&lt;br&gt;  may happen at different 'places' depending on the concrete type.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn conj!&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;  Adds x to the transient collection, and return coll. The 'addition'&amp;lt;br&amp;gt;  may happen at different 'places' depending on the concrete type.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.ITransientCollection coll x]&amp;lt;br&amp;gt;  (.conj coll x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">conj!</a>[coll x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;cons&lt;/b&gt; ([x seq])&lt;br&gt; Returns a new seq where x is the first element and seq is&lt;br&gt;    the rest.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([x seq])&amp;lt;br&amp;gt;    :doc &amp;quot;Returns a new seq where x is the first element and seq is&amp;lt;br&amp;gt;    the rest.&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; cons (fn* ^:static cons [x seq] (. clojure.lang.RT (cons x seq))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cons</a>[x seq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;constantly&lt;/b&gt; ([x])&lt;br&gt; Returns a function that takes any number of arguments and returns x.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn constantly&amp;lt;br&amp;gt;  &amp;quot;Returns a function that takes any number of arguments and returns x.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (fn [&amp;amp; args] x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">constantly</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;construct-proxy&lt;/b&gt; ([c &amp; ctor-args])&lt;br&gt; Takes a proxy class and any arguments for its superclass ctor and&lt;br&gt;  creates and returns an instance of the proxy.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn construct-proxy&amp;lt;br&amp;gt;  &amp;quot;Takes a proxy class and any arguments for its superclass ctor and&amp;lt;br&amp;gt;  creates and returns an instance of the proxy.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [c &amp;amp; ctor-args]&amp;lt;br&amp;gt;    (. Reflector (invokeConstructor c (to-array ctor-args))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">construct-proxy</a>[c & ctor-args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;contains?&lt;/b&gt; ([coll key])&lt;br&gt; Returns true if key is present in the given collection, otherwise&lt;br&gt;  returns false.  Note that for numerically indexed collections like&lt;br&gt;  vectors and Java arrays, this tests if the numeric key is within the&lt;br&gt;  range of indexes. 'contains?' operates constant or logarithmic time;&lt;br&gt;  it will not perform a linear search for a value.  See also 'some'.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn contains?&amp;lt;br&amp;gt;  &amp;quot;Returns true if key is present in the given collection, otherwise&amp;lt;br&amp;gt;  returns false.  Note that for numerically indexed collections like&amp;lt;br&amp;gt;  vectors and Java arrays, this tests if the numeric key is within the&amp;lt;br&amp;gt;  range of indexes. 'contains?' operates constant or logarithmic time;&amp;lt;br&amp;gt;  it will not perform a linear search for a value.  See also 'some'.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll key] (. clojure.lang.RT (contains coll key)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">contains?</a>[coll key]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;count&lt;/b&gt; ([coll])&lt;br&gt; Returns the number of items in the collection. (count nil) returns&lt;br&gt;  0.  Also works on strings, arrays, and Java Collections and Maps&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn count&amp;lt;br&amp;gt;  &amp;quot;Returns the number of items in the collection. (count nil) returns&amp;lt;br&amp;gt;  0.  Also works on strings, arrays, and Java Collections and Maps&amp;quot;&amp;lt;br&amp;gt;  {&amp;lt;br&amp;gt;   :inline (fn  [x] `(. clojure.lang.RT (count ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [coll] (clojure.lang.RT/count coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">count</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;counted?&lt;/b&gt; ([coll])&lt;br&gt; Returns true if coll implements count in constant time&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn counted?&amp;lt;br&amp;gt; &amp;quot;Returns true if coll implements count in constant time&amp;quot;&amp;lt;br&amp;gt; {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll] (instance? clojure.lang.Counted coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">counted?</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;create-ns&lt;/b&gt; ([sym])&lt;br&gt; Create a new namespace named by the symbol if one doesn't already&lt;br&gt;  exist, returns it or the already-existing namespace of the same&lt;br&gt;  name.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn create-ns&amp;lt;br&amp;gt;  &amp;quot;Create a new namespace named by the symbol if one doesn't already&amp;lt;br&amp;gt;  exist, returns it or the already-existing namespace of the same&amp;lt;br&amp;gt;  name.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [sym] (clojure.lang.Namespace/findOrCreate sym))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">create-ns</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;create-struct&lt;/b&gt; ([&amp; keys])&lt;br&gt; Returns a structure basis object.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn create-struct&amp;lt;br&amp;gt;  &amp;quot;Returns a structure basis object.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; keys]&amp;lt;br&amp;gt;    (. clojure.lang.PersistentStructMap (createSlotMap keys)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">create-struct</a>[& keys]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;cycle&lt;/b&gt; ([coll])&lt;br&gt; Returns a lazy (infinite!) sequence of repetitions of the items in coll.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cycle&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy (infinite!) sequence of repetitions of the items in coll.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll] (lazy-seq &amp;lt;br&amp;gt;          (when-let [s (seq coll)] &amp;lt;br&amp;gt;              (concat s (cycle s)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cycle</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;dec&lt;/b&gt; ([x])&lt;br&gt; Returns a number one less than num. Does not auto-promote&lt;br&gt;  longs, will throw on overflow. See also: dec'&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dec&amp;lt;br&amp;gt;  &amp;quot;Returns a number one less than num. Does not auto-promote&amp;lt;br&amp;gt;  longs, will throw on overflow. See also: dec'&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x] `(. clojure.lang.Numbers (~(if *unchecked-math* 'unchecked_dec 'dec) ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (dec x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dec</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;dec'&lt;/b&gt; ([x])&lt;br&gt; Returns a number one less than num. Supports arbitrary precision.&lt;br&gt;  See also: dec&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dec'&amp;lt;br&amp;gt;  &amp;quot;Returns a number one less than num. Supports arbitrary precision.&amp;lt;br&amp;gt;  See also: dec&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x] `(. clojure.lang.Numbers (decP ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (decP x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dec'</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;decimal?&lt;/b&gt; ([n])&lt;br&gt; Returns true if n is a BigDecimal&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn decimal?&amp;lt;br&amp;gt;  &amp;quot;Returns true if n is a BigDecimal&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [n] (instance? BigDecimal n))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">decimal?</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;declare&lt;/b&gt; ([&amp; names])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; defs the supplied var names with no bindings, useful for making forward declarations.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro declare&amp;lt;br&amp;gt;  &amp;quot;defs the supplied var names with no bindings, useful for making forward declarations.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare</a>[& names]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;definline&lt;/b&gt; ([name &amp; decl])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Experimental - like defmacro, except defines a named function whose&lt;br&gt;  body is the expansion, calls to which may be expanded inline as if&lt;br&gt;  it were a macro. Cannot be used with variadic (&amp;) args.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro definline&amp;lt;br&amp;gt;  &amp;quot;Experimental - like defmacro, except defines a named function whose&amp;lt;br&amp;gt;  body is the expansion, calls to which may be expanded inline as if&amp;lt;br&amp;gt;  it were a macro. Cannot be used with variadic (&amp;amp;) args.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [name &amp;amp; decl]&amp;lt;br&amp;gt;  (let [[pre-args [args expr]] (split-with (comp not vector?) decl)]&amp;lt;br&amp;gt;    `(do&amp;lt;br&amp;gt;       (defn ~name ~@pre-args ~args ~(apply (eval (list `fn args expr)) args))&amp;lt;br&amp;gt;       (alter-meta! (var ~name) assoc :inline (fn ~name ~args ~expr))&amp;lt;br&amp;gt;       (var ~name))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">definline</a>[name & decl]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;definterface&lt;/b&gt; ([name &amp; sigs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Creates a new Java interface with the given name and method sigs.&lt;br&gt;  The method return types and parameter types may be specified with type hints,&lt;br&gt;  defaulting to Object if omitted.&lt;br&gt;&lt;br&gt;  (definterface MyInterface&lt;br&gt;    (^int method1 [x])&lt;br&gt;    (^Bar method2 [^Baz b ^Quux q]))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro definterface&amp;lt;br&amp;gt;  &amp;quot;Creates a new Java interface with the given name and method sigs.&amp;lt;br&amp;gt;  The method return types and parameter types may be specified with type hints,&amp;lt;br&amp;gt;  defaulting to Object if omitted.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (definterface MyInterface&amp;lt;br&amp;gt;    (^int method1 [x])&amp;lt;br&amp;gt;    (^Bar method2 [^Baz b ^Quux q]))&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;} ;; Present since 1.2, but made public in 1.5.&amp;lt;br&amp;gt;  [name &amp;amp; sigs]&amp;lt;br&amp;gt;  (let [tag (fn [x] (or (:tag (meta x)) Object))&amp;lt;br&amp;gt;        psig (fn [[name [&amp;amp; args]]]&amp;lt;br&amp;gt;               (vector name (vec (map tag args)) (tag name) (map meta args)))&amp;lt;br&amp;gt;        cname (with-meta (symbol (str (namespace-munge *ns*) &amp;quot;.&amp;quot; name)) (meta name))]&amp;lt;br&amp;gt;    `(let [] &amp;lt;br&amp;gt;       (gen-interface :name ~cname :methods ~(vec (map psig sigs)))&amp;lt;br&amp;gt;       (import ~cname))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">definterface</a>[name & sigs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;defmacro&lt;/b&gt; ([name doc-string? attr-map? [params*] body] [name doc-string? attr-map? ([params*] body) + attr-map?])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Like defn, but the resulting function name is declared as a&lt;br&gt;  macro and will be used as a macro by the compiler when it is&lt;br&gt;  called.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; ^{:doc &amp;quot;Like defn, but the resulting function name is declared as a&amp;lt;br&amp;gt;  macro and will be used as a macro by the compiler when it is&amp;lt;br&amp;gt;  called.&amp;quot;&amp;lt;br&amp;gt;   :arglists '([name doc-string? attr-map? [params*] body]&amp;lt;br&amp;gt;                 [name doc-string? attr-map? ([params*] body)+ attr-map?])&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt; defmacro (fn [&amp;amp;form &amp;amp;env &amp;lt;br&amp;gt;                name &amp;amp; args]&amp;lt;br&amp;gt;             (let [prefix (loop [p (list name) args args]&amp;lt;br&amp;gt;                            (let [f (first args)]&amp;lt;br&amp;gt;                              (if (string? f)&amp;lt;br&amp;gt;                                (recur (cons f p) (next args))&amp;lt;br&amp;gt;                                (if (map? f)&amp;lt;br&amp;gt;                                  (recur (cons f p) (next args))&amp;lt;br&amp;gt;                                  p))))&amp;lt;br&amp;gt;                   fdecl (loop [fd args]&amp;lt;br&amp;gt;                           (if (string? (first fd))&amp;lt;br&amp;gt;                             (recur (next fd))&amp;lt;br&amp;gt;                             (if (map? (first fd))&amp;lt;br&amp;gt;                               (recur (next fd))&amp;lt;br&amp;gt;                               fd)))&amp;lt;br&amp;gt;                   fdecl (if (vector? (first fdecl))&amp;lt;br&amp;gt;                           (list fdecl)&amp;lt;br&amp;gt;                           fdecl)&amp;lt;br&amp;gt;                   add-implicit-args (fn [fd]&amp;lt;br&amp;gt;                             (let [args (first fd)]&amp;lt;br&amp;gt;                               (cons (vec (cons '&amp;amp;form (cons '&amp;amp;env args))) (next fd))))&amp;lt;br&amp;gt;                   add-args (fn [acc ds]&amp;lt;br&amp;gt;                              (if (nil? ds)&amp;lt;br&amp;gt;                                acc&amp;lt;br&amp;gt;                                (let [d (first ds)]&amp;lt;br&amp;gt;                                  (if (map? d)&amp;lt;br&amp;gt;                                    (conj acc d)&amp;lt;br&amp;gt;                                    (recur (conj acc (add-implicit-args d)) (next ds))))))&amp;lt;br&amp;gt;                   fdecl (seq (add-args [] fdecl))&amp;lt;br&amp;gt;                   decl (loop [p prefix d fdecl]&amp;lt;br&amp;gt;                          (if p&amp;lt;br&amp;gt;                            (recur (next p) (cons (first p) d))&amp;lt;br&amp;gt;                            d))]&amp;lt;br&amp;gt;               (list 'do&amp;lt;br&amp;gt;                     (cons `defn decl)&amp;lt;br&amp;gt;                     (list '. (list 'var name) '(setMacro))&amp;lt;br&amp;gt;                     (list 'var name)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defmacro</a>[name doc-string? attr-map? [params*] body] [name doc-string? attr-map? ([params*] body) + attr-map?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;defmethod&lt;/b&gt; ([multifn dispatch-val &amp; fn-tail])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Creates and installs a new method of multimethod associated with dispatch-value. &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defmethod&amp;lt;br&amp;gt;  &amp;quot;Creates and installs a new method of multimethod associated with dispatch-value. &amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [multifn dispatch-val &amp;amp; fn-tail]&amp;lt;br&amp;gt;  `(. ~(with-meta multifn {:tag 'clojure.lang.MultiFn}) addMethod ~dispatch-val (fn ~@fn-tail)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defmethod</a>[multifn dispatch-val & fn-tail]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;defmulti&lt;/b&gt; ([name docstring? attr-map? dispatch-fn &amp; options])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Creates a new multimethod with the associated dispatch function.&lt;br&gt;  The docstring and attribute-map are optional.&lt;br&gt;&lt;br&gt;  Options are key-value pairs and may be one of:&lt;br&gt;    :default    the default dispatch value, defaults to :default&lt;br&gt;    :hierarchy  the isa? hierarchy to use for dispatching&lt;br&gt;                defaults to the global hierarchy&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defmulti&amp;lt;br&amp;gt;  &amp;quot;Creates a new multimethod with the associated dispatch function.&amp;lt;br&amp;gt;  The docstring and attribute-map are optional.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Options are key-value pairs and may be one of:&amp;lt;br&amp;gt;    :default    the default dispatch value, defaults to :default&amp;lt;br&amp;gt;    :hierarchy  the isa? hierarchy to use for dispatching&amp;lt;br&amp;gt;                defaults to the global hierarchy&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([name docstring? attr-map? dispatch-fn &amp;amp; options])&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [mm-name &amp;amp; options]&amp;lt;br&amp;gt;  (let [docstring   (if (string? (first options))&amp;lt;br&amp;gt;                      (first options)&amp;lt;br&amp;gt;                      nil)&amp;lt;br&amp;gt;        options     (if (string? (first options))&amp;lt;br&amp;gt;                      (next options)&amp;lt;br&amp;gt;                      options)&amp;lt;br&amp;gt;        m           (if (map? (first options))&amp;lt;br&amp;gt;                      (first options)&amp;lt;br&amp;gt;                      {})&amp;lt;br&amp;gt;        options     (if (map? (first options))&amp;lt;br&amp;gt;                      (next options)&amp;lt;br&amp;gt;                      options)&amp;lt;br&amp;gt;        dispatch-fn (first options)&amp;lt;br&amp;gt;        options     (next options)&amp;lt;br&amp;gt;        m           (if docstring&amp;lt;br&amp;gt;                      (assoc m :doc docstring)&amp;lt;br&amp;gt;                      m)&amp;lt;br&amp;gt;        m           (if (meta mm-name)&amp;lt;br&amp;gt;                      (conj (meta mm-name) m)&amp;lt;br&amp;gt;                      m)]&amp;lt;br&amp;gt;    (when (= (count options) 1)&amp;lt;br&amp;gt;      (throw (Exception. &amp;quot;The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)&amp;quot;)))&amp;lt;br&amp;gt;    (let [options   (apply hash-map options)&amp;lt;br&amp;gt;          default   (get options :default :default)&amp;lt;br&amp;gt;          hierarchy (get options :hierarchy #'global-hierarchy)]&amp;lt;br&amp;gt;      (check-valid-options options :default :hierarchy)&amp;lt;br&amp;gt;      `(let [v# (def ~mm-name)]&amp;lt;br&amp;gt;         (when-not (and (.hasRoot v#) (instance? clojure.lang.MultiFn (deref v#)))&amp;lt;br&amp;gt;           (def ~(with-meta mm-name m)&amp;lt;br&amp;gt;                (new clojure.lang.MultiFn ~(name mm-name) ~dispatch-fn ~default ~hierarchy)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defmulti</a>[name docstring? attr-map? dispatch-fn & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;defn&lt;/b&gt; ([name doc-string? attr-map? [params*] prepost-map? body] [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Same as (def name (fn [params* ] exprs*)) or (def&lt;br&gt;    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added&lt;br&gt;    to the var metadata. prepost-map defines a map with optional keys&lt;br&gt;    :pre and :post that contain collections of pre or post conditions.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def &amp;lt;br&amp;gt;&amp;lt;br&amp;gt; ^{:doc &amp;quot;Same as (def name (fn [params* ] exprs*)) or (def&amp;lt;br&amp;gt;    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added&amp;lt;br&amp;gt;    to the var metadata. prepost-map defines a map with optional keys&amp;lt;br&amp;gt;    :pre and :post that contain collections of pre or post conditions.&amp;quot;&amp;lt;br&amp;gt;   :arglists '([name doc-string? attr-map? [params*] prepost-map? body]&amp;lt;br&amp;gt;                [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt; defn (fn defn [&amp;amp;form &amp;amp;env name &amp;amp; fdecl]&amp;lt;br&amp;gt;        ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)&amp;lt;br&amp;gt;        (if (instance? clojure.lang.Symbol name)&amp;lt;br&amp;gt;          nil&amp;lt;br&amp;gt;          (throw (IllegalArgumentException. &amp;quot;First argument to defn must be a symbol&amp;quot;)))&amp;lt;br&amp;gt;        (let [m (if (string? (first fdecl))&amp;lt;br&amp;gt;                  {:doc (first fdecl)}&amp;lt;br&amp;gt;                  {})&amp;lt;br&amp;gt;              fdecl (if (string? (first fdecl))&amp;lt;br&amp;gt;                      (next fdecl)&amp;lt;br&amp;gt;                      fdecl)&amp;lt;br&amp;gt;              m (if (map? (first fdecl))&amp;lt;br&amp;gt;                  (conj m (first fdecl))&amp;lt;br&amp;gt;                  m)&amp;lt;br&amp;gt;              fdecl (if (map? (first fdecl))&amp;lt;br&amp;gt;                      (next fdecl)&amp;lt;br&amp;gt;                      fdecl)&amp;lt;br&amp;gt;              fdecl (if (vector? (first fdecl))&amp;lt;br&amp;gt;                      (list fdecl)&amp;lt;br&amp;gt;                      fdecl)&amp;lt;br&amp;gt;              m (if (map? (last fdecl))&amp;lt;br&amp;gt;                  (conj m (last fdecl))&amp;lt;br&amp;gt;                  m)&amp;lt;br&amp;gt;              fdecl (if (map? (last fdecl))&amp;lt;br&amp;gt;                      (butlast fdecl)&amp;lt;br&amp;gt;                      fdecl)&amp;lt;br&amp;gt;              m (conj {:arglists (list 'quote (sigs fdecl))} m)&amp;lt;br&amp;gt;              m (let [inline (:inline m)&amp;lt;br&amp;gt;                      ifn (first inline)&amp;lt;br&amp;gt;                      iname (second inline)]&amp;lt;br&amp;gt;                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)&amp;lt;br&amp;gt;                  (if (if (clojure.lang.Util/equiv 'fn ifn)&amp;lt;br&amp;gt;                        (if (instance? clojure.lang.Symbol iname) false true))&amp;lt;br&amp;gt;                    ;; inserts the same fn name to the inline fn if it does not have one&amp;lt;br&amp;gt;                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) &amp;quot;__inliner&amp;quot;))&amp;lt;br&amp;gt;                                                     (next inline))))&amp;lt;br&amp;gt;                    m))&amp;lt;br&amp;gt;              m (conj (if (meta name) (meta name) {}) m)]&amp;lt;br&amp;gt;          (list 'def (with-meta name m)&amp;lt;br&amp;gt;                ;;todo - restore propagation of fn name&amp;lt;br&amp;gt;                ;;must figure out how to convey primitive hints to self calls first&amp;lt;br&amp;gt;                (cons `fn fdecl) ))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defn</a>[name doc-string? attr-map? [params*] prepost-map? body] [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;defn-&lt;/b&gt; ([name &amp; decls])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; same as defn, yielding non-public def&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defn-&amp;lt;br&amp;gt;  &amp;quot;same as defn, yielding non-public def&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [name &amp;amp; decls]&amp;lt;br&amp;gt;    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defn-</a>[name & decls]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;defonce&lt;/b&gt; ([name expr])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; defs name to have the root value of the expr iff the named var has no root value,&lt;br&gt;  else expr is unevaluated&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defonce&amp;lt;br&amp;gt;  &amp;quot;defs name to have the root value of the expr iff the named var has no root value,&amp;lt;br&amp;gt;  else expr is unevaluated&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [name expr]&amp;lt;br&amp;gt;  `(let [v# (def ~name)]&amp;lt;br&amp;gt;     (when-not (.hasRoot v#)&amp;lt;br&amp;gt;       (def ~name ~expr))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defonce</a>[name expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;defprotocol&lt;/b&gt; ([name &amp; opts+sigs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; A protocol is a named set of named methods and their signatures:&lt;br&gt;  (defprotocol AProtocolName&lt;br&gt;&lt;br&gt;    ;optional doc string&lt;br&gt;    &quot;A doc string for AProtocol abstraction&quot;&lt;br&gt;&lt;br&gt;  ;method signatures&lt;br&gt;    (bar [this a b] &quot;bar docs&quot;)&lt;br&gt;    (baz [this a] [this a b] [this a b c] &quot;baz docs&quot;))&lt;br&gt;&lt;br&gt;  No implementations are provided. Docs can be specified for the&lt;br&gt;  protocol overall and for each method. The above yields a set of&lt;br&gt;  polymorphic functions and a protocol object. All are&lt;br&gt;  namespace-qualified by the ns enclosing the definition The resulting&lt;br&gt;  functions dispatch on the type of their first argument, which is&lt;br&gt;  required and corresponds to the implicit target object ('this' in &lt;br&gt;  Java parlance). defprotocol is dynamic, has no special compile-time &lt;br&gt;  effect, and defines no new types or classes. Implementations of &lt;br&gt;  the protocol methods can be provided using extend.&lt;br&gt;&lt;br&gt;  defprotocol will automatically generate a corresponding interface,&lt;br&gt;  with the same name as the protocol, i.e. given a protocol:&lt;br&gt;  my.ns/Protocol, an interface: my.ns.Protocol. The interface will&lt;br&gt;  have methods corresponding to the protocol functions, and the&lt;br&gt;  protocol will automatically work with instances of the interface.&lt;br&gt;&lt;br&gt;  Note that you should not use this interface with deftype or&lt;br&gt;  reify, as they support the protocol directly:&lt;br&gt;&lt;br&gt;  (defprotocol P &lt;br&gt;    (foo [this]) &lt;br&gt;    (bar-me [this] [this y]))&lt;br&gt;&lt;br&gt;  (deftype Foo [a b c] &lt;br&gt;   P&lt;br&gt;    (foo [this] a)&lt;br&gt;    (bar-me [this] b)&lt;br&gt;    (bar-me [this y] (+ c y)))&lt;br&gt;  &lt;br&gt;  (bar-me (Foo. 1 2 3) 42)&lt;br&gt;  =&gt; 45&lt;br&gt;&lt;br&gt;  (foo &lt;br&gt;    (let [x 42]&lt;br&gt;      (reify P &lt;br&gt;        (foo [this] 17)&lt;br&gt;        (bar-me [this] x)&lt;br&gt;        (bar-me [this y] x))))&lt;br&gt;  =&gt; 17&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defprotocol &amp;lt;br&amp;gt;  &amp;quot;A protocol is a named set of named methods and their signatures:&amp;lt;br&amp;gt;  (defprotocol AProtocolName&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    ;optional doc string&amp;lt;br&amp;gt;    \&amp;quot;A doc string for AProtocol abstraction\&amp;quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  ;method signatures&amp;lt;br&amp;gt;    (bar [this a b] \&amp;quot;bar docs\&amp;quot;)&amp;lt;br&amp;gt;    (baz [this a] [this a b] [this a b c] \&amp;quot;baz docs\&amp;quot;))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  No implementations are provided. Docs can be specified for the&amp;lt;br&amp;gt;  protocol overall and for each method. The above yields a set of&amp;lt;br&amp;gt;  polymorphic functions and a protocol object. All are&amp;lt;br&amp;gt;  namespace-qualified by the ns enclosing the definition The resulting&amp;lt;br&amp;gt;  functions dispatch on the type of their first argument, which is&amp;lt;br&amp;gt;  required and corresponds to the implicit target object ('this' in &amp;lt;br&amp;gt;  Java parlance). defprotocol is dynamic, has no special compile-time &amp;lt;br&amp;gt;  effect, and defines no new types or classes. Implementations of &amp;lt;br&amp;gt;  the protocol methods can be provided using extend.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  defprotocol will automatically generate a corresponding interface,&amp;lt;br&amp;gt;  with the same name as the protocol, i.e. given a protocol:&amp;lt;br&amp;gt;  my.ns/Protocol, an interface: my.ns.Protocol. The interface will&amp;lt;br&amp;gt;  have methods corresponding to the protocol functions, and the&amp;lt;br&amp;gt;  protocol will automatically work with instances of the interface.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Note that you should not use this interface with deftype or&amp;lt;br&amp;gt;  reify, as they support the protocol directly:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (defprotocol P &amp;lt;br&amp;gt;    (foo [this]) &amp;lt;br&amp;gt;    (bar-me [this] [this y]))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (deftype Foo [a b c] &amp;lt;br&amp;gt;   P&amp;lt;br&amp;gt;    (foo [this] a)&amp;lt;br&amp;gt;    (bar-me [this] b)&amp;lt;br&amp;gt;    (bar-me [this y] (+ c y)))&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  (bar-me (Foo. 1 2 3) 42)&amp;lt;br&amp;gt;  =&amp;gt; 45&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (foo &amp;lt;br&amp;gt;    (let [x 42]&amp;lt;br&amp;gt;      (reify P &amp;lt;br&amp;gt;        (foo [this] 17)&amp;lt;br&amp;gt;        (bar-me [this] x)&amp;lt;br&amp;gt;        (bar-me [this y] x))))&amp;lt;br&amp;gt;  =&amp;gt; 17&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;} &amp;lt;br&amp;gt;  [name &amp;amp; opts+sigs]&amp;lt;br&amp;gt;  (emit-protocol name opts+sigs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defprotocol</a>[name & opts+sigs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;defrecord&lt;/b&gt; ([name [&amp; fields] &amp; opts+specs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Alpha - subject to change&lt;br&gt;  &lt;br&gt;  (defrecord name [fields*]  options* specs*)&lt;br&gt;  &lt;br&gt;  Currently there are no options.&lt;br&gt;&lt;br&gt;  Each spec consists of a protocol or interface name followed by zero&lt;br&gt;  or more method bodies:&lt;br&gt;&lt;br&gt;  protocol-or-interface-or-Object&lt;br&gt;  (methodName [args*] body)*&lt;br&gt;&lt;br&gt;  Dynamically generates compiled bytecode for class with the given&lt;br&gt;  name, in a package with the same name as the current namespace, the&lt;br&gt;  given fields, and, optionally, methods for protocols and/or&lt;br&gt;  interfaces.&lt;br&gt;&lt;br&gt;  The class will have the (immutable) fields named by&lt;br&gt;  fields, which can have type hints. Protocols/interfaces and methods&lt;br&gt;  are optional. The only methods that can be supplied are those&lt;br&gt;  declared in the protocols/interfaces.  Note that method bodies are&lt;br&gt;  not closures, the local environment includes only the named fields,&lt;br&gt;  and those fields can be accessed directy.&lt;br&gt;&lt;br&gt;  Method definitions take the form:&lt;br&gt;&lt;br&gt;  (methodname [args*] body)&lt;br&gt;&lt;br&gt;  The argument and return types can be hinted on the arg and&lt;br&gt;  methodname symbols. If not supplied, they will be inferred, so type&lt;br&gt;  hints should be reserved for disambiguation.&lt;br&gt;&lt;br&gt;  Methods should be supplied for all methods of the desired&lt;br&gt;  protocol(s) and interface(s). You can also define overrides for&lt;br&gt;  methods of Object. Note that a parameter must be supplied to&lt;br&gt;  correspond to the target object ('this' in Java parlance). Thus&lt;br&gt;  methods for interfaces will take one more argument than do the&lt;br&gt;  interface declarations. Note also that recur calls to the method&lt;br&gt;  head should *not* pass the target object, it will be supplied&lt;br&gt;  automatically and can not be substituted.&lt;br&gt;&lt;br&gt;  In the method bodies, the (unqualified) name can be used to name the&lt;br&gt;  class (for calls to new, instance? etc).&lt;br&gt;&lt;br&gt;  The class will have implementations of several (clojure.lang)&lt;br&gt;  interfaces generated automatically: IObj (metadata support) and&lt;br&gt;  IPersistentMap, and all of their superinterfaces.&lt;br&gt;&lt;br&gt;  In addition, defrecord will define type-and-value-based =,&lt;br&gt;  and will defined Java .hashCode and .equals consistent with the&lt;br&gt;  contract for java.util.Map.&lt;br&gt;&lt;br&gt;  When AOT compiling, generates compiled bytecode for a class with the&lt;br&gt;  given name (a symbol), prepends the current ns as the package, and&lt;br&gt;  writes the .class file to the *compile-path* directory.&lt;br&gt;&lt;br&gt;  Two constructors will be defined, one taking the designated fields&lt;br&gt;  followed by a metadata map (nil for none) and an extension field&lt;br&gt;  map (nil for none), and one taking only the fields (using nil for&lt;br&gt;  meta and extension fields). Note that the field names __meta&lt;br&gt;  and __extmap are currently reserved and should not be used when&lt;br&gt;  defining your own records.&lt;br&gt;&lt;br&gt;  Given (defrecord TypeName ...), two factory functions will be&lt;br&gt;  defined: -&gt;TypeName, taking positional parameters for the fields,&lt;br&gt;  and map-&gt;TypeName, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defrecord&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  (defrecord name [fields*]  options* specs*)&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  Currently there are no options.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Each spec consists of a protocol or interface name followed by zero&amp;lt;br&amp;gt;  or more method bodies:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  protocol-or-interface-or-Object&amp;lt;br&amp;gt;  (methodName [args*] body)*&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Dynamically generates compiled bytecode for class with the given&amp;lt;br&amp;gt;  name, in a package with the same name as the current namespace, the&amp;lt;br&amp;gt;  given fields, and, optionally, methods for protocols and/or&amp;lt;br&amp;gt;  interfaces.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The class will have the (immutable) fields named by&amp;lt;br&amp;gt;  fields, which can have type hints. Protocols/interfaces and methods&amp;lt;br&amp;gt;  are optional. The only methods that can be supplied are those&amp;lt;br&amp;gt;  declared in the protocols/interfaces.  Note that method bodies are&amp;lt;br&amp;gt;  not closures, the local environment includes only the named fields,&amp;lt;br&amp;gt;  and those fields can be accessed directy.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Method definitions take the form:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (methodname [args*] body)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The argument and return types can be hinted on the arg and&amp;lt;br&amp;gt;  methodname symbols. If not supplied, they will be inferred, so type&amp;lt;br&amp;gt;  hints should be reserved for disambiguation.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Methods should be supplied for all methods of the desired&amp;lt;br&amp;gt;  protocol(s) and interface(s). You can also define overrides for&amp;lt;br&amp;gt;  methods of Object. Note that a parameter must be supplied to&amp;lt;br&amp;gt;  correspond to the target object ('this' in Java parlance). Thus&amp;lt;br&amp;gt;  methods for interfaces will take one more argument than do the&amp;lt;br&amp;gt;  interface declarations. Note also that recur calls to the method&amp;lt;br&amp;gt;  head should *not* pass the target object, it will be supplied&amp;lt;br&amp;gt;  automatically and can not be substituted.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  In the method bodies, the (unqualified) name can be used to name the&amp;lt;br&amp;gt;  class (for calls to new, instance? etc).&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The class will have implementations of several (clojure.lang)&amp;lt;br&amp;gt;  interfaces generated automatically: IObj (metadata support) and&amp;lt;br&amp;gt;  IPersistentMap, and all of their superinterfaces.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  In addition, defrecord will define type-and-value-based =,&amp;lt;br&amp;gt;  and will defined Java .hashCode and .equals consistent with the&amp;lt;br&amp;gt;  contract for java.util.Map.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  When AOT compiling, generates compiled bytecode for a class with the&amp;lt;br&amp;gt;  given name (a symbol), prepends the current ns as the package, and&amp;lt;br&amp;gt;  writes the .class file to the *compile-path* directory.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Two constructors will be defined, one taking the designated fields&amp;lt;br&amp;gt;  followed by a metadata map (nil for none) and an extension field&amp;lt;br&amp;gt;  map (nil for none), and one taking only the fields (using nil for&amp;lt;br&amp;gt;  meta and extension fields). Note that the field names __meta&amp;lt;br&amp;gt;  and __extmap are currently reserved and should not be used when&amp;lt;br&amp;gt;  defining your own records.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Given (defrecord TypeName ...), two factory functions will be&amp;lt;br&amp;gt;  defined: -&amp;gt;TypeName, taking positional parameters for the fields,&amp;lt;br&amp;gt;  and map-&amp;gt;TypeName, taking a map of keywords to field values.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :arglists '([name [&amp;amp; fields] &amp;amp; opts+specs])}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  [name fields &amp;amp; opts+specs]&amp;lt;br&amp;gt;  (validate-fields fields)&amp;lt;br&amp;gt;  (let [gname name&amp;lt;br&amp;gt;        [interfaces methods opts] (parse-opts+specs opts+specs)&amp;lt;br&amp;gt;        ns-part (namespace-munge *ns*)&amp;lt;br&amp;gt;        classname (symbol (str ns-part &amp;quot;.&amp;quot; gname))&amp;lt;br&amp;gt;        hinted-fields fields&amp;lt;br&amp;gt;        fields (vec (map #(with-meta % nil) fields))]&amp;lt;br&amp;gt;    `(let []&amp;lt;br&amp;gt;       (declare ~(symbol (str  '-&amp;gt; gname)))&amp;lt;br&amp;gt;       (declare ~(symbol (str 'map-&amp;gt; gname)))&amp;lt;br&amp;gt;       ~(emit-defrecord name gname (vec hinted-fields) (vec interfaces) methods)&amp;lt;br&amp;gt;       (import ~classname)&amp;lt;br&amp;gt;       ~(build-positional-factory gname classname fields)&amp;lt;br&amp;gt;       (defn ~(symbol (str 'map-&amp;gt; gname))&amp;lt;br&amp;gt;         ~(str &amp;quot;Factory function for class &amp;quot; classname &amp;quot;, taking a map of keywords to field values.&amp;quot;)&amp;lt;br&amp;gt;         ([m#] (~(symbol (str classname &amp;quot;/create&amp;quot;)) m#)))&amp;lt;br&amp;gt;       ~classname)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defrecord</a>[name [& fields] & opts+specs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;defstruct&lt;/b&gt; ([name &amp; keys])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Same as (def name (create-struct keys...))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defstruct&amp;lt;br&amp;gt;  &amp;quot;Same as (def name (create-struct keys...))&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [name &amp;amp; keys]&amp;lt;br&amp;gt;  `(def ~name (create-struct ~@keys)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defstruct</a>[name & keys]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;deftype&lt;/b&gt; ([name [&amp; fields] &amp; opts+specs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Alpha - subject to change&lt;br&gt;  &lt;br&gt;  (deftype name [fields*]  options* specs*)&lt;br&gt;  &lt;br&gt;  Currently there are no options.&lt;br&gt;&lt;br&gt;  Each spec consists of a protocol or interface name followed by zero&lt;br&gt;  or more method bodies:&lt;br&gt;&lt;br&gt;  protocol-or-interface-or-Object&lt;br&gt;  (methodName [args*] body)*&lt;br&gt;&lt;br&gt;  Dynamically generates compiled bytecode for class with the given&lt;br&gt;  name, in a package with the same name as the current namespace, the&lt;br&gt;  given fields, and, optionally, methods for protocols and/or&lt;br&gt;  interfaces. &lt;br&gt;&lt;br&gt;  The class will have the (by default, immutable) fields named by&lt;br&gt;  fields, which can have type hints. Protocols/interfaces and methods&lt;br&gt;  are optional. The only methods that can be supplied are those&lt;br&gt;  declared in the protocols/interfaces.  Note that method bodies are&lt;br&gt;  not closures, the local environment includes only the named fields,&lt;br&gt;  and those fields can be accessed directy. Fields can be qualified&lt;br&gt;  with the metadata :volatile-mutable true or :unsynchronized-mutable&lt;br&gt;  true, at which point (set! afield aval) will be supported in method&lt;br&gt;  bodies. Note well that mutable fields are extremely difficult to use&lt;br&gt;  correctly, and are present only to facilitate the building of higher&lt;br&gt;  level constructs, such as Clojure's reference types, in Clojure&lt;br&gt;  itself. They are for experts only - if the semantics and&lt;br&gt;  implications of :volatile-mutable or :unsynchronized-mutable are not&lt;br&gt;  immediately apparent to you, you should not be using them.&lt;br&gt;&lt;br&gt;  Method definitions take the form:&lt;br&gt;&lt;br&gt;  (methodname [args*] body)&lt;br&gt;&lt;br&gt;  The argument and return types can be hinted on the arg and&lt;br&gt;  methodname symbols. If not supplied, they will be inferred, so type&lt;br&gt;  hints should be reserved for disambiguation.&lt;br&gt;&lt;br&gt;  Methods should be supplied for all methods of the desired&lt;br&gt;  protocol(s) and interface(s). You can also define overrides for&lt;br&gt;  methods of Object. Note that a parameter must be supplied to&lt;br&gt;  correspond to the target object ('this' in Java parlance). Thus&lt;br&gt;  methods for interfaces will take one more argument than do the&lt;br&gt;  interface declarations. Note also that recur calls to the method&lt;br&gt;  head should *not* pass the target object, it will be supplied&lt;br&gt;  automatically and can not be substituted.&lt;br&gt;&lt;br&gt;  In the method bodies, the (unqualified) name can be used to name the&lt;br&gt;  class (for calls to new, instance? etc).&lt;br&gt;&lt;br&gt;  When AOT compiling, generates compiled bytecode for a class with the&lt;br&gt;  given name (a symbol), prepends the current ns as the package, and&lt;br&gt;  writes the .class file to the *compile-path* directory.&lt;br&gt;&lt;br&gt;  One constructor will be defined, taking the designated fields.  Note&lt;br&gt;  that the field names __meta and __extmap are currently reserved and&lt;br&gt;  should not be used when defining your own types.&lt;br&gt;&lt;br&gt;  Given (deftype TypeName ...), a factory function called -&gt;TypeName&lt;br&gt;  will be defined, taking positional parameters for the fields&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro deftype&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  (deftype name [fields*]  options* specs*)&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  Currently there are no options.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Each spec consists of a protocol or interface name followed by zero&amp;lt;br&amp;gt;  or more method bodies:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  protocol-or-interface-or-Object&amp;lt;br&amp;gt;  (methodName [args*] body)*&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Dynamically generates compiled bytecode for class with the given&amp;lt;br&amp;gt;  name, in a package with the same name as the current namespace, the&amp;lt;br&amp;gt;  given fields, and, optionally, methods for protocols and/or&amp;lt;br&amp;gt;  interfaces. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The class will have the (by default, immutable) fields named by&amp;lt;br&amp;gt;  fields, which can have type hints. Protocols/interfaces and methods&amp;lt;br&amp;gt;  are optional. The only methods that can be supplied are those&amp;lt;br&amp;gt;  declared in the protocols/interfaces.  Note that method bodies are&amp;lt;br&amp;gt;  not closures, the local environment includes only the named fields,&amp;lt;br&amp;gt;  and those fields can be accessed directy. Fields can be qualified&amp;lt;br&amp;gt;  with the metadata :volatile-mutable true or :unsynchronized-mutable&amp;lt;br&amp;gt;  true, at which point (set! afield aval) will be supported in method&amp;lt;br&amp;gt;  bodies. Note well that mutable fields are extremely difficult to use&amp;lt;br&amp;gt;  correctly, and are present only to facilitate the building of higher&amp;lt;br&amp;gt;  level constructs, such as Clojure's reference types, in Clojure&amp;lt;br&amp;gt;  itself. They are for experts only - if the semantics and&amp;lt;br&amp;gt;  implications of :volatile-mutable or :unsynchronized-mutable are not&amp;lt;br&amp;gt;  immediately apparent to you, you should not be using them.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Method definitions take the form:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (methodname [args*] body)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The argument and return types can be hinted on the arg and&amp;lt;br&amp;gt;  methodname symbols. If not supplied, they will be inferred, so type&amp;lt;br&amp;gt;  hints should be reserved for disambiguation.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Methods should be supplied for all methods of the desired&amp;lt;br&amp;gt;  protocol(s) and interface(s). You can also define overrides for&amp;lt;br&amp;gt;  methods of Object. Note that a parameter must be supplied to&amp;lt;br&amp;gt;  correspond to the target object ('this' in Java parlance). Thus&amp;lt;br&amp;gt;  methods for interfaces will take one more argument than do the&amp;lt;br&amp;gt;  interface declarations. Note also that recur calls to the method&amp;lt;br&amp;gt;  head should *not* pass the target object, it will be supplied&amp;lt;br&amp;gt;  automatically and can not be substituted.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  In the method bodies, the (unqualified) name can be used to name the&amp;lt;br&amp;gt;  class (for calls to new, instance? etc).&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  When AOT compiling, generates compiled bytecode for a class with the&amp;lt;br&amp;gt;  given name (a symbol), prepends the current ns as the package, and&amp;lt;br&amp;gt;  writes the .class file to the *compile-path* directory.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  One constructor will be defined, taking the designated fields.  Note&amp;lt;br&amp;gt;  that the field names __meta and __extmap are currently reserved and&amp;lt;br&amp;gt;  should not be used when defining your own types.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Given (deftype TypeName ...), a factory function called -&amp;gt;TypeName&amp;lt;br&amp;gt;  will be defined, taking positional parameters for the fields&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :arglists '([name [&amp;amp; fields] &amp;amp; opts+specs])}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  [name fields &amp;amp; opts+specs]&amp;lt;br&amp;gt;  (validate-fields fields)&amp;lt;br&amp;gt;  (let [gname name&amp;lt;br&amp;gt;        [interfaces methods opts] (parse-opts+specs opts+specs)&amp;lt;br&amp;gt;        ns-part (namespace-munge *ns*)&amp;lt;br&amp;gt;        classname (symbol (str ns-part &amp;quot;.&amp;quot; gname))&amp;lt;br&amp;gt;        hinted-fields fields&amp;lt;br&amp;gt;        fields (vec (map #(with-meta % nil) fields))&amp;lt;br&amp;gt;        [field-args over] (split-at 20 fields)]&amp;lt;br&amp;gt;    `(let []&amp;lt;br&amp;gt;       ~(emit-deftype* name gname (vec hinted-fields) (vec interfaces) methods)&amp;lt;br&amp;gt;       (import ~classname)&amp;lt;br&amp;gt;       ~(build-positional-factory gname classname fields)&amp;lt;br&amp;gt;       ~classname)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">deftype</a>[name [& fields] & opts+specs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;delay&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Takes a body of expressions and yields a Delay object that will&lt;br&gt;  invoke the body only the first time it is forced (with force or deref/@), and&lt;br&gt;  will cache the result and return it on all subsequent force&lt;br&gt;  calls. See also - realized?&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro delay&amp;lt;br&amp;gt;  &amp;quot;Takes a body of expressions and yields a Delay object that will&amp;lt;br&amp;gt;  invoke the body only the first time it is forced (with force or deref/@), and&amp;lt;br&amp;gt;  will cache the result and return it on all subsequent force&amp;lt;br&amp;gt;  calls. See also - realized?&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;    (list 'new 'clojure.lang.Delay (list* `^{:once true} fn* [] body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">delay</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;delay?&lt;/b&gt; ([x])&lt;br&gt; returns true if x is a Delay created with delay&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn delay?&amp;lt;br&amp;gt;  &amp;quot;returns true if x is a Delay created with delay&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (instance? clojure.lang.Delay x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">delay?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;deliver&lt;/b&gt; ([promise val])&lt;br&gt; Alpha - subject to change.&lt;br&gt;  Delivers the supplied value to the promise, releasing any pending&lt;br&gt;  derefs. A subsequent call to deliver on a promise will have no effect.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn deliver&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;  Delivers the supplied value to the promise, releasing any pending&amp;lt;br&amp;gt;  derefs. A subsequent call to deliver on a promise will have no effect.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [promise val] (promise val))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">deliver</a>[promise val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;denominator&lt;/b&gt; ([r])&lt;br&gt; Returns the denominator part of a Ratio.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn denominator&amp;lt;br&amp;gt;  &amp;quot;Returns the denominator part of a Ratio.&amp;quot;&amp;lt;br&amp;gt;  {:tag BigInteger&amp;lt;br&amp;gt;   :added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [r]&amp;lt;br&amp;gt;  (.denominator ^clojure.lang.Ratio r))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">denominator</a>[r]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;deref&lt;/b&gt; ([ref] [ref timeout-ms timeout-val])&lt;br&gt; Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,&lt;br&gt;  returns the in-transaction-value of ref, else returns the&lt;br&gt;  most-recently-committed value of ref. When applied to a var, agent&lt;br&gt;  or atom, returns its current state. When applied to a delay, forces&lt;br&gt;  it if not already forced. When applied to a future, will block if&lt;br&gt;  computation not complete. When applied to a promise, will block&lt;br&gt;  until a value is delivered.  The variant taking a timeout can be&lt;br&gt;  used for blocking references (futures and promises), and will return&lt;br&gt;  timeout-val if the timeout (in milliseconds) is reached before a&lt;br&gt;  value is available. See also - realized?.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn deref&amp;lt;br&amp;gt;  &amp;quot;Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,&amp;lt;br&amp;gt;  returns the in-transaction-value of ref, else returns the&amp;lt;br&amp;gt;  most-recently-committed value of ref. When applied to a var, agent&amp;lt;br&amp;gt;  or atom, returns its current state. When applied to a delay, forces&amp;lt;br&amp;gt;  it if not already forced. When applied to a future, will block if&amp;lt;br&amp;gt;  computation not complete. When applied to a promise, will block&amp;lt;br&amp;gt;  until a value is delivered.  The variant taking a timeout can be&amp;lt;br&amp;gt;  used for blocking references (futures and promises), and will return&amp;lt;br&amp;gt;  timeout-val if the timeout (in milliseconds) is reached before a&amp;lt;br&amp;gt;  value is available. See also - realized?.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([ref] (if (instance? clojure.lang.IDeref ref)&amp;lt;br&amp;gt;           (.deref ^clojure.lang.IDeref ref)&amp;lt;br&amp;gt;           (deref-future ref)))&amp;lt;br&amp;gt;  ([ref timeout-ms timeout-val]&amp;lt;br&amp;gt;     (if (instance? clojure.lang.IBlockingDeref ref)&amp;lt;br&amp;gt;       (.deref ^clojure.lang.IBlockingDeref ref timeout-ms timeout-val)&amp;lt;br&amp;gt;       (deref-future ref timeout-ms timeout-val))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">deref</a>[ref] [ref timeout-ms timeout-val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;derive&lt;/b&gt; ([tag parent] [h tag parent])&lt;br&gt; Establishes a parent/child relationship between parent and&lt;br&gt;  tag. Parent must be a namespace-qualified symbol or keyword and&lt;br&gt;  child can be either a namespace-qualified symbol or keyword or a&lt;br&gt;  class. h must be a hierarchy obtained from make-hierarchy, if not&lt;br&gt;  supplied defaults to, and modifies, the global hierarchy.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn derive&amp;lt;br&amp;gt;  &amp;quot;Establishes a parent/child relationship between parent and&amp;lt;br&amp;gt;  tag. Parent must be a namespace-qualified symbol or keyword and&amp;lt;br&amp;gt;  child can be either a namespace-qualified symbol or keyword or a&amp;lt;br&amp;gt;  class. h must be a hierarchy obtained from make-hierarchy, if not&amp;lt;br&amp;gt;  supplied defaults to, and modifies, the global hierarchy.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([tag parent]&amp;lt;br&amp;gt;   (assert (namespace parent))&amp;lt;br&amp;gt;   (assert (or (class? tag) (and (instance? clojure.lang.Named tag) (namespace tag))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   (alter-var-root #'global-hierarchy derive tag parent) nil)&amp;lt;br&amp;gt;  ([h tag parent]&amp;lt;br&amp;gt;   (assert (not= tag parent))&amp;lt;br&amp;gt;   (assert (or (class? tag) (instance? clojure.lang.Named tag)))&amp;lt;br&amp;gt;   (assert (instance? clojure.lang.Named parent))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   (let [tp (:parents h)&amp;lt;br&amp;gt;         td (:descendants h)&amp;lt;br&amp;gt;         ta (:ancestors h)&amp;lt;br&amp;gt;         tf (fn [m source sources target targets]&amp;lt;br&amp;gt;              (reduce1 (fn [ret k]&amp;lt;br&amp;gt;                        (assoc ret k&amp;lt;br&amp;gt;                               (reduce1 conj (get targets k #{}) (cons target (targets target)))))&amp;lt;br&amp;gt;                      m (cons source (sources source))))]&amp;lt;br&amp;gt;     (or&amp;lt;br&amp;gt;      (when-not (contains? (tp tag) parent)&amp;lt;br&amp;gt;        (when (contains? (ta tag) parent)&amp;lt;br&amp;gt;          (throw (Exception. (print-str tag &amp;quot;already has&amp;quot; parent &amp;quot;as ancestor&amp;quot;))))&amp;lt;br&amp;gt;        (when (contains? (ta parent) tag)&amp;lt;br&amp;gt;          (throw (Exception. (print-str &amp;quot;Cyclic derivation:&amp;quot; parent &amp;quot;has&amp;quot; tag &amp;quot;as ancestor&amp;quot;))))&amp;lt;br&amp;gt;        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))&amp;lt;br&amp;gt;         :ancestors (tf (:ancestors h) tag td parent ta)&amp;lt;br&amp;gt;         :descendants (tf (:descendants h) parent ta tag td)})&amp;lt;br&amp;gt;      h))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">derive</a>[tag parent] [h tag parent]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;descendants&lt;/b&gt; ([tag] [h tag])&lt;br&gt; Returns the immediate and indirect children of tag, through a&lt;br&gt;  relationship established via derive. h must be a hierarchy obtained&lt;br&gt;  from make-hierarchy, if not supplied defaults to the global&lt;br&gt;  hierarchy. Note: does not work on Java type inheritance&lt;br&gt;  relationships.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn descendants&amp;lt;br&amp;gt;  &amp;quot;Returns the immediate and indirect children of tag, through a&amp;lt;br&amp;gt;  relationship established via derive. h must be a hierarchy obtained&amp;lt;br&amp;gt;  from make-hierarchy, if not supplied defaults to the global&amp;lt;br&amp;gt;  hierarchy. Note: does not work on Java type inheritance&amp;lt;br&amp;gt;  relationships.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([tag] (descendants global-hierarchy tag))&amp;lt;br&amp;gt;  ([h tag] (if (class? tag)&amp;lt;br&amp;gt;             (throw (java.lang.UnsupportedOperationException. &amp;quot;Can't get descendants of classes&amp;quot;))&amp;lt;br&amp;gt;             (not-empty (get (:descendants h) tag)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">descendants</a>[tag] [h tag]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;destructure&lt;/b&gt; ([bindings])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn destructure [bindings]&amp;lt;br&amp;gt;  (let [bents (partition 2 bindings)&amp;lt;br&amp;gt;        pb (fn pb [bvec b v]&amp;lt;br&amp;gt;               (let [pvec&amp;lt;br&amp;gt;                     (fn [bvec b val]&amp;lt;br&amp;gt;                       (let [gvec (gensym &amp;quot;vec__&amp;quot;)]&amp;lt;br&amp;gt;                         (loop [ret (-&amp;gt; bvec (conj gvec) (conj val))&amp;lt;br&amp;gt;                                n 0&amp;lt;br&amp;gt;                                bs b&amp;lt;br&amp;gt;                                seen-rest? false]&amp;lt;br&amp;gt;                           (if (seq bs)&amp;lt;br&amp;gt;                             (let [firstb (first bs)]&amp;lt;br&amp;gt;                               (cond&amp;lt;br&amp;gt;                                (= firstb '&amp;amp;) (recur (pb ret (second bs) (list `nthnext gvec n))&amp;lt;br&amp;gt;                                                     n&amp;lt;br&amp;gt;                                                     (nnext bs)&amp;lt;br&amp;gt;                                                     true)&amp;lt;br&amp;gt;                                (= firstb :as) (pb ret (second bs) gvec)&amp;lt;br&amp;gt;                                :else (if seen-rest?&amp;lt;br&amp;gt;                                        (throw (new Exception &amp;quot;Unsupported binding form, only :as can follow &amp;amp; parameter&amp;quot;))&amp;lt;br&amp;gt;                                        (recur (pb ret firstb  (list `nth gvec n nil))&amp;lt;br&amp;gt;                                               (inc n)&amp;lt;br&amp;gt;                                               (next bs)&amp;lt;br&amp;gt;                                               seen-rest?))))&amp;lt;br&amp;gt;                             ret))))&amp;lt;br&amp;gt;                     pmap&amp;lt;br&amp;gt;                     (fn [bvec b v]&amp;lt;br&amp;gt;                       (let [gmap (gensym &amp;quot;map__&amp;quot;)&amp;lt;br&amp;gt;                             gmapseq (with-meta gmap {:tag 'clojure.lang.ISeq})&amp;lt;br&amp;gt;                             defaults (:or b)]&amp;lt;br&amp;gt;                         (loop [ret (-&amp;gt; bvec (conj gmap) (conj v)&amp;lt;br&amp;gt;                                        (conj gmap) (conj `(if (seq? ~gmap) (clojure.lang.PersistentHashMap/create (seq ~gmapseq)) ~gmap))&amp;lt;br&amp;gt;                                        ((fn [ret]&amp;lt;br&amp;gt;                                           (if (:as b)&amp;lt;br&amp;gt;                                             (conj ret (:as b) gmap)&amp;lt;br&amp;gt;                                             ret))))&amp;lt;br&amp;gt;                                bes (reduce1&amp;lt;br&amp;gt;                                     (fn [bes entry]&amp;lt;br&amp;gt;                                       (reduce1 #(assoc %1 %2 ((val entry) %2))&amp;lt;br&amp;gt;                                               (dissoc bes (key entry))&amp;lt;br&amp;gt;                                               ((key entry) bes)))&amp;lt;br&amp;gt;                                     (dissoc b :as :or)&amp;lt;br&amp;gt;                                     {:keys #(keyword (str %)), :strs str, :syms #(list `quote %)})]&amp;lt;br&amp;gt;                           (if (seq bes)&amp;lt;br&amp;gt;                             (let [bb (key (first bes))&amp;lt;br&amp;gt;                                   bk (val (first bes))&amp;lt;br&amp;gt;                                   has-default (contains? defaults bb)]&amp;lt;br&amp;gt;                               (recur (pb ret bb (if has-default&amp;lt;br&amp;gt;                                                   (list `get gmap bk (defaults bb))&amp;lt;br&amp;gt;                                                   (list `get gmap bk)))&amp;lt;br&amp;gt;                                      (next bes)))&amp;lt;br&amp;gt;                             ret))))]&amp;lt;br&amp;gt;                 (cond&amp;lt;br&amp;gt;                  (symbol? b) (-&amp;gt; bvec (conj b) (conj v))&amp;lt;br&amp;gt;                  (vector? b) (pvec bvec b v)&amp;lt;br&amp;gt;                  (map? b) (pmap bvec b v)&amp;lt;br&amp;gt;                  :else (throw (new Exception (str &amp;quot;Unsupported binding form: &amp;quot; b))))))&amp;lt;br&amp;gt;        process-entry (fn [bvec b] (pb bvec (first b) (second b)))]&amp;lt;br&amp;gt;    (if (every? symbol? (map first bents))&amp;lt;br&amp;gt;      bindings&amp;lt;br&amp;gt;      (reduce1 process-entry [] bents))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">destructure</a>[bindings]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;disj&lt;/b&gt; ([set] [set key] [set key &amp; ks])&lt;br&gt; disj[oin]. Returns a new set of the same (hashed/sorted) type, that&lt;br&gt;  does not contain key(s).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn disj&amp;lt;br&amp;gt;  &amp;quot;disj[oin]. Returns a new set of the same (hashed/sorted) type, that&amp;lt;br&amp;gt;  does not contain key(s).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([set] set)&amp;lt;br&amp;gt;  ([^clojure.lang.IPersistentSet set key]&amp;lt;br&amp;gt;   (when set&amp;lt;br&amp;gt;     (. set (disjoin key))))&amp;lt;br&amp;gt;  ([set key &amp;amp; ks]&amp;lt;br&amp;gt;   (when set&amp;lt;br&amp;gt;     (let [ret (disj set key)]&amp;lt;br&amp;gt;       (if ks&amp;lt;br&amp;gt;         (recur ret (first ks) (next ks))&amp;lt;br&amp;gt;         ret)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">disj</a>[set] [set key] [set key & ks]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;disj!&lt;/b&gt; ([set] [set key] [set key &amp; ks])&lt;br&gt; Alpha - subject to change.&lt;br&gt;  disj[oin]. Returns a transient set of the same (hashed/sorted) type, that&lt;br&gt;  does not contain key(s).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn disj!&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;  disj[oin]. Returns a transient set of the same (hashed/sorted) type, that&amp;lt;br&amp;gt;  does not contain key(s).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([set] set)&amp;lt;br&amp;gt;  ([^clojure.lang.ITransientSet set key]&amp;lt;br&amp;gt;   (. set (disjoin key)))&amp;lt;br&amp;gt;  ([^clojure.lang.ITransientSet set key &amp;amp; ks]&amp;lt;br&amp;gt;   (let [ret (. set (disjoin key))]&amp;lt;br&amp;gt;     (if ks&amp;lt;br&amp;gt;       (recur ret (first ks) (next ks))&amp;lt;br&amp;gt;       ret))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">disj!</a>[set] [set key] [set key & ks]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;dissoc&lt;/b&gt; ([map] [map key] [map key &amp; ks])&lt;br&gt; dissoc[iate]. Returns a new map of the same (hashed/sorted) type,&lt;br&gt;  that does not contain a mapping for key(s).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dissoc&amp;lt;br&amp;gt;  &amp;quot;dissoc[iate]. Returns a new map of the same (hashed/sorted) type,&amp;lt;br&amp;gt;  that does not contain a mapping for key(s).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([map] map)&amp;lt;br&amp;gt;  ([map key]&amp;lt;br&amp;gt;   (. clojure.lang.RT (dissoc map key)))&amp;lt;br&amp;gt;  ([map key &amp;amp; ks]&amp;lt;br&amp;gt;   (let [ret (dissoc map key)]&amp;lt;br&amp;gt;     (if ks&amp;lt;br&amp;gt;       (recur ret (first ks) (next ks))&amp;lt;br&amp;gt;       ret))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dissoc</a>[map] [map key] [map key & ks]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;dissoc!&lt;/b&gt; ([map key] [map key &amp; ks])&lt;br&gt; Alpha - subject to change.&lt;br&gt;  Returns a transient map that doesn't contain a mapping for key(s).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dissoc!&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;  Returns a transient map that doesn't contain a mapping for key(s).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([^clojure.lang.ITransientMap map key] (.without map key))&amp;lt;br&amp;gt;  ([^clojure.lang.ITransientMap map key &amp;amp; ks]&amp;lt;br&amp;gt;   (let [ret (.without map key)]&amp;lt;br&amp;gt;     (if ks&amp;lt;br&amp;gt;       (recur ret (first ks) (next ks))&amp;lt;br&amp;gt;       ret))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dissoc!</a>[map key] [map key & ks]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;distinct&lt;/b&gt; ([coll])&lt;br&gt; Returns a lazy sequence of the elements of coll with duplicates removed&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn distinct&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of the elements of coll with duplicates removed&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;    (let [step (fn step [xs seen]&amp;lt;br&amp;gt;                   (lazy-seq&amp;lt;br&amp;gt;                    ((fn [[f :as xs] seen]&amp;lt;br&amp;gt;                      (when-let [s (seq xs)]&amp;lt;br&amp;gt;                        (if (contains? seen f) &amp;lt;br&amp;gt;                          (recur (rest s) seen)&amp;lt;br&amp;gt;                          (cons f (step (rest s) (conj seen f))))))&amp;lt;br&amp;gt;                     xs seen)))]&amp;lt;br&amp;gt;      (step coll #{})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">distinct</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;distinct?&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; Returns true if no two of the arguments are =&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn distinct?&amp;lt;br&amp;gt;  &amp;quot;Returns true if no two of the arguments are =&amp;quot;&amp;lt;br&amp;gt;  {:tag Boolean&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([x] true)&amp;lt;br&amp;gt;  ([x y] (not (= x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (if (not= x y)&amp;lt;br&amp;gt;     (loop [s #{x y} [x &amp;amp; etc :as xs] more]&amp;lt;br&amp;gt;       (if xs&amp;lt;br&amp;gt;         (if (contains? s x)&amp;lt;br&amp;gt;           false&amp;lt;br&amp;gt;           (recur (conj s x) etc))&amp;lt;br&amp;gt;         true))&amp;lt;br&amp;gt;     false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">distinct?</a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;doall&lt;/b&gt; ([coll] [n coll])&lt;br&gt; When lazy sequences are produced via functions that have side&lt;br&gt;  effects, any effects other than those needed to produce the first&lt;br&gt;  element in the seq do not occur until the seq is consumed. doall can&lt;br&gt;  be used to force any effects. Walks through the successive nexts of&lt;br&gt;  the seq, retains the head and returns it, thus causing the entire&lt;br&gt;  seq to reside in memory at one time.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn doall&amp;lt;br&amp;gt;  &amp;quot;When lazy sequences are produced via functions that have side&amp;lt;br&amp;gt;  effects, any effects other than those needed to produce the first&amp;lt;br&amp;gt;  element in the seq do not occur until the seq is consumed. doall can&amp;lt;br&amp;gt;  be used to force any effects. Walks through the successive nexts of&amp;lt;br&amp;gt;  the seq, retains the head and returns it, thus causing the entire&amp;lt;br&amp;gt;  seq to reside in memory at one time.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([coll]&amp;lt;br&amp;gt;   (dorun coll)&amp;lt;br&amp;gt;   coll)&amp;lt;br&amp;gt;  ([n coll]&amp;lt;br&amp;gt;   (dorun n coll)&amp;lt;br&amp;gt;   coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">doall</a>[coll] [n coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;dorun&lt;/b&gt; ([coll] [n coll])&lt;br&gt; When lazy sequences are produced via functions that have side&lt;br&gt;  effects, any effects other than those needed to produce the first&lt;br&gt;  element in the seq do not occur until the seq is consumed. dorun can&lt;br&gt;  be used to force any effects. Walks through the successive nexts of&lt;br&gt;  the seq, does not retain the head and returns nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dorun&amp;lt;br&amp;gt;  &amp;quot;When lazy sequences are produced via functions that have side&amp;lt;br&amp;gt;  effects, any effects other than those needed to produce the first&amp;lt;br&amp;gt;  element in the seq do not occur until the seq is consumed. dorun can&amp;lt;br&amp;gt;  be used to force any effects. Walks through the successive nexts of&amp;lt;br&amp;gt;  the seq, does not retain the head and returns nil.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([coll]&amp;lt;br&amp;gt;   (when (seq coll)&amp;lt;br&amp;gt;     (recur (next coll))))&amp;lt;br&amp;gt;  ([n coll]&amp;lt;br&amp;gt;   (when (and (seq coll) (pos? n))&amp;lt;br&amp;gt;     (recur (dec n) (next coll)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dorun</a>[coll] [n coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;doseq&lt;/b&gt; ([seq-exprs &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Repeatedly executes body (presumably for side-effects) with&lt;br&gt;  bindings and filtering as provided by &quot;for&quot;.  Does not retain&lt;br&gt;  the head of the sequence. Returns nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro doseq&amp;lt;br&amp;gt;  &amp;quot;Repeatedly executes body (presumably for side-effects) with&amp;lt;br&amp;gt;  bindings and filtering as provided by \&amp;quot;for\&amp;quot;.  Does not retain&amp;lt;br&amp;gt;  the head of the sequence. Returns nil.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [seq-exprs &amp;amp; body]&amp;lt;br&amp;gt;  (assert-args&amp;lt;br&amp;gt;     (vector? seq-exprs) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;     (even? (count seq-exprs)) &amp;quot;an even number of forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;  (let [step (fn step [recform exprs]&amp;lt;br&amp;gt;               (if-not exprs&amp;lt;br&amp;gt;                 [true `(do ~@body)]&amp;lt;br&amp;gt;                 (let [k (first exprs)&amp;lt;br&amp;gt;                       v (second exprs)]&amp;lt;br&amp;gt;                   (if (keyword? k)&amp;lt;br&amp;gt;                     (let [steppair (step recform (nnext exprs))&amp;lt;br&amp;gt;                           needrec (steppair 0)&amp;lt;br&amp;gt;                           subform (steppair 1)]&amp;lt;br&amp;gt;                       (cond&amp;lt;br&amp;gt;                         (= k :let) [needrec `(let ~v ~subform)]&amp;lt;br&amp;gt;                         (= k :while) [false `(when ~v&amp;lt;br&amp;gt;                                                ~subform&amp;lt;br&amp;gt;                                                ~@(when needrec [recform]))]&amp;lt;br&amp;gt;                         (= k :when) [false `(if ~v&amp;lt;br&amp;gt;                                               (do&amp;lt;br&amp;gt;                                                 ~subform&amp;lt;br&amp;gt;                                                 ~@(when needrec [recform]))&amp;lt;br&amp;gt;                                               ~recform)]))&amp;lt;br&amp;gt;                     (let [seq- (gensym &amp;quot;seq_&amp;quot;)&amp;lt;br&amp;gt;                           chunk- (with-meta (gensym &amp;quot;chunk_&amp;quot;)&amp;lt;br&amp;gt;                                             {:tag 'clojure.lang.IChunk})&amp;lt;br&amp;gt;                           count- (gensym &amp;quot;count_&amp;quot;)&amp;lt;br&amp;gt;                           i- (gensym &amp;quot;i_&amp;quot;)&amp;lt;br&amp;gt;                           recform `(recur (next ~seq-) nil 0 0)&amp;lt;br&amp;gt;                           steppair (step recform (nnext exprs))&amp;lt;br&amp;gt;                           needrec (steppair 0)&amp;lt;br&amp;gt;                           subform (steppair 1)&amp;lt;br&amp;gt;                           recform-chunk &amp;lt;br&amp;gt;                             `(recur ~seq- ~chunk- ~count- (unchecked-inc ~i-))&amp;lt;br&amp;gt;                           steppair-chunk (step recform-chunk (nnext exprs))&amp;lt;br&amp;gt;                           subform-chunk (steppair-chunk 1)]&amp;lt;br&amp;gt;                       [true&amp;lt;br&amp;gt;                        `(loop [~seq- (seq ~v), ~chunk- nil,&amp;lt;br&amp;gt;                                ~count- 0, ~i- 0]&amp;lt;br&amp;gt;                           (if (&amp;lt; ~i- ~count-)&amp;lt;br&amp;gt;                             (let [~k (.nth ~chunk- ~i-)]&amp;lt;br&amp;gt;                               ~subform-chunk&amp;lt;br&amp;gt;                               ~@(when needrec [recform-chunk]))&amp;lt;br&amp;gt;                             (when-let [~seq- (seq ~seq-)]&amp;lt;br&amp;gt;                               (if (chunked-seq? ~seq-)&amp;lt;br&amp;gt;                                 (let [c# (chunk-first ~seq-)]&amp;lt;br&amp;gt;                                   (recur (chunk-rest ~seq-) c#&amp;lt;br&amp;gt;                                          (int (count c#)) (int 0)))&amp;lt;br&amp;gt;                                 (let [~k (first ~seq-)]&amp;lt;br&amp;gt;                                   ~subform&amp;lt;br&amp;gt;                                   ~@(when needrec [recform]))))))])))))]&amp;lt;br&amp;gt;    (nth (step nil (seq seq-exprs)) 1)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">doseq</a>[seq-exprs & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;dosync&lt;/b&gt; ([&amp; exprs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Runs the exprs (in an implicit do) in a transaction that encompasses&lt;br&gt;  exprs and any nested calls.  Starts a transaction if none is already&lt;br&gt;  running on this thread. Any uncaught exception will abort the&lt;br&gt;  transaction and flow out of dosync. The exprs may be run more than&lt;br&gt;  once, but any effects on Refs will be atomic.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro dosync&amp;lt;br&amp;gt;  &amp;quot;Runs the exprs (in an implicit do) in a transaction that encompasses&amp;lt;br&amp;gt;  exprs and any nested calls.  Starts a transaction if none is already&amp;lt;br&amp;gt;  running on this thread. Any uncaught exception will abort the&amp;lt;br&amp;gt;  transaction and flow out of dosync. The exprs may be run more than&amp;lt;br&amp;gt;  once, but any effects on Refs will be atomic.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; exprs]&amp;lt;br&amp;gt;  `(sync nil ~@exprs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dosync</a>[& exprs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;dotimes&lt;/b&gt; ([bindings &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; bindings =&gt; name n&lt;br&gt;&lt;br&gt;  Repeatedly executes body (presumably for side-effects) with name&lt;br&gt;  bound to integers from 0 through n-1.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro dotimes&amp;lt;br&amp;gt;  &amp;quot;bindings =&amp;gt; name n&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Repeatedly executes body (presumably for side-effects) with name&amp;lt;br&amp;gt;  bound to integers from 0 through n-1.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [bindings &amp;amp; body]&amp;lt;br&amp;gt;  (assert-args&amp;lt;br&amp;gt;     (vector? bindings) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;     (= 2 (count bindings)) &amp;quot;exactly 2 forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;  (let [i (first bindings)&amp;lt;br&amp;gt;        n (second bindings)]&amp;lt;br&amp;gt;    `(let [n# (long ~n)]&amp;lt;br&amp;gt;       (loop [~i 0]&amp;lt;br&amp;gt;         (when (&amp;lt; ~i n#)&amp;lt;br&amp;gt;           ~@body&amp;lt;br&amp;gt;           (recur (unchecked-inc ~i)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dotimes</a>[bindings & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;doto&lt;/b&gt; ([x &amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates x then calls all of the methods and functions with the&lt;br&gt;  value of x supplied at the front of the given arguments.  The forms&lt;br&gt;  are evaluated in order.  Returns x.&lt;br&gt;&lt;br&gt;  (doto (new java.util.HashMap) (.put &quot;a&quot; 1) (.put &quot;b&quot; 2))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro doto&amp;lt;br&amp;gt;  &amp;quot;Evaluates x then calls all of the methods and functions with the&amp;lt;br&amp;gt;  value of x supplied at the front of the given arguments.  The forms&amp;lt;br&amp;gt;  are evaluated in order.  Returns x.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (doto (new java.util.HashMap) (.put \&amp;quot;a\&amp;quot; 1) (.put \&amp;quot;b\&amp;quot; 2))&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x &amp;amp; forms]&amp;lt;br&amp;gt;    (let [gx (gensym)]&amp;lt;br&amp;gt;      `(let [~gx ~x]&amp;lt;br&amp;gt;         ~@(map (fn [f]&amp;lt;br&amp;gt;                  (if (seq? f)&amp;lt;br&amp;gt;                    `(~(first f) ~gx ~@(next f))&amp;lt;br&amp;gt;                    `(~f ~gx)))&amp;lt;br&amp;gt;                forms)&amp;lt;br&amp;gt;         ~gx)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">doto</a>[x & forms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;double&lt;/b&gt; ([x])&lt;br&gt; Coerce to double&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn double&amp;lt;br&amp;gt;  &amp;quot;Coerce to double&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (doubleCast ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [^Number x] (clojure.lang.RT/doubleCast x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">double</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;double-array&lt;/b&gt; ([size-or-seq] [size init-val-or-seq])&lt;br&gt; Creates an array of doubles&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn double-array&amp;lt;br&amp;gt;  &amp;quot;Creates an array of doubles&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [&amp;amp; args] `(. clojure.lang.Numbers double_array ~@args))&amp;lt;br&amp;gt;   :inline-arities #{1 2}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([size-or-seq] (. clojure.lang.Numbers double_array size-or-seq))&amp;lt;br&amp;gt;  ([size init-val-or-seq] (. clojure.lang.Numbers double_array size init-val-or-seq)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">double-array</a>[size-or-seq] [size init-val-or-seq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;doubles&lt;/b&gt; ([xs])&lt;br&gt; Casts to double[]&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(definline doubles&amp;lt;br&amp;gt;  &amp;quot;Casts to double[]&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [xs] `(. clojure.lang.Numbers doubles ~xs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">doubles</a>[xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;drop&lt;/b&gt; ([n coll])&lt;br&gt; Returns a lazy sequence of all but the first n items in coll.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn drop&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of all but the first n items in coll.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [n coll]&amp;lt;br&amp;gt;  (let [step (fn [n coll]&amp;lt;br&amp;gt;               (let [s (seq coll)]&amp;lt;br&amp;gt;                 (if (and (pos? n) s)&amp;lt;br&amp;gt;                   (recur (dec n) (rest s))&amp;lt;br&amp;gt;                   s)))]&amp;lt;br&amp;gt;    (lazy-seq (step n coll))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">drop</a>[n coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;drop-last&lt;/b&gt; ([s] [n s])&lt;br&gt; Return a lazy sequence of all but the last n (default 1) items in coll&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn drop-last&amp;lt;br&amp;gt;  &amp;quot;Return a lazy sequence of all but the last n (default 1) items in coll&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([s] (drop-last 1 s))&amp;lt;br&amp;gt;  ([n s] (map (fn [x _] x) s (drop n s))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">drop-last</a>[s] [n s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;drop-while&lt;/b&gt; ([pred coll])&lt;br&gt; Returns a lazy sequence of the items in coll starting from the first&lt;br&gt;  item for which (pred item) returns logical false.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn drop-while&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of the items in coll starting from the first&amp;lt;br&amp;gt;  item for which (pred item) returns logical false.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [pred coll]&amp;lt;br&amp;gt;  (let [step (fn [pred coll]&amp;lt;br&amp;gt;               (let [s (seq coll)]&amp;lt;br&amp;gt;                 (if (and s (pred (first s)))&amp;lt;br&amp;gt;                   (recur pred (rest s))&amp;lt;br&amp;gt;                   s)))]&amp;lt;br&amp;gt;    (lazy-seq (step pred coll))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">drop-while</a>[pred coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;empty&lt;/b&gt; ([coll])&lt;br&gt; Returns an empty collection of the same category as coll, or nil&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn empty&amp;lt;br&amp;gt;  &amp;quot;Returns an empty collection of the same category as coll, or nil&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;  (when (instance? clojure.lang.IPersistentCollection coll)&amp;lt;br&amp;gt;    (.empty ^clojure.lang.IPersistentCollection coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">empty</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;empty?&lt;/b&gt; ([coll])&lt;br&gt; Returns true if coll has no items - same as (not (seq coll)).&lt;br&gt;  Please use the idiom (seq x) rather than (not (empty? x))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn empty?&amp;lt;br&amp;gt;  &amp;quot;Returns true if coll has no items - same as (not (seq coll)).&amp;lt;br&amp;gt;  Please use the idiom (seq x) rather than (not (empty? x))&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll] (not (seq coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">empty?</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ensure&lt;/b&gt; ([ref])&lt;br&gt; Must be called in a transaction. Protects the ref from modification&lt;br&gt;  by other transactions.  Returns the in-transaction-value of&lt;br&gt;  ref. Allows for more concurrency than (ref-set ref @ref)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ensure&amp;lt;br&amp;gt;  &amp;quot;Must be called in a transaction. Protects the ref from modification&amp;lt;br&amp;gt;  by other transactions.  Returns the in-transaction-value of&amp;lt;br&amp;gt;  ref. Allows for more concurrency than (ref-set ref @ref)&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Ref ref]&amp;lt;br&amp;gt;    (. ref (touch))&amp;lt;br&amp;gt;    (. ref (deref)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ensure</a>[ref]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;enumeration-seq&lt;/b&gt; ([e])&lt;br&gt; Returns a seq on a java.util.Enumeration&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn enumeration-seq&amp;lt;br&amp;gt;  &amp;quot;Returns a seq on a java.util.Enumeration&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [e]&amp;lt;br&amp;gt;  (clojure.lang.EnumerationSeq/create e))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">enumeration-seq</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;error-handler&lt;/b&gt; ([a])&lt;br&gt; Returns the error-handler of agent a, or nil if there is none.&lt;br&gt;  See set-error-handler!&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn error-handler&amp;lt;br&amp;gt;  &amp;quot;Returns the error-handler of agent a, or nil if there is none.&amp;lt;br&amp;gt;  See set-error-handler!&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Agent a]&amp;lt;br&amp;gt;  (.getErrorHandler a))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">error-handler</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;error-mode&lt;/b&gt; ([a])&lt;br&gt; Returns the error-mode of agent a.  See set-error-mode!&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn error-mode&amp;lt;br&amp;gt;  &amp;quot;Returns the error-mode of agent a.  See set-error-mode!&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Agent a]&amp;lt;br&amp;gt;  (.getErrorMode a))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">error-mode</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;eval&lt;/b&gt; ([form])&lt;br&gt; Evaluates the form data structure (not text!) and returns the result.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn eval&amp;lt;br&amp;gt;  &amp;quot;Evaluates the form data structure (not text!) and returns the result.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [form] (. clojure.lang.Compiler (eval form)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">eval</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;even?&lt;/b&gt; ([n])&lt;br&gt; Returns true if n is even, throws an exception if n is not an integer&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn even?&amp;lt;br&amp;gt;  &amp;quot;Returns true if n is even, throws an exception if n is not an integer&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;   [n] (if (integer? n)&amp;lt;br&amp;gt;        (zero? (bit-and (clojure.lang.RT/uncheckedLongCast n) 1))&amp;lt;br&amp;gt;        (throw (IllegalArgumentException. (str &amp;quot;Argument must be an integer: &amp;quot; n)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">even?</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;every-pred&lt;/b&gt; ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 &amp; ps])&lt;br&gt; Takes a set of predicates and returns a function f that returns true if all of its&lt;br&gt;  composing predicates return a logical true value against all of its arguments, else it returns&lt;br&gt;  false. Note that f is short-circuiting in that it will stop execution on the first&lt;br&gt;  argument that triggers a logical false result against the original predicates.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn every-pred&amp;lt;br&amp;gt;  &amp;quot;Takes a set of predicates and returns a function f that returns true if all of its&amp;lt;br&amp;gt;  composing predicates return a logical true value against all of its arguments, else it returns&amp;lt;br&amp;gt;  false. Note that f is short-circuiting in that it will stop execution on the first&amp;lt;br&amp;gt;  argument that triggers a logical false result against the original predicates.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  ([p]&amp;lt;br&amp;gt;     (fn ep1&amp;lt;br&amp;gt;       ([] true)&amp;lt;br&amp;gt;       ([x] (boolean (p x)))&amp;lt;br&amp;gt;       ([x y] (boolean (and (p x) (p y))))&amp;lt;br&amp;gt;       ([x y z] (boolean (and (p x) (p y) (p z))))&amp;lt;br&amp;gt;       ([x y z &amp;amp; args] (boolean (and (ep1 x y z)&amp;lt;br&amp;gt;                                     (every? p args))))))&amp;lt;br&amp;gt;  ([p1 p2]&amp;lt;br&amp;gt;     (fn ep2&amp;lt;br&amp;gt;       ([] true)&amp;lt;br&amp;gt;       ([x] (boolean (and (p1 x) (p2 x))))&amp;lt;br&amp;gt;       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))&amp;lt;br&amp;gt;       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))&amp;lt;br&amp;gt;       ([x y z &amp;amp; args] (boolean (and (ep2 x y z)&amp;lt;br&amp;gt;                                     (every? #(and (p1 %) (p2 %)) args))))))&amp;lt;br&amp;gt;  ([p1 p2 p3]&amp;lt;br&amp;gt;     (fn ep3&amp;lt;br&amp;gt;       ([] true)&amp;lt;br&amp;gt;       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))&amp;lt;br&amp;gt;       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))&amp;lt;br&amp;gt;       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))&amp;lt;br&amp;gt;       ([x y z &amp;amp; args] (boolean (and (ep3 x y z)&amp;lt;br&amp;gt;                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))&amp;lt;br&amp;gt;  ([p1 p2 p3 &amp;amp; ps]&amp;lt;br&amp;gt;     (let [ps (list* p1 p2 p3 ps)]&amp;lt;br&amp;gt;       (fn epn&amp;lt;br&amp;gt;         ([] true)&amp;lt;br&amp;gt;         ([x] (every? #(% x) ps))&amp;lt;br&amp;gt;         ([x y] (every? #(and (% x) (% y)) ps))&amp;lt;br&amp;gt;         ([x y z] (every? #(and (% x) (% y) (% z)) ps))&amp;lt;br&amp;gt;         ([x y z &amp;amp; args] (boolean (and (epn x y z)&amp;lt;br&amp;gt;                                       (every? #(every? % args) ps))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">every-pred</a>[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;every?&lt;/b&gt; ([pred coll])&lt;br&gt; Returns true if (pred x) is logical true for every x in coll, else&lt;br&gt;  false.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn every?&amp;lt;br&amp;gt;  &amp;quot;Returns true if (pred x) is logical true for every x in coll, else&amp;lt;br&amp;gt;  false.&amp;quot;&amp;lt;br&amp;gt;  {:tag Boolean&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [pred coll]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;   (nil? (seq coll)) true&amp;lt;br&amp;gt;   (pred (first coll)) (recur pred (next coll))&amp;lt;br&amp;gt;   :else false))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">every?</a>[pred coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ex-data&lt;/b&gt; ([ex])&lt;br&gt; Alpha - subject to change.&lt;br&gt;   Returns exception data (a map) if ex is an IExceptionInfo.&lt;br&gt;   Otherwise returns nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ex-data&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;   Returns exception data (a map) if ex is an IExceptionInfo.&amp;lt;br&amp;gt;   Otherwise returns nil.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.4&amp;quot;}&amp;lt;br&amp;gt;  [ex]&amp;lt;br&amp;gt;  (when (instance? IExceptionInfo ex)&amp;lt;br&amp;gt;    (.getData ^IExceptionInfo ex)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ex-data</a>[ex]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ex-info&lt;/b&gt; ([msg map] [msg map cause])&lt;br&gt; Alpha - subject to change.&lt;br&gt;   Create an instance of ExceptionInfo, a RuntimeException subclass&lt;br&gt;   that carries a map of additional data.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ex-info&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;   Create an instance of ExceptionInfo, a RuntimeException subclass&amp;lt;br&amp;gt;   that carries a map of additional data.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.4&amp;quot;}&amp;lt;br&amp;gt;  ([msg map]&amp;lt;br&amp;gt;     (ExceptionInfo. msg map))&amp;lt;br&amp;gt;  ([msg map cause]&amp;lt;br&amp;gt;     (ExceptionInfo. msg map cause)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ex-info</a>[msg map] [msg map cause]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;extend&lt;/b&gt; ([atype &amp; proto+mmaps])&lt;br&gt; Implementations of protocol methods can be provided using the extend construct:&lt;br&gt;&lt;br&gt;  (extend AType&lt;br&gt;    AProtocol&lt;br&gt;     {:foo an-existing-fn&lt;br&gt;      :bar (fn [a b] ...)&lt;br&gt;      :baz (fn ([a]...) ([a b] ...)...)}&lt;br&gt;    BProtocol &lt;br&gt;      {...} &lt;br&gt;    ...)&lt;br&gt; &lt;br&gt;  extend takes a type/class (or interface, see below), and one or more&lt;br&gt;  protocol + method map pairs. It will extend the polymorphism of the&lt;br&gt;  protocol's methods to call the supplied methods when an AType is&lt;br&gt;  provided as the first argument. &lt;br&gt;&lt;br&gt;  Method maps are maps of the keyword-ized method names to ordinary&lt;br&gt;  fns. This facilitates easy reuse of existing fns and fn maps, for&lt;br&gt;  code reuse/mixins without derivation or composition. You can extend&lt;br&gt;  an interface to a protocol. This is primarily to facilitate interop&lt;br&gt;  with the host (e.g. Java) but opens the door to incidental multiple&lt;br&gt;  inheritance of implementation since a class can inherit from more&lt;br&gt;  than one interface, both of which extend the protocol. It is TBD how&lt;br&gt;  to specify which impl to use. You can extend a protocol on nil.&lt;br&gt;&lt;br&gt;  If you are supplying the definitions explicitly (i.e. not reusing&lt;br&gt;  exsting functions or mixin maps), you may find it more convenient to&lt;br&gt;  use the extend-type or extend-protocol macros.&lt;br&gt;&lt;br&gt;  Note that multiple independent extend clauses can exist for the same&lt;br&gt;  type, not all protocols need be defined in a single extend call.&lt;br&gt;&lt;br&gt;  See also:&lt;br&gt;  extends?, satisfies?, extenders&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn extend &amp;lt;br&amp;gt;  &amp;quot;Implementations of protocol methods can be provided using the extend construct:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (extend AType&amp;lt;br&amp;gt;    AProtocol&amp;lt;br&amp;gt;     {:foo an-existing-fn&amp;lt;br&amp;gt;      :bar (fn [a b] ...)&amp;lt;br&amp;gt;      :baz (fn ([a]...) ([a b] ...)...)}&amp;lt;br&amp;gt;    BProtocol &amp;lt;br&amp;gt;      {...} &amp;lt;br&amp;gt;    ...)&amp;lt;br&amp;gt; &amp;lt;br&amp;gt;  extend takes a type/class (or interface, see below), and one or more&amp;lt;br&amp;gt;  protocol + method map pairs. It will extend the polymorphism of the&amp;lt;br&amp;gt;  protocol's methods to call the supplied methods when an AType is&amp;lt;br&amp;gt;  provided as the first argument. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Method maps are maps of the keyword-ized method names to ordinary&amp;lt;br&amp;gt;  fns. This facilitates easy reuse of existing fns and fn maps, for&amp;lt;br&amp;gt;  code reuse/mixins without derivation or composition. You can extend&amp;lt;br&amp;gt;  an interface to a protocol. This is primarily to facilitate interop&amp;lt;br&amp;gt;  with the host (e.g. Java) but opens the door to incidental multiple&amp;lt;br&amp;gt;  inheritance of implementation since a class can inherit from more&amp;lt;br&amp;gt;  than one interface, both of which extend the protocol. It is TBD how&amp;lt;br&amp;gt;  to specify which impl to use. You can extend a protocol on nil.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  If you are supplying the definitions explicitly (i.e. not reusing&amp;lt;br&amp;gt;  exsting functions or mixin maps), you may find it more convenient to&amp;lt;br&amp;gt;  use the extend-type or extend-protocol macros.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Note that multiple independent extend clauses can exist for the same&amp;lt;br&amp;gt;  type, not all protocols need be defined in a single extend call.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  See also:&amp;lt;br&amp;gt;  extends?, satisfies?, extenders&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;} &amp;lt;br&amp;gt;  [atype &amp;amp; proto+mmaps]&amp;lt;br&amp;gt;  (doseq [[proto mmap] (partition 2 proto+mmaps)]&amp;lt;br&amp;gt;    (when-not (protocol? proto)&amp;lt;br&amp;gt;      (throw (IllegalArgumentException.&amp;lt;br&amp;gt;              (str proto &amp;quot; is not a protocol&amp;quot;))))&amp;lt;br&amp;gt;    (when (implements? proto atype)&amp;lt;br&amp;gt;      (throw (IllegalArgumentException. &amp;lt;br&amp;gt;              (str atype &amp;quot; already directly implements &amp;quot; (:on-interface proto) &amp;quot; for protocol:&amp;quot;  &amp;lt;br&amp;gt;                   (:var proto)))))&amp;lt;br&amp;gt;    (-reset-methods (alter-var-root (:var proto) assoc-in [:impls atype] mmap))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">extend</a>[atype & proto+mmaps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;extend-protocol&lt;/b&gt; ([p &amp; specs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Useful when you want to provide several implementations of the same&lt;br&gt;  protocol all at once. Takes a single protocol and the implementation&lt;br&gt;  of that protocol for one or more types. Expands into calls to&lt;br&gt;  extend-type:&lt;br&gt;&lt;br&gt;  (extend-protocol Protocol&lt;br&gt;    AType&lt;br&gt;      (foo [x] ...)&lt;br&gt;      (bar [x y] ...)&lt;br&gt;    BType&lt;br&gt;      (foo [x] ...)&lt;br&gt;      (bar [x y] ...)&lt;br&gt;    AClass&lt;br&gt;      (foo [x] ...)&lt;br&gt;      (bar [x y] ...)&lt;br&gt;    nil&lt;br&gt;      (foo [x] ...)&lt;br&gt;      (bar [x y] ...))&lt;br&gt;&lt;br&gt;  expands into:&lt;br&gt;&lt;br&gt;  (do&lt;br&gt;   (clojure.core/extend-type AType Protocol &lt;br&gt;     (foo [x] ...) &lt;br&gt;     (bar [x y] ...))&lt;br&gt;   (clojure.core/extend-type BType Protocol &lt;br&gt;     (foo [x] ...) &lt;br&gt;     (bar [x y] ...))&lt;br&gt;   (clojure.core/extend-type AClass Protocol &lt;br&gt;     (foo [x] ...) &lt;br&gt;     (bar [x y] ...))&lt;br&gt;   (clojure.core/extend-type nil Protocol &lt;br&gt;     (foo [x] ...) &lt;br&gt;     (bar [x y] ...)))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro extend-protocol &amp;lt;br&amp;gt;  &amp;quot;Useful when you want to provide several implementations of the same&amp;lt;br&amp;gt;  protocol all at once. Takes a single protocol and the implementation&amp;lt;br&amp;gt;  of that protocol for one or more types. Expands into calls to&amp;lt;br&amp;gt;  extend-type:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (extend-protocol Protocol&amp;lt;br&amp;gt;    AType&amp;lt;br&amp;gt;      (foo [x] ...)&amp;lt;br&amp;gt;      (bar [x y] ...)&amp;lt;br&amp;gt;    BType&amp;lt;br&amp;gt;      (foo [x] ...)&amp;lt;br&amp;gt;      (bar [x y] ...)&amp;lt;br&amp;gt;    AClass&amp;lt;br&amp;gt;      (foo [x] ...)&amp;lt;br&amp;gt;      (bar [x y] ...)&amp;lt;br&amp;gt;    nil&amp;lt;br&amp;gt;      (foo [x] ...)&amp;lt;br&amp;gt;      (bar [x y] ...))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  expands into:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (do&amp;lt;br&amp;gt;   (clojure.core/extend-type AType Protocol &amp;lt;br&amp;gt;     (foo [x] ...) &amp;lt;br&amp;gt;     (bar [x y] ...))&amp;lt;br&amp;gt;   (clojure.core/extend-type BType Protocol &amp;lt;br&amp;gt;     (foo [x] ...) &amp;lt;br&amp;gt;     (bar [x y] ...))&amp;lt;br&amp;gt;   (clojure.core/extend-type AClass Protocol &amp;lt;br&amp;gt;     (foo [x] ...) &amp;lt;br&amp;gt;     (bar [x y] ...))&amp;lt;br&amp;gt;   (clojure.core/extend-type nil Protocol &amp;lt;br&amp;gt;     (foo [x] ...) &amp;lt;br&amp;gt;     (bar [x y] ...)))&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  [p &amp;amp; specs]&amp;lt;br&amp;gt;  (emit-extend-protocol p specs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">extend-protocol</a>[p & specs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;extend-type&lt;/b&gt; ([t &amp; specs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; A macro that expands into an extend call. Useful when you are&lt;br&gt;  supplying the definitions explicitly inline, extend-type&lt;br&gt;  automatically creates the maps required by extend.  Propagates the&lt;br&gt;  class as a type hint on the first argument of all fns.&lt;br&gt;&lt;br&gt;  (extend-type MyType &lt;br&gt;    Countable&lt;br&gt;      (cnt [c] ...)&lt;br&gt;    Foo&lt;br&gt;      (bar [x y] ...)&lt;br&gt;      (baz ([x] ...) ([x y &amp; zs] ...)))&lt;br&gt;&lt;br&gt;  expands into:&lt;br&gt;&lt;br&gt;  (extend MyType&lt;br&gt;   Countable&lt;br&gt;     {:cnt (fn [c] ...)}&lt;br&gt;   Foo&lt;br&gt;     {:baz (fn ([x] ...) ([x y &amp; zs] ...))&lt;br&gt;      :bar (fn [x y] ...)})&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro extend-type &amp;lt;br&amp;gt;  &amp;quot;A macro that expands into an extend call. Useful when you are&amp;lt;br&amp;gt;  supplying the definitions explicitly inline, extend-type&amp;lt;br&amp;gt;  automatically creates the maps required by extend.  Propagates the&amp;lt;br&amp;gt;  class as a type hint on the first argument of all fns.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (extend-type MyType &amp;lt;br&amp;gt;    Countable&amp;lt;br&amp;gt;      (cnt [c] ...)&amp;lt;br&amp;gt;    Foo&amp;lt;br&amp;gt;      (bar [x y] ...)&amp;lt;br&amp;gt;      (baz ([x] ...) ([x y &amp;amp; zs] ...)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  expands into:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (extend MyType&amp;lt;br&amp;gt;   Countable&amp;lt;br&amp;gt;     {:cnt (fn [c] ...)}&amp;lt;br&amp;gt;   Foo&amp;lt;br&amp;gt;     {:baz (fn ([x] ...) ([x y &amp;amp; zs] ...))&amp;lt;br&amp;gt;      :bar (fn [x y] ...)})&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;} &amp;lt;br&amp;gt;  [t &amp;amp; specs]&amp;lt;br&amp;gt;  (emit-extend-type t specs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">extend-type</a>[t & specs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;extenders&lt;/b&gt; ([protocol])&lt;br&gt; Returns a collection of the types explicitly extending protocol&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn extenders &amp;lt;br&amp;gt;  &amp;quot;Returns a collection of the types explicitly extending protocol&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [protocol]&amp;lt;br&amp;gt;  (keys (:impls protocol)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">extenders</a>[protocol]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;extends?&lt;/b&gt; ([protocol atype])&lt;br&gt; Returns true if atype extends protocol&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn extends? &amp;lt;br&amp;gt;  &amp;quot;Returns true if atype extends protocol&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [protocol atype]&amp;lt;br&amp;gt;  (boolean (or (implements? protocol atype) &amp;lt;br&amp;gt;               (get (:impls protocol) atype))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">extends?</a>[protocol atype]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;false?&lt;/b&gt; ([x])&lt;br&gt; Returns true if x is the value false, false otherwise.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn false?&amp;lt;br&amp;gt;  &amp;quot;Returns true if x is the value false, false otherwise.&amp;quot;&amp;lt;br&amp;gt;  {:tag Boolean,&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (clojure.lang.Util/identical x false))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">false?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ffirst&lt;/b&gt; ([x])&lt;br&gt; Same as (first (first x))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:doc &amp;quot;Same as (first (first x))&amp;quot;&amp;lt;br&amp;gt;   :arglists '([x])&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; ffirst (fn ^:static ffirst [x] (first (first x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ffirst</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;file-seq&lt;/b&gt; ([dir])&lt;br&gt; A tree seq on java.io.Files&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn file-seq&amp;lt;br&amp;gt;  &amp;quot;A tree seq on java.io.Files&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [dir]&amp;lt;br&amp;gt;    (tree-seq&amp;lt;br&amp;gt;     (fn [^java.io.File f] (. f (isDirectory)))&amp;lt;br&amp;gt;     (fn [^java.io.File d] (seq (. d (listFiles))))&amp;lt;br&amp;gt;     dir))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">file-seq</a>[dir]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;filter&lt;/b&gt; ([pred coll])&lt;br&gt; Returns a lazy sequence of the items in coll for which&lt;br&gt;  (pred item) returns true. pred must be free of side-effects.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn filter&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of the items in coll for which&amp;lt;br&amp;gt;  (pred item) returns true. pred must be free of side-effects.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([pred coll]&amp;lt;br&amp;gt;   (lazy-seq&amp;lt;br&amp;gt;    (when-let [s (seq coll)]&amp;lt;br&amp;gt;      (if (chunked-seq? s)&amp;lt;br&amp;gt;        (let [c (chunk-first s)&amp;lt;br&amp;gt;              size (count c)&amp;lt;br&amp;gt;              b (chunk-buffer size)]&amp;lt;br&amp;gt;          (dotimes [i size]&amp;lt;br&amp;gt;              (when (pred (.nth c i))&amp;lt;br&amp;gt;                (chunk-append b (.nth c i))))&amp;lt;br&amp;gt;          (chunk-cons (chunk b) (filter pred (chunk-rest s))))&amp;lt;br&amp;gt;        (let [f (first s) r (rest s)]&amp;lt;br&amp;gt;          (if (pred f)&amp;lt;br&amp;gt;            (cons f (filter pred r))&amp;lt;br&amp;gt;            (filter pred r))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">filter</a>[pred coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;filterv&lt;/b&gt; ([pred coll])&lt;br&gt; Returns a vector of the items in coll for which&lt;br&gt;  (pred item) returns true. pred must be free of side-effects.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn filterv&amp;lt;br&amp;gt;  &amp;quot;Returns a vector of the items in coll for which&amp;lt;br&amp;gt;  (pred item) returns true. pred must be free of side-effects.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.4&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [pred coll]&amp;lt;br&amp;gt;  (-&amp;gt; (reduce (fn [v o] (if (pred o) (conj! v o) v))&amp;lt;br&amp;gt;              (transient [])&amp;lt;br&amp;gt;              coll)&amp;lt;br&amp;gt;      persistent!))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">filterv</a>[pred coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;find&lt;/b&gt; ([map key])&lt;br&gt; Returns the map entry for key, or nil if key not present.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find&amp;lt;br&amp;gt;  &amp;quot;Returns the map entry for key, or nil if key not present.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [map key] (. clojure.lang.RT (find map key)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find</a>[map key]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;find-keyword&lt;/b&gt; ([name] [ns name])&lt;br&gt; Returns a Keyword with the given namespace and name if one already&lt;br&gt;  exists.  This function will not intern a new keyword. If the keyword&lt;br&gt;  has not already been interned, it will return nil.  Do not use :&lt;br&gt;  in the keyword strings, it will be added automatically.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-keyword&amp;lt;br&amp;gt;  &amp;quot;Returns a Keyword with the given namespace and name if one already&amp;lt;br&amp;gt;  exists.  This function will not intern a new keyword. If the keyword&amp;lt;br&amp;gt;  has not already been interned, it will return nil.  Do not use :&amp;lt;br&amp;gt;  in the keyword strings, it will be added automatically.&amp;quot;&amp;lt;br&amp;gt;  {:tag clojure.lang.Keyword&amp;lt;br&amp;gt;   :added &amp;quot;1.3&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([name] (cond (keyword? name) name&amp;lt;br&amp;gt;                (symbol? name) (clojure.lang.Keyword/find ^clojure.lang.Symbol name)&amp;lt;br&amp;gt;                (string? name) (clojure.lang.Keyword/find ^String name)))&amp;lt;br&amp;gt;  ([ns name] (clojure.lang.Keyword/find ns name)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-keyword</a>[name] [ns name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;find-ns&lt;/b&gt; ([sym])&lt;br&gt; Returns the namespace named by the symbol or nil if it doesn't exist.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-ns&amp;lt;br&amp;gt;  &amp;quot;Returns the namespace named by the symbol or nil if it doesn't exist.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [sym] (clojure.lang.Namespace/find sym))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-ns</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;find-protocol-impl&lt;/b&gt; ([protocol x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-protocol-impl [protocol x]&amp;lt;br&amp;gt;  (if (instance? (:on-interface protocol) x)&amp;lt;br&amp;gt;    x&amp;lt;br&amp;gt;    (let [c (class x)&amp;lt;br&amp;gt;          impl #(get (:impls protocol) %)]&amp;lt;br&amp;gt;      (or (impl c)&amp;lt;br&amp;gt;          (and c (or (first (remove nil? (map impl (butlast (super-chain c)))))&amp;lt;br&amp;gt;                     (when-let [t (reduce1 pref (filter impl (disj (supers c) Object)))]&amp;lt;br&amp;gt;                       (impl t))&amp;lt;br&amp;gt;                     (impl Object)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-protocol-impl</a>[protocol x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;find-protocol-method&lt;/b&gt; ([protocol methodk x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-protocol-method [protocol methodk x]&amp;lt;br&amp;gt;  (get (find-protocol-impl protocol x) methodk))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-protocol-method</a>[protocol methodk x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;find-var&lt;/b&gt; ([sym])&lt;br&gt; Returns the global var named by the namespace-qualified symbol, or&lt;br&gt;  nil if no var with that name.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-var&amp;lt;br&amp;gt;  &amp;quot;Returns the global var named by the namespace-qualified symbol, or&amp;lt;br&amp;gt;  nil if no var with that name.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [sym] (. clojure.lang.Var (find sym)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-var</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;first&lt;/b&gt; ([coll])&lt;br&gt; Returns the first item in the collection. Calls seq on its&lt;br&gt;    argument. If coll is nil, returns nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([coll])&amp;lt;br&amp;gt;   :doc &amp;quot;Returns the first item in the collection. Calls seq on its&amp;lt;br&amp;gt;    argument. If coll is nil, returns nil.&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; first (fn ^:static first [coll] (. clojure.lang.RT (first coll))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">first</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;flatten&lt;/b&gt; ([x])&lt;br&gt; Takes any nested combination of sequential things (lists, vectors,&lt;br&gt;  etc.) and returns their contents as a single, flat sequence.&lt;br&gt;  (flatten nil) returns an empty sequence.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn flatten&amp;lt;br&amp;gt;  &amp;quot;Takes any nested combination of sequential things (lists, vectors,&amp;lt;br&amp;gt;  etc.) and returns their contents as a single, flat sequence.&amp;lt;br&amp;gt;  (flatten nil) returns an empty sequence.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x]&amp;lt;br&amp;gt;  (filter (complement sequential?)&amp;lt;br&amp;gt;          (rest (tree-seq sequential? seq x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">flatten</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;float&lt;/b&gt; ([x])&lt;br&gt; Coerce to float&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn float&amp;lt;br&amp;gt;  &amp;quot;Coerce to float&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedFloatCast 'floatCast) ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [^Number x] (clojure.lang.RT/floatCast x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">float</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;float-array&lt;/b&gt; ([size-or-seq] [size init-val-or-seq])&lt;br&gt; Creates an array of floats&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn float-array&amp;lt;br&amp;gt;  &amp;quot;Creates an array of floats&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [&amp;amp; args] `(. clojure.lang.Numbers float_array ~@args))&amp;lt;br&amp;gt;   :inline-arities #{1 2}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([size-or-seq] (. clojure.lang.Numbers float_array size-or-seq))&amp;lt;br&amp;gt;  ([size init-val-or-seq] (. clojure.lang.Numbers float_array size init-val-or-seq)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">float-array</a>[size-or-seq] [size init-val-or-seq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;float?&lt;/b&gt; ([n])&lt;br&gt; Returns true if n is a floating point number&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn float?&amp;lt;br&amp;gt;  &amp;quot;Returns true if n is a floating point number&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [n]&amp;lt;br&amp;gt;  (or (instance? Double n)&amp;lt;br&amp;gt;      (instance? Float n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">float?</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;floats&lt;/b&gt; ([xs])&lt;br&gt; Casts to float[]&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(definline floats&amp;lt;br&amp;gt;  &amp;quot;Casts to float[]&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [xs] `(. clojure.lang.Numbers floats ~xs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">floats</a>[xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;flush&lt;/b&gt; ([])&lt;br&gt; Flushes the output stream that is the current value of&lt;br&gt;  *out*&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn flush&amp;lt;br&amp;gt;  &amp;quot;Flushes the output stream that is the current value of&amp;lt;br&amp;gt;  *out*&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;    (. *out* (flush))&amp;lt;br&amp;gt;    nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">flush</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;fn&lt;/b&gt; ((fn name? [params*] exprs*) (fn name? ([params*] exprs*) +))&lt;br&gt;&lt;i&gt;Special Form&lt;/i&gt; params =&gt; positional-params* , or positional-params* &amp; next-param&lt;br&gt;  positional-param =&gt; binding-form&lt;br&gt;  next-param =&gt; binding-form&lt;br&gt;  name =&gt; symbol&lt;br&gt;&lt;br&gt;  Defines a function&lt;br&gt;&lt;br&gt;  Please see http://clojure.org/special_forms#fn&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro fn&amp;lt;br&amp;gt;  &amp;quot;params =&amp;gt; positional-params* , or positional-params* &amp;amp; next-param&amp;lt;br&amp;gt;  positional-param =&amp;gt; binding-form&amp;lt;br&amp;gt;  next-param =&amp;gt; binding-form&amp;lt;br&amp;gt;  name =&amp;gt; symbol&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Defines a function&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;, :special-form true,&amp;lt;br&amp;gt;   :forms '[(fn name? [params* ] exprs*) (fn name? ([params* ] exprs*)+)]}&amp;lt;br&amp;gt;  [&amp;amp; sigs]&amp;lt;br&amp;gt;    (let [name (if (symbol? (first sigs)) (first sigs) nil)&amp;lt;br&amp;gt;          sigs (if name (next sigs) sigs)&amp;lt;br&amp;gt;          sigs (if (vector? (first sigs)) &amp;lt;br&amp;gt;                 (list sigs) &amp;lt;br&amp;gt;                 (if (seq? (first sigs))&amp;lt;br&amp;gt;                   sigs&amp;lt;br&amp;gt;                   ;; Assume single arity syntax&amp;lt;br&amp;gt;                   (throw (IllegalArgumentException. &amp;lt;br&amp;gt;                            (if (seq sigs)&amp;lt;br&amp;gt;                              (str &amp;quot;Parameter declaration &amp;quot; &amp;lt;br&amp;gt;                                   (first sigs)&amp;lt;br&amp;gt;                                   &amp;quot; should be a vector&amp;quot;)&amp;lt;br&amp;gt;                              (str &amp;quot;Parameter declaration missing&amp;quot;))))))&amp;lt;br&amp;gt;          psig (fn* [sig]&amp;lt;br&amp;gt;                 ;; Ensure correct type before destructuring sig&amp;lt;br&amp;gt;                 (when (not (seq? sig))&amp;lt;br&amp;gt;                   (throw (IllegalArgumentException.&amp;lt;br&amp;gt;                            (str &amp;quot;Invalid signature &amp;quot; sig&amp;lt;br&amp;gt;                                 &amp;quot; should be a list&amp;quot;))))&amp;lt;br&amp;gt;                 (let [[params &amp;amp; body] sig&amp;lt;br&amp;gt;                       _ (when (not (vector? params))&amp;lt;br&amp;gt;                           (throw (IllegalArgumentException. &amp;lt;br&amp;gt;                                    (if (seq? (first sigs))&amp;lt;br&amp;gt;                                      (str &amp;quot;Parameter declaration &amp;quot; params&amp;lt;br&amp;gt;                                           &amp;quot; should be a vector&amp;quot;)&amp;lt;br&amp;gt;                                      (str &amp;quot;Invalid signature &amp;quot; sig&amp;lt;br&amp;gt;                                           &amp;quot; should be a list&amp;quot;)))))&amp;lt;br&amp;gt;                       conds (when (and (next body) (map? (first body))) &amp;lt;br&amp;gt;                                           (first body))&amp;lt;br&amp;gt;                       body (if conds (next body) body)&amp;lt;br&amp;gt;                       conds (or conds (meta params))&amp;lt;br&amp;gt;                       pre (:pre conds)&amp;lt;br&amp;gt;                       post (:post conds)                       &amp;lt;br&amp;gt;                       body (if post&amp;lt;br&amp;gt;                              `((let [~'% ~(if (&amp;lt; 1 (count body)) &amp;lt;br&amp;gt;                                            `(do ~@body) &amp;lt;br&amp;gt;                                            (first body))]&amp;lt;br&amp;gt;                                 ~@(map (fn* [c] `(assert ~c)) post)&amp;lt;br&amp;gt;                                 ~'%))&amp;lt;br&amp;gt;                              body)&amp;lt;br&amp;gt;                       body (if pre&amp;lt;br&amp;gt;                              (concat (map (fn* [c] `(assert ~c)) pre) &amp;lt;br&amp;gt;                                      body)&amp;lt;br&amp;gt;                              body)]&amp;lt;br&amp;gt;                   (maybe-destructured params body)))&amp;lt;br&amp;gt;          new-sigs (map psig sigs)]&amp;lt;br&amp;gt;      (with-meta&amp;lt;br&amp;gt;        (if name&amp;lt;br&amp;gt;          (list* 'fn* name new-sigs)&amp;lt;br&amp;gt;          (cons 'fn* new-sigs))&amp;lt;br&amp;gt;        (meta &amp;amp;form))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fn</a>(fn name? [params*] exprs*) (fn name? ([params*] exprs*) +)</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;fn?&lt;/b&gt; ([x])&lt;br&gt; Returns true if x implements Fn, i.e. is an object created via fn.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fn?&amp;lt;br&amp;gt;  &amp;quot;Returns true if x implements Fn, i.e. is an object created via fn.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (instance? clojure.lang.Fn x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fn?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;fnext&lt;/b&gt; ([x])&lt;br&gt; Same as (first (next x))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:doc &amp;quot;Same as (first (next x))&amp;quot;&amp;lt;br&amp;gt;   :arglists '([x])&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; fnext (fn ^:static fnext [x] (first (next x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fnext</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;fnil&lt;/b&gt; ([f x] [f x y] [f x y z])&lt;br&gt; Takes a function f, and returns a function that calls f, replacing&lt;br&gt;  a nil first argument to f with the supplied value x. Higher arity&lt;br&gt;  versions can replace arguments in the second and third&lt;br&gt;  positions (y, z). Note that the function f can take any number of&lt;br&gt;  arguments, not just the one(s) being nil-patched.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fnil&amp;lt;br&amp;gt;  &amp;quot;Takes a function f, and returns a function that calls f, replacing&amp;lt;br&amp;gt;  a nil first argument to f with the supplied value x. Higher arity&amp;lt;br&amp;gt;  versions can replace arguments in the second and third&amp;lt;br&amp;gt;  positions (y, z). Note that the function f can take any number of&amp;lt;br&amp;gt;  arguments, not just the one(s) being nil-patched.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([f x]&amp;lt;br&amp;gt;   (fn&amp;lt;br&amp;gt;     ([a] (f (if (nil? a) x a)))&amp;lt;br&amp;gt;     ([a b] (f (if (nil? a) x a) b))&amp;lt;br&amp;gt;     ([a b c] (f (if (nil? a) x a) b c))&amp;lt;br&amp;gt;     ([a b c &amp;amp; ds] (apply f (if (nil? a) x a) b c ds))))&amp;lt;br&amp;gt;  ([f x y]&amp;lt;br&amp;gt;   (fn&amp;lt;br&amp;gt;     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))&amp;lt;br&amp;gt;     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))&amp;lt;br&amp;gt;     ([a b c &amp;amp; ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))&amp;lt;br&amp;gt;  ([f x y z]&amp;lt;br&amp;gt;   (fn&amp;lt;br&amp;gt;     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))&amp;lt;br&amp;gt;     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))&amp;lt;br&amp;gt;     ([a b c &amp;amp; ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fnil</a>[f x] [f x y] [f x y z]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;for&lt;/b&gt; ([seq-exprs body-expr])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; List comprehension. Takes a vector of one or more&lt;br&gt;   binding-form/collection-expr pairs, each followed by zero or more&lt;br&gt;   modifiers, and yields a lazy sequence of evaluations of expr.&lt;br&gt;   Collections are iterated in a nested fashion, rightmost fastest,&lt;br&gt;   and nested coll-exprs can refer to bindings created in prior&lt;br&gt;   binding-forms.  Supported modifiers are: :let [binding-form expr ...],&lt;br&gt;   :while test, :when test.&lt;br&gt;&lt;br&gt;  (take 100 (for [x (range 100000000) y (range 1000000) :while (&lt; y x)] [x y]))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro for&amp;lt;br&amp;gt;  &amp;quot;List comprehension. Takes a vector of one or more&amp;lt;br&amp;gt;   binding-form/collection-expr pairs, each followed by zero or more&amp;lt;br&amp;gt;   modifiers, and yields a lazy sequence of evaluations of expr.&amp;lt;br&amp;gt;   Collections are iterated in a nested fashion, rightmost fastest,&amp;lt;br&amp;gt;   and nested coll-exprs can refer to bindings created in prior&amp;lt;br&amp;gt;   binding-forms.  Supported modifiers are: :let [binding-form expr ...],&amp;lt;br&amp;gt;   :while test, :when test.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (take 100 (for [x (range 100000000) y (range 1000000) :while (&amp;lt; y x)] [x y]))&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [seq-exprs body-expr]&amp;lt;br&amp;gt;  (assert-args&amp;lt;br&amp;gt;     (vector? seq-exprs) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;     (even? (count seq-exprs)) &amp;quot;an even number of forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;  (let [to-groups (fn [seq-exprs]&amp;lt;br&amp;gt;                    (reduce1 (fn [groups [k v]]&amp;lt;br&amp;gt;                              (if (keyword? k)&amp;lt;br&amp;gt;                                (conj (pop groups) (conj (peek groups) [k v]))&amp;lt;br&amp;gt;                                (conj groups [k v])))&amp;lt;br&amp;gt;                            [] (partition 2 seq-exprs)))&amp;lt;br&amp;gt;        err (fn [&amp;amp; msg] (throw (IllegalArgumentException. ^String (apply str msg))))&amp;lt;br&amp;gt;        emit-bind (fn emit-bind [[[bind expr &amp;amp; mod-pairs]&amp;lt;br&amp;gt;                                  &amp;amp; [[_ next-expr] :as next-groups]]]&amp;lt;br&amp;gt;                    (let [giter (gensym &amp;quot;iter__&amp;quot;)&amp;lt;br&amp;gt;                          gxs (gensym &amp;quot;s__&amp;quot;)&amp;lt;br&amp;gt;                          do-mod (fn do-mod [[[k v :as pair] &amp;amp; etc]]&amp;lt;br&amp;gt;                                   (cond&amp;lt;br&amp;gt;                                     (= k :let) `(let ~v ~(do-mod etc))&amp;lt;br&amp;gt;                                     (= k :while) `(when ~v ~(do-mod etc))&amp;lt;br&amp;gt;                                     (= k :when) `(if ~v&amp;lt;br&amp;gt;                                                    ~(do-mod etc)&amp;lt;br&amp;gt;                                                    (recur (rest ~gxs)))&amp;lt;br&amp;gt;                                     (keyword? k) (err &amp;quot;Invalid 'for' keyword &amp;quot; k)&amp;lt;br&amp;gt;                                     next-groups&amp;lt;br&amp;gt;                                      `(let [iterys# ~(emit-bind next-groups)&amp;lt;br&amp;gt;                                             fs# (seq (iterys# ~next-expr))]&amp;lt;br&amp;gt;                                         (if fs#&amp;lt;br&amp;gt;                                           (concat fs# (~giter (rest ~gxs)))&amp;lt;br&amp;gt;                                           (recur (rest ~gxs))))&amp;lt;br&amp;gt;                                     :else `(cons ~body-expr&amp;lt;br&amp;gt;                                                  (~giter (rest ~gxs)))))]&amp;lt;br&amp;gt;                      (if next-groups&amp;lt;br&amp;gt;                        #_&amp;quot;not the inner-most loop&amp;quot;&amp;lt;br&amp;gt;                        `(fn ~giter [~gxs]&amp;lt;br&amp;gt;                           (lazy-seq&amp;lt;br&amp;gt;                             (loop [~gxs ~gxs]&amp;lt;br&amp;gt;                               (when-first [~bind ~gxs]&amp;lt;br&amp;gt;                                 ~(do-mod mod-pairs)))))&amp;lt;br&amp;gt;                        #_&amp;quot;inner-most loop&amp;quot;&amp;lt;br&amp;gt;                        (let [gi (gensym &amp;quot;i__&amp;quot;)&amp;lt;br&amp;gt;                              gb (gensym &amp;quot;b__&amp;quot;)&amp;lt;br&amp;gt;                              do-cmod (fn do-cmod [[[k v :as pair] &amp;amp; etc]]&amp;lt;br&amp;gt;                                        (cond&amp;lt;br&amp;gt;                                          (= k :let) `(let ~v ~(do-cmod etc))&amp;lt;br&amp;gt;                                          (= k :while) `(when ~v ~(do-cmod etc))&amp;lt;br&amp;gt;                                          (= k :when) `(if ~v&amp;lt;br&amp;gt;                                                         ~(do-cmod etc)&amp;lt;br&amp;gt;                                                         (recur&amp;lt;br&amp;gt;                                                           (unchecked-inc ~gi)))&amp;lt;br&amp;gt;                                          (keyword? k)&amp;lt;br&amp;gt;                                            (err &amp;quot;Invalid 'for' keyword &amp;quot; k)&amp;lt;br&amp;gt;                                          :else&amp;lt;br&amp;gt;                                            `(do (chunk-append ~gb ~body-expr)&amp;lt;br&amp;gt;                                                 (recur (unchecked-inc ~gi)))))]&amp;lt;br&amp;gt;                          `(fn ~giter [~gxs]&amp;lt;br&amp;gt;                             (lazy-seq&amp;lt;br&amp;gt;                               (loop [~gxs ~gxs]&amp;lt;br&amp;gt;                                 (when-let [~gxs (seq ~gxs)]&amp;lt;br&amp;gt;                                   (if (chunked-seq? ~gxs)&amp;lt;br&amp;gt;                                     (let [c# (chunk-first ~gxs)&amp;lt;br&amp;gt;                                           size# (int (count c#))&amp;lt;br&amp;gt;                                           ~gb (chunk-buffer size#)]&amp;lt;br&amp;gt;                                       (if (loop [~gi (int 0)]&amp;lt;br&amp;gt;                                             (if (&amp;lt; ~gi size#)&amp;lt;br&amp;gt;                                               (let [~bind (.nth c# ~gi)]&amp;lt;br&amp;gt;                                                 ~(do-cmod mod-pairs))&amp;lt;br&amp;gt;                                               true))&amp;lt;br&amp;gt;                                         (chunk-cons&amp;lt;br&amp;gt;                                           (chunk ~gb)&amp;lt;br&amp;gt;                                           (~giter (chunk-rest ~gxs)))&amp;lt;br&amp;gt;                                         (chunk-cons (chunk ~gb) nil)))&amp;lt;br&amp;gt;                                     (let [~bind (first ~gxs)]&amp;lt;br&amp;gt;                                       ~(do-mod mod-pairs)))))))))))]&amp;lt;br&amp;gt;    `(let [iter# ~(emit-bind (to-groups seq-exprs))]&amp;lt;br&amp;gt;        (iter# ~(second seq-exprs)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">for</a>[seq-exprs body-expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;force&lt;/b&gt; ([x])&lt;br&gt; If x is a Delay, returns the (possibly cached) value of its expression, else returns x&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn force&amp;lt;br&amp;gt;  &amp;quot;If x is a Delay, returns the (possibly cached) value of its expression, else returns x&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Delay (force x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">force</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;format&lt;/b&gt; ([fmt &amp; args])&lt;br&gt; Formats a string using java.lang.String.format, see java.util.Formatter for format&lt;br&gt;  string syntax&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn format&amp;lt;br&amp;gt;  &amp;quot;Formats a string using java.lang.String.format, see java.util.Formatter for format&amp;lt;br&amp;gt;  string syntax&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ^String [fmt &amp;amp; args]&amp;lt;br&amp;gt;  (String/format fmt (to-array args)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">format</a>[fmt & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;frequencies&lt;/b&gt; ([coll])&lt;br&gt; Returns a map from distinct items in coll to the number of times&lt;br&gt;  they appear.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn frequencies&amp;lt;br&amp;gt;  &amp;quot;Returns a map from distinct items in coll to the number of times&amp;lt;br&amp;gt;  they appear.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;  (persistent!&amp;lt;br&amp;gt;   (reduce (fn [counts x]&amp;lt;br&amp;gt;             (assoc! counts x (inc (get counts x 0))))&amp;lt;br&amp;gt;           (transient {}) coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">frequencies</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;future&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Takes a body of expressions and yields a future object that will&lt;br&gt;  invoke the body in another thread, and will cache the result and&lt;br&gt;  return it on all subsequent calls to deref/@. If the computation has&lt;br&gt;  not yet finished, calls to deref/@ will block, unless the variant of&lt;br&gt;  deref with timeout is used. See also - realized?.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro future&amp;lt;br&amp;gt;  &amp;quot;Takes a body of expressions and yields a future object that will&amp;lt;br&amp;gt;  invoke the body in another thread, and will cache the result and&amp;lt;br&amp;gt;  return it on all subsequent calls to deref/@. If the computation has&amp;lt;br&amp;gt;  not yet finished, calls to deref/@ will block, unless the variant of&amp;lt;br&amp;gt;  deref with timeout is used. See also - realized?.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; body] `(future-call (^{:once true} fn* [] ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">future</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;future-call&lt;/b&gt; ([f])&lt;br&gt; Takes a function of no args and yields a future object that will&lt;br&gt;  invoke the function in another thread, and will cache the result and&lt;br&gt;  return it on all subsequent calls to deref/@. If the computation has&lt;br&gt;  not yet finished, calls to deref/@ will block, unless the variant&lt;br&gt;  of deref with timeout is used. See also - realized?.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn future-call &amp;lt;br&amp;gt;  &amp;quot;Takes a function of no args and yields a future object that will&amp;lt;br&amp;gt;  invoke the function in another thread, and will cache the result and&amp;lt;br&amp;gt;  return it on all subsequent calls to deref/@. If the computation has&amp;lt;br&amp;gt;  not yet finished, calls to deref/@ will block, unless the variant&amp;lt;br&amp;gt;  of deref with timeout is used. See also - realized?.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (let [f (binding-conveyor-fn f)&amp;lt;br&amp;gt;        fut (.submit clojure.lang.Agent/soloExecutor ^Callable f)]&amp;lt;br&amp;gt;    (reify &amp;lt;br&amp;gt;     clojure.lang.IDeref &amp;lt;br&amp;gt;     (deref [_] (deref-future fut))&amp;lt;br&amp;gt;     clojure.lang.IBlockingDeref&amp;lt;br&amp;gt;     (deref&amp;lt;br&amp;gt;      [_ timeout-ms timeout-val]&amp;lt;br&amp;gt;      (deref-future fut timeout-ms timeout-val))&amp;lt;br&amp;gt;     clojure.lang.IPending&amp;lt;br&amp;gt;     (isRealized [_] (.isDone fut))&amp;lt;br&amp;gt;     java.util.concurrent.Future&amp;lt;br&amp;gt;      (get [_] (.get fut))&amp;lt;br&amp;gt;      (get [_ timeout unit] (.get fut timeout unit))&amp;lt;br&amp;gt;      (isCancelled [_] (.isCancelled fut))&amp;lt;br&amp;gt;      (isDone [_] (.isDone fut))&amp;lt;br&amp;gt;      (cancel [_ interrupt?] (.cancel fut interrupt?)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">future-call</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;future-cancel&lt;/b&gt; ([f])&lt;br&gt; Cancels the future, if possible.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn future-cancel&amp;lt;br&amp;gt;  &amp;quot;Cancels the future, if possible.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^java.util.concurrent.Future f] (.cancel f true))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">future-cancel</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;future-cancelled?&lt;/b&gt; ([f])&lt;br&gt; Returns true if future f is cancelled&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn future-cancelled?&amp;lt;br&amp;gt;  &amp;quot;Returns true if future f is cancelled&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^java.util.concurrent.Future f] (.isCancelled f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">future-cancelled?</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;future-done?&lt;/b&gt; ([f])&lt;br&gt; Returns true if future f is done&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn future-done?&amp;lt;br&amp;gt;  &amp;quot;Returns true if future f is done&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^java.util.concurrent.Future f] (.isDone f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">future-done?</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;future?&lt;/b&gt; ([x])&lt;br&gt; Returns true if x is a future&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn future?&amp;lt;br&amp;gt;  &amp;quot;Returns true if x is a future&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (instance? java.util.concurrent.Future x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">future?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;gen-class&lt;/b&gt; ([&amp; options])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; When compiling, generates compiled bytecode for a class with the&lt;br&gt;  given package-qualified :name (which, as all names in these&lt;br&gt;  parameters, can be a string or symbol), and writes the .class file&lt;br&gt;  to the *compile-path* directory.  When not compiling, does&lt;br&gt;  nothing. The gen-class construct contains no implementation, as the&lt;br&gt;  implementation will be dynamically sought by the generated class in&lt;br&gt;  functions in an implementing Clojure namespace. Given a generated&lt;br&gt;  class org.mydomain.MyClass with a method named mymethod, gen-class&lt;br&gt;  will generate an implementation that looks for a function named by &lt;br&gt;  (str prefix mymethod) (default prefix: &quot;-&quot;) in a&lt;br&gt;  Clojure namespace specified by :impl-ns&lt;br&gt;  (defaults to the current namespace). All inherited methods,&lt;br&gt;  generated methods, and init and main functions (see :methods, :init,&lt;br&gt;  and :main below) will be found similarly prefixed. By default, the&lt;br&gt;  static initializer for the generated class will attempt to load the&lt;br&gt;  Clojure support code for the class as a resource from the classpath,&lt;br&gt;  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This&lt;br&gt;  behavior can be controlled by :load-impl-ns&lt;br&gt;&lt;br&gt;  Note that methods with a maximum of 18 parameters are supported.&lt;br&gt;&lt;br&gt;  In all subsequent sections taking types, the primitive types can be&lt;br&gt;  referred to by their Java names (int, float etc), and classes in the&lt;br&gt;  java.lang package can be used without a package qualifier. All other&lt;br&gt;  classes must be fully qualified.&lt;br&gt;&lt;br&gt;  Options should be a set of key/value pairs, all except for :name are optional:&lt;br&gt;&lt;br&gt;  :name aname&lt;br&gt;&lt;br&gt;  The package-qualified name of the class to be generated&lt;br&gt;&lt;br&gt;  :extends aclass&lt;br&gt;&lt;br&gt;  Specifies the superclass, the non-private methods of which will be&lt;br&gt;  overridden by the class. If not provided, defaults to Object.&lt;br&gt;&lt;br&gt;  :implements [interface ...]&lt;br&gt;&lt;br&gt;  One or more interfaces, the methods of which will be implemented by the class.&lt;br&gt;&lt;br&gt;  :init name&lt;br&gt;&lt;br&gt;  If supplied, names a function that will be called with the arguments&lt;br&gt;  to the constructor. Must return [ [superclass-constructor-args] state] &lt;br&gt;  If not supplied, the constructor args are passed directly to&lt;br&gt;  the superclass constructor and the state will be nil&lt;br&gt;&lt;br&gt;  :constructors {[param-types] [super-param-types], ...}&lt;br&gt;&lt;br&gt;  By default, constructors are created for the generated class which&lt;br&gt;  match the signature(s) of the constructors for the superclass. This&lt;br&gt;  parameter may be used to explicitly specify constructors, each entry&lt;br&gt;  providing a mapping from a constructor signature to a superclass&lt;br&gt;  constructor signature. When you supply this, you must supply an :init&lt;br&gt;  specifier. &lt;br&gt;&lt;br&gt;  :post-init name&lt;br&gt;&lt;br&gt;  If supplied, names a function that will be called with the object as&lt;br&gt;  the first argument, followed by the arguments to the constructor.&lt;br&gt;  It will be called every time an object of this class is created,&lt;br&gt;  immediately after all the inherited constructors have completed.&lt;br&gt;  It's return value is ignored.&lt;br&gt;&lt;br&gt;  :methods [ [name [param-types] return-type], ...]&lt;br&gt;&lt;br&gt;  The generated class automatically defines all of the non-private&lt;br&gt;  methods of its superclasses/interfaces. This parameter can be used&lt;br&gt;  to specify the signatures of additional methods of the generated&lt;br&gt;  class. Static methods can be specified with ^{:static true} in the&lt;br&gt;  signature's metadata. Do not repeat superclass/interface signatures&lt;br&gt;  here.&lt;br&gt;&lt;br&gt;  :main boolean&lt;br&gt;&lt;br&gt;  If supplied and true, a static public main function will be generated. It will&lt;br&gt;  pass each string of the String[] argument as a separate argument to&lt;br&gt;  a function called (str prefix main).&lt;br&gt;&lt;br&gt;  :factory name&lt;br&gt;&lt;br&gt;  If supplied, a (set of) public static factory function(s) will be&lt;br&gt;  created with the given name, and the same signature(s) as the&lt;br&gt;  constructor(s).&lt;br&gt;  &lt;br&gt;  :state name&lt;br&gt;&lt;br&gt;  If supplied, a public final instance field with the given name will be&lt;br&gt;  created. You must supply an :init function in order to provide a&lt;br&gt;  value for the state. Note that, though final, the state can be a ref&lt;br&gt;  or agent, supporting the creation of Java objects with transactional&lt;br&gt;  or asynchronous mutation semantics.&lt;br&gt;&lt;br&gt;  :exposes {protected-field-name {:get name :set name}, ...}&lt;br&gt;&lt;br&gt;  Since the implementations of the methods of the generated class&lt;br&gt;  occur in Clojure functions, they have no access to the inherited&lt;br&gt;  protected fields of the superclass. This parameter can be used to&lt;br&gt;  generate public getter/setter methods exposing the protected field(s)&lt;br&gt;  for use in the implementation.&lt;br&gt;&lt;br&gt;  :exposes-methods {super-method-name exposed-name, ...}&lt;br&gt;&lt;br&gt;  It is sometimes necessary to call the superclass' implementation of an&lt;br&gt;  overridden method.  Those methods may be exposed and referred in &lt;br&gt;  the new method implementation by a local name.&lt;br&gt;&lt;br&gt;  :prefix string&lt;br&gt;&lt;br&gt;  Default: &quot;-&quot; Methods called e.g. Foo will be looked up in vars called&lt;br&gt;  prefixFoo in the implementing ns.&lt;br&gt;&lt;br&gt;  :impl-ns name&lt;br&gt;&lt;br&gt;  Default: the name of the current ns. Implementations of methods will be &lt;br&gt;  looked up in this namespace.&lt;br&gt;&lt;br&gt;  :load-impl-ns boolean&lt;br&gt;&lt;br&gt;  Default: true. Causes the static initializer for the generated class&lt;br&gt;  to reference the load code for the implementing namespace. Should be&lt;br&gt;  true when implementing-ns is the default, false if you intend to&lt;br&gt;  load the code via some other method.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro gen-class &amp;lt;br&amp;gt;  &amp;quot;When compiling, generates compiled bytecode for a class with the&amp;lt;br&amp;gt;  given package-qualified :name (which, as all names in these&amp;lt;br&amp;gt;  parameters, can be a string or symbol), and writes the .class file&amp;lt;br&amp;gt;  to the *compile-path* directory.  When not compiling, does&amp;lt;br&amp;gt;  nothing. The gen-class construct contains no implementation, as the&amp;lt;br&amp;gt;  implementation will be dynamically sought by the generated class in&amp;lt;br&amp;gt;  functions in an implementing Clojure namespace. Given a generated&amp;lt;br&amp;gt;  class org.mydomain.MyClass with a method named mymethod, gen-class&amp;lt;br&amp;gt;  will generate an implementation that looks for a function named by &amp;lt;br&amp;gt;  (str prefix mymethod) (default prefix: \&amp;quot;-\&amp;quot;) in a&amp;lt;br&amp;gt;  Clojure namespace specified by :impl-ns&amp;lt;br&amp;gt;  (defaults to the current namespace). All inherited methods,&amp;lt;br&amp;gt;  generated methods, and init and main functions (see :methods, :init,&amp;lt;br&amp;gt;  and :main below) will be found similarly prefixed. By default, the&amp;lt;br&amp;gt;  static initializer for the generated class will attempt to load the&amp;lt;br&amp;gt;  Clojure support code for the class as a resource from the classpath,&amp;lt;br&amp;gt;  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This&amp;lt;br&amp;gt;  behavior can be controlled by :load-impl-ns&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Note that methods with a maximum of 18 parameters are supported.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  In all subsequent sections taking types, the primitive types can be&amp;lt;br&amp;gt;  referred to by their Java names (int, float etc), and classes in the&amp;lt;br&amp;gt;  java.lang package can be used without a package qualifier. All other&amp;lt;br&amp;gt;  classes must be fully qualified.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Options should be a set of key/value pairs, all except for :name are optional:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :name aname&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The package-qualified name of the class to be generated&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :extends aclass&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Specifies the superclass, the non-private methods of which will be&amp;lt;br&amp;gt;  overridden by the class. If not provided, defaults to Object.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :implements [interface ...]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  One or more interfaces, the methods of which will be implemented by the class.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :init name&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  If supplied, names a function that will be called with the arguments&amp;lt;br&amp;gt;  to the constructor. Must return [ [superclass-constructor-args] state] &amp;lt;br&amp;gt;  If not supplied, the constructor args are passed directly to&amp;lt;br&amp;gt;  the superclass constructor and the state will be nil&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :constructors {[param-types] [super-param-types], ...}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  By default, constructors are created for the generated class which&amp;lt;br&amp;gt;  match the signature(s) of the constructors for the superclass. This&amp;lt;br&amp;gt;  parameter may be used to explicitly specify constructors, each entry&amp;lt;br&amp;gt;  providing a mapping from a constructor signature to a superclass&amp;lt;br&amp;gt;  constructor signature. When you supply this, you must supply an :init&amp;lt;br&amp;gt;  specifier. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :post-init name&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  If supplied, names a function that will be called with the object as&amp;lt;br&amp;gt;  the first argument, followed by the arguments to the constructor.&amp;lt;br&amp;gt;  It will be called every time an object of this class is created,&amp;lt;br&amp;gt;  immediately after all the inherited constructors have completed.&amp;lt;br&amp;gt;  It's return value is ignored.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :methods [ [name [param-types] return-type], ...]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The generated class automatically defines all of the non-private&amp;lt;br&amp;gt;  methods of its superclasses/interfaces. This parameter can be used&amp;lt;br&amp;gt;  to specify the signatures of additional methods of the generated&amp;lt;br&amp;gt;  class. Static methods can be specified with ^{:static true} in the&amp;lt;br&amp;gt;  signature's metadata. Do not repeat superclass/interface signatures&amp;lt;br&amp;gt;  here.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :main boolean&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  If supplied and true, a static public main function will be generated. It will&amp;lt;br&amp;gt;  pass each string of the String[] argument as a separate argument to&amp;lt;br&amp;gt;  a function called (str prefix main).&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :factory name&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  If supplied, a (set of) public static factory function(s) will be&amp;lt;br&amp;gt;  created with the given name, and the same signature(s) as the&amp;lt;br&amp;gt;  constructor(s).&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  :state name&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  If supplied, a public final instance field with the given name will be&amp;lt;br&amp;gt;  created. You must supply an :init function in order to provide a&amp;lt;br&amp;gt;  value for the state. Note that, though final, the state can be a ref&amp;lt;br&amp;gt;  or agent, supporting the creation of Java objects with transactional&amp;lt;br&amp;gt;  or asynchronous mutation semantics.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :exposes {protected-field-name {:get name :set name}, ...}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Since the implementations of the methods of the generated class&amp;lt;br&amp;gt;  occur in Clojure functions, they have no access to the inherited&amp;lt;br&amp;gt;  protected fields of the superclass. This parameter can be used to&amp;lt;br&amp;gt;  generate public getter/setter methods exposing the protected field(s)&amp;lt;br&amp;gt;  for use in the implementation.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :exposes-methods {super-method-name exposed-name, ...}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  It is sometimes necessary to call the superclass' implementation of an&amp;lt;br&amp;gt;  overridden method.  Those methods may be exposed and referred in &amp;lt;br&amp;gt;  the new method implementation by a local name.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :prefix string&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Default: \&amp;quot;-\&amp;quot; Methods called e.g. Foo will be looked up in vars called&amp;lt;br&amp;gt;  prefixFoo in the implementing ns.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :impl-ns name&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Default: the name of the current ns. Implementations of methods will be &amp;lt;br&amp;gt;  looked up in this namespace.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :load-impl-ns boolean&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Default: true. Causes the static initializer for the generated class&amp;lt;br&amp;gt;  to reference the load code for the implementing namespace. Should be&amp;lt;br&amp;gt;  true when implementing-ns is the default, false if you intend to&amp;lt;br&amp;gt;  load the code via some other method.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  [&amp;amp; options]&amp;lt;br&amp;gt;    (when *compile-files*&amp;lt;br&amp;gt;      (let [options-map (into1 {} (map vec (partition 2 options)))&amp;lt;br&amp;gt;            [cname bytecode] (generate-class options-map)]&amp;lt;br&amp;gt;        (clojure.lang.Compiler/writeClassFile cname bytecode))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">gen-class</a>[& options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;gen-interface&lt;/b&gt; ([&amp; options])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; When compiling, generates compiled bytecode for an interface with&lt;br&gt;  the given package-qualified :name (which, as all names in these&lt;br&gt;  parameters, can be a string or symbol), and writes the .class file&lt;br&gt;  to the *compile-path* directory.  When not compiling, does nothing.&lt;br&gt; &lt;br&gt;  In all subsequent sections taking types, the primitive types can be&lt;br&gt;  referred to by their Java names (int, float etc), and classes in the&lt;br&gt;  java.lang package can be used without a package qualifier. All other&lt;br&gt;  classes must be fully qualified.&lt;br&gt; &lt;br&gt;  Options should be a set of key/value pairs, all except for :name are&lt;br&gt;  optional:&lt;br&gt;&lt;br&gt;  :name aname&lt;br&gt;&lt;br&gt;  The package-qualified name of the class to be generated&lt;br&gt;&lt;br&gt;  :extends [interface ...]&lt;br&gt;&lt;br&gt;  One or more interfaces, which will be extended by this interface.&lt;br&gt;&lt;br&gt;  :methods [ [name [param-types] return-type], ...]&lt;br&gt;&lt;br&gt;  This parameter is used to specify the signatures of the methods of&lt;br&gt;  the generated interface.  Do not repeat superinterface signatures&lt;br&gt;  here.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro gen-interface&amp;lt;br&amp;gt;  &amp;quot;When compiling, generates compiled bytecode for an interface with&amp;lt;br&amp;gt;  the given package-qualified :name (which, as all names in these&amp;lt;br&amp;gt;  parameters, can be a string or symbol), and writes the .class file&amp;lt;br&amp;gt;  to the *compile-path* directory.  When not compiling, does nothing.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt;  In all subsequent sections taking types, the primitive types can be&amp;lt;br&amp;gt;  referred to by their Java names (int, float etc), and classes in the&amp;lt;br&amp;gt;  java.lang package can be used without a package qualifier. All other&amp;lt;br&amp;gt;  classes must be fully qualified.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt;  Options should be a set of key/value pairs, all except for :name are&amp;lt;br&amp;gt;  optional:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :name aname&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The package-qualified name of the class to be generated&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :extends [interface ...]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  One or more interfaces, which will be extended by this interface.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :methods [ [name [param-types] return-type], ...]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  This parameter is used to specify the signatures of the methods of&amp;lt;br&amp;gt;  the generated interface.  Do not repeat superinterface signatures&amp;lt;br&amp;gt;  here.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  [&amp;amp; options]&amp;lt;br&amp;gt;    (let [options-map (apply hash-map options)&amp;lt;br&amp;gt;          [cname bytecode] (generate-interface options-map)]&amp;lt;br&amp;gt;      (if *compile-files*&amp;lt;br&amp;gt;        (clojure.lang.Compiler/writeClassFile cname bytecode)&amp;lt;br&amp;gt;        (.defineClass ^DynamicClassLoader (deref clojure.lang.Compiler/LOADER) &amp;lt;br&amp;gt;                      (str (:name options-map)) bytecode options))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">gen-interface</a>[& options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;gensym&lt;/b&gt; ([] [prefix-string])&lt;br&gt; Returns a new symbol with a unique name. If a prefix string is&lt;br&gt;  supplied, the name is prefix# where # is some unique number. If&lt;br&gt;  prefix is not supplied, the prefix is 'G__'.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn gensym&amp;lt;br&amp;gt;  &amp;quot;Returns a new symbol with a unique name. If a prefix string is&amp;lt;br&amp;gt;  supplied, the name is prefix# where # is some unique number. If&amp;lt;br&amp;gt;  prefix is not supplied, the prefix is 'G__'.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([] (gensym &amp;quot;G__&amp;quot;))&amp;lt;br&amp;gt;  ([prefix-string] (. clojure.lang.Symbol (intern (str prefix-string (str (. clojure.lang.RT (nextID))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">gensym</a>[] [prefix-string]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;get&lt;/b&gt; ([map key] [map key not-found])&lt;br&gt; Returns the value mapped to key, not-found or nil if key not present.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get&amp;lt;br&amp;gt;  &amp;quot;Returns the value mapped to key, not-found or nil if key not present.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [m k &amp;amp; nf] `(. clojure.lang.RT (get ~m ~k ~@nf)))&amp;lt;br&amp;gt;   :inline-arities #{2 3}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([map key]&amp;lt;br&amp;gt;   (. clojure.lang.RT (get map key)))&amp;lt;br&amp;gt;  ([map key not-found]&amp;lt;br&amp;gt;   (. clojure.lang.RT (get map key not-found))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get</a>[map key] [map key not-found]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;get-in&lt;/b&gt; ([m ks] [m ks not-found])&lt;br&gt; Returns the value in a nested associative structure,&lt;br&gt;  where ks is a sequence of keys. Returns nil if the key&lt;br&gt;  is not present, or the not-found value if supplied.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-in&amp;lt;br&amp;gt;  &amp;quot;Returns the value in a nested associative structure,&amp;lt;br&amp;gt;  where ks is a sequence of keys. Returns nil if the key&amp;lt;br&amp;gt;  is not present, or the not-found value if supplied.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([m ks]&amp;lt;br&amp;gt;     (reduce1 get m ks))&amp;lt;br&amp;gt;  ([m ks not-found]&amp;lt;br&amp;gt;     (loop [sentinel (Object.)&amp;lt;br&amp;gt;            m m&amp;lt;br&amp;gt;            ks (seq ks)]&amp;lt;br&amp;gt;       (if ks&amp;lt;br&amp;gt;         (let [m (get m (first ks) sentinel)]&amp;lt;br&amp;gt;           (if (identical? sentinel m)&amp;lt;br&amp;gt;             not-found&amp;lt;br&amp;gt;             (recur sentinel m (next ks))))&amp;lt;br&amp;gt;         m))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-in</a>[m ks] [m ks not-found]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;get-method&lt;/b&gt; ([multifn dispatch-val])&lt;br&gt; Given a multimethod and a dispatch value, returns the dispatch fn&lt;br&gt;  that would apply to that value, or nil if none apply and no default&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-method&amp;lt;br&amp;gt;  &amp;quot;Given a multimethod and a dispatch value, returns the dispatch fn&amp;lt;br&amp;gt;  that would apply to that value, or nil if none apply and no default&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.MultiFn multifn dispatch-val] (.getMethod multifn dispatch-val))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-method</a>[multifn dispatch-val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;get-proxy-class&lt;/b&gt; ([&amp; bases])&lt;br&gt; Takes an optional single class followed by zero or more&lt;br&gt;  interfaces. If not supplied class defaults to Object.  Creates an&lt;br&gt;  returns an instance of a proxy class derived from the supplied&lt;br&gt;  classes. The resulting value is cached and used for any subsequent&lt;br&gt;  requests for the same class set. Returns a Class object.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-proxy-class &amp;lt;br&amp;gt;  &amp;quot;Takes an optional single class followed by zero or more&amp;lt;br&amp;gt;  interfaces. If not supplied class defaults to Object.  Creates an&amp;lt;br&amp;gt;  returns an instance of a proxy class derived from the supplied&amp;lt;br&amp;gt;  classes. The resulting value is cached and used for any subsequent&amp;lt;br&amp;gt;  requests for the same class set. Returns a Class object.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; bases]&amp;lt;br&amp;gt;    (let [[super interfaces] (get-super-and-interfaces bases)&amp;lt;br&amp;gt;          pname (proxy-name super interfaces)]&amp;lt;br&amp;gt;      (or (RT/loadClassForName pname)&amp;lt;br&amp;gt;          (let [[cname bytecode] (generate-proxy super interfaces)]&amp;lt;br&amp;gt;            (. ^DynamicClassLoader (deref clojure.lang.Compiler/LOADER) (defineClass pname bytecode [super interfaces]))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-proxy-class</a>[& bases]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;get-thread-bindings&lt;/b&gt; ([])&lt;br&gt; Get a map with the Var/value pairs which is currently in effect for the&lt;br&gt;  current thread.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-thread-bindings&amp;lt;br&amp;gt;  &amp;quot;Get a map with the Var/value pairs which is currently in effect for the&amp;lt;br&amp;gt;  current thread.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (clojure.lang.Var/getThreadBindings))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-thread-bindings</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;get-validator&lt;/b&gt; ([iref])&lt;br&gt; Gets the validator-fn for a var/ref/agent/atom.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-validator&amp;lt;br&amp;gt;  &amp;quot;Gets the validator-fn for a var/ref/agent/atom.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; [^clojure.lang.IRef iref] (. iref (getValidator)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-validator</a>[iref]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;group-by&lt;/b&gt; ([f coll])&lt;br&gt; Returns a map of the elements of coll keyed by the result of&lt;br&gt;  f on each element. The value at each key will be a vector of the&lt;br&gt;  corresponding elements, in the order they appeared in coll.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn group-by &amp;lt;br&amp;gt;  &amp;quot;Returns a map of the elements of coll keyed by the result of&amp;lt;br&amp;gt;  f on each element. The value at each key will be a vector of the&amp;lt;br&amp;gt;  corresponding elements, in the order they appeared in coll.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [f coll]  &amp;lt;br&amp;gt;  (persistent!&amp;lt;br&amp;gt;   (reduce&amp;lt;br&amp;gt;    (fn [ret x]&amp;lt;br&amp;gt;      (let [k (f x)]&amp;lt;br&amp;gt;        (assoc! ret k (conj (get ret k []) x))))&amp;lt;br&amp;gt;    (transient {}) coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">group-by</a>[f coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;hash&lt;/b&gt; ([x])&lt;br&gt; Returns the hash code of its argument. Note this is the hash code&lt;br&gt;  consistent with =, and thus is different than .hashCode for Integer,&lt;br&gt;  Short, Byte and Clojure collections.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hash&amp;lt;br&amp;gt;  &amp;quot;Returns the hash code of its argument. Note this is the hash code&amp;lt;br&amp;gt;  consistent with =, and thus is different than .hashCode for Integer,&amp;lt;br&amp;gt;  Short, Byte and Clojure collections.&amp;quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Util (hasheq x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hash</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;hash-combine&lt;/b&gt; ([x y])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hash-combine [x y] &amp;lt;br&amp;gt;  (clojure.lang.Util/hashCombine x (clojure.lang.Util/hash y)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hash-combine</a>[x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;hash-map&lt;/b&gt; ([] [&amp; keyvals])&lt;br&gt; keyval =&gt; key val&lt;br&gt;  Returns a new hash map with supplied mappings.  If any keys are&lt;br&gt;  equal, they are handled as if by repeated uses of assoc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hash-map&amp;lt;br&amp;gt;  &amp;quot;keyval =&amp;gt; key val&amp;lt;br&amp;gt;  Returns a new hash map with supplied mappings.  If any keys are&amp;lt;br&amp;gt;  equal, they are handled as if by repeated uses of assoc.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([] {})&amp;lt;br&amp;gt;  ([&amp;amp; keyvals]&amp;lt;br&amp;gt;   (. clojure.lang.PersistentHashMap (create keyvals))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hash-map</a>[] [& keyvals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;hash-set&lt;/b&gt; ([] [&amp; keys])&lt;br&gt; Returns a new hash set with supplied keys.  Any equal keys are&lt;br&gt;  handled as if by repeated uses of conj.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hash-set&amp;lt;br&amp;gt;  &amp;quot;Returns a new hash set with supplied keys.  Any equal keys are&amp;lt;br&amp;gt;  handled as if by repeated uses of conj.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([] #{})&amp;lt;br&amp;gt;  ([&amp;amp; keys]&amp;lt;br&amp;gt;   (clojure.lang.PersistentHashSet/create keys)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hash-set</a>[] [& keys]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;identical?&lt;/b&gt; ([x y])&lt;br&gt; Tests if 2 arguments are the same object&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn identical?&amp;lt;br&amp;gt;  &amp;quot;Tests if 2 arguments are the same object&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Util identical ~x ~y))&amp;lt;br&amp;gt;   :inline-arities #{2}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([x y] (clojure.lang.Util/identical x y)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">identical?</a>[x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;identity&lt;/b&gt; ([x])&lt;br&gt; Returns its argument.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn identity&amp;lt;br&amp;gt;  &amp;quot;Returns its argument.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] x)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">identity</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;if-let&lt;/b&gt; ([bindings then] [bindings then else &amp; oldform])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; bindings =&gt; binding-form test&lt;br&gt;&lt;br&gt;  If test is true, evaluates then with binding-form bound to the value of &lt;br&gt;  test, if not, yields else&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro if-let&amp;lt;br&amp;gt;  &amp;quot;bindings =&amp;gt; binding-form test&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  If test is true, evaluates then with binding-form bound to the value of &amp;lt;br&amp;gt;  test, if not, yields else&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([bindings then]&amp;lt;br&amp;gt;   `(if-let ~bindings ~then nil))&amp;lt;br&amp;gt;  ([bindings then else &amp;amp; oldform]&amp;lt;br&amp;gt;   (assert-args&amp;lt;br&amp;gt;     (vector? bindings) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;     (nil? oldform) &amp;quot;1 or 2 forms after binding vector&amp;quot;&amp;lt;br&amp;gt;     (= 2 (count bindings)) &amp;quot;exactly 2 forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;   (let [form (bindings 0) tst (bindings 1)]&amp;lt;br&amp;gt;     `(let [temp# ~tst]&amp;lt;br&amp;gt;        (if temp#&amp;lt;br&amp;gt;          (let [~form temp#]&amp;lt;br&amp;gt;            ~then)&amp;lt;br&amp;gt;          ~else)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">if-let</a>[bindings then] [bindings then else & oldform]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;if-not&lt;/b&gt; ([test then] [test then else])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates test. If logical false, evaluates and returns then expr, &lt;br&gt;  otherwise else expr, if supplied, else nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro if-not&amp;lt;br&amp;gt;  &amp;quot;Evaluates test. If logical false, evaluates and returns then expr, &amp;lt;br&amp;gt;  otherwise else expr, if supplied, else nil.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([test then] `(if-not ~test ~then nil))&amp;lt;br&amp;gt;  ([test then else]&amp;lt;br&amp;gt;   `(if (not ~test) ~then ~else)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">if-not</a>[test then] [test then else]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ifn?&lt;/b&gt; ([x])&lt;br&gt; Returns true if x implements IFn. Note that many data structures&lt;br&gt;  (e.g. sets and maps) implement IFn&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ifn?&amp;lt;br&amp;gt;  &amp;quot;Returns true if x implements IFn. Note that many data structures&amp;lt;br&amp;gt;  (e.g. sets and maps) implement IFn&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (instance? clojure.lang.IFn x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ifn?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;import&lt;/b&gt; ([&amp; import-symbols-or-lists])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; import-list =&gt; (package-symbol class-name-symbols*)&lt;br&gt;&lt;br&gt;  For each name in class-name-symbols, adds a mapping from name to the&lt;br&gt;  class named by package.name to the current namespace. Use :import in the ns&lt;br&gt;  macro in preference to calling this directly.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro import &amp;lt;br&amp;gt;  &amp;quot;import-list =&amp;gt; (package-symbol class-name-symbols*)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  For each name in class-name-symbols, adds a mapping from name to the&amp;lt;br&amp;gt;  class named by package.name to the current namespace. Use :import in the ns&amp;lt;br&amp;gt;  macro in preference to calling this directly.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; import-symbols-or-lists]&amp;lt;br&amp;gt;  (let [specs (map #(if (and (seq? %) (= 'quote (first %))) (second %) %) &amp;lt;br&amp;gt;                   import-symbols-or-lists)]&amp;lt;br&amp;gt;    `(do ~@(map #(list 'clojure.core/import* %)&amp;lt;br&amp;gt;                (reduce1 (fn [v spec] &amp;lt;br&amp;gt;                          (if (symbol? spec)&amp;lt;br&amp;gt;                            (conj v (name spec))&amp;lt;br&amp;gt;                            (let [p (first spec) cs (rest spec)]&amp;lt;br&amp;gt;                              (into1 v (map #(str p &amp;quot;.&amp;quot; %) cs)))))&amp;lt;br&amp;gt;                        [] specs)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">import</a>[& import-symbols-or-lists]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;in-ns&lt;/b&gt; ([name])&lt;br&gt; Sets *ns* to the namespace named by the symbol, creating it if needed.&lt;/div&gt;" data-placement="right">in-ns</a>[name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;inc&lt;/b&gt; ([x])&lt;br&gt; Returns a number one greater than num. Does not auto-promote&lt;br&gt;  longs, will throw on overflow. See also: inc'&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn inc&amp;lt;br&amp;gt;  &amp;quot;Returns a number one greater than num. Does not auto-promote&amp;lt;br&amp;gt;  longs, will throw on overflow. See also: inc'&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x] `(. clojure.lang.Numbers (~(if *unchecked-math* 'unchecked_inc 'inc) ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (inc x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">inc</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;inc'&lt;/b&gt; ([x])&lt;br&gt; Returns a number one greater than num. Supports arbitrary precision.&lt;br&gt;  See also: inc&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn inc'&amp;lt;br&amp;gt;  &amp;quot;Returns a number one greater than num. Supports arbitrary precision.&amp;lt;br&amp;gt;  See also: inc&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x] `(. clojure.lang.Numbers (incP ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (incP x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">inc'</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;init-proxy&lt;/b&gt; ([proxy mappings])&lt;br&gt; Takes a proxy instance and a map of strings (which must&lt;br&gt;  correspond to methods of the proxy superclass/superinterfaces) to&lt;br&gt;  fns (which must take arguments matching the corresponding method,&lt;br&gt;  plus an additional (explicit) first arg corresponding to this, and&lt;br&gt;  sets the proxy's fn map.  Returns the proxy.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn init-proxy&amp;lt;br&amp;gt;  &amp;quot;Takes a proxy instance and a map of strings (which must&amp;lt;br&amp;gt;  correspond to methods of the proxy superclass/superinterfaces) to&amp;lt;br&amp;gt;  fns (which must take arguments matching the corresponding method,&amp;lt;br&amp;gt;  plus an additional (explicit) first arg corresponding to this, and&amp;lt;br&amp;gt;  sets the proxy's fn map.  Returns the proxy.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [^IProxy proxy mappings]&amp;lt;br&amp;gt;    (. proxy (__initClojureFnMappings mappings))&amp;lt;br&amp;gt;    proxy)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">init-proxy</a>[proxy mappings]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;instance?&lt;/b&gt; ([c x])&lt;br&gt; Evaluates x and tests if it is an instance of the class&lt;br&gt;    c. Returns true or false&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([^Class c x])&amp;lt;br&amp;gt;   :doc &amp;quot;Evaluates x and tests if it is an instance of the class&amp;lt;br&amp;gt;    c. Returns true or false&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt; instance? (fn instance? [^Class c x] (. c (isInstance x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">instance?</a>[c x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;int&lt;/b&gt; ([x])&lt;br&gt; Coerce to int&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn int&amp;lt;br&amp;gt;  &amp;quot;Coerce to int&amp;quot;&amp;lt;br&amp;gt;  {&amp;lt;br&amp;gt;   :inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedIntCast 'intCast) ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.RT (intCast x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">int</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;int-array&lt;/b&gt; ([size-or-seq] [size init-val-or-seq])&lt;br&gt; Creates an array of ints&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn int-array&amp;lt;br&amp;gt;  &amp;quot;Creates an array of ints&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [&amp;amp; args] `(. clojure.lang.Numbers int_array ~@args))&amp;lt;br&amp;gt;   :inline-arities #{1 2}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([size-or-seq] (. clojure.lang.Numbers int_array size-or-seq))&amp;lt;br&amp;gt;  ([size init-val-or-seq] (. clojure.lang.Numbers int_array size init-val-or-seq)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">int-array</a>[size-or-seq] [size init-val-or-seq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;integer?&lt;/b&gt; ([n])&lt;br&gt; Returns true if n is an integer&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn integer?&amp;lt;br&amp;gt;  &amp;quot;Returns true if n is an integer&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [n]&amp;lt;br&amp;gt;  (or (instance? Integer n)&amp;lt;br&amp;gt;      (instance? Long n)&amp;lt;br&amp;gt;      (instance? clojure.lang.BigInt n)&amp;lt;br&amp;gt;      (instance? BigInteger n)&amp;lt;br&amp;gt;      (instance? Short n)&amp;lt;br&amp;gt;      (instance? Byte n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">integer?</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;interleave&lt;/b&gt; ([c1 c2] [c1 c2 &amp; colls])&lt;br&gt; Returns a lazy seq of the first item in each coll, then the second etc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn interleave&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy seq of the first item in each coll, then the second etc.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([c1 c2]&amp;lt;br&amp;gt;     (lazy-seq&amp;lt;br&amp;gt;      (let [s1 (seq c1) s2 (seq c2)]&amp;lt;br&amp;gt;        (when (and s1 s2)&amp;lt;br&amp;gt;          (cons (first s1) (cons (first s2) &amp;lt;br&amp;gt;                                 (interleave (rest s1) (rest s2))))))))&amp;lt;br&amp;gt;  ([c1 c2 &amp;amp; colls] &amp;lt;br&amp;gt;     (lazy-seq &amp;lt;br&amp;gt;      (let [ss (map seq (conj colls c2 c1))]&amp;lt;br&amp;gt;        (when (every? identity ss)&amp;lt;br&amp;gt;          (concat (map first ss) (apply interleave (map rest ss))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">interleave</a>[c1 c2] [c1 c2 & colls]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;intern&lt;/b&gt; ([ns name] [ns name val])&lt;br&gt; Finds or creates a var named by the symbol name in the namespace&lt;br&gt;  ns (which can be a symbol or a namespace), setting its root binding&lt;br&gt;  to val if supplied. The namespace must exist. The var will adopt any&lt;br&gt;  metadata from the name symbol.  Returns the var.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn intern&amp;lt;br&amp;gt;  &amp;quot;Finds or creates a var named by the symbol name in the namespace&amp;lt;br&amp;gt;  ns (which can be a symbol or a namespace), setting its root binding&amp;lt;br&amp;gt;  to val if supplied. The namespace must exist. The var will adopt any&amp;lt;br&amp;gt;  metadata from the name symbol.  Returns the var.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([ns ^clojure.lang.Symbol name]&amp;lt;br&amp;gt;     (let [v (clojure.lang.Var/intern (the-ns ns) name)]&amp;lt;br&amp;gt;       (when (meta name) (.setMeta v (meta name)))&amp;lt;br&amp;gt;       v))&amp;lt;br&amp;gt;  ([ns name val]&amp;lt;br&amp;gt;     (let [v (clojure.lang.Var/intern (the-ns ns) name val)]&amp;lt;br&amp;gt;       (when (meta name) (.setMeta v (meta name)))&amp;lt;br&amp;gt;       v)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">intern</a>[ns name] [ns name val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;interpose&lt;/b&gt; ([sep coll])&lt;br&gt; Returns a lazy seq of the elements of coll separated by sep&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn interpose&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy seq of the elements of coll separated by sep&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [sep coll] (drop 1 (interleave (repeat sep) coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">interpose</a>[sep coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;into&lt;/b&gt; ([to from])&lt;br&gt; Returns a new coll consisting of to-coll with all of the items of&lt;br&gt;  from-coll conjoined.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn into&amp;lt;br&amp;gt;  &amp;quot;Returns a new coll consisting of to-coll with all of the items of&amp;lt;br&amp;gt;  from-coll conjoined.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [to from]&amp;lt;br&amp;gt;  (if (instance? clojure.lang.IEditableCollection to)&amp;lt;br&amp;gt;    (with-meta (persistent! (reduce conj! (transient to) from)) (meta to))&amp;lt;br&amp;gt;    (reduce conj to from)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">into</a>[to from]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;into-array&lt;/b&gt; ([aseq] [type aseq])&lt;br&gt; Returns an array with components set to the values in aseq. The array's&lt;br&gt;  component type is type if provided, or the type of the first value in&lt;br&gt;  aseq if present, or Object. All values in aseq must be compatible with&lt;br&gt;  the component type. Class objects for the primitive types can be obtained&lt;br&gt;  using, e.g., Integer/TYPE.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn into-array&amp;lt;br&amp;gt;  &amp;quot;Returns an array with components set to the values in aseq. The array's&amp;lt;br&amp;gt;  component type is type if provided, or the type of the first value in&amp;lt;br&amp;gt;  aseq if present, or Object. All values in aseq must be compatible with&amp;lt;br&amp;gt;  the component type. Class objects for the primitive types can be obtained&amp;lt;br&amp;gt;  using, e.g., Integer/TYPE.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([aseq]&amp;lt;br&amp;gt;     (clojure.lang.RT/seqToTypedArray (seq aseq)))&amp;lt;br&amp;gt;  ([type aseq]&amp;lt;br&amp;gt;     (clojure.lang.RT/seqToTypedArray type (seq aseq))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">into-array</a>[aseq] [type aseq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ints&lt;/b&gt; ([xs])&lt;br&gt; Casts to int[]&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(definline ints&amp;lt;br&amp;gt;  &amp;quot;Casts to int[]&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [xs] `(. clojure.lang.Numbers ints ~xs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ints</a>[xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;io!&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; If an io! block occurs in a transaction, throws an&lt;br&gt;  IllegalStateException, else runs body in an implicit do. If the&lt;br&gt;  first expression in body is a literal string, will use that as the&lt;br&gt;  exception message.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro io!&amp;lt;br&amp;gt;  &amp;quot;If an io! block occurs in a transaction, throws an&amp;lt;br&amp;gt;  IllegalStateException, else runs body in an implicit do. If the&amp;lt;br&amp;gt;  first expression in body is a literal string, will use that as the&amp;lt;br&amp;gt;  exception message.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;  (let [message (when (string? (first body)) (first body))&amp;lt;br&amp;gt;        body (if message (next body) body)]&amp;lt;br&amp;gt;    `(if (clojure.lang.LockingTransaction/isRunning)&amp;lt;br&amp;gt;       (throw (new IllegalStateException ~(or message &amp;quot;I/O in transaction&amp;quot;)))&amp;lt;br&amp;gt;       (do ~@body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">io!</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;isa?&lt;/b&gt; ([child parent] [h child parent])&lt;br&gt; Returns true if (= child parent), or child is directly or indirectly derived from&lt;br&gt;  parent, either via a Java type inheritance relationship or a&lt;br&gt;  relationship established via derive. h must be a hierarchy obtained&lt;br&gt;  from make-hierarchy, if not supplied defaults to the global&lt;br&gt;  hierarchy&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn isa?&amp;lt;br&amp;gt;  &amp;quot;Returns true if (= child parent), or child is directly or indirectly derived from&amp;lt;br&amp;gt;  parent, either via a Java type inheritance relationship or a&amp;lt;br&amp;gt;  relationship established via derive. h must be a hierarchy obtained&amp;lt;br&amp;gt;  from make-hierarchy, if not supplied defaults to the global&amp;lt;br&amp;gt;  hierarchy&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([child parent] (isa? global-hierarchy child parent))&amp;lt;br&amp;gt;  ([h child parent]&amp;lt;br&amp;gt;   (or (= child parent)&amp;lt;br&amp;gt;       (and (class? parent) (class? child)&amp;lt;br&amp;gt;            (. ^Class parent isAssignableFrom child))&amp;lt;br&amp;gt;       (contains? ((:ancestors h) child) parent)&amp;lt;br&amp;gt;       (and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))&amp;lt;br&amp;gt;       (and (vector? parent) (vector? child)&amp;lt;br&amp;gt;            (= (count parent) (count child))&amp;lt;br&amp;gt;            (loop [ret true i 0]&amp;lt;br&amp;gt;              (if (or (not ret) (= i (count parent)))&amp;lt;br&amp;gt;                ret&amp;lt;br&amp;gt;                (recur (isa? h (child i) (parent i)) (inc i))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">isa?</a>[child parent] [h child parent]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;iterate&lt;/b&gt; ([f x])&lt;br&gt; Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn iterate&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [f x] (cons x (lazy-seq (iterate f (f x)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">iterate</a>[f x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;iterator-seq&lt;/b&gt; ([iter])&lt;br&gt; Returns a seq on a java.util.Iterator. Note that most collections&lt;br&gt;  providing iterators implement Iterable and thus support seq directly.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn iterator-seq&amp;lt;br&amp;gt;  &amp;quot;Returns a seq on a java.util.Iterator. Note that most collections&amp;lt;br&amp;gt;  providing iterators implement Iterable and thus support seq directly.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [iter]&amp;lt;br&amp;gt;  (clojure.lang.IteratorSeq/create iter))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">iterator-seq</a>[iter]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;juxt&lt;/b&gt; ([f] [f g] [f g h] [f g h &amp; fs])&lt;br&gt; Takes a set of functions and returns a fn that is the juxtaposition&lt;br&gt;  of those fns.  The returned fn takes a variable number of args, and&lt;br&gt;  returns a vector containing the result of applying each fn to the&lt;br&gt;  args (left-to-right).&lt;br&gt;  ((juxt a b c) x) =&gt; [(a x) (b x) (c x)]&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn juxt &amp;lt;br&amp;gt;  &amp;quot;Takes a set of functions and returns a fn that is the juxtaposition&amp;lt;br&amp;gt;  of those fns.  The returned fn takes a variable number of args, and&amp;lt;br&amp;gt;  returns a vector containing the result of applying each fn to the&amp;lt;br&amp;gt;  args (left-to-right).&amp;lt;br&amp;gt;  ((juxt a b c) x) =&amp;gt; [(a x) (b x) (c x)]&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([f] &amp;lt;br&amp;gt;     (fn&amp;lt;br&amp;gt;       ([] [(f)])&amp;lt;br&amp;gt;       ([x] [(f x)])&amp;lt;br&amp;gt;       ([x y] [(f x y)])&amp;lt;br&amp;gt;       ([x y z] [(f x y z)])&amp;lt;br&amp;gt;       ([x y z &amp;amp; args] [(apply f x y z args)])))&amp;lt;br&amp;gt;  ([f g] &amp;lt;br&amp;gt;     (fn&amp;lt;br&amp;gt;       ([] [(f) (g)])&amp;lt;br&amp;gt;       ([x] [(f x) (g x)])&amp;lt;br&amp;gt;       ([x y] [(f x y) (g x y)])&amp;lt;br&amp;gt;       ([x y z] [(f x y z) (g x y z)])&amp;lt;br&amp;gt;       ([x y z &amp;amp; args] [(apply f x y z args) (apply g x y z args)])))&amp;lt;br&amp;gt;  ([f g h] &amp;lt;br&amp;gt;     (fn&amp;lt;br&amp;gt;       ([] [(f) (g) (h)])&amp;lt;br&amp;gt;       ([x] [(f x) (g x) (h x)])&amp;lt;br&amp;gt;       ([x y] [(f x y) (g x y) (h x y)])&amp;lt;br&amp;gt;       ([x y z] [(f x y z) (g x y z) (h x y z)])&amp;lt;br&amp;gt;       ([x y z &amp;amp; args] [(apply f x y z args) (apply g x y z args) (apply h x y z args)])))&amp;lt;br&amp;gt;  ([f g h &amp;amp; fs]&amp;lt;br&amp;gt;     (let [fs (list* f g h fs)]&amp;lt;br&amp;gt;       (fn&amp;lt;br&amp;gt;         ([] (reduce1 #(conj %1 (%2)) [] fs))&amp;lt;br&amp;gt;         ([x] (reduce1 #(conj %1 (%2 x)) [] fs))&amp;lt;br&amp;gt;         ([x y] (reduce1 #(conj %1 (%2 x y)) [] fs))&amp;lt;br&amp;gt;         ([x y z] (reduce1 #(conj %1 (%2 x y z)) [] fs))&amp;lt;br&amp;gt;         ([x y z &amp;amp; args] (reduce1 #(conj %1 (apply %2 x y z args)) [] fs))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">juxt</a>[f] [f g] [f g h] [f g h & fs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;keep&lt;/b&gt; ([f coll])&lt;br&gt; Returns a lazy sequence of the non-nil results of (f item). Note,&lt;br&gt;  this means false return values will be included.  f must be free of&lt;br&gt;  side-effects.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn keep&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of the non-nil results of (f item). Note,&amp;lt;br&amp;gt;  this means false return values will be included.  f must be free of&amp;lt;br&amp;gt;  side-effects.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([f coll]&amp;lt;br&amp;gt;   (lazy-seq&amp;lt;br&amp;gt;    (when-let [s (seq coll)]&amp;lt;br&amp;gt;      (if (chunked-seq? s)&amp;lt;br&amp;gt;        (let [c (chunk-first s)&amp;lt;br&amp;gt;              size (count c)&amp;lt;br&amp;gt;              b (chunk-buffer size)]&amp;lt;br&amp;gt;          (dotimes [i size]&amp;lt;br&amp;gt;            (let [x (f (.nth c i))]&amp;lt;br&amp;gt;              (when-not (nil? x)&amp;lt;br&amp;gt;                (chunk-append b x))))&amp;lt;br&amp;gt;          (chunk-cons (chunk b) (keep f (chunk-rest s))))&amp;lt;br&amp;gt;        (let [x (f (first s))]&amp;lt;br&amp;gt;          (if (nil? x)&amp;lt;br&amp;gt;            (keep f (rest s))&amp;lt;br&amp;gt;            (cons x (keep f (rest s))))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">keep</a>[f coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;keep-indexed&lt;/b&gt; ([f coll])&lt;br&gt; Returns a lazy sequence of the non-nil results of (f index item). Note,&lt;br&gt;  this means false return values will be included.  f must be free of&lt;br&gt;  side-effects.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn keep-indexed&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of the non-nil results of (f index item). Note,&amp;lt;br&amp;gt;  this means false return values will be included.  f must be free of&amp;lt;br&amp;gt;  side-effects.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([f coll]&amp;lt;br&amp;gt;     (letfn [(keepi [idx coll]&amp;lt;br&amp;gt;               (lazy-seq&amp;lt;br&amp;gt;                (when-let [s (seq coll)]&amp;lt;br&amp;gt;                  (if (chunked-seq? s)&amp;lt;br&amp;gt;                    (let [c (chunk-first s)&amp;lt;br&amp;gt;                          size (count c)&amp;lt;br&amp;gt;                          b (chunk-buffer size)]&amp;lt;br&amp;gt;                      (dotimes [i size]&amp;lt;br&amp;gt;                        (let [x (f (+ idx i) (.nth c i))]&amp;lt;br&amp;gt;                          (when-not (nil? x)&amp;lt;br&amp;gt;                            (chunk-append b x))))&amp;lt;br&amp;gt;                      (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))&amp;lt;br&amp;gt;                    (let [x (f idx (first s))]&amp;lt;br&amp;gt;                      (if (nil? x)&amp;lt;br&amp;gt;                        (keepi (inc idx) (rest s))&amp;lt;br&amp;gt;                        (cons x (keepi (inc idx) (rest s)))))))))]&amp;lt;br&amp;gt;       (keepi 0 coll))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">keep-indexed</a>[f coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;key&lt;/b&gt; ([e])&lt;br&gt; Returns the key of the map entry.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn key&amp;lt;br&amp;gt;  &amp;quot;Returns the key of the map entry.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^java.util.Map$Entry e]&amp;lt;br&amp;gt;    (. e (getKey)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">key</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;keys&lt;/b&gt; ([map])&lt;br&gt; Returns a sequence of the map's keys.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn keys&amp;lt;br&amp;gt;  &amp;quot;Returns a sequence of the map's keys.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [map] (. clojure.lang.RT (keys map)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">keys</a>[map]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;keyword&lt;/b&gt; ([name] [ns name])&lt;br&gt; Returns a Keyword with the given namespace and name.  Do not use :&lt;br&gt;  in the keyword strings, it will be added automatically.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn keyword&amp;lt;br&amp;gt;  &amp;quot;Returns a Keyword with the given namespace and name.  Do not use :&amp;lt;br&amp;gt;  in the keyword strings, it will be added automatically.&amp;quot;&amp;lt;br&amp;gt;  {:tag clojure.lang.Keyword&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([name] (cond (keyword? name) name&amp;lt;br&amp;gt;                (symbol? name) (clojure.lang.Keyword/intern ^clojure.lang.Symbol name)&amp;lt;br&amp;gt;                (string? name) (clojure.lang.Keyword/intern ^String name)))&amp;lt;br&amp;gt;  ([ns name] (clojure.lang.Keyword/intern ns name)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">keyword</a>[name] [ns name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;keyword?&lt;/b&gt; ([x])&lt;br&gt; Return true if x is a Keyword&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn keyword?&amp;lt;br&amp;gt;  &amp;quot;Return true if x is a Keyword&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (instance? clojure.lang.Keyword x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">keyword?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;last&lt;/b&gt; ([coll])&lt;br&gt; Return the last item in coll, in linear time&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def &amp;lt;br&amp;gt; ^{:arglists '([coll])&amp;lt;br&amp;gt;   :doc &amp;quot;Return the last item in coll, in linear time&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; last (fn ^:static last [s]&amp;lt;br&amp;gt;        (if (next s)&amp;lt;br&amp;gt;          (recur (next s))&amp;lt;br&amp;gt;          (first s))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">last</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;lazy-cat&lt;/b&gt; ([&amp; colls])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Expands to code which yields a lazy sequence of the concatenation&lt;br&gt;  of the supplied colls.  Each coll expr is not evaluated until it is&lt;br&gt;  needed. &lt;br&gt;&lt;br&gt;  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro lazy-cat&amp;lt;br&amp;gt;  &amp;quot;Expands to code which yields a lazy sequence of the concatenation&amp;lt;br&amp;gt;  of the supplied colls.  Each coll expr is not evaluated until it is&amp;lt;br&amp;gt;  needed. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; colls]&amp;lt;br&amp;gt;  `(concat ~@(map #(list `lazy-seq %) colls)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lazy-cat</a>[& colls]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;lazy-seq&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Takes a body of expressions that returns an ISeq or nil, and yields&lt;br&gt;  a Seqable object that will invoke the body only the first time seq&lt;br&gt;  is called, and will cache the result and return it on all subsequent&lt;br&gt;  seq calls. See also - realized?&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro lazy-seq&amp;lt;br&amp;gt;  &amp;quot;Takes a body of expressions that returns an ISeq or nil, and yields&amp;lt;br&amp;gt;  a Seqable object that will invoke the body only the first time seq&amp;lt;br&amp;gt;  is called, and will cache the result and return it on all subsequent&amp;lt;br&amp;gt;  seq calls. See also - realized?&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;  (list 'new 'clojure.lang.LazySeq (list* '^{:once true} fn* [] body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lazy-seq</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;let&lt;/b&gt; ((let [bindings*] exprs*))&lt;br&gt;&lt;i&gt;Special Form&lt;/i&gt; binding =&gt; binding-form init-expr&lt;br&gt;&lt;br&gt;  Evaluates the exprs in a lexical context in which the symbols in&lt;br&gt;  the binding-forms are bound to their respective init-exprs or parts&lt;br&gt;  therein.&lt;br&gt;&lt;br&gt;  Please see http://clojure.org/special_forms#let&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro let&amp;lt;br&amp;gt;  &amp;quot;binding =&amp;gt; binding-form init-expr&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Evaluates the exprs in a lexical context in which the symbols in&amp;lt;br&amp;gt;  the binding-forms are bound to their respective init-exprs or parts&amp;lt;br&amp;gt;  therein.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;, :special-form true, :forms '[(let [bindings*] exprs*)]}&amp;lt;br&amp;gt;  [bindings &amp;amp; body]&amp;lt;br&amp;gt;  (assert-args&amp;lt;br&amp;gt;     (vector? bindings) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;     (even? (count bindings)) &amp;quot;an even number of forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;  `(let* ~(destructure bindings) ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">let</a>(let [bindings*] exprs*)</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;letfn&lt;/b&gt; ((letfn [fnspecs*] exprs*))&lt;br&gt;&lt;i&gt;Special Form&lt;/i&gt; fnspec ==&gt; (fname [params*] exprs) or (fname ([params*] exprs)+)&lt;br&gt;&lt;br&gt;  Takes a vector of function specs and a body, and generates a set of&lt;br&gt;  bindings of functions to their names. All of the names are available&lt;br&gt;  in all of the definitions of the functions, as well as the body.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro letfn &amp;lt;br&amp;gt;  &amp;quot;fnspec ==&amp;gt; (fname [params*] exprs) or (fname ([params*] exprs)+)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Takes a vector of function specs and a body, and generates a set of&amp;lt;br&amp;gt;  bindings of functions to their names. All of the names are available&amp;lt;br&amp;gt;  in all of the definitions of the functions, as well as the body.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;, :forms '[(letfn [fnspecs*] exprs*)],&amp;lt;br&amp;gt;   :special-form true, :url nil}&amp;lt;br&amp;gt;  [fnspecs &amp;amp; body] &amp;lt;br&amp;gt;  `(letfn* ~(vec (interleave (map first fnspecs) &amp;lt;br&amp;gt;                             (map #(cons `fn %) fnspecs)))&amp;lt;br&amp;gt;           ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">letfn</a>(letfn [fnspecs*] exprs*)</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;line-seq&lt;/b&gt; ([rdr])&lt;br&gt; Returns the lines of text from rdr as a lazy sequence of strings.&lt;br&gt;  rdr must implement java.io.BufferedReader.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn line-seq&amp;lt;br&amp;gt;  &amp;quot;Returns the lines of text from rdr as a lazy sequence of strings.&amp;lt;br&amp;gt;  rdr must implement java.io.BufferedReader.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^java.io.BufferedReader rdr]&amp;lt;br&amp;gt;  (when-let [line (.readLine rdr)]&amp;lt;br&amp;gt;    (cons line (lazy-seq (line-seq rdr)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">line-seq</a>[rdr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;list&lt;/b&gt; ([&amp; items])&lt;br&gt; Creates a new list containing the items.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([&amp;amp; items])&amp;lt;br&amp;gt;   :doc &amp;quot;Creates a new list containing the items.&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  list (. clojure.lang.PersistentList creator))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">list</a>[& items]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;list*&lt;/b&gt; ([args] [a args] [a b args] [a b c args] [a b c d &amp; more])&lt;br&gt; Creates a new list containing the items prepended to the rest, the&lt;br&gt;  last of which will be treated as a sequence.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn list*&amp;lt;br&amp;gt;  &amp;quot;Creates a new list containing the items prepended to the rest, the&amp;lt;br&amp;gt;  last of which will be treated as a sequence.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([args] (seq args))&amp;lt;br&amp;gt;  ([a args] (cons a args))&amp;lt;br&amp;gt;  ([a b args] (cons a (cons b args)))&amp;lt;br&amp;gt;  ([a b c args] (cons a (cons b (cons c args))))&amp;lt;br&amp;gt;  ([a b c d &amp;amp; more]&amp;lt;br&amp;gt;     (cons a (cons b (cons c (cons d (spread more)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">list*</a>[args] [a args] [a b args] [a b c args] [a b c d & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;list?&lt;/b&gt; ([x])&lt;br&gt; Returns true if x implements IPersistentList&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn list?&amp;lt;br&amp;gt;  &amp;quot;Returns true if x implements IPersistentList&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (instance? clojure.lang.IPersistentList x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">list?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;load&lt;/b&gt; ([&amp; paths])&lt;br&gt; Loads Clojure code from resources in classpath. A path is interpreted as&lt;br&gt;  classpath-relative if it begins with a slash or relative to the root&lt;br&gt;  directory for the current namespace otherwise.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn load&amp;lt;br&amp;gt;  &amp;quot;Loads Clojure code from resources in classpath. A path is interpreted as&amp;lt;br&amp;gt;  classpath-relative if it begins with a slash or relative to the root&amp;lt;br&amp;gt;  directory for the current namespace otherwise.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; paths]&amp;lt;br&amp;gt;  (doseq [^String path paths]&amp;lt;br&amp;gt;    (let [^String path (if (.startsWith path &amp;quot;/&amp;quot;)&amp;lt;br&amp;gt;                          path&amp;lt;br&amp;gt;                          (str (root-directory (ns-name *ns*)) \/ path))]&amp;lt;br&amp;gt;      (when *loading-verbosely*&amp;lt;br&amp;gt;        (printf &amp;quot;(clojure.core/load \&amp;quot;%s\&amp;quot;)\n&amp;quot; path)&amp;lt;br&amp;gt;        (flush))&amp;lt;br&amp;gt;      (check-cyclic-dependency path)&amp;lt;br&amp;gt;      (when-not (= path (first *pending-paths*))&amp;lt;br&amp;gt;        (binding [*pending-paths* (conj *pending-paths* path)]&amp;lt;br&amp;gt;          (clojure.lang.RT/load (.substring path 1)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">load</a>[& paths]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;load-file&lt;/b&gt; ([name])&lt;br&gt; Sequentially read and evaluate the set of forms contained in the file.&lt;/div&gt;" data-placement="right">load-file</a>[name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;load-reader&lt;/b&gt; ([rdr])&lt;br&gt; Sequentially read and evaluate the set of forms contained in the&lt;br&gt;  stream/file&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn load-reader&amp;lt;br&amp;gt;  &amp;quot;Sequentially read and evaluate the set of forms contained in the&amp;lt;br&amp;gt;  stream/file&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [rdr] (. clojure.lang.Compiler (load rdr)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">load-reader</a>[rdr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;load-string&lt;/b&gt; ([s])&lt;br&gt; Sequentially read and evaluate the set of forms contained in the&lt;br&gt;  string&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn load-string&amp;lt;br&amp;gt;  &amp;quot;Sequentially read and evaluate the set of forms contained in the&amp;lt;br&amp;gt;  string&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [s]&amp;lt;br&amp;gt;  (let [rdr (-&amp;gt; (java.io.StringReader. s)&amp;lt;br&amp;gt;                (clojure.lang.LineNumberingPushbackReader.))]&amp;lt;br&amp;gt;    (load-reader rdr)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">load-string</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;loaded-libs&lt;/b&gt; ([])&lt;br&gt; Returns a sorted set of symbols naming the currently loaded libs&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn loaded-libs&amp;lt;br&amp;gt;  &amp;quot;Returns a sorted set of symbols naming the currently loaded libs&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [] @*loaded-libs*)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">loaded-libs</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;locking&lt;/b&gt; ([x &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Executes exprs in an implicit do, while holding the monitor of x.&lt;br&gt;  Will release the monitor of x in all circumstances.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro locking&amp;lt;br&amp;gt;  &amp;quot;Executes exprs in an implicit do, while holding the monitor of x.&amp;lt;br&amp;gt;  Will release the monitor of x in all circumstances.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x &amp;amp; body]&amp;lt;br&amp;gt;  `(let [lockee# ~x]&amp;lt;br&amp;gt;     (try&amp;lt;br&amp;gt;      (monitor-enter lockee#)&amp;lt;br&amp;gt;      ~@body&amp;lt;br&amp;gt;      (finally&amp;lt;br&amp;gt;       (monitor-exit lockee#)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">locking</a>[x & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;long&lt;/b&gt; ([x])&lt;br&gt; Coerce to long&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn long&amp;lt;br&amp;gt;  &amp;quot;Coerce to long&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (longCast ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [^Number x] (clojure.lang.RT/longCast x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">long</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;long-array&lt;/b&gt; ([size-or-seq] [size init-val-or-seq])&lt;br&gt; Creates an array of longs&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn long-array&amp;lt;br&amp;gt;  &amp;quot;Creates an array of longs&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [&amp;amp; args] `(. clojure.lang.Numbers long_array ~@args))&amp;lt;br&amp;gt;   :inline-arities #{1 2}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([size-or-seq] (. clojure.lang.Numbers long_array size-or-seq))&amp;lt;br&amp;gt;  ([size init-val-or-seq] (. clojure.lang.Numbers long_array size init-val-or-seq)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">long-array</a>[size-or-seq] [size init-val-or-seq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;longs&lt;/b&gt; ([xs])&lt;br&gt; Casts to long[]&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(definline longs&amp;lt;br&amp;gt;  &amp;quot;Casts to long[]&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [xs] `(. clojure.lang.Numbers longs ~xs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">longs</a>[xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;loop&lt;/b&gt; ((loop [bindings*] exprs*))&lt;br&gt;&lt;i&gt;Special Form&lt;/i&gt; Evaluates the exprs in a lexical context in which the symbols in&lt;br&gt;  the binding-forms are bound to their respective init-exprs or parts&lt;br&gt;  therein. Acts as a recur target.&lt;br&gt;&lt;br&gt;  Please see http://clojure.org/special_forms#loop&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro loop&amp;lt;br&amp;gt;  &amp;quot;Evaluates the exprs in a lexical context in which the symbols in&amp;lt;br&amp;gt;  the binding-forms are bound to their respective init-exprs or parts&amp;lt;br&amp;gt;  therein. Acts as a recur target.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;, :special-form true, :forms '[(loop [bindings*] exprs*)]}&amp;lt;br&amp;gt;  [bindings &amp;amp; body]&amp;lt;br&amp;gt;    (assert-args&amp;lt;br&amp;gt;      (vector? bindings) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;      (even? (count bindings)) &amp;quot;an even number of forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;    (let [db (destructure bindings)]&amp;lt;br&amp;gt;      (if (= db bindings)&amp;lt;br&amp;gt;        `(loop* ~bindings ~@body)&amp;lt;br&amp;gt;        (let [vs (take-nth 2 (drop 1 bindings))&amp;lt;br&amp;gt;              bs (take-nth 2 bindings)&amp;lt;br&amp;gt;              gs (map (fn [b] (if (symbol? b) b (gensym))) bs)&amp;lt;br&amp;gt;              bfs (reduce1 (fn [ret [b v g]]&amp;lt;br&amp;gt;                            (if (symbol? b)&amp;lt;br&amp;gt;                              (conj ret g v)&amp;lt;br&amp;gt;                              (conj ret g v b g)))&amp;lt;br&amp;gt;                          [] (map vector bs vs gs))]&amp;lt;br&amp;gt;          `(let ~bfs&amp;lt;br&amp;gt;             (loop* ~(vec (interleave gs gs))&amp;lt;br&amp;gt;               (let ~(vec (interleave bs gs))&amp;lt;br&amp;gt;                 ~@body)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">loop</a>(loop [bindings*] exprs*)</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;macroexpand&lt;/b&gt; ([form])&lt;br&gt; Repeatedly calls macroexpand-1 on form until it no longer&lt;br&gt;  represents a macro form, then returns it.  Note neither&lt;br&gt;  macroexpand-1 nor macroexpand expand macros in subforms.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn macroexpand&amp;lt;br&amp;gt;  &amp;quot;Repeatedly calls macroexpand-1 on form until it no longer&amp;lt;br&amp;gt;  represents a macro form, then returns it.  Note neither&amp;lt;br&amp;gt;  macroexpand-1 nor macroexpand expand macros in subforms.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;    (let [ex (macroexpand-1 form)]&amp;lt;br&amp;gt;      (if (identical? ex form)&amp;lt;br&amp;gt;        form&amp;lt;br&amp;gt;        (macroexpand ex))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">macroexpand</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;macroexpand-1&lt;/b&gt; ([form])&lt;br&gt; If form represents a macro form, returns its expansion,&lt;br&gt;  else returns form.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn macroexpand-1&amp;lt;br&amp;gt;  &amp;quot;If form represents a macro form, returns its expansion,&amp;lt;br&amp;gt;  else returns form.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;    (. clojure.lang.Compiler (macroexpand1 form)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">macroexpand-1</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;make-array&lt;/b&gt; ([type len] [type dim &amp; more-dims])&lt;br&gt; Creates and returns an array of instances of the specified class of&lt;br&gt;  the specified dimension(s).  Note that a class object is required.&lt;br&gt;  Class objects can be obtained by using their imported or&lt;br&gt;  fully-qualified name.  Class objects for the primitive types can be&lt;br&gt;  obtained using, e.g., Integer/TYPE.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-array&amp;lt;br&amp;gt;  &amp;quot;Creates and returns an array of instances of the specified class of&amp;lt;br&amp;gt;  the specified dimension(s).  Note that a class object is required.&amp;lt;br&amp;gt;  Class objects can be obtained by using their imported or&amp;lt;br&amp;gt;  fully-qualified name.  Class objects for the primitive types can be&amp;lt;br&amp;gt;  obtained using, e.g., Integer/TYPE.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([^Class type len]&amp;lt;br&amp;gt;   (. Array (newInstance type (int len))))&amp;lt;br&amp;gt;  ([^Class type dim &amp;amp; more-dims]&amp;lt;br&amp;gt;   (let [dims (cons dim more-dims)&amp;lt;br&amp;gt;         ^&amp;quot;[I&amp;quot; dimarray (make-array (. Integer TYPE)  (count dims))]&amp;lt;br&amp;gt;     (dotimes [i (alength dimarray)]&amp;lt;br&amp;gt;       (aset-int dimarray i (nth dims i)))&amp;lt;br&amp;gt;     (. Array (newInstance type dimarray)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-array</a>[type len] [type dim & more-dims]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;make-hierarchy&lt;/b&gt; ([])&lt;br&gt; Creates a hierarchy object for use with derive, isa? etc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-hierarchy&amp;lt;br&amp;gt;  &amp;quot;Creates a hierarchy object for use with derive, isa? etc.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [] {:parents {} :descendants {} :ancestors {}})&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-hierarchy</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;map&lt;/b&gt; ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 &amp; colls])&lt;br&gt; Returns a lazy sequence consisting of the result of applying f to the&lt;br&gt;  set of first items of each coll, followed by applying f to the set&lt;br&gt;  of second items in each coll, until any one of the colls is&lt;br&gt;  exhausted.  Any remaining items in other colls are ignored. Function&lt;br&gt;  f should accept number-of-colls arguments.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn map&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence consisting of the result of applying f to the&amp;lt;br&amp;gt;  set of first items of each coll, followed by applying f to the set&amp;lt;br&amp;gt;  of second items in each coll, until any one of the colls is&amp;lt;br&amp;gt;  exhausted.  Any remaining items in other colls are ignored. Function&amp;lt;br&amp;gt;  f should accept number-of-colls arguments.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([f coll]&amp;lt;br&amp;gt;   (lazy-seq&amp;lt;br&amp;gt;    (when-let [s (seq coll)]&amp;lt;br&amp;gt;      (if (chunked-seq? s)&amp;lt;br&amp;gt;        (let [c (chunk-first s)&amp;lt;br&amp;gt;              size (int (count c))&amp;lt;br&amp;gt;              b (chunk-buffer size)]&amp;lt;br&amp;gt;          (dotimes [i size]&amp;lt;br&amp;gt;              (chunk-append b (f (.nth c i))))&amp;lt;br&amp;gt;          (chunk-cons (chunk b) (map f (chunk-rest s))))&amp;lt;br&amp;gt;        (cons (f (first s)) (map f (rest s)))))))&amp;lt;br&amp;gt;  ([f c1 c2]&amp;lt;br&amp;gt;   (lazy-seq&amp;lt;br&amp;gt;    (let [s1 (seq c1) s2 (seq c2)]&amp;lt;br&amp;gt;      (when (and s1 s2)&amp;lt;br&amp;gt;        (cons (f (first s1) (first s2))&amp;lt;br&amp;gt;              (map f (rest s1) (rest s2)))))))&amp;lt;br&amp;gt;  ([f c1 c2 c3]&amp;lt;br&amp;gt;   (lazy-seq&amp;lt;br&amp;gt;    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]&amp;lt;br&amp;gt;      (when (and  s1 s2 s3)&amp;lt;br&amp;gt;        (cons (f (first s1) (first s2) (first s3))&amp;lt;br&amp;gt;              (map f (rest s1) (rest s2) (rest s3)))))))&amp;lt;br&amp;gt;  ([f c1 c2 c3 &amp;amp; colls]&amp;lt;br&amp;gt;   (let [step (fn step [cs]&amp;lt;br&amp;gt;                 (lazy-seq&amp;lt;br&amp;gt;                  (let [ss (map seq cs)]&amp;lt;br&amp;gt;                    (when (every? identity ss)&amp;lt;br&amp;gt;                      (cons (map first ss) (step (map rest ss)))))))]&amp;lt;br&amp;gt;     (map #(apply f %) (step (conj colls c3 c2 c1))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map</a>[f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;map-indexed&lt;/b&gt; ([f coll])&lt;br&gt; Returns a lazy sequence consisting of the result of applying f to 0&lt;br&gt;  and the first item of coll, followed by applying f to 1 and the second&lt;br&gt;  item in coll, etc, until coll is exhausted. Thus function f should&lt;br&gt;  accept 2 arguments, index and item.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn map-indexed&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence consisting of the result of applying f to 0&amp;lt;br&amp;gt;  and the first item of coll, followed by applying f to 1 and the second&amp;lt;br&amp;gt;  item in coll, etc, until coll is exhausted. Thus function f should&amp;lt;br&amp;gt;  accept 2 arguments, index and item.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [f coll]&amp;lt;br&amp;gt;  (letfn [(mapi [idx coll]&amp;lt;br&amp;gt;            (lazy-seq&amp;lt;br&amp;gt;             (when-let [s (seq coll)]&amp;lt;br&amp;gt;               (if (chunked-seq? s)&amp;lt;br&amp;gt;                 (let [c (chunk-first s)&amp;lt;br&amp;gt;                       size (int (count c))&amp;lt;br&amp;gt;                       b (chunk-buffer size)]&amp;lt;br&amp;gt;                   (dotimes [i size]&amp;lt;br&amp;gt;                     (chunk-append b (f (+ idx i) (.nth c i))))&amp;lt;br&amp;gt;                   (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))&amp;lt;br&amp;gt;                 (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]&amp;lt;br&amp;gt;    (mapi 0 coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map-indexed</a>[f coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;map?&lt;/b&gt; ([x])&lt;br&gt; Return true if x implements IPersistentMap&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([x])&amp;lt;br&amp;gt;   :doc &amp;quot;Return true if x implements IPersistentMap&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; map? (fn ^:static map? [x] (instance? clojure.lang.IPersistentMap x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;mapcat&lt;/b&gt; ([f &amp; colls])&lt;br&gt; Returns the result of applying concat to the result of applying map&lt;br&gt;  to f and colls.  Thus function f should return a collection.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mapcat&amp;lt;br&amp;gt;  &amp;quot;Returns the result of applying concat to the result of applying map&amp;lt;br&amp;gt;  to f and colls.  Thus function f should return a collection.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [f &amp;amp; colls]&amp;lt;br&amp;gt;    (apply concat (apply map f colls)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mapcat</a>[f & colls]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;mapv&lt;/b&gt; ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 &amp; colls])&lt;br&gt; Returns a vector consisting of the result of applying f to the&lt;br&gt;  set of first items of each coll, followed by applying f to the set&lt;br&gt;  of second items in each coll, until any one of the colls is&lt;br&gt;  exhausted.  Any remaining items in other colls are ignored. Function&lt;br&gt;  f should accept number-of-colls arguments.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mapv&amp;lt;br&amp;gt;  &amp;quot;Returns a vector consisting of the result of applying f to the&amp;lt;br&amp;gt;  set of first items of each coll, followed by applying f to the set&amp;lt;br&amp;gt;  of second items in each coll, until any one of the colls is&amp;lt;br&amp;gt;  exhausted.  Any remaining items in other colls are ignored. Function&amp;lt;br&amp;gt;  f should accept number-of-colls arguments.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.4&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([f coll]&amp;lt;br&amp;gt;     (-&amp;gt; (reduce (fn [v o] (conj! v (f o))) (transient []) coll)&amp;lt;br&amp;gt;         persistent!))&amp;lt;br&amp;gt;  ([f c1 c2]&amp;lt;br&amp;gt;     (into [] (map f c1 c2)))&amp;lt;br&amp;gt;  ([f c1 c2 c3]&amp;lt;br&amp;gt;     (into [] (map f c1 c2 c3)))&amp;lt;br&amp;gt;  ([f c1 c2 c3 &amp;amp; colls]&amp;lt;br&amp;gt;     (into [] (apply map f c1 c2 c3 colls))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mapv</a>[f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;max&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; Returns the greatest of the nums.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn max&amp;lt;br&amp;gt;  &amp;quot;Returns the greatest of the nums.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :inline-arities &amp;gt;1?&amp;lt;br&amp;gt;   :inline (nary-inline 'max)}&amp;lt;br&amp;gt;  ([x] x)&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (max x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (reduce1 max (max x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">max</a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;max-key&lt;/b&gt; ([k x] [k x y] [k x y &amp; more])&lt;br&gt; Returns the x for which (k x), a number, is greatest.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn max-key&amp;lt;br&amp;gt;  &amp;quot;Returns the x for which (k x), a number, is greatest.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([k x] x)&amp;lt;br&amp;gt;  ([k x y] (if (&amp;gt; (k x) (k y)) x y))&amp;lt;br&amp;gt;  ([k x y &amp;amp; more]&amp;lt;br&amp;gt;   (reduce1 #(max-key k %1 %2) (max-key k x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">max-key</a>[k x] [k x y] [k x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;memfn&lt;/b&gt; ([name &amp; args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Expands into code that creates a fn that expects to be passed an&lt;br&gt;  object and any args and calls the named instance method on the&lt;br&gt;  object passing the args. Use when you want to treat a Java method as&lt;br&gt;  a first-class fn. name may be type-hinted with the method receiver's&lt;br&gt;  type in order to avoid reflective calls.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro memfn&amp;lt;br&amp;gt;  &amp;quot;Expands into code that creates a fn that expects to be passed an&amp;lt;br&amp;gt;  object and any args and calls the named instance method on the&amp;lt;br&amp;gt;  object passing the args. Use when you want to treat a Java method as&amp;lt;br&amp;gt;  a first-class fn. name may be type-hinted with the method receiver's&amp;lt;br&amp;gt;  type in order to avoid reflective calls.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [name &amp;amp; args]&amp;lt;br&amp;gt;  (let [t (with-meta (gensym &amp;quot;target&amp;quot;)&amp;lt;br&amp;gt;            (meta name))]&amp;lt;br&amp;gt;    `(fn [~t ~@args]&amp;lt;br&amp;gt;       (. ~t (~name ~@args)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">memfn</a>[name & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;memoize&lt;/b&gt; ([f])&lt;br&gt; Returns a memoized version of a referentially transparent function. The&lt;br&gt;  memoized version of the function keeps a cache of the mapping from arguments&lt;br&gt;  to results and, when calls with the same arguments are repeated often, has&lt;br&gt;  higher performance at the expense of higher memory use.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn memoize&amp;lt;br&amp;gt;  &amp;quot;Returns a memoized version of a referentially transparent function. The&amp;lt;br&amp;gt;  memoized version of the function keeps a cache of the mapping from arguments&amp;lt;br&amp;gt;  to results and, when calls with the same arguments are repeated often, has&amp;lt;br&amp;gt;  higher performance at the expense of higher memory use.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (let [mem (atom {})]&amp;lt;br&amp;gt;    (fn [&amp;amp; args]&amp;lt;br&amp;gt;      (if-let [e (find @mem args)]&amp;lt;br&amp;gt;        (val e)&amp;lt;br&amp;gt;        (let [ret (apply f args)]&amp;lt;br&amp;gt;          (swap! mem assoc args ret)&amp;lt;br&amp;gt;          ret)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">memoize</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;merge&lt;/b&gt; ([&amp; maps])&lt;br&gt; Returns a map that consists of the rest of the maps conj-ed onto&lt;br&gt;  the first.  If a key occurs in more than one map, the mapping from&lt;br&gt;  the latter (left-to-right) will be the mapping in the result.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn merge&amp;lt;br&amp;gt;  &amp;quot;Returns a map that consists of the rest of the maps conj-ed onto&amp;lt;br&amp;gt;  the first.  If a key occurs in more than one map, the mapping from&amp;lt;br&amp;gt;  the latter (left-to-right) will be the mapping in the result.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; maps]&amp;lt;br&amp;gt;  (when (some identity maps)&amp;lt;br&amp;gt;    (reduce1 #(conj (or %1 {}) %2) maps)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">merge</a>[& maps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;merge-with&lt;/b&gt; ([f &amp; maps])&lt;br&gt; Returns a map that consists of the rest of the maps conj-ed onto&lt;br&gt;  the first.  If a key occurs in more than one map, the mapping(s)&lt;br&gt;  from the latter (left-to-right) will be combined with the mapping in&lt;br&gt;  the result by calling (f val-in-result val-in-latter).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn merge-with&amp;lt;br&amp;gt;  &amp;quot;Returns a map that consists of the rest of the maps conj-ed onto&amp;lt;br&amp;gt;  the first.  If a key occurs in more than one map, the mapping(s)&amp;lt;br&amp;gt;  from the latter (left-to-right) will be combined with the mapping in&amp;lt;br&amp;gt;  the result by calling (f val-in-result val-in-latter).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [f &amp;amp; maps]&amp;lt;br&amp;gt;  (when (some identity maps)&amp;lt;br&amp;gt;    (let [merge-entry (fn [m e]&amp;lt;br&amp;gt;			(let [k (key e) v (val e)]&amp;lt;br&amp;gt;			  (if (contains? m k)&amp;lt;br&amp;gt;			    (assoc m k (f (get m k) v))&amp;lt;br&amp;gt;			    (assoc m k v))))&amp;lt;br&amp;gt;          merge2 (fn [m1 m2]&amp;lt;br&amp;gt;		   (reduce1 merge-entry (or m1 {}) (seq m2)))]&amp;lt;br&amp;gt;      (reduce1 merge2 maps))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">merge-with</a>[f & maps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;meta&lt;/b&gt; ([obj])&lt;br&gt; Returns the metadata of obj, returns nil if there is no metadata.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([obj])&amp;lt;br&amp;gt;   :doc &amp;quot;Returns the metadata of obj, returns nil if there is no metadata.&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; meta (fn ^:static meta [x]&amp;lt;br&amp;gt;        (if (instance? clojure.lang.IMeta x)&amp;lt;br&amp;gt;          (. ^clojure.lang.IMeta x (meta)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">meta</a>[obj]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;method-sig&lt;/b&gt; ([meth])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn method-sig [^java.lang.reflect.Method meth]&amp;lt;br&amp;gt;  [(. meth (getName)) (seq (. meth (getParameterTypes))) (. meth getReturnType)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">method-sig</a>[meth]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;methods&lt;/b&gt; ([multifn])&lt;br&gt; Given a multimethod, returns a map of dispatch values -&gt; dispatch fns&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn methods&amp;lt;br&amp;gt;  &amp;quot;Given a multimethod, returns a map of dispatch values -&amp;gt; dispatch fns&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.MultiFn multifn] (.getMethodTable multifn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">methods</a>[multifn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;min&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; Returns the least of the nums.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn min&amp;lt;br&amp;gt;  &amp;quot;Returns the least of the nums.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :inline-arities &amp;gt;1?&amp;lt;br&amp;gt;   :inline (nary-inline 'min)}&amp;lt;br&amp;gt;  ([x] x)&amp;lt;br&amp;gt;  ([x y] (. clojure.lang.Numbers (min x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (reduce1 min (min x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">min</a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;min-key&lt;/b&gt; ([k x] [k x y] [k x y &amp; more])&lt;br&gt; Returns the x for which (k x), a number, is least.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn min-key&amp;lt;br&amp;gt;  &amp;quot;Returns the x for which (k x), a number, is least.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([k x] x)&amp;lt;br&amp;gt;  ([k x y] (if (&amp;lt; (k x) (k y)) x y))&amp;lt;br&amp;gt;  ([k x y &amp;amp; more]&amp;lt;br&amp;gt;   (reduce1 #(min-key k %1 %2) (min-key k x y) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">min-key</a>[k x] [k x y] [k x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;mod&lt;/b&gt; ([num div])&lt;br&gt; Modulus of num and div. Truncates toward negative infinity.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mod&amp;lt;br&amp;gt;  &amp;quot;Modulus of num and div. Truncates toward negative infinity.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [num div] &amp;lt;br&amp;gt;  (let [m (rem num div)] &amp;lt;br&amp;gt;    (if (or (zero? m) (= (pos? num) (pos? div)))&amp;lt;br&amp;gt;      m &amp;lt;br&amp;gt;      (+ m div))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mod</a>[num div]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;munge&lt;/b&gt; ([s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn munge [s]&amp;lt;br&amp;gt;  ((if (symbol? s) symbol str) (clojure.lang.Compiler/munge (str s))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">munge</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;name&lt;/b&gt; ([x])&lt;br&gt; Returns the name String of a string, symbol or keyword.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn name&amp;lt;br&amp;gt;  &amp;quot;Returns the name String of a string, symbol or keyword.&amp;quot;&amp;lt;br&amp;gt;  {:tag String&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x]&amp;lt;br&amp;gt;  (if (string? x) x (. ^clojure.lang.Named x (getName))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">name</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;namespace&lt;/b&gt; ([x])&lt;br&gt; Returns the namespace String of a symbol or keyword, or nil if not present.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn namespace&amp;lt;br&amp;gt;  &amp;quot;Returns the namespace String of a symbol or keyword, or nil if not present.&amp;quot;&amp;lt;br&amp;gt;  {:tag String&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Named x]&amp;lt;br&amp;gt;    (. x (getNamespace)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">namespace</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;namespace-munge&lt;/b&gt; ([ns])&lt;br&gt; Convert a Clojure namespace name to a legal Java package name.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn namespace-munge&amp;lt;br&amp;gt;  &amp;quot;Convert a Clojure namespace name to a legal Java package name.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (.replace (str ns) \- \_))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">namespace-munge</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;neg?&lt;/b&gt; ([x])&lt;br&gt; Returns true if num is less than zero, else false&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn neg?&amp;lt;br&amp;gt;  &amp;quot;Returns true if num is less than zero, else false&amp;quot;&amp;lt;br&amp;gt;  {&amp;lt;br&amp;gt;   :inline (fn [x] `(. clojure.lang.Numbers (isNeg ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (isNeg x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">neg?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;newline&lt;/b&gt; ([])&lt;br&gt; Writes a platform-specific newline to *out*&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn newline&amp;lt;br&amp;gt;  &amp;quot;Writes a platform-specific newline to *out*&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;    (. *out* (append system-newline))&amp;lt;br&amp;gt;    nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">newline</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;next&lt;/b&gt; ([coll])&lt;br&gt; Returns a seq of the items after the first. Calls seq on its&lt;br&gt;  argument.  If there are no more items, returns nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([coll])&amp;lt;br&amp;gt;   :tag clojure.lang.ISeq&amp;lt;br&amp;gt;   :doc &amp;quot;Returns a seq of the items after the first. Calls seq on its&amp;lt;br&amp;gt;  argument.  If there are no more items, returns nil.&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}  &amp;lt;br&amp;gt; next (fn ^:static next [x] (. clojure.lang.RT (next x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">next</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;nfirst&lt;/b&gt; ([x])&lt;br&gt; Same as (next (first x))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:doc &amp;quot;Same as (next (first x))&amp;quot;&amp;lt;br&amp;gt;   :arglists '([x])&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; nfirst (fn ^:static nfirst [x] (next (first x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nfirst</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;nil?&lt;/b&gt; ([x])&lt;br&gt; Returns true if x is nil, false otherwise.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn nil?&amp;lt;br&amp;gt;  &amp;quot;Returns true if x is nil, false otherwise.&amp;quot;&amp;lt;br&amp;gt;  {:tag Boolean&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true&amp;lt;br&amp;gt;   :inline (fn [x] (list 'clojure.lang.Util/identical x nil))}&amp;lt;br&amp;gt;  [x] (clojure.lang.Util/identical x nil))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nil?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;nnext&lt;/b&gt; ([x])&lt;br&gt; Same as (next (next x))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:doc &amp;quot;Same as (next (next x))&amp;quot;&amp;lt;br&amp;gt;   :arglists '([x])&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; nnext (fn ^:static nnext [x] (next (next x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nnext</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;not&lt;/b&gt; ([x])&lt;br&gt; Returns true if x is logical false, false otherwise.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn not&amp;lt;br&amp;gt;  &amp;quot;Returns true if x is logical false, false otherwise.&amp;quot;&amp;lt;br&amp;gt;  {:tag Boolean&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (if x false true))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">not</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;not-any?&lt;/b&gt; ([pred coll])&lt;br&gt; Returns false if (pred x) is logical true for any x in coll,&lt;br&gt;  else true.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:tag Boolean&amp;lt;br&amp;gt;   :doc &amp;quot;Returns false if (pred x) is logical true for any x in coll,&amp;lt;br&amp;gt;  else true.&amp;quot;&amp;lt;br&amp;gt;   :arglists '([pred coll])&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt; not-any? (comp not some))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">not-any?</a>[pred coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;not-empty&lt;/b&gt; ([coll])&lt;br&gt; If coll is empty, returns nil, else coll&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn not-empty&amp;lt;br&amp;gt;  &amp;quot;If coll is empty, returns nil, else coll&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll] (when (seq coll) coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">not-empty</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;not-every?&lt;/b&gt; ([pred coll])&lt;br&gt; Returns false if (pred x) is logical true for every x in&lt;br&gt;  coll, else true.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:tag Boolean&amp;lt;br&amp;gt;   :doc &amp;quot;Returns false if (pred x) is logical true for every x in&amp;lt;br&amp;gt;  coll, else true.&amp;quot;&amp;lt;br&amp;gt;   :arglists '([pred coll])&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt; not-every? (comp not every?))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">not-every?</a>[pred coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;not=&lt;/b&gt; ([x] [x y] [x y &amp; more])&lt;br&gt; Same as (not (= obj1 obj2))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn not=&amp;lt;br&amp;gt;  &amp;quot;Same as (not (= obj1 obj2))&amp;quot;&amp;lt;br&amp;gt;  {:tag Boolean&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([x] false)&amp;lt;br&amp;gt;  ([x y] (not (= x y)))&amp;lt;br&amp;gt;  ([x y &amp;amp; more]&amp;lt;br&amp;gt;   (not (apply = x y more))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">not=</a>[x] [x y] [x y & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ns&lt;/b&gt; ([name docstring? attr-map? references*])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Sets *ns* to the namespace named by name (unevaluated), creating it&lt;br&gt;  if needed.  references can be zero or more of: (:refer-clojure ...)&lt;br&gt;  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)&lt;br&gt;  with the syntax of refer-clojure/require/use/import/load/gen-class&lt;br&gt;  respectively, except the arguments are unevaluated and need not be&lt;br&gt;  quoted. (:gen-class ...), when supplied, defaults to :name&lt;br&gt;  corresponding to the ns name, :main true, :impl-ns same as ns, and&lt;br&gt;  :init-impl-ns true. All options of gen-class are&lt;br&gt;  supported. The :gen-class directive is ignored when not&lt;br&gt;  compiling. If :gen-class is not supplied, when compiled only an&lt;br&gt;  nsname__init.class will be generated. If :refer-clojure is not used, a&lt;br&gt;  default (refer 'clojure) is used.  Use of ns is preferred to&lt;br&gt;  individual calls to in-ns/require/use/import:&lt;br&gt;&lt;br&gt;  (ns foo.bar&lt;br&gt;    (:refer-clojure :exclude [ancestors printf])&lt;br&gt;    (:require (clojure.contrib sql combinatorics))&lt;br&gt;    (:use (my.lib this that))&lt;br&gt;    (:import (java.util Date Timer Random)&lt;br&gt;             (java.sql Connection Statement)))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ns&amp;lt;br&amp;gt;  &amp;quot;Sets *ns* to the namespace named by name (unevaluated), creating it&amp;lt;br&amp;gt;  if needed.  references can be zero or more of: (:refer-clojure ...)&amp;lt;br&amp;gt;  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)&amp;lt;br&amp;gt;  with the syntax of refer-clojure/require/use/import/load/gen-class&amp;lt;br&amp;gt;  respectively, except the arguments are unevaluated and need not be&amp;lt;br&amp;gt;  quoted. (:gen-class ...), when supplied, defaults to :name&amp;lt;br&amp;gt;  corresponding to the ns name, :main true, :impl-ns same as ns, and&amp;lt;br&amp;gt;  :init-impl-ns true. All options of gen-class are&amp;lt;br&amp;gt;  supported. The :gen-class directive is ignored when not&amp;lt;br&amp;gt;  compiling. If :gen-class is not supplied, when compiled only an&amp;lt;br&amp;gt;  nsname__init.class will be generated. If :refer-clojure is not used, a&amp;lt;br&amp;gt;  default (refer 'clojure) is used.  Use of ns is preferred to&amp;lt;br&amp;gt;  individual calls to in-ns/require/use/import:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (ns foo.bar&amp;lt;br&amp;gt;    (:refer-clojure :exclude [ancestors printf])&amp;lt;br&amp;gt;    (:require (clojure.contrib sql combinatorics))&amp;lt;br&amp;gt;    (:use (my.lib this that))&amp;lt;br&amp;gt;    (:import (java.util Date Timer Random)&amp;lt;br&amp;gt;             (java.sql Connection Statement)))&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([name docstring? attr-map? references*])&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [name &amp;amp; references]&amp;lt;br&amp;gt;  (let [process-reference&amp;lt;br&amp;gt;        (fn [[kname &amp;amp; args]]&amp;lt;br&amp;gt;          `(~(symbol &amp;quot;clojure.core&amp;quot; (clojure.core/name kname))&amp;lt;br&amp;gt;             ~@(map #(list 'quote %) args)))&amp;lt;br&amp;gt;        docstring  (when (string? (first references)) (first references))&amp;lt;br&amp;gt;        references (if docstring (next references) references)&amp;lt;br&amp;gt;        name (if docstring&amp;lt;br&amp;gt;               (vary-meta name assoc :doc docstring)&amp;lt;br&amp;gt;               name)&amp;lt;br&amp;gt;        metadata   (when (map? (first references)) (first references))&amp;lt;br&amp;gt;        references (if metadata (next references) references)&amp;lt;br&amp;gt;        name (if metadata&amp;lt;br&amp;gt;               (vary-meta name merge metadata)&amp;lt;br&amp;gt;               name)&amp;lt;br&amp;gt;        gen-class-clause (first (filter #(= :gen-class (first %)) references))&amp;lt;br&amp;gt;        gen-class-call&amp;lt;br&amp;gt;          (when gen-class-clause&amp;lt;br&amp;gt;            (list* `gen-class :name (.replace (str name) \- \_) :impl-ns name :main true (next gen-class-clause)))&amp;lt;br&amp;gt;        references (remove #(= :gen-class (first %)) references)&amp;lt;br&amp;gt;        ;ns-effect (clojure.core/in-ns name)&amp;lt;br&amp;gt;        ]&amp;lt;br&amp;gt;    `(do&amp;lt;br&amp;gt;       (clojure.core/in-ns '~name)&amp;lt;br&amp;gt;       (with-loading-context&amp;lt;br&amp;gt;        ~@(when gen-class-call (list gen-class-call))&amp;lt;br&amp;gt;        ~@(when (and (not= name 'clojure.core) (not-any? #(= :refer-clojure (first %)) references))&amp;lt;br&amp;gt;            `((clojure.core/refer '~'clojure.core)))&amp;lt;br&amp;gt;        ~@(map process-reference references))&amp;lt;br&amp;gt;        (if (.equals '~name 'clojure.core) &amp;lt;br&amp;gt;          nil&amp;lt;br&amp;gt;          (do (dosync (commute @#'*loaded-libs* conj '~name)) nil)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns</a>[name docstring? attr-map? references*]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ns-aliases&lt;/b&gt; ([ns])&lt;br&gt; Returns a map of the aliases for the namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-aliases&amp;lt;br&amp;gt;  &amp;quot;Returns a map of the aliases for the namespace.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (.getAliases (the-ns ns)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-aliases</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ns-imports&lt;/b&gt; ([ns])&lt;br&gt; Returns a map of the import mappings for the namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-imports&amp;lt;br&amp;gt;  &amp;quot;Returns a map of the import mappings for the namespace.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (filter-key val (partial instance? Class) (ns-map ns)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-imports</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ns-interns&lt;/b&gt; ([ns])&lt;br&gt; Returns a map of the intern mappings for the namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-interns&amp;lt;br&amp;gt;  &amp;quot;Returns a map of the intern mappings for the namespace.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (let [ns (the-ns ns)]&amp;lt;br&amp;gt;    (filter-key val (fn [^clojure.lang.Var v] (and (instance? clojure.lang.Var v)&amp;lt;br&amp;gt;                                 (= ns (.ns v))))&amp;lt;br&amp;gt;                (ns-map ns))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-interns</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ns-map&lt;/b&gt; ([ns])&lt;br&gt; Returns a map of all the mappings for the namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-map&amp;lt;br&amp;gt;  &amp;quot;Returns a map of all the mappings for the namespace.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (.getMappings (the-ns ns)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-map</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ns-name&lt;/b&gt; ([ns])&lt;br&gt; Returns the name of the namespace, a symbol.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-name&amp;lt;br&amp;gt;  &amp;quot;Returns the name of the namespace, a symbol.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (.getName (the-ns ns)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-name</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ns-publics&lt;/b&gt; ([ns])&lt;br&gt; Returns a map of the public intern mappings for the namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-publics&amp;lt;br&amp;gt;  &amp;quot;Returns a map of the public intern mappings for the namespace.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (let [ns (the-ns ns)]&amp;lt;br&amp;gt;    (filter-key val (fn [^clojure.lang.Var v] (and (instance? clojure.lang.Var v)&amp;lt;br&amp;gt;                                 (= ns (.ns v))&amp;lt;br&amp;gt;                                 (.isPublic v)))&amp;lt;br&amp;gt;                (ns-map ns))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-publics</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ns-refers&lt;/b&gt; ([ns])&lt;br&gt; Returns a map of the refer mappings for the namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-refers&amp;lt;br&amp;gt;  &amp;quot;Returns a map of the refer mappings for the namespace.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (let [ns (the-ns ns)]&amp;lt;br&amp;gt;    (filter-key val (fn [^clojure.lang.Var v] (and (instance? clojure.lang.Var v)&amp;lt;br&amp;gt;                                 (not= ns (.ns v))))&amp;lt;br&amp;gt;                (ns-map ns))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-refers</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ns-resolve&lt;/b&gt; ([ns sym] [ns env sym])&lt;br&gt; Returns the var or Class to which a symbol will be resolved in the&lt;br&gt;  namespace (unless found in the environment), else nil.  Note that&lt;br&gt;  if the symbol is fully qualified, the var/Class to which it resolves&lt;br&gt;  need not be present in the namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-resolve&amp;lt;br&amp;gt;  &amp;quot;Returns the var or Class to which a symbol will be resolved in the&amp;lt;br&amp;gt;  namespace (unless found in the environment), else nil.  Note that&amp;lt;br&amp;gt;  if the symbol is fully qualified, the var/Class to which it resolves&amp;lt;br&amp;gt;  need not be present in the namespace.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([ns sym]&amp;lt;br&amp;gt;    (ns-resolve ns nil sym))&amp;lt;br&amp;gt;  ([ns env sym]&amp;lt;br&amp;gt;    (when-not (contains? env sym)&amp;lt;br&amp;gt;      (clojure.lang.Compiler/maybeResolveIn (the-ns ns) sym))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-resolve</a>[ns sym] [ns env sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ns-unalias&lt;/b&gt; ([ns sym])&lt;br&gt; Removes the alias for the symbol from the namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-unalias&amp;lt;br&amp;gt;  &amp;quot;Removes the alias for the symbol from the namespace.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [ns sym]&amp;lt;br&amp;gt;  (.removeAlias (the-ns ns) sym))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-unalias</a>[ns sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ns-unmap&lt;/b&gt; ([ns sym])&lt;br&gt; Removes the mappings for the symbol from the namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-unmap&amp;lt;br&amp;gt;  &amp;quot;Removes the mappings for the symbol from the namespace.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [ns sym]&amp;lt;br&amp;gt;  (.unmap (the-ns ns) sym))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-unmap</a>[ns sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;nth&lt;/b&gt; ([coll index] [coll index not-found])&lt;br&gt; Returns the value at the index. get returns nil if index out of&lt;br&gt;  bounds, nth throws an exception unless not-found is supplied.  nth&lt;br&gt;  also works for strings, Java arrays, regex Matchers and Lists, and,&lt;br&gt;  in O(n) time, for sequences.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn nth&amp;lt;br&amp;gt;  &amp;quot;Returns the value at the index. get returns nil if index out of&amp;lt;br&amp;gt;  bounds, nth throws an exception unless not-found is supplied.  nth&amp;lt;br&amp;gt;  also works for strings, Java arrays, regex Matchers and Lists, and,&amp;lt;br&amp;gt;  in O(n) time, for sequences.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [c i &amp;amp; nf] `(. clojure.lang.RT (nth ~c ~i ~@nf)))&amp;lt;br&amp;gt;   :inline-arities #{2 3}&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([coll index] (. clojure.lang.RT (nth coll index)))&amp;lt;br&amp;gt;  ([coll index not-found] (. clojure.lang.RT (nth coll index not-found))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nth</a>[coll index] [coll index not-found]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;nthnext&lt;/b&gt; ([coll n])&lt;br&gt; Returns the nth next of coll, (seq coll) when n is 0.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn nthnext&amp;lt;br&amp;gt;  &amp;quot;Returns the nth next of coll, (seq coll) when n is 0.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll n]&amp;lt;br&amp;gt;    (loop [n n xs (seq coll)]&amp;lt;br&amp;gt;      (if (and xs (pos? n))&amp;lt;br&amp;gt;        (recur (dec n) (next xs))&amp;lt;br&amp;gt;        xs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nthnext</a>[coll n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;nthrest&lt;/b&gt; ([coll n])&lt;br&gt; Returns the nth rest of coll, coll when n is 0.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn nthrest&amp;lt;br&amp;gt;  &amp;quot;Returns the nth rest of coll, coll when n is 0.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll n]&amp;lt;br&amp;gt;    (loop [n n xs coll]&amp;lt;br&amp;gt;      (if (and (pos? n) (seq xs))&amp;lt;br&amp;gt;        (recur (dec n) (rest xs))&amp;lt;br&amp;gt;        xs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nthrest</a>[coll n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;num&lt;/b&gt; ([x])&lt;br&gt; Coerce to Number&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn num&amp;lt;br&amp;gt;  &amp;quot;Coerce to Number&amp;quot;&amp;lt;br&amp;gt;  {:tag Number&amp;lt;br&amp;gt;   :inline (fn  [x] `(. clojure.lang.Numbers (num ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (num x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">num</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;number?&lt;/b&gt; ([x])&lt;br&gt; Returns true if x is a Number&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn number?&amp;lt;br&amp;gt;  &amp;quot;Returns true if x is a Number&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x]&amp;lt;br&amp;gt;  (instance? Number x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">number?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;numerator&lt;/b&gt; ([r])&lt;br&gt; Returns the numerator part of a Ratio.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn numerator&amp;lt;br&amp;gt;  &amp;quot;Returns the numerator part of a Ratio.&amp;quot;&amp;lt;br&amp;gt;  {:tag BigInteger&amp;lt;br&amp;gt;   :added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [r]&amp;lt;br&amp;gt;  (.numerator ^clojure.lang.Ratio r))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">numerator</a>[r]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;object-array&lt;/b&gt; ([size-or-seq])&lt;br&gt; Creates an array of objects&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn object-array&amp;lt;br&amp;gt;  &amp;quot;Creates an array of objects&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [arg] `(. clojure.lang.RT object_array ~arg))&amp;lt;br&amp;gt;   :inline-arities #{1}&amp;lt;br&amp;gt;   :added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  ([size-or-seq] (. clojure.lang.RT object_array size-or-seq)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">object-array</a>[size-or-seq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;odd?&lt;/b&gt; ([n])&lt;br&gt; Returns true if n is odd, throws an exception if n is not an integer&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn odd?&amp;lt;br&amp;gt;  &amp;quot;Returns true if n is odd, throws an exception if n is not an integer&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [n] (not (even? n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">odd?</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;or&lt;/b&gt; ([] [x] [x &amp; next])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates exprs one at a time, from left to right. If a form&lt;br&gt;  returns a logical true value, or returns that value and doesn't&lt;br&gt;  evaluate any of the other expressions, otherwise it returns the&lt;br&gt;  value of the last expression. (or) returns nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro or&amp;lt;br&amp;gt;  &amp;quot;Evaluates exprs one at a time, from left to right. If a form&amp;lt;br&amp;gt;  returns a logical true value, or returns that value and doesn't&amp;lt;br&amp;gt;  evaluate any of the other expressions, otherwise it returns the&amp;lt;br&amp;gt;  value of the last expression. (or) returns nil.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([] nil)&amp;lt;br&amp;gt;  ([x] x)&amp;lt;br&amp;gt;  ([x &amp;amp; next]&amp;lt;br&amp;gt;      `(let [or# ~x]&amp;lt;br&amp;gt;         (if or# or# (or ~@next)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">or</a>[] [x] [x & next]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;parents&lt;/b&gt; ([tag] [h tag])&lt;br&gt; Returns the immediate parents of tag, either via a Java type&lt;br&gt;  inheritance relationship or a relationship established via derive. h&lt;br&gt;  must be a hierarchy obtained from make-hierarchy, if not supplied&lt;br&gt;  defaults to the global hierarchy&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parents&amp;lt;br&amp;gt;  &amp;quot;Returns the immediate parents of tag, either via a Java type&amp;lt;br&amp;gt;  inheritance relationship or a relationship established via derive. h&amp;lt;br&amp;gt;  must be a hierarchy obtained from make-hierarchy, if not supplied&amp;lt;br&amp;gt;  defaults to the global hierarchy&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([tag] (parents global-hierarchy tag))&amp;lt;br&amp;gt;  ([h tag] (not-empty&amp;lt;br&amp;gt;            (let [tp (get (:parents h) tag)]&amp;lt;br&amp;gt;              (if (class? tag)&amp;lt;br&amp;gt;                (into1 (set (bases tag)) tp)&amp;lt;br&amp;gt;                tp)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parents</a>[tag] [h tag]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;partial&lt;/b&gt; ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 &amp; more])&lt;br&gt; Takes a function f and fewer than the normal arguments to f, and&lt;br&gt;  returns a fn that takes a variable number of additional args. When&lt;br&gt;  called, the returned function calls f with args + additional args.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn partial&amp;lt;br&amp;gt;  &amp;quot;Takes a function f and fewer than the normal arguments to f, and&amp;lt;br&amp;gt;  returns a fn that takes a variable number of additional args. When&amp;lt;br&amp;gt;  called, the returned function calls f with args + additional args.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([f] f)&amp;lt;br&amp;gt;  ([f arg1]&amp;lt;br&amp;gt;   (fn [&amp;amp; args] (apply f arg1 args)))&amp;lt;br&amp;gt;  ([f arg1 arg2]&amp;lt;br&amp;gt;   (fn [&amp;amp; args] (apply f arg1 arg2 args)))&amp;lt;br&amp;gt;  ([f arg1 arg2 arg3]&amp;lt;br&amp;gt;   (fn [&amp;amp; args] (apply f arg1 arg2 arg3 args)))&amp;lt;br&amp;gt;  ([f arg1 arg2 arg3 &amp;amp; more]&amp;lt;br&amp;gt;   (fn [&amp;amp; args] (apply f arg1 arg2 arg3 (concat more args)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">partial</a>[f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;partition&lt;/b&gt; ([n coll] [n step coll] [n step pad coll])&lt;br&gt; Returns a lazy sequence of lists of n items each, at offsets step&lt;br&gt;  apart. If step is not supplied, defaults to n, i.e. the partitions&lt;br&gt;  do not overlap. If a pad collection is supplied, use its elements as&lt;br&gt;  necessary to complete last partition upto n items. In case there are&lt;br&gt;  not enough padding elements, return a partition with less than n items.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn partition&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of lists of n items each, at offsets step&amp;lt;br&amp;gt;  apart. If step is not supplied, defaults to n, i.e. the partitions&amp;lt;br&amp;gt;  do not overlap. If a pad collection is supplied, use its elements as&amp;lt;br&amp;gt;  necessary to complete last partition upto n items. In case there are&amp;lt;br&amp;gt;  not enough padding elements, return a partition with less than n items.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([n coll]&amp;lt;br&amp;gt;     (partition n n coll))&amp;lt;br&amp;gt;  ([n step coll]&amp;lt;br&amp;gt;     (lazy-seq&amp;lt;br&amp;gt;       (when-let [s (seq coll)]&amp;lt;br&amp;gt;         (let [p (doall (take n s))]&amp;lt;br&amp;gt;           (when (= n (count p))&amp;lt;br&amp;gt;             (cons p (partition n step (nthrest s step))))))))&amp;lt;br&amp;gt;  ([n step pad coll]&amp;lt;br&amp;gt;     (lazy-seq&amp;lt;br&amp;gt;       (when-let [s (seq coll)]&amp;lt;br&amp;gt;         (let [p (doall (take n s))]&amp;lt;br&amp;gt;           (if (= n (count p))&amp;lt;br&amp;gt;             (cons p (partition n step pad (nthrest s step)))&amp;lt;br&amp;gt;             (list (take n (concat p pad)))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">partition</a>[n coll] [n step coll] [n step pad coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;partition-all&lt;/b&gt; ([n coll] [n step coll])&lt;br&gt; Returns a lazy sequence of lists like partition, but may include&lt;br&gt;  partitions with fewer than n items at the end.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn partition-all&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of lists like partition, but may include&amp;lt;br&amp;gt;  partitions with fewer than n items at the end.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([n coll]&amp;lt;br&amp;gt;     (partition-all n n coll))&amp;lt;br&amp;gt;  ([n step coll]&amp;lt;br&amp;gt;     (lazy-seq&amp;lt;br&amp;gt;      (when-let [s (seq coll)]&amp;lt;br&amp;gt;        (let [seg (doall (take n s))]&amp;lt;br&amp;gt;          (cons seg (partition-all n step (nthrest s step))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">partition-all</a>[n coll] [n step coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;partition-by&lt;/b&gt; ([f coll])&lt;br&gt; Applies f to each value in coll, splitting it each time f returns&lt;br&gt;   a new value.  Returns a lazy seq of partitions.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn partition-by&amp;lt;br&amp;gt;  &amp;quot;Applies f to each value in coll, splitting it each time f returns&amp;lt;br&amp;gt;   a new value.  Returns a lazy seq of partitions.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [f coll]&amp;lt;br&amp;gt;  (lazy-seq&amp;lt;br&amp;gt;   (when-let [s (seq coll)]&amp;lt;br&amp;gt;     (let [fst (first s)&amp;lt;br&amp;gt;           fv (f fst)&amp;lt;br&amp;gt;           run (cons fst (take-while #(= fv (f %)) (next s)))]&amp;lt;br&amp;gt;       (cons run (partition-by f (seq (drop (count run) s))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">partition-by</a>[f coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;pcalls&lt;/b&gt; ([&amp; fns])&lt;br&gt; Executes the no-arg fns in parallel, returning a lazy sequence of&lt;br&gt;  their values&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pcalls&amp;lt;br&amp;gt;  &amp;quot;Executes the no-arg fns in parallel, returning a lazy sequence of&amp;lt;br&amp;gt;  their values&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; fns] (pmap #(%) fns))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pcalls</a>[& fns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;peek&lt;/b&gt; ([coll])&lt;br&gt; For a list or queue, same as first, for a vector, same as, but much&lt;br&gt;  more efficient than, last. If the collection is empty, returns nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn peek&amp;lt;br&amp;gt;  &amp;quot;For a list or queue, same as first, for a vector, same as, but much&amp;lt;br&amp;gt;  more efficient than, last. If the collection is empty, returns nil.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll] (. clojure.lang.RT (peek coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">peek</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;persistent!&lt;/b&gt; ([coll])&lt;br&gt; Alpha - subject to change.&lt;br&gt;  Returns a new, persistent version of the transient collection, in&lt;br&gt;  constant time. The transient collection cannot be used after this&lt;br&gt;  call, any such use will throw an exception.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn persistent! &amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;  Returns a new, persistent version of the transient collection, in&amp;lt;br&amp;gt;  constant time. The transient collection cannot be used after this&amp;lt;br&amp;gt;  call, any such use will throw an exception.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.ITransientCollection coll]&amp;lt;br&amp;gt;  (.persistent coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">persistent!</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;pmap&lt;/b&gt; ([f coll] [f coll &amp; colls])&lt;br&gt; Like map, except f is applied in parallel. Semi-lazy in that the&lt;br&gt;  parallel computation stays ahead of the consumption, but doesn't&lt;br&gt;  realize the entire result unless required. Only useful for&lt;br&gt;  computationally intensive functions where the time of f dominates&lt;br&gt;  the coordination overhead.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pmap&amp;lt;br&amp;gt;  &amp;quot;Like map, except f is applied in parallel. Semi-lazy in that the&amp;lt;br&amp;gt;  parallel computation stays ahead of the consumption, but doesn't&amp;lt;br&amp;gt;  realize the entire result unless required. Only useful for&amp;lt;br&amp;gt;  computationally intensive functions where the time of f dominates&amp;lt;br&amp;gt;  the coordination overhead.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([f coll]&amp;lt;br&amp;gt;   (let [n (+ 2 (.. Runtime getRuntime availableProcessors))&amp;lt;br&amp;gt;         rets (map #(future (f %)) coll)&amp;lt;br&amp;gt;         step (fn step [[x &amp;amp; xs :as vs] fs]&amp;lt;br&amp;gt;                (lazy-seq&amp;lt;br&amp;gt;                 (if-let [s (seq fs)]&amp;lt;br&amp;gt;                   (cons (deref x) (step xs (rest s)))&amp;lt;br&amp;gt;                   (map deref vs))))]&amp;lt;br&amp;gt;     (step rets (drop n rets))))&amp;lt;br&amp;gt;  ([f coll &amp;amp; colls]&amp;lt;br&amp;gt;   (let [step (fn step [cs]&amp;lt;br&amp;gt;                (lazy-seq&amp;lt;br&amp;gt;                 (let [ss (map seq cs)]&amp;lt;br&amp;gt;                   (when (every? identity ss)&amp;lt;br&amp;gt;                     (cons (map first ss) (step (map rest ss)))))))]&amp;lt;br&amp;gt;     (pmap #(apply f %) (step (cons coll colls))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pmap</a>[f coll] [f coll & colls]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;pop&lt;/b&gt; ([coll])&lt;br&gt; For a list or queue, returns a new list/queue without the first&lt;br&gt;  item, for a vector, returns a new vector without the last item. If&lt;br&gt;  the collection is empty, throws an exception.  Note - not the same&lt;br&gt;  as next/butlast.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pop&amp;lt;br&amp;gt;  &amp;quot;For a list or queue, returns a new list/queue without the first&amp;lt;br&amp;gt;  item, for a vector, returns a new vector without the last item. If&amp;lt;br&amp;gt;  the collection is empty, throws an exception.  Note - not the same&amp;lt;br&amp;gt;  as next/butlast.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll] (. clojure.lang.RT (pop coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pop</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;pop!&lt;/b&gt; ([coll])&lt;br&gt; Alpha - subject to change.&lt;br&gt;  Removes the last item from a transient vector. If&lt;br&gt;  the collection is empty, throws an exception. Returns coll&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pop!&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;  Removes the last item from a transient vector. If&amp;lt;br&amp;gt;  the collection is empty, throws an exception. Returns coll&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.ITransientVector coll] &amp;lt;br&amp;gt;  (.pop coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pop!</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;pop-thread-bindings&lt;/b&gt; ([])&lt;br&gt; Pop one set of bindings pushed with push-binding before. It is an error to&lt;br&gt;  pop bindings without pushing before.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pop-thread-bindings&amp;lt;br&amp;gt;  &amp;quot;Pop one set of bindings pushed with push-binding before. It is an error to&amp;lt;br&amp;gt;  pop bindings without pushing before.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (clojure.lang.Var/popThreadBindings))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pop-thread-bindings</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;pos?&lt;/b&gt; ([x])&lt;br&gt; Returns true if num is greater than zero, else false&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pos?&amp;lt;br&amp;gt;  &amp;quot;Returns true if num is greater than zero, else false&amp;quot;&amp;lt;br&amp;gt;  {&amp;lt;br&amp;gt;   :inline (fn [x] `(. clojure.lang.Numbers (isPos ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (isPos x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pos?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;pr&lt;/b&gt; ([] [x] [x &amp; more])&lt;br&gt; Prints the object(s) to the output stream that is the current value&lt;br&gt;  of *out*.  Prints the object(s), separated by spaces if there is&lt;br&gt;  more than one.  By default, pr and prn print in a way that objects&lt;br&gt;  can be read by the reader&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pr&amp;lt;br&amp;gt;  &amp;quot;Prints the object(s) to the output stream that is the current value&amp;lt;br&amp;gt;  of *out*.  Prints the object(s), separated by spaces if there is&amp;lt;br&amp;gt;  more than one.  By default, pr and prn print in a way that objects&amp;lt;br&amp;gt;  can be read by the reader&amp;quot;&amp;lt;br&amp;gt;  {:dynamic true&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([] nil)&amp;lt;br&amp;gt;  ([x]&amp;lt;br&amp;gt;     (pr-on x *out*))&amp;lt;br&amp;gt;  ([x &amp;amp; more]&amp;lt;br&amp;gt;   (pr x)&amp;lt;br&amp;gt;   (. *out* (append \space))&amp;lt;br&amp;gt;   (if-let [nmore (next more)]&amp;lt;br&amp;gt;     (recur (first more) nmore)&amp;lt;br&amp;gt;     (apply pr more))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pr</a>[] [x] [x & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;pr-str&lt;/b&gt; ([&amp; xs])&lt;br&gt; pr to a string, returning it&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pr-str&amp;lt;br&amp;gt;  &amp;quot;pr to a string, returning it&amp;quot;&amp;lt;br&amp;gt;  {:tag String&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; xs]&amp;lt;br&amp;gt;    (with-out-str&amp;lt;br&amp;gt;     (apply pr xs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pr-str</a>[& xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;prefer-method&lt;/b&gt; ([multifn dispatch-val-x dispatch-val-y])&lt;br&gt; Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y &lt;br&gt;   when there is a conflict&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn prefer-method&amp;lt;br&amp;gt;  &amp;quot;Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y &amp;lt;br&amp;gt;   when there is a conflict&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.MultiFn multifn dispatch-val-x dispatch-val-y]&amp;lt;br&amp;gt;  (. multifn preferMethod dispatch-val-x dispatch-val-y))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">prefer-method</a>[multifn dispatch-val-x dispatch-val-y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;prefers&lt;/b&gt; ([multifn])&lt;br&gt; Given a multimethod, returns a map of preferred value -&gt; set of other values&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn prefers&amp;lt;br&amp;gt;  &amp;quot;Given a multimethod, returns a map of preferred value -&amp;gt; set of other values&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.MultiFn multifn] (.getPreferTable multifn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">prefers</a>[multifn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;print&lt;/b&gt; ([&amp; more])&lt;br&gt; Prints the object(s) to the output stream that is the current value&lt;br&gt;  of *out*.  print and println produce output for human consumption.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print&amp;lt;br&amp;gt;  &amp;quot;Prints the object(s) to the output stream that is the current value&amp;lt;br&amp;gt;  of *out*.  print and println produce output for human consumption.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; more]&amp;lt;br&amp;gt;    (binding [*print-readably* nil]&amp;lt;br&amp;gt;      (apply pr more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print</a>[& more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;print-ctor&lt;/b&gt; ([o print-args w])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-ctor [o print-args ^Writer w]&amp;lt;br&amp;gt;  (.write w &amp;quot;#=(&amp;quot;)&amp;lt;br&amp;gt;  (.write w (.getName ^Class (class o)))&amp;lt;br&amp;gt;  (.write w &amp;quot;. &amp;quot;)&amp;lt;br&amp;gt;  (print-args o w)&amp;lt;br&amp;gt;  (.write w &amp;quot;)&amp;quot;))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-ctor</a>[o print-args w]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;print-simple&lt;/b&gt; ([o w])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-simple [o, ^Writer w]&amp;lt;br&amp;gt;  (print-meta o w)&amp;lt;br&amp;gt;  (.write w (str o)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-simple</a>[o w]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;print-str&lt;/b&gt; ([&amp; xs])&lt;br&gt; print to a string, returning it&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-str&amp;lt;br&amp;gt;  &amp;quot;print to a string, returning it&amp;quot;&amp;lt;br&amp;gt;  {:tag String&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; xs]&amp;lt;br&amp;gt;    (with-out-str&amp;lt;br&amp;gt;     (apply print xs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-str</a>[& xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;printf&lt;/b&gt; ([fmt &amp; args])&lt;br&gt; Prints formatted output, as per format&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn printf&amp;lt;br&amp;gt;  &amp;quot;Prints formatted output, as per format&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [fmt &amp;amp; args]&amp;lt;br&amp;gt;  (print (apply format fmt args)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">printf</a>[fmt & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;println&lt;/b&gt; ([&amp; more])&lt;br&gt; Same as print followed by (newline)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn println&amp;lt;br&amp;gt;  &amp;quot;Same as print followed by (newline)&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; more]&amp;lt;br&amp;gt;    (binding [*print-readably* nil]&amp;lt;br&amp;gt;      (apply prn more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">println</a>[& more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;println-str&lt;/b&gt; ([&amp; xs])&lt;br&gt; println to a string, returning it&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn println-str&amp;lt;br&amp;gt;  &amp;quot;println to a string, returning it&amp;quot;&amp;lt;br&amp;gt;  {:tag String&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; xs]&amp;lt;br&amp;gt;    (with-out-str&amp;lt;br&amp;gt;     (apply println xs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">println-str</a>[& xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;prn&lt;/b&gt; ([&amp; more])&lt;br&gt; Same as pr followed by (newline). Observes *flush-on-newline*&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn prn&amp;lt;br&amp;gt;  &amp;quot;Same as pr followed by (newline). Observes *flush-on-newline*&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; more]&amp;lt;br&amp;gt;    (apply pr more)&amp;lt;br&amp;gt;    (newline)&amp;lt;br&amp;gt;    (when *flush-on-newline*&amp;lt;br&amp;gt;      (flush)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">prn</a>[& more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;prn-str&lt;/b&gt; ([&amp; xs])&lt;br&gt; prn to a string, returning it&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn prn-str&amp;lt;br&amp;gt;  &amp;quot;prn to a string, returning it&amp;quot;&amp;lt;br&amp;gt;  {:tag String&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; xs]&amp;lt;br&amp;gt;  (with-out-str&amp;lt;br&amp;gt;   (apply prn xs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">prn-str</a>[& xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;promise&lt;/b&gt; ([])&lt;br&gt; Alpha - subject to change.&lt;br&gt;  Returns a promise object that can be read with deref/@, and set,&lt;br&gt;  once only, with deliver. Calls to deref/@ prior to delivery will&lt;br&gt;  block, unless the variant of deref with timeout is used. All&lt;br&gt;  subsequent derefs will return the same delivered value without&lt;br&gt;  blocking. See also - realized?.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn promise&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;  Returns a promise object that can be read with deref/@, and set,&amp;lt;br&amp;gt;  once only, with deliver. Calls to deref/@ prior to delivery will&amp;lt;br&amp;gt;  block, unless the variant of deref with timeout is used. All&amp;lt;br&amp;gt;  subsequent derefs will return the same delivered value without&amp;lt;br&amp;gt;  blocking. See also - realized?.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (let [d (java.util.concurrent.CountDownLatch. 1)&amp;lt;br&amp;gt;        v (atom d)]&amp;lt;br&amp;gt;    (reify &amp;lt;br&amp;gt;     clojure.lang.IDeref&amp;lt;br&amp;gt;       (deref [_] (.await d) @v)&amp;lt;br&amp;gt;     clojure.lang.IBlockingDeref&amp;lt;br&amp;gt;       (deref&amp;lt;br&amp;gt;        [_ timeout-ms timeout-val]&amp;lt;br&amp;gt;        (if (.await d timeout-ms java.util.concurrent.TimeUnit/MILLISECONDS)&amp;lt;br&amp;gt;          @v&amp;lt;br&amp;gt;          timeout-val))  &amp;lt;br&amp;gt;     clojure.lang.IPending&amp;lt;br&amp;gt;      (isRealized [this]&amp;lt;br&amp;gt;       (zero? (.getCount d)))&amp;lt;br&amp;gt;     clojure.lang.IFn&amp;lt;br&amp;gt;     (invoke&amp;lt;br&amp;gt;      [this x]&amp;lt;br&amp;gt;      (when (and (pos? (.getCount d))&amp;lt;br&amp;gt;                 (compare-and-set! v d x))&amp;lt;br&amp;gt;        (.countDown d)&amp;lt;br&amp;gt;        this)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">promise</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;proxy&lt;/b&gt; ([class-and-interfaces args &amp; fs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; class-and-interfaces - a vector of class names&lt;br&gt;&lt;br&gt;  args - a (possibly empty) vector of arguments to the superclass&lt;br&gt;  constructor.&lt;br&gt;&lt;br&gt;  f =&gt; (name [params*] body) or&lt;br&gt;  (name ([params*] body) ([params+] body) ...)&lt;br&gt;&lt;br&gt;  Expands to code which creates a instance of a proxy class that&lt;br&gt;  implements the named class/interface(s) by calling the supplied&lt;br&gt;  fns. A single class, if provided, must be first. If not provided it&lt;br&gt;  defaults to Object.&lt;br&gt;&lt;br&gt;  The interfaces names must be valid interface types. If a method fn&lt;br&gt;  is not provided for a class method, the superclass methd will be&lt;br&gt;  called. If a method fn is not provided for an interface method, an&lt;br&gt;  UnsupportedOperationException will be thrown should it be&lt;br&gt;  called. Method fns are closures and can capture the environment in&lt;br&gt;  which proxy is called. Each method fn takes an additional implicit&lt;br&gt;  first arg, which is bound to 'this. Note that while method fns can&lt;br&gt;  be provided to override protected methods, they have no other access&lt;br&gt;  to protected members, nor to super, as these capabilities cannot be&lt;br&gt;  proxied.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro proxy&amp;lt;br&amp;gt;  &amp;quot;class-and-interfaces - a vector of class names&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  args - a (possibly empty) vector of arguments to the superclass&amp;lt;br&amp;gt;  constructor.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  f =&amp;gt; (name [params*] body) or&amp;lt;br&amp;gt;  (name ([params*] body) ([params+] body) ...)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Expands to code which creates a instance of a proxy class that&amp;lt;br&amp;gt;  implements the named class/interface(s) by calling the supplied&amp;lt;br&amp;gt;  fns. A single class, if provided, must be first. If not provided it&amp;lt;br&amp;gt;  defaults to Object.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The interfaces names must be valid interface types. If a method fn&amp;lt;br&amp;gt;  is not provided for a class method, the superclass methd will be&amp;lt;br&amp;gt;  called. If a method fn is not provided for an interface method, an&amp;lt;br&amp;gt;  UnsupportedOperationException will be thrown should it be&amp;lt;br&amp;gt;  called. Method fns are closures and can capture the environment in&amp;lt;br&amp;gt;  which proxy is called. Each method fn takes an additional implicit&amp;lt;br&amp;gt;  first arg, which is bound to 'this. Note that while method fns can&amp;lt;br&amp;gt;  be provided to override protected methods, they have no other access&amp;lt;br&amp;gt;  to protected members, nor to super, as these capabilities cannot be&amp;lt;br&amp;gt;  proxied.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [class-and-interfaces args &amp;amp; fs]&amp;lt;br&amp;gt;   (let [bases (map #(or (resolve %) (throw (Exception. (str &amp;quot;Can't resolve: &amp;quot; %)))) &amp;lt;br&amp;gt;                    class-and-interfaces)&amp;lt;br&amp;gt;         [super interfaces] (get-super-and-interfaces bases)&amp;lt;br&amp;gt;         compile-effect (when *compile-files*&amp;lt;br&amp;gt;                          (let [[cname bytecode] (generate-proxy super interfaces)]&amp;lt;br&amp;gt;                            (clojure.lang.Compiler/writeClassFile cname bytecode)))&amp;lt;br&amp;gt;         pc-effect (apply get-proxy-class bases)&amp;lt;br&amp;gt;         pname (proxy-name super interfaces)]&amp;lt;br&amp;gt;     ;remember the class to prevent it from disappearing before use&amp;lt;br&amp;gt;     (intern *ns* (symbol pname) pc-effect)&amp;lt;br&amp;gt;     `(let [;pc# (get-proxy-class ~@class-and-interfaces)&amp;lt;br&amp;gt;            p# (new ~(symbol pname) ~@args)] ;(construct-proxy pc# ~@args)]   &amp;lt;br&amp;gt;        (init-proxy p#&amp;lt;br&amp;gt;         ~(loop [fmap {} fs fs]&amp;lt;br&amp;gt;            (if fs&amp;lt;br&amp;gt;              (let [[sym &amp;amp; meths] (first fs)&amp;lt;br&amp;gt;                    meths (if (vector? (first meths))&amp;lt;br&amp;gt;                            (list meths)&amp;lt;br&amp;gt;                            meths)&amp;lt;br&amp;gt;                    meths (map (fn [[params &amp;amp; body]]&amp;lt;br&amp;gt;                                   (cons (apply vector 'this params) body))&amp;lt;br&amp;gt;                               meths)]&amp;lt;br&amp;gt;                (if-not (contains? fmap (name sym))		  &amp;lt;br&amp;gt;                (recur (assoc fmap (name sym) (cons `fn meths)) (next fs))&amp;lt;br&amp;gt;		           (throw (IllegalArgumentException.&amp;lt;br&amp;gt;			              (str &amp;quot;Method '&amp;quot; (name sym) &amp;quot;' redefined&amp;quot;)))))&amp;lt;br&amp;gt;              fmap)))&amp;lt;br&amp;gt;        p#)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">proxy</a>[class-and-interfaces args & fs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;proxy-call-with-super&lt;/b&gt; ([call this meth])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn proxy-call-with-super [call this meth]&amp;lt;br&amp;gt; (let [m (proxy-mappings this)]&amp;lt;br&amp;gt;    (update-proxy this (assoc m meth nil))&amp;lt;br&amp;gt;    (let [ret (call)]&amp;lt;br&amp;gt;      (update-proxy this m)&amp;lt;br&amp;gt;      ret)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">proxy-call-with-super</a>[call this meth]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;proxy-mappings&lt;/b&gt; ([proxy])&lt;br&gt; Takes a proxy instance and returns the proxy's fn map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn proxy-mappings&amp;lt;br&amp;gt;  &amp;quot;Takes a proxy instance and returns the proxy's fn map.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [^IProxy proxy]&amp;lt;br&amp;gt;    (. proxy (__getClojureFnMappings)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">proxy-mappings</a>[proxy]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;proxy-name&lt;/b&gt; ([super interfaces])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn proxy-name&amp;lt;br&amp;gt; {:tag String} &amp;lt;br&amp;gt; [^Class super interfaces]&amp;lt;br&amp;gt;  (let [inames (into1 (sorted-set) (map #(.getName ^Class %) interfaces))]&amp;lt;br&amp;gt;    (apply str (.replace (str *ns*) \- \_) &amp;quot;.proxy&amp;quot;&amp;lt;br&amp;gt;      (interleave (repeat &amp;quot;$&amp;quot;)&amp;lt;br&amp;gt;        (concat&amp;lt;br&amp;gt;          [(.getName super)]&amp;lt;br&amp;gt;          (map #(subs % (inc (.lastIndexOf ^String % &amp;quot;.&amp;quot;))) inames)&amp;lt;br&amp;gt;          [(Integer/toHexString (hash inames))])))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">proxy-name</a>[super interfaces]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;proxy-super&lt;/b&gt; ([meth &amp; args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Use to call a superclass method in the body of a proxy method. &lt;br&gt;  Note, expansion captures 'this&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro proxy-super &amp;lt;br&amp;gt;  &amp;quot;Use to call a superclass method in the body of a proxy method. &amp;lt;br&amp;gt;  Note, expansion captures 'this&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [meth &amp;amp; args]&amp;lt;br&amp;gt; `(proxy-call-with-super (fn [] (. ~'this ~meth ~@args))  ~'this ~(name meth)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">proxy-super</a>[meth & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;push-thread-bindings&lt;/b&gt; ([bindings])&lt;br&gt; WARNING: This is a low-level function. Prefer high-level macros like&lt;br&gt;  binding where ever possible.&lt;br&gt;&lt;br&gt;  Takes a map of Var/value pairs. Binds each Var to the associated value for&lt;br&gt;  the current thread. Each call *MUST* be accompanied by a matching call to&lt;br&gt;  pop-thread-bindings wrapped in a try-finally!&lt;br&gt;  &lt;br&gt;      (push-thread-bindings bindings)&lt;br&gt;      (try&lt;br&gt;        ...&lt;br&gt;        (finally&lt;br&gt;          (pop-thread-bindings)))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn push-thread-bindings&amp;lt;br&amp;gt;  &amp;quot;WARNING: This is a low-level function. Prefer high-level macros like&amp;lt;br&amp;gt;  binding where ever possible.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Takes a map of Var/value pairs. Binds each Var to the associated value for&amp;lt;br&amp;gt;  the current thread. Each call *MUST* be accompanied by a matching call to&amp;lt;br&amp;gt;  pop-thread-bindings wrapped in a try-finally!&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;      (push-thread-bindings bindings)&amp;lt;br&amp;gt;      (try&amp;lt;br&amp;gt;        ...&amp;lt;br&amp;gt;        (finally&amp;lt;br&amp;gt;          (pop-thread-bindings)))&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true} &amp;lt;br&amp;gt;  [bindings]&amp;lt;br&amp;gt;  (clojure.lang.Var/pushThreadBindings bindings))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">push-thread-bindings</a>[bindings]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;pvalues&lt;/b&gt; ([&amp; exprs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Returns a lazy sequence of the values of the exprs, which are&lt;br&gt;  evaluated in parallel&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro pvalues&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of the values of the exprs, which are&amp;lt;br&amp;gt;  evaluated in parallel&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; exprs]&amp;lt;br&amp;gt;  `(pcalls ~@(map #(list `fn [] %) exprs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pvalues</a>[& exprs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;quot&lt;/b&gt; ([num div])&lt;br&gt; quot[ient] of dividing numerator by denominator.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn quot&amp;lt;br&amp;gt;  &amp;quot;quot[ient] of dividing numerator by denominator.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true&amp;lt;br&amp;gt;   :inline (fn [x y] `(. clojure.lang.Numbers (quotient ~x ~y)))}&amp;lt;br&amp;gt;  [num div]&amp;lt;br&amp;gt;    (. clojure.lang.Numbers (quotient num div)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">quot</a>[num div]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;rand&lt;/b&gt; ([] [n])&lt;br&gt; Returns a random floating point number between 0 (inclusive) and&lt;br&gt;  n (default 1) (exclusive).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rand&amp;lt;br&amp;gt;  &amp;quot;Returns a random floating point number between 0 (inclusive) and&amp;lt;br&amp;gt;  n (default 1) (exclusive).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([] (. Math (random)))&amp;lt;br&amp;gt;  ([n] (* n (rand))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rand</a>[] [n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;rand-int&lt;/b&gt; ([n])&lt;br&gt; Returns a random integer between 0 (inclusive) and n (exclusive).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rand-int&amp;lt;br&amp;gt;  &amp;quot;Returns a random integer between 0 (inclusive) and n (exclusive).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [n] (int (rand n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rand-int</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;rand-nth&lt;/b&gt; ([coll])&lt;br&gt; Return a random element of the (sequential) collection. Will have&lt;br&gt;  the same performance characteristics as nth for the given&lt;br&gt;  collection.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rand-nth&amp;lt;br&amp;gt;  &amp;quot;Return a random element of the (sequential) collection. Will have&amp;lt;br&amp;gt;  the same performance characteristics as nth for the given&amp;lt;br&amp;gt;  collection.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;  (nth coll (rand-int (count coll))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rand-nth</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;range&lt;/b&gt; ([] [end] [start end] [start end step])&lt;br&gt; Returns a lazy seq of nums from start (inclusive) to end&lt;br&gt;  (exclusive), by step, where start defaults to 0, step to 1, and end&lt;br&gt;  to infinity.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn range &amp;lt;br&amp;gt;  &amp;quot;Returns a lazy seq of nums from start (inclusive) to end&amp;lt;br&amp;gt;  (exclusive), by step, where start defaults to 0, step to 1, and end&amp;lt;br&amp;gt;  to infinity.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([] (range 0 Double/POSITIVE_INFINITY 1))&amp;lt;br&amp;gt;  ([end] (range 0 end 1))&amp;lt;br&amp;gt;  ([start end] (range start end 1))&amp;lt;br&amp;gt;  ([start end step]&amp;lt;br&amp;gt;   (lazy-seq&amp;lt;br&amp;gt;    (let [b (chunk-buffer 32)&amp;lt;br&amp;gt;          comp (if (pos? step) &amp;lt; &amp;gt;)]&amp;lt;br&amp;gt;      (loop [i start]&amp;lt;br&amp;gt;        (if (and (&amp;lt; (count b) 32)&amp;lt;br&amp;gt;                 (comp i end))&amp;lt;br&amp;gt;          (do&amp;lt;br&amp;gt;            (chunk-append b i)&amp;lt;br&amp;gt;            (recur (+ i step)))&amp;lt;br&amp;gt;          (chunk-cons (chunk b) &amp;lt;br&amp;gt;                      (when (comp i end) &amp;lt;br&amp;gt;                        (range i end step)))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">range</a>[] [end] [start end] [start end step]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ratio?&lt;/b&gt; ([n])&lt;br&gt; Returns true if n is a Ratio&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ratio?&amp;lt;br&amp;gt;  &amp;quot;Returns true if n is a Ratio&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [n] (instance? clojure.lang.Ratio n))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ratio?</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;rational?&lt;/b&gt; ([n])&lt;br&gt; Returns true if n is a rational number&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rational? &amp;lt;br&amp;gt;  &amp;quot;Returns true if n is a rational number&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [n]&amp;lt;br&amp;gt;  (or (integer? n) (ratio? n) (decimal? n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rational?</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;rationalize&lt;/b&gt; ([num])&lt;br&gt; returns the rational value of num&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rationalize&amp;lt;br&amp;gt;  &amp;quot;returns the rational value of num&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [num]&amp;lt;br&amp;gt;  (. clojure.lang.Numbers (rationalize num)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rationalize</a>[num]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;re-find&lt;/b&gt; ([m] [re s])&lt;br&gt; Returns the next regex match, if any, of string to pattern, using&lt;br&gt;  java.util.regex.Matcher.find().  Uses re-groups to return the&lt;br&gt;  groups.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn re-find&amp;lt;br&amp;gt;  &amp;quot;Returns the next regex match, if any, of string to pattern, using&amp;lt;br&amp;gt;  java.util.regex.Matcher.find().  Uses re-groups to return the&amp;lt;br&amp;gt;  groups.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([^java.util.regex.Matcher m]&amp;lt;br&amp;gt;   (when (. m (find))&amp;lt;br&amp;gt;     (re-groups m)))&amp;lt;br&amp;gt;  ([^java.util.regex.Pattern re s]&amp;lt;br&amp;gt;   (let [m (re-matcher re s)]&amp;lt;br&amp;gt;     (re-find m))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">re-find</a>[m] [re s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;re-groups&lt;/b&gt; ([m])&lt;br&gt; Returns the groups from the most recent match/find. If there are no&lt;br&gt;  nested groups, returns a string of the entire match. If there are&lt;br&gt;  nested groups, returns a vector of the groups, the first element&lt;br&gt;  being the entire match.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn re-groups&amp;lt;br&amp;gt;  &amp;quot;Returns the groups from the most recent match/find. If there are no&amp;lt;br&amp;gt;  nested groups, returns a string of the entire match. If there are&amp;lt;br&amp;gt;  nested groups, returns a vector of the groups, the first element&amp;lt;br&amp;gt;  being the entire match.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^java.util.regex.Matcher m]&amp;lt;br&amp;gt;    (let [gc  (. m (groupCount))]&amp;lt;br&amp;gt;      (if (zero? gc)&amp;lt;br&amp;gt;        (. m (group))&amp;lt;br&amp;gt;        (loop [ret [] c 0]&amp;lt;br&amp;gt;          (if (&amp;lt;= c gc)&amp;lt;br&amp;gt;            (recur (conj ret (. m (group c))) (inc c))&amp;lt;br&amp;gt;            ret)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">re-groups</a>[m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;re-matcher&lt;/b&gt; ([re s])&lt;br&gt; Returns an instance of java.util.regex.Matcher, for use, e.g. in&lt;br&gt;  re-find.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn re-matcher&amp;lt;br&amp;gt;  &amp;quot;Returns an instance of java.util.regex.Matcher, for use, e.g. in&amp;lt;br&amp;gt;  re-find.&amp;quot;&amp;lt;br&amp;gt;  {:tag java.util.regex.Matcher&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^java.util.regex.Pattern re s]&amp;lt;br&amp;gt;    (. re (matcher s)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">re-matcher</a>[re s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;re-matches&lt;/b&gt; ([re s])&lt;br&gt; Returns the match, if any, of string to pattern, using&lt;br&gt;  java.util.regex.Matcher.matches().  Uses re-groups to return the&lt;br&gt;  groups.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn re-matches&amp;lt;br&amp;gt;  &amp;quot;Returns the match, if any, of string to pattern, using&amp;lt;br&amp;gt;  java.util.regex.Matcher.matches().  Uses re-groups to return the&amp;lt;br&amp;gt;  groups.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^java.util.regex.Pattern re s]&amp;lt;br&amp;gt;    (let [m (re-matcher re s)]&amp;lt;br&amp;gt;      (when (. m (matches))&amp;lt;br&amp;gt;        (re-groups m))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">re-matches</a>[re s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;re-pattern&lt;/b&gt; ([s])&lt;br&gt; Returns an instance of java.util.regex.Pattern, for use, e.g. in&lt;br&gt;  re-matcher.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn re-pattern&amp;lt;br&amp;gt;  &amp;quot;Returns an instance of java.util.regex.Pattern, for use, e.g. in&amp;lt;br&amp;gt;  re-matcher.&amp;quot;&amp;lt;br&amp;gt;  {:tag java.util.regex.Pattern&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [s] (if (instance? java.util.regex.Pattern s)&amp;lt;br&amp;gt;        s&amp;lt;br&amp;gt;        (. java.util.regex.Pattern (compile s))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">re-pattern</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;re-seq&lt;/b&gt; ([re s])&lt;br&gt; Returns a lazy sequence of successive matches of pattern in string,&lt;br&gt;  using java.util.regex.Matcher.find(), each such match processed with&lt;br&gt;  re-groups.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn re-seq&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of successive matches of pattern in string,&amp;lt;br&amp;gt;  using java.util.regex.Matcher.find(), each such match processed with&amp;lt;br&amp;gt;  re-groups.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^java.util.regex.Pattern re s]&amp;lt;br&amp;gt;  (let [m (re-matcher re s)]&amp;lt;br&amp;gt;    ((fn step []&amp;lt;br&amp;gt;       (when (. m (find))&amp;lt;br&amp;gt;         (cons (re-groups m) (lazy-seq (step))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">re-seq</a>[re s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;read&lt;/b&gt; ([] [stream] [stream eof-error? eof-value] [stream eof-error? eof-value recursive?])&lt;br&gt; Reads the next object from stream, which must be an instance of&lt;br&gt;  java.io.PushbackReader or some derivee.  stream defaults to the&lt;br&gt;  current value of *in*.&lt;br&gt;&lt;br&gt;  Note that read can execute code (controlled by *read-eval*),&lt;br&gt;  and as such should be used only with trusted sources.&lt;br&gt;&lt;br&gt;  For data structure interop use clojure.edn/read&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read&amp;lt;br&amp;gt;  &amp;quot;Reads the next object from stream, which must be an instance of&amp;lt;br&amp;gt;  java.io.PushbackReader or some derivee.  stream defaults to the&amp;lt;br&amp;gt;  current value of *in*.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Note that read can execute code (controlled by *read-eval*),&amp;lt;br&amp;gt;  and as such should be used only with trusted sources.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  For data structure interop use clojure.edn/read&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([]&amp;lt;br&amp;gt;   (read *in*))&amp;lt;br&amp;gt;  ([stream]&amp;lt;br&amp;gt;   (read stream true nil))&amp;lt;br&amp;gt;  ([stream eof-error? eof-value]&amp;lt;br&amp;gt;   (read stream eof-error? eof-value false))&amp;lt;br&amp;gt;  ([stream eof-error? eof-value recursive?]&amp;lt;br&amp;gt;   (. clojure.lang.LispReader (read stream (boolean eof-error?) eof-value recursive?))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read</a>[] [stream] [stream eof-error? eof-value] [stream eof-error? eof-value recursive?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;read-line&lt;/b&gt; ([])&lt;br&gt; Reads the next line from stream that is the current value of *in* .&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-line&amp;lt;br&amp;gt;  &amp;quot;Reads the next line from stream that is the current value of *in* .&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (if (instance? clojure.lang.LineNumberingPushbackReader *in*)&amp;lt;br&amp;gt;    (.readLine ^clojure.lang.LineNumberingPushbackReader *in*)&amp;lt;br&amp;gt;    (.readLine ^java.io.BufferedReader *in*)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-line</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;read-string&lt;/b&gt; ([s])&lt;br&gt; Reads one object from the string s.&lt;br&gt;&lt;br&gt;  Note that read-string can execute code (controlled by *read-eval*),&lt;br&gt;  and as such should be used only with trusted sources.&lt;br&gt;&lt;br&gt;  For data structure interop use clojure.edn/read-string&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-string&amp;lt;br&amp;gt;  &amp;quot;Reads one object from the string s.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Note that read-string can execute code (controlled by *read-eval*),&amp;lt;br&amp;gt;  and as such should be used only with trusted sources.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  For data structure interop use clojure.edn/read-string&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [s] (clojure.lang.RT/readString s))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-string</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;realized?&lt;/b&gt; ([x])&lt;br&gt; Returns true if a value has been produced for a promise, delay, future or lazy sequence.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn realized?&amp;lt;br&amp;gt;  &amp;quot;Returns true if a value has been produced for a promise, delay, future or lazy sequence.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [^clojure.lang.IPending x] (.isRealized x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">realized?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;reduce&lt;/b&gt; ([f coll] [f val coll])&lt;br&gt; f should be a function of 2 arguments. If val is not supplied,&lt;br&gt;  returns the result of applying f to the first 2 items in coll, then&lt;br&gt;  applying f to that result and the 3rd item, etc. If coll contains no&lt;br&gt;  items, f must accept no arguments as well, and reduce returns the&lt;br&gt;  result of calling f with no arguments.  If coll has only 1 item, it&lt;br&gt;  is returned and f is not called.  If val is supplied, returns the&lt;br&gt;  result of applying f to val and the first item in coll, then&lt;br&gt;  applying f to that result and the 2nd item, etc. If coll contains no&lt;br&gt;  items, returns val and f is not called.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reduce&amp;lt;br&amp;gt;  &amp;quot;f should be a function of 2 arguments. If val is not supplied,&amp;lt;br&amp;gt;  returns the result of applying f to the first 2 items in coll, then&amp;lt;br&amp;gt;  applying f to that result and the 3rd item, etc. If coll contains no&amp;lt;br&amp;gt;  items, f must accept no arguments as well, and reduce returns the&amp;lt;br&amp;gt;  result of calling f with no arguments.  If coll has only 1 item, it&amp;lt;br&amp;gt;  is returned and f is not called.  If val is supplied, returns the&amp;lt;br&amp;gt;  result of applying f to val and the first item in coll, then&amp;lt;br&amp;gt;  applying f to that result and the 2nd item, etc. If coll contains no&amp;lt;br&amp;gt;  items, returns val and f is not called.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([f coll]&amp;lt;br&amp;gt;     (clojure.core.protocols/coll-reduce coll f))&amp;lt;br&amp;gt;  ([f val coll]&amp;lt;br&amp;gt;     (clojure.core.protocols/coll-reduce coll f val)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reduce</a>[f coll] [f val coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;reduce-kv&lt;/b&gt; ([f init coll])&lt;br&gt; Reduces an associative collection. f should be a function of 3&lt;br&gt;  arguments. Returns the result of applying f to init, the first key&lt;br&gt;  and the first value in coll, then applying f to that result and the&lt;br&gt;  2nd key and value, etc. If coll contains no entries, returns init&lt;br&gt;  and f is not called. Note that reduce-kv is supported on vectors,&lt;br&gt;  where the keys will be the ordinals.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reduce-kv&amp;lt;br&amp;gt;  &amp;quot;Reduces an associative collection. f should be a function of 3&amp;lt;br&amp;gt;  arguments. Returns the result of applying f to init, the first key&amp;lt;br&amp;gt;  and the first value in coll, then applying f to that result and the&amp;lt;br&amp;gt;  2nd key and value, etc. If coll contains no entries, returns init&amp;lt;br&amp;gt;  and f is not called. Note that reduce-kv is supported on vectors,&amp;lt;br&amp;gt;  where the keys will be the ordinals.&amp;quot;  &amp;lt;br&amp;gt;  {:added &amp;quot;1.4&amp;quot;}&amp;lt;br&amp;gt;  ([f init coll]&amp;lt;br&amp;gt;     (clojure.core.protocols/kv-reduce coll f init)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reduce-kv</a>[f init coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;reduced&lt;/b&gt; ([x])&lt;br&gt; Wraps x in a way such that a reduce will terminate with the value x&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reduced&amp;lt;br&amp;gt;  &amp;quot;Wraps x in a way such that a reduce will terminate with the value x&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [x]&amp;lt;br&amp;gt;  (clojure.lang.Reduced. x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reduced</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;reduced?&lt;/b&gt; ([x])&lt;br&gt; Returns true if x is the result of a call to reduced&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reduced?&amp;lt;br&amp;gt;  &amp;quot;Returns true if x is the result of a call to reduced&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x] `(clojure.lang.RT/isReduced ~x ))&amp;lt;br&amp;gt;   :inline-arities #{1}&amp;lt;br&amp;gt;   :added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  ([x] (clojure.lang.RT/isReduced x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reduced?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;reductions&lt;/b&gt; ([f coll] [f init coll])&lt;br&gt; Returns a lazy seq of the intermediate values of the reduction (as&lt;br&gt;  per reduce) of coll by f, starting with init.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reductions&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy seq of the intermediate values of the reduction (as&amp;lt;br&amp;gt;  per reduce) of coll by f, starting with init.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  ([f coll]&amp;lt;br&amp;gt;     (lazy-seq&amp;lt;br&amp;gt;      (if-let [s (seq coll)]&amp;lt;br&amp;gt;        (reductions f (first s) (rest s))&amp;lt;br&amp;gt;        (list (f)))))&amp;lt;br&amp;gt;  ([f init coll]&amp;lt;br&amp;gt;     (cons init&amp;lt;br&amp;gt;           (lazy-seq&amp;lt;br&amp;gt;            (when-let [s (seq coll)]&amp;lt;br&amp;gt;              (reductions f (f init (first s)) (rest s)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reductions</a>[f coll] [f init coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ref&lt;/b&gt; ([x] [x &amp; options])&lt;br&gt; Creates and returns a Ref with an initial value of x and zero or&lt;br&gt;  more options (in any order):&lt;br&gt;&lt;br&gt;  :meta metadata-map&lt;br&gt;&lt;br&gt;  :validator validate-fn&lt;br&gt;&lt;br&gt;  :min-history (default 0)&lt;br&gt;  :max-history (default 10)&lt;br&gt;&lt;br&gt;  If metadata-map is supplied, it will become the metadata on the&lt;br&gt;  ref. validate-fn must be nil or a side-effect-free fn of one&lt;br&gt;  argument, which will be passed the intended new state on any state&lt;br&gt;  change. If the new state is unacceptable, the validate-fn should&lt;br&gt;  return false or throw an exception. validate-fn will be called on&lt;br&gt;  transaction commit, when all refs have their final values.&lt;br&gt;&lt;br&gt;  Normally refs accumulate history dynamically as needed to deal with&lt;br&gt;  read demands. If you know in advance you will need history you can&lt;br&gt;  set :min-history to ensure it will be available when first needed (instead&lt;br&gt;  of after a read fault). History is limited, and the limit can be set&lt;br&gt;  with :max-history.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ref&amp;lt;br&amp;gt;  &amp;quot;Creates and returns a Ref with an initial value of x and zero or&amp;lt;br&amp;gt;  more options (in any order):&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :meta metadata-map&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :validator validate-fn&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :min-history (default 0)&amp;lt;br&amp;gt;  :max-history (default 10)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  If metadata-map is supplied, it will become the metadata on the&amp;lt;br&amp;gt;  ref. validate-fn must be nil or a side-effect-free fn of one&amp;lt;br&amp;gt;  argument, which will be passed the intended new state on any state&amp;lt;br&amp;gt;  change. If the new state is unacceptable, the validate-fn should&amp;lt;br&amp;gt;  return false or throw an exception. validate-fn will be called on&amp;lt;br&amp;gt;  transaction commit, when all refs have their final values.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Normally refs accumulate history dynamically as needed to deal with&amp;lt;br&amp;gt;  read demands. If you know in advance you will need history you can&amp;lt;br&amp;gt;  set :min-history to ensure it will be available when first needed (instead&amp;lt;br&amp;gt;  of after a read fault). History is limited, and the limit can be set&amp;lt;br&amp;gt;  with :max-history.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true&amp;lt;br&amp;gt;   }&amp;lt;br&amp;gt;  ([x] (new clojure.lang.Ref x))&amp;lt;br&amp;gt;  ([x &amp;amp; options] &amp;lt;br&amp;gt;   (let [r  ^clojure.lang.Ref (setup-reference (ref x) options)&amp;lt;br&amp;gt;         opts (apply hash-map options)]&amp;lt;br&amp;gt;    (when (:max-history opts)&amp;lt;br&amp;gt;      (.setMaxHistory r (:max-history opts)))&amp;lt;br&amp;gt;    (when (:min-history opts)&amp;lt;br&amp;gt;      (.setMinHistory r (:min-history opts)))&amp;lt;br&amp;gt;    r)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ref</a>[x] [x & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ref-history-count&lt;/b&gt; ([ref])&lt;br&gt; Returns the history count of a ref&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ref-history-count&amp;lt;br&amp;gt;  &amp;quot;Returns the history count of a ref&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Ref ref]&amp;lt;br&amp;gt;    (.getHistoryCount ref))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ref-history-count</a>[ref]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ref-max-history&lt;/b&gt; ([ref] [ref n])&lt;br&gt; Gets the max-history of a ref, or sets it and returns the ref&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ref-max-history&amp;lt;br&amp;gt;  &amp;quot;Gets the max-history of a ref, or sets it and returns the ref&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([^clojure.lang.Ref ref]&amp;lt;br&amp;gt;    (.getMaxHistory ref))&amp;lt;br&amp;gt;  ([^clojure.lang.Ref ref n]&amp;lt;br&amp;gt;    (.setMaxHistory ref n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ref-max-history</a>[ref] [ref n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ref-min-history&lt;/b&gt; ([ref] [ref n])&lt;br&gt; Gets the min-history of a ref, or sets it and returns the ref&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ref-min-history&amp;lt;br&amp;gt;  &amp;quot;Gets the min-history of a ref, or sets it and returns the ref&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([^clojure.lang.Ref ref]&amp;lt;br&amp;gt;    (.getMinHistory ref))&amp;lt;br&amp;gt;  ([^clojure.lang.Ref ref n]&amp;lt;br&amp;gt;    (.setMinHistory ref n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ref-min-history</a>[ref] [ref n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;ref-set&lt;/b&gt; ([ref val])&lt;br&gt; Must be called in a transaction. Sets the value of ref.&lt;br&gt;  Returns val.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ref-set&amp;lt;br&amp;gt;  &amp;quot;Must be called in a transaction. Sets the value of ref.&amp;lt;br&amp;gt;  Returns val.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Ref ref val]&amp;lt;br&amp;gt;    (. ref (set val)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ref-set</a>[ref val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;refer&lt;/b&gt; ([ns-sym &amp; filters])&lt;br&gt; refers to all public vars of ns, subject to filters.&lt;br&gt;  filters can include at most one each of:&lt;br&gt;&lt;br&gt;  :exclude list-of-symbols&lt;br&gt;  :only list-of-symbols&lt;br&gt;  :rename map-of-fromsymbol-tosymbol&lt;br&gt;&lt;br&gt;  For each public interned var in the namespace named by the symbol,&lt;br&gt;  adds a mapping from the name of the var to the var to the current&lt;br&gt;  namespace.  Throws an exception if name is already mapped to&lt;br&gt;  something else in the current namespace. Filters can be used to&lt;br&gt;  select a subset, via inclusion or exclusion, or to provide a mapping&lt;br&gt;  to a symbol different from the var's name, in order to prevent&lt;br&gt;  clashes. Use :use in the ns macro in preference to calling this directly.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn refer&amp;lt;br&amp;gt;  &amp;quot;refers to all public vars of ns, subject to filters.&amp;lt;br&amp;gt;  filters can include at most one each of:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :exclude list-of-symbols&amp;lt;br&amp;gt;  :only list-of-symbols&amp;lt;br&amp;gt;  :rename map-of-fromsymbol-tosymbol&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  For each public interned var in the namespace named by the symbol,&amp;lt;br&amp;gt;  adds a mapping from the name of the var to the var to the current&amp;lt;br&amp;gt;  namespace.  Throws an exception if name is already mapped to&amp;lt;br&amp;gt;  something else in the current namespace. Filters can be used to&amp;lt;br&amp;gt;  select a subset, via inclusion or exclusion, or to provide a mapping&amp;lt;br&amp;gt;  to a symbol different from the var's name, in order to prevent&amp;lt;br&amp;gt;  clashes. Use :use in the ns macro in preference to calling this directly.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [ns-sym &amp;amp; filters]&amp;lt;br&amp;gt;    (let [ns (or (find-ns ns-sym) (throw (new Exception (str &amp;quot;No namespace: &amp;quot; ns-sym))))&amp;lt;br&amp;gt;          fs (apply hash-map filters)&amp;lt;br&amp;gt;          nspublics (ns-publics ns)&amp;lt;br&amp;gt;          rename (or (:rename fs) {})&amp;lt;br&amp;gt;          exclude (set (:exclude fs))&amp;lt;br&amp;gt;          to-do (if (= :all (:refer fs))&amp;lt;br&amp;gt;                  (keys nspublics)&amp;lt;br&amp;gt;                  (or (:refer fs) (:only fs) (keys nspublics)))]&amp;lt;br&amp;gt;      (when (and to-do (not (instance? clojure.lang.Sequential to-do)))&amp;lt;br&amp;gt;        (throw (new Exception &amp;quot;:only/:refer value must be a sequential collection of symbols&amp;quot;)))&amp;lt;br&amp;gt;      (doseq [sym to-do]&amp;lt;br&amp;gt;        (when-not (exclude sym)&amp;lt;br&amp;gt;          (let [v (nspublics sym)]&amp;lt;br&amp;gt;            (when-not v&amp;lt;br&amp;gt;              (throw (new java.lang.IllegalAccessError&amp;lt;br&amp;gt;                          (if (get (ns-interns ns) sym)&amp;lt;br&amp;gt;                            (str sym &amp;quot; is not public&amp;quot;)&amp;lt;br&amp;gt;                            (str sym &amp;quot; does not exist&amp;quot;)))))&amp;lt;br&amp;gt;            (. *ns* (refer (or (rename sym) sym) v)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">refer</a>[ns-sym & filters]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;refer-clojure&lt;/b&gt; ([&amp; filters])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Same as (refer 'clojure.core &lt;filters&gt;)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro refer-clojure&amp;lt;br&amp;gt;  &amp;quot;Same as (refer 'clojure.core &amp;lt;filters&amp;gt;)&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; filters]&amp;lt;br&amp;gt;  `(clojure.core/refer '~'clojure.core ~@filters))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">refer-clojure</a>[& filters]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;reify&lt;/b&gt; ([&amp; opts+specs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; reify is a macro with the following structure:&lt;br&gt;&lt;br&gt; (reify options* specs*)&lt;br&gt;  &lt;br&gt;  Currently there are no options.&lt;br&gt;&lt;br&gt;  Each spec consists of the protocol or interface name followed by zero&lt;br&gt;  or more method bodies:&lt;br&gt;&lt;br&gt;  protocol-or-interface-or-Object&lt;br&gt;  (methodName [args+] body)*&lt;br&gt;&lt;br&gt;  Methods should be supplied for all methods of the desired&lt;br&gt;  protocol(s) and interface(s). You can also define overrides for&lt;br&gt;  methods of Object. Note that the first parameter must be supplied to&lt;br&gt;  correspond to the target object ('this' in Java parlance). Thus&lt;br&gt;  methods for interfaces will take one more argument than do the&lt;br&gt;  interface declarations.  Note also that recur calls to the method&lt;br&gt;  head should *not* pass the target object, it will be supplied&lt;br&gt;  automatically and can not be substituted.&lt;br&gt;&lt;br&gt;  The return type can be indicated by a type hint on the method name,&lt;br&gt;  and arg types can be indicated by a type hint on arg names. If you&lt;br&gt;  leave out all hints, reify will try to match on same name/arity&lt;br&gt;  method in the protocol(s)/interface(s) - this is preferred. If you&lt;br&gt;  supply any hints at all, no inference is done, so all hints (or&lt;br&gt;  default of Object) must be correct, for both arguments and return&lt;br&gt;  type. If a method is overloaded in a protocol/interface, multiple&lt;br&gt;  independent method definitions must be supplied.  If overloaded with&lt;br&gt;  same arity in an interface you must specify complete hints to&lt;br&gt;  disambiguate - a missing hint implies Object.&lt;br&gt;&lt;br&gt;  recur works to method heads The method bodies of reify are lexical&lt;br&gt;  closures, and can refer to the surrounding local scope:&lt;br&gt;  &lt;br&gt;  (str (let [f &quot;foo&quot;] &lt;br&gt;       (reify Object &lt;br&gt;         (toString [this] f))))&lt;br&gt;  == &quot;foo&quot;&lt;br&gt;&lt;br&gt;  (seq (let [f &quot;foo&quot;] &lt;br&gt;       (reify clojure.lang.Seqable &lt;br&gt;         (seq [this] (seq f)))))&lt;br&gt;  == (\f \o \o))&lt;br&gt;  &lt;br&gt;  reify always implements clojure.lang.IObj and transfers meta&lt;br&gt;  data of the form to the created object.&lt;br&gt;  &lt;br&gt;  (meta ^{:k :v} (reify Object (toString [this] &quot;foo&quot;)))&lt;br&gt;  == {:k :v}&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro reify &amp;lt;br&amp;gt;  &amp;quot;reify is a macro with the following structure:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; (reify options* specs*)&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  Currently there are no options.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Each spec consists of the protocol or interface name followed by zero&amp;lt;br&amp;gt;  or more method bodies:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  protocol-or-interface-or-Object&amp;lt;br&amp;gt;  (methodName [args+] body)*&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Methods should be supplied for all methods of the desired&amp;lt;br&amp;gt;  protocol(s) and interface(s). You can also define overrides for&amp;lt;br&amp;gt;  methods of Object. Note that the first parameter must be supplied to&amp;lt;br&amp;gt;  correspond to the target object ('this' in Java parlance). Thus&amp;lt;br&amp;gt;  methods for interfaces will take one more argument than do the&amp;lt;br&amp;gt;  interface declarations.  Note also that recur calls to the method&amp;lt;br&amp;gt;  head should *not* pass the target object, it will be supplied&amp;lt;br&amp;gt;  automatically and can not be substituted.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The return type can be indicated by a type hint on the method name,&amp;lt;br&amp;gt;  and arg types can be indicated by a type hint on arg names. If you&amp;lt;br&amp;gt;  leave out all hints, reify will try to match on same name/arity&amp;lt;br&amp;gt;  method in the protocol(s)/interface(s) - this is preferred. If you&amp;lt;br&amp;gt;  supply any hints at all, no inference is done, so all hints (or&amp;lt;br&amp;gt;  default of Object) must be correct, for both arguments and return&amp;lt;br&amp;gt;  type. If a method is overloaded in a protocol/interface, multiple&amp;lt;br&amp;gt;  independent method definitions must be supplied.  If overloaded with&amp;lt;br&amp;gt;  same arity in an interface you must specify complete hints to&amp;lt;br&amp;gt;  disambiguate - a missing hint implies Object.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  recur works to method heads The method bodies of reify are lexical&amp;lt;br&amp;gt;  closures, and can refer to the surrounding local scope:&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  (str (let [f \&amp;quot;foo\&amp;quot;] &amp;lt;br&amp;gt;       (reify Object &amp;lt;br&amp;gt;         (toString [this] f))))&amp;lt;br&amp;gt;  == \&amp;quot;foo\&amp;quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (seq (let [f \&amp;quot;foo\&amp;quot;] &amp;lt;br&amp;gt;       (reify clojure.lang.Seqable &amp;lt;br&amp;gt;         (seq [this] (seq f)))))&amp;lt;br&amp;gt;  == (\\f \\o \\o))&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  reify always implements clojure.lang.IObj and transfers meta&amp;lt;br&amp;gt;  data of the form to the created object.&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  (meta ^{:k :v} (reify Object (toString [this] \&amp;quot;foo\&amp;quot;)))&amp;lt;br&amp;gt;  == {:k :v}&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;} &amp;lt;br&amp;gt;  [&amp;amp; opts+specs]&amp;lt;br&amp;gt;  (let [[interfaces methods] (parse-opts+specs opts+specs)]&amp;lt;br&amp;gt;    (with-meta `(reify* ~interfaces ~@methods) (meta &amp;amp;form))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reify</a>[& opts+specs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;release-pending-sends&lt;/b&gt; ([])&lt;br&gt; Normally, actions sent directly or indirectly during another action&lt;br&gt;  are held until the action completes (changes the agent's&lt;br&gt;  state). This function can be used to dispatch any pending sent&lt;br&gt;  actions immediately. This has no impact on actions sent during a&lt;br&gt;  transaction, which are still held until commit. If no action is&lt;br&gt;  occurring, does nothing. Returns the number of actions dispatched.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn release-pending-sends&amp;lt;br&amp;gt;  &amp;quot;Normally, actions sent directly or indirectly during another action&amp;lt;br&amp;gt;  are held until the action completes (changes the agent's&amp;lt;br&amp;gt;  state). This function can be used to dispatch any pending sent&amp;lt;br&amp;gt;  actions immediately. This has no impact on actions sent during a&amp;lt;br&amp;gt;  transaction, which are still held until commit. If no action is&amp;lt;br&amp;gt;  occurring, does nothing. Returns the number of actions dispatched.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [] (clojure.lang.Agent/releasePendingSends))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">release-pending-sends</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;rem&lt;/b&gt; ([num div])&lt;br&gt; remainder of dividing numerator by denominator.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rem&amp;lt;br&amp;gt;  &amp;quot;remainder of dividing numerator by denominator.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true&amp;lt;br&amp;gt;   :inline (fn [x y] `(. clojure.lang.Numbers (remainder ~x ~y)))}&amp;lt;br&amp;gt;  [num div]&amp;lt;br&amp;gt;    (. clojure.lang.Numbers (remainder num div)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rem</a>[num div]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;remove&lt;/b&gt; ([pred coll])&lt;br&gt; Returns a lazy sequence of the items in coll for which&lt;br&gt;  (pred item) returns false. pred must be free of side-effects.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of the items in coll for which&amp;lt;br&amp;gt;  (pred item) returns false. pred must be free of side-effects.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [pred coll]&amp;lt;br&amp;gt;  (filter (complement pred) coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove</a>[pred coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;remove-all-methods&lt;/b&gt; ([multifn])&lt;br&gt; Removes all of the methods of multimethod.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove-all-methods&amp;lt;br&amp;gt;  &amp;quot;Removes all of the methods of multimethod.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true} &amp;lt;br&amp;gt; [^clojure.lang.MultiFn multifn]&amp;lt;br&amp;gt; (.reset multifn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove-all-methods</a>[multifn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;remove-method&lt;/b&gt; ([multifn dispatch-val])&lt;br&gt; Removes the method of multimethod associated with dispatch-value.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove-method&amp;lt;br&amp;gt;  &amp;quot;Removes the method of multimethod associated with dispatch-value.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; [^clojure.lang.MultiFn multifn dispatch-val]&amp;lt;br&amp;gt; (. multifn removeMethod dispatch-val))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove-method</a>[multifn dispatch-val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;remove-ns&lt;/b&gt; ([sym])&lt;br&gt; Removes the namespace named by the symbol. Use with caution.&lt;br&gt;  Cannot be used to remove the clojure namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove-ns&amp;lt;br&amp;gt;  &amp;quot;Removes the namespace named by the symbol. Use with caution.&amp;lt;br&amp;gt;  Cannot be used to remove the clojure namespace.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [sym] (clojure.lang.Namespace/remove sym))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove-ns</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;remove-watch&lt;/b&gt; ([reference key])&lt;br&gt; Alpha - subject to change.&lt;br&gt;  Removes a watch (set by add-watch) from a reference&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove-watch&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;  Removes a watch (set by add-watch) from a reference&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.IRef reference key]&amp;lt;br&amp;gt;  (.removeWatch reference key))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove-watch</a>[reference key]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;repeat&lt;/b&gt; ([x] [n x])&lt;br&gt; Returns a lazy (infinite!, or length n if supplied) sequence of xs.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn repeat&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy (infinite!, or length n if supplied) sequence of xs.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([x] (lazy-seq (cons x (repeat x))))&amp;lt;br&amp;gt;  ([n x] (take n (repeat x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">repeat</a>[x] [n x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;repeatedly&lt;/b&gt; ([f] [n f])&lt;br&gt; Takes a function of no args, presumably with side effects, and&lt;br&gt;  returns an infinite (or length n if supplied) lazy sequence of calls&lt;br&gt;  to it&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn repeatedly&amp;lt;br&amp;gt;  &amp;quot;Takes a function of no args, presumably with side effects, and&amp;lt;br&amp;gt;  returns an infinite (or length n if supplied) lazy sequence of calls&amp;lt;br&amp;gt;  to it&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([f] (lazy-seq (cons (f) (repeatedly f))))&amp;lt;br&amp;gt;  ([n f] (take n (repeatedly f))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">repeatedly</a>[f] [n f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;replace&lt;/b&gt; ([smap coll])&lt;br&gt; Given a map of replacement pairs and a vector/collection, returns a&lt;br&gt;  vector/seq with any elements = a key in smap replaced with the&lt;br&gt;  corresponding val in smap&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn replace&amp;lt;br&amp;gt;  &amp;quot;Given a map of replacement pairs and a vector/collection, returns a&amp;lt;br&amp;gt;  vector/seq with any elements = a key in smap replaced with the&amp;lt;br&amp;gt;  corresponding val in smap&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [smap coll]&amp;lt;br&amp;gt;    (if (vector? coll)&amp;lt;br&amp;gt;      (reduce1 (fn [v i]&amp;lt;br&amp;gt;                (if-let [e (find smap (nth v i))]&amp;lt;br&amp;gt;                        (assoc v i (val e))&amp;lt;br&amp;gt;                        v))&amp;lt;br&amp;gt;              coll (range (count coll)))&amp;lt;br&amp;gt;      (map #(if-let [e (find smap %)] (val e) %) coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">replace</a>[smap coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;replicate&lt;/b&gt; ([n x])&lt;br&gt; DEPRECATED: Use 'repeat' instead.&lt;br&gt;   Returns a lazy seq of n xs.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn replicate&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED: Use 'repeat' instead.&amp;lt;br&amp;gt;   Returns a lazy seq of n xs.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :deprecated &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [n x] (take n (repeat x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">replicate</a>[n x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;require&lt;/b&gt; ([&amp; args])&lt;br&gt; Loads libs, skipping any that are already loaded. Each argument is&lt;br&gt;  either a libspec that identifies a lib, a prefix list that identifies&lt;br&gt;  multiple libs whose names share a common prefix, or a flag that modifies&lt;br&gt;  how all the identified libs are loaded. Use :require in the ns macro&lt;br&gt;  in preference to calling this directly.&lt;br&gt;&lt;br&gt;  Libs&lt;br&gt;&lt;br&gt;  A 'lib' is a named set of resources in classpath whose contents define a&lt;br&gt;  library of Clojure code. Lib names are symbols and each lib is associated&lt;br&gt;  with a Clojure namespace and a Java package that share its name. A lib's&lt;br&gt;  name also locates its root directory within classpath using Java's&lt;br&gt;  package name to classpath-relative path mapping. All resources in a lib&lt;br&gt;  should be contained in the directory structure under its root directory.&lt;br&gt;  All definitions a lib makes should be in its associated namespace.&lt;br&gt;&lt;br&gt;  'require loads a lib by loading its root resource. The root resource path&lt;br&gt;  is derived from the lib name in the following manner:&lt;br&gt;  Consider a lib named by the symbol 'x.y.z; it has the root directory&lt;br&gt;  &lt;classpath&gt;/x/y/, and its root resource is &lt;classpath&gt;/x/y/z.clj. The root&lt;br&gt;  resource should contain code to create the lib's namespace (usually by using&lt;br&gt;  the ns macro) and load any additional lib resources.&lt;br&gt;&lt;br&gt;  Libspecs&lt;br&gt;&lt;br&gt;  A libspec is a lib name or a vector containing a lib name followed by&lt;br&gt;  options expressed as sequential keywords and arguments.&lt;br&gt;&lt;br&gt;  Recognized options:&lt;br&gt;  :as takes a symbol as its argument and makes that symbol an alias to the&lt;br&gt;    lib's namespace in the current namespace.&lt;br&gt;  :refer takes a list of symbols to refer from the namespace or the :all&lt;br&gt;    keyword to bring in all public vars.&lt;br&gt;&lt;br&gt;  Prefix Lists&lt;br&gt;&lt;br&gt;  It's common for Clojure code to depend on several libs whose names have&lt;br&gt;  the same prefix. When specifying libs, prefix lists can be used to reduce&lt;br&gt;  repetition. A prefix list contains the shared prefix followed by libspecs&lt;br&gt;  with the shared prefix removed from the lib names. After removing the&lt;br&gt;  prefix, the names that remain must not contain any periods.&lt;br&gt;&lt;br&gt;  Flags&lt;br&gt;&lt;br&gt;  A flag is a keyword.&lt;br&gt;  Recognized flags: :reload, :reload-all, :verbose&lt;br&gt;  :reload forces loading of all the identified libs even if they are&lt;br&gt;    already loaded&lt;br&gt;  :reload-all implies :reload and also forces loading of all libs that the&lt;br&gt;    identified libs directly or indirectly load via require or use&lt;br&gt;  :verbose triggers printing information about each load, alias, and refer&lt;br&gt;&lt;br&gt;  Example:&lt;br&gt;&lt;br&gt;  The following would load the libraries clojure.zip and clojure.set&lt;br&gt;  abbreviated as 's'.&lt;br&gt;&lt;br&gt;  (require '(clojure zip [set :as s]))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn require&amp;lt;br&amp;gt;  &amp;quot;Loads libs, skipping any that are already loaded. Each argument is&amp;lt;br&amp;gt;  either a libspec that identifies a lib, a prefix list that identifies&amp;lt;br&amp;gt;  multiple libs whose names share a common prefix, or a flag that modifies&amp;lt;br&amp;gt;  how all the identified libs are loaded. Use :require in the ns macro&amp;lt;br&amp;gt;  in preference to calling this directly.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Libs&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  A 'lib' is a named set of resources in classpath whose contents define a&amp;lt;br&amp;gt;  library of Clojure code. Lib names are symbols and each lib is associated&amp;lt;br&amp;gt;  with a Clojure namespace and a Java package that share its name. A lib's&amp;lt;br&amp;gt;  name also locates its root directory within classpath using Java's&amp;lt;br&amp;gt;  package name to classpath-relative path mapping. All resources in a lib&amp;lt;br&amp;gt;  should be contained in the directory structure under its root directory.&amp;lt;br&amp;gt;  All definitions a lib makes should be in its associated namespace.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  'require loads a lib by loading its root resource. The root resource path&amp;lt;br&amp;gt;  is derived from the lib name in the following manner:&amp;lt;br&amp;gt;  Consider a lib named by the symbol 'x.y.z; it has the root directory&amp;lt;br&amp;gt;  &amp;lt;classpath&amp;gt;/x/y/, and its root resource is &amp;lt;classpath&amp;gt;/x/y/z.clj. The root&amp;lt;br&amp;gt;  resource should contain code to create the lib's namespace (usually by using&amp;lt;br&amp;gt;  the ns macro) and load any additional lib resources.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Libspecs&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  A libspec is a lib name or a vector containing a lib name followed by&amp;lt;br&amp;gt;  options expressed as sequential keywords and arguments.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Recognized options:&amp;lt;br&amp;gt;  :as takes a symbol as its argument and makes that symbol an alias to the&amp;lt;br&amp;gt;    lib's namespace in the current namespace.&amp;lt;br&amp;gt;  :refer takes a list of symbols to refer from the namespace or the :all&amp;lt;br&amp;gt;    keyword to bring in all public vars.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Prefix Lists&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  It's common for Clojure code to depend on several libs whose names have&amp;lt;br&amp;gt;  the same prefix. When specifying libs, prefix lists can be used to reduce&amp;lt;br&amp;gt;  repetition. A prefix list contains the shared prefix followed by libspecs&amp;lt;br&amp;gt;  with the shared prefix removed from the lib names. After removing the&amp;lt;br&amp;gt;  prefix, the names that remain must not contain any periods.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Flags&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  A flag is a keyword.&amp;lt;br&amp;gt;  Recognized flags: :reload, :reload-all, :verbose&amp;lt;br&amp;gt;  :reload forces loading of all the identified libs even if they are&amp;lt;br&amp;gt;    already loaded&amp;lt;br&amp;gt;  :reload-all implies :reload and also forces loading of all libs that the&amp;lt;br&amp;gt;    identified libs directly or indirectly load via require or use&amp;lt;br&amp;gt;  :verbose triggers printing information about each load, alias, and refer&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Example:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The following would load the libraries clojure.zip and clojure.set&amp;lt;br&amp;gt;  abbreviated as 's'.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (require '(clojure zip [set :as s]))&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  (apply load-libs :require args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">require</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;reset!&lt;/b&gt; ([atom newval])&lt;br&gt; Sets the value of atom to newval without regard for the&lt;br&gt;  current value. Returns newval.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reset!&amp;lt;br&amp;gt;  &amp;quot;Sets the value of atom to newval without regard for the&amp;lt;br&amp;gt;  current value. Returns newval.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Atom atom newval] (.reset atom newval))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reset!</a>[atom newval]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;reset-meta!&lt;/b&gt; ([iref metadata-map])&lt;br&gt; Atomically resets the metadata for a namespace/var/ref/agent/atom&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reset-meta!&amp;lt;br&amp;gt;  &amp;quot;Atomically resets the metadata for a namespace/var/ref/agent/atom&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; [^clojure.lang.IReference iref metadata-map] (.resetMeta iref metadata-map))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reset-meta!</a>[iref metadata-map]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;resolve&lt;/b&gt; ([sym] [env sym])&lt;br&gt; same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &amp;env symbol)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve&amp;lt;br&amp;gt;  &amp;quot;same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &amp;amp;env symbol)&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([sym] (ns-resolve *ns* sym))&amp;lt;br&amp;gt;  ([env sym] (ns-resolve *ns* env sym)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve</a>[sym] [env sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;rest&lt;/b&gt; ([coll])&lt;br&gt; Returns a possibly empty seq of the items after the first. Calls seq on its&lt;br&gt;  argument.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([coll])&amp;lt;br&amp;gt;   :tag clojure.lang.ISeq&amp;lt;br&amp;gt;   :doc &amp;quot;Returns a possibly empty seq of the items after the first. Calls seq on its&amp;lt;br&amp;gt;  argument.&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}  &amp;lt;br&amp;gt; rest (fn ^:static rest [x] (. clojure.lang.RT (more x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rest</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;restart-agent&lt;/b&gt; ([a new-state &amp; options])&lt;br&gt; When an agent is failed, changes the agent state to new-state and&lt;br&gt;  then un-fails the agent so that sends are allowed again.  If&lt;br&gt;  a :clear-actions true option is given, any actions queued on the&lt;br&gt;  agent that were being held while it was failed will be discarded,&lt;br&gt;  otherwise those held actions will proceed.  The new-state must pass&lt;br&gt;  the validator if any, or restart will throw an exception and the&lt;br&gt;  agent will remain failed with its old state and error.  Watchers, if&lt;br&gt;  any, will NOT be notified of the new state.  Throws an exception if&lt;br&gt;  the agent is not failed.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn restart-agent&amp;lt;br&amp;gt;  &amp;quot;When an agent is failed, changes the agent state to new-state and&amp;lt;br&amp;gt;  then un-fails the agent so that sends are allowed again.  If&amp;lt;br&amp;gt;  a :clear-actions true option is given, any actions queued on the&amp;lt;br&amp;gt;  agent that were being held while it was failed will be discarded,&amp;lt;br&amp;gt;  otherwise those held actions will proceed.  The new-state must pass&amp;lt;br&amp;gt;  the validator if any, or restart will throw an exception and the&amp;lt;br&amp;gt;  agent will remain failed with its old state and error.  Watchers, if&amp;lt;br&amp;gt;  any, will NOT be notified of the new state.  Throws an exception if&amp;lt;br&amp;gt;  the agent is not failed.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true&amp;lt;br&amp;gt;   }&amp;lt;br&amp;gt;  [^clojure.lang.Agent a, new-state &amp;amp; options]&amp;lt;br&amp;gt;  (let [opts (apply hash-map options)]&amp;lt;br&amp;gt;    (.restart a new-state (if (:clear-actions opts) true false))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">restart-agent</a>[a new-state & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;resultset-seq&lt;/b&gt; ([rs])&lt;br&gt; Creates and returns a lazy sequence of structmaps corresponding to&lt;br&gt;  the rows in the java.sql.ResultSet rs&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resultset-seq&amp;lt;br&amp;gt;  &amp;quot;Creates and returns a lazy sequence of structmaps corresponding to&amp;lt;br&amp;gt;  the rows in the java.sql.ResultSet rs&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [^java.sql.ResultSet rs]&amp;lt;br&amp;gt;    (let [rsmeta (. rs (getMetaData))&amp;lt;br&amp;gt;          idxs (range 1 (inc (. rsmeta (getColumnCount))))&amp;lt;br&amp;gt;          keys (map (comp keyword #(.toLowerCase ^String %))&amp;lt;br&amp;gt;                    (map (fn [i] (. rsmeta (getColumnLabel i))) idxs))&amp;lt;br&amp;gt;          check-keys&amp;lt;br&amp;gt;                (or (apply distinct? keys)&amp;lt;br&amp;gt;                    (throw (Exception. &amp;quot;ResultSet must have unique column labels&amp;quot;)))&amp;lt;br&amp;gt;          row-struct (apply create-struct keys)&amp;lt;br&amp;gt;          row-values (fn [] (map (fn [^Integer i] (. rs (getObject i))) idxs))&amp;lt;br&amp;gt;          rows (fn thisfn []&amp;lt;br&amp;gt;                 (when (. rs (next))&amp;lt;br&amp;gt;                   (cons (apply struct row-struct (row-values)) (lazy-seq (thisfn)))))]&amp;lt;br&amp;gt;      (rows)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resultset-seq</a>[rs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;reverse&lt;/b&gt; ([coll])&lt;br&gt; Returns a seq of the items in coll in reverse order. Not lazy.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reverse&amp;lt;br&amp;gt;  &amp;quot;Returns a seq of the items in coll in reverse order. Not lazy.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;    (reduce1 conj () coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reverse</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;reversible?&lt;/b&gt; ([coll])&lt;br&gt; Returns true if coll implements Reversible&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reversible?&amp;lt;br&amp;gt; &amp;quot;Returns true if coll implements Reversible&amp;quot;&amp;lt;br&amp;gt; {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll] (instance? clojure.lang.Reversible coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reversible?</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;rseq&lt;/b&gt; ([rev])&lt;br&gt; Returns, in constant time, a seq of the items in rev (which&lt;br&gt;  can be a vector or sorted-map), in reverse order. If rev is empty returns nil&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rseq&amp;lt;br&amp;gt;  &amp;quot;Returns, in constant time, a seq of the items in rev (which&amp;lt;br&amp;gt;  can be a vector or sorted-map), in reverse order. If rev is empty returns nil&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Reversible rev]&amp;lt;br&amp;gt;    (. rev (rseq)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rseq</a>[rev]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;rsubseq&lt;/b&gt; ([sc test key] [sc start-test start-key end-test end-key])&lt;br&gt; sc must be a sorted collection, test(s) one of &lt;, &lt;=, &gt; or&lt;br&gt;  &gt;=. Returns a reverse seq of those entries with keys ek for&lt;br&gt;  which (test (.. sc comparator (compare ek key)) 0) is true&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rsubseq&amp;lt;br&amp;gt;  &amp;quot;sc must be a sorted collection, test(s) one of &amp;lt;, &amp;lt;=, &amp;gt; or&amp;lt;br&amp;gt;  &amp;gt;=. Returns a reverse seq of those entries with keys ek for&amp;lt;br&amp;gt;  which (test (.. sc comparator (compare ek key)) 0) is true&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([^clojure.lang.Sorted sc test key]&amp;lt;br&amp;gt;   (let [include (mk-bound-fn sc test key)]&amp;lt;br&amp;gt;     (if (#{&amp;lt; &amp;lt;=} test)&amp;lt;br&amp;gt;       (when-let [[e :as s] (. sc seqFrom key false)]&amp;lt;br&amp;gt;         (if (include e) s (next s)))&amp;lt;br&amp;gt;       (take-while include (. sc seq false)))))&amp;lt;br&amp;gt;  ([^clojure.lang.Sorted sc start-test start-key end-test end-key]&amp;lt;br&amp;gt;   (when-let [[e :as s] (. sc seqFrom end-key false)]&amp;lt;br&amp;gt;     (take-while (mk-bound-fn sc start-test start-key)&amp;lt;br&amp;gt;                 (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rsubseq</a>[sc test key] [sc start-test start-key end-test end-key]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;satisfies?&lt;/b&gt; ([protocol x])&lt;br&gt; Returns true if x satisfies the protocol&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn satisfies? &amp;lt;br&amp;gt;  &amp;quot;Returns true if x satisfies the protocol&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [protocol x]&amp;lt;br&amp;gt;  (boolean (find-protocol-impl protocol x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">satisfies?</a>[protocol x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;second&lt;/b&gt; ([x])&lt;br&gt; Same as (first (next x))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:doc &amp;quot;Same as (first (next x))&amp;quot;&amp;lt;br&amp;gt;   :arglists '([x])&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; second (fn ^:static second [x] (first (next x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">second</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;select-keys&lt;/b&gt; ([map keyseq])&lt;br&gt; Returns a map containing only those entries in map whose key is in keys&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn select-keys&amp;lt;br&amp;gt;  &amp;quot;Returns a map containing only those entries in map whose key is in keys&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [map keyseq]&amp;lt;br&amp;gt;    (loop [ret {} keys (seq keyseq)]&amp;lt;br&amp;gt;      (if keys&amp;lt;br&amp;gt;        (let [entry (. clojure.lang.RT (find map (first keys)))]&amp;lt;br&amp;gt;          (recur&amp;lt;br&amp;gt;           (if entry&amp;lt;br&amp;gt;             (conj ret entry)&amp;lt;br&amp;gt;             ret)&amp;lt;br&amp;gt;           (next keys)))&amp;lt;br&amp;gt;        (with-meta ret (meta map)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">select-keys</a>[map keyseq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;send&lt;/b&gt; ([a f &amp; args])&lt;br&gt; Dispatch an action to an agent. Returns the agent immediately.&lt;br&gt;  Subsequently, in a thread from a thread pool, the state of the agent&lt;br&gt;  will be set to the value of:&lt;br&gt;&lt;br&gt;  (apply action-fn state-of-agent args)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn send&amp;lt;br&amp;gt;  &amp;quot;Dispatch an action to an agent. Returns the agent immediately.&amp;lt;br&amp;gt;  Subsequently, in a thread from a thread pool, the state of the agent&amp;lt;br&amp;gt;  will be set to the value of:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (apply action-fn state-of-agent args)&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Agent a f &amp;amp; args]&amp;lt;br&amp;gt;  (apply send-via clojure.lang.Agent/pooledExecutor a f args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">send</a>[a f & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;send-off&lt;/b&gt; ([a f &amp; args])&lt;br&gt; Dispatch a potentially blocking action to an agent. Returns the&lt;br&gt;  agent immediately. Subsequently, in a separate thread, the state of&lt;br&gt;  the agent will be set to the value of:&lt;br&gt;&lt;br&gt;  (apply action-fn state-of-agent args)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn send-off&amp;lt;br&amp;gt;  &amp;quot;Dispatch a potentially blocking action to an agent. Returns the&amp;lt;br&amp;gt;  agent immediately. Subsequently, in a separate thread, the state of&amp;lt;br&amp;gt;  the agent will be set to the value of:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (apply action-fn state-of-agent args)&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Agent a f &amp;amp; args]&amp;lt;br&amp;gt;  (apply send-via clojure.lang.Agent/soloExecutor a f args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">send-off</a>[a f & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;send-via&lt;/b&gt; ([executor a f &amp; args])&lt;br&gt; Dispatch an action to an agent. Returns the agent immediately.&lt;br&gt;  Subsequently, in a thread supplied by executor, the state of the agent&lt;br&gt;  will be set to the value of:&lt;br&gt;&lt;br&gt;  (apply action-fn state-of-agent args)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn send-via&amp;lt;br&amp;gt;  &amp;quot;Dispatch an action to an agent. Returns the agent immediately.&amp;lt;br&amp;gt;  Subsequently, in a thread supplied by executor, the state of the agent&amp;lt;br&amp;gt;  will be set to the value of:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (apply action-fn state-of-agent args)&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [executor ^clojure.lang.Agent a f &amp;amp; args]&amp;lt;br&amp;gt;  (.dispatch a (binding [*agent* a] (binding-conveyor-fn f)) args executor))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">send-via</a>[executor a f & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;seq&lt;/b&gt; ([coll])&lt;br&gt; Returns a seq on the collection. If the collection is&lt;br&gt;    empty, returns nil.  (seq nil) returns nil. seq also works on&lt;br&gt;    Strings, native Java arrays (of reference types) and any objects&lt;br&gt;    that implement Iterable.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '(^clojure.lang.ISeq [coll])&amp;lt;br&amp;gt;   :doc &amp;quot;Returns a seq on the collection. If the collection is&amp;lt;br&amp;gt;    empty, returns nil.  (seq nil) returns nil. seq also works on&amp;lt;br&amp;gt;    Strings, native Java arrays (of reference types) and any objects&amp;lt;br&amp;gt;    that implement Iterable.&amp;quot;&amp;lt;br&amp;gt;   :tag clojure.lang.ISeq&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; seq (fn ^:static seq ^clojure.lang.ISeq [coll] (. clojure.lang.RT (seq coll))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">seq</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;seq?&lt;/b&gt; ([x])&lt;br&gt; Return true if x implements ISeq&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([x])&amp;lt;br&amp;gt;   :doc &amp;quot;Return true if x implements ISeq&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; seq? (fn ^:static seq? [x] (instance? clojure.lang.ISeq x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">seq?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;seque&lt;/b&gt; ([s] [n-or-q s])&lt;br&gt; Creates a queued seq on another (presumably lazy) seq s. The queued&lt;br&gt;  seq will produce a concrete seq in the background, and can get up to&lt;br&gt;  n items ahead of the consumer. n-or-q can be an integer n buffer&lt;br&gt;  size, or an instance of java.util.concurrent BlockingQueue. Note&lt;br&gt;  that reading from a seque can block if the reader gets ahead of the&lt;br&gt;  producer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn seque&amp;lt;br&amp;gt;  &amp;quot;Creates a queued seq on another (presumably lazy) seq s. The queued&amp;lt;br&amp;gt;  seq will produce a concrete seq in the background, and can get up to&amp;lt;br&amp;gt;  n items ahead of the consumer. n-or-q can be an integer n buffer&amp;lt;br&amp;gt;  size, or an instance of java.util.concurrent BlockingQueue. Note&amp;lt;br&amp;gt;  that reading from a seque can block if the reader gets ahead of the&amp;lt;br&amp;gt;  producer.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([s] (seque 100 s))&amp;lt;br&amp;gt;  ([n-or-q s]&amp;lt;br&amp;gt;   (let [^BlockingQueue q (if (instance? BlockingQueue n-or-q)&amp;lt;br&amp;gt;                             n-or-q&amp;lt;br&amp;gt;                             (LinkedBlockingQueue. (int n-or-q)))&amp;lt;br&amp;gt;         NIL (Object.) ;nil sentinel since LBQ doesn't support nils&amp;lt;br&amp;gt;         agt (agent (lazy-seq s)) ; never start with nil; that signifies we've already put eos&amp;lt;br&amp;gt;         log-error (fn [q e]&amp;lt;br&amp;gt;                     (if (.offer q q)&amp;lt;br&amp;gt;                       (throw e)&amp;lt;br&amp;gt;                       e))&amp;lt;br&amp;gt;         fill (fn [s]&amp;lt;br&amp;gt;                (when s&amp;lt;br&amp;gt;                  (if (instance? Exception s) ; we failed to .offer an error earlier&amp;lt;br&amp;gt;                    (log-error q s)&amp;lt;br&amp;gt;                    (try&amp;lt;br&amp;gt;                      (loop [[x &amp;amp; xs :as s] (seq s)]&amp;lt;br&amp;gt;                        (if s&amp;lt;br&amp;gt;                          (if (.offer q (if (nil? x) NIL x))&amp;lt;br&amp;gt;                            (recur xs)&amp;lt;br&amp;gt;                            s)&amp;lt;br&amp;gt;                          (when-not (.offer q q) ; q itself is eos sentinel&amp;lt;br&amp;gt;                            ()))) ; empty seq, not nil, so we know to put eos next time&amp;lt;br&amp;gt;                      (catch Exception e&amp;lt;br&amp;gt;                        (log-error q e))))))&amp;lt;br&amp;gt;         drain (fn drain []&amp;lt;br&amp;gt;                 (lazy-seq&amp;lt;br&amp;gt;                  (let [x (.take q)]&amp;lt;br&amp;gt;                    (if (identical? x q) ;q itself is eos sentinel&amp;lt;br&amp;gt;                      (do @agt nil)  ;touch agent just to propagate errors&amp;lt;br&amp;gt;                      (do&amp;lt;br&amp;gt;                        (send-off agt fill)&amp;lt;br&amp;gt;                        (cons (if (identical? x NIL) nil x) (drain)))))))]&amp;lt;br&amp;gt;     (send-off agt fill)&amp;lt;br&amp;gt;     (drain))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">seque</a>[s] [n-or-q s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;sequence&lt;/b&gt; ([coll])&lt;br&gt; Coerces coll to a (possibly empty) sequence, if it is not already&lt;br&gt;  one. Will not force a lazy seq. (sequence nil) yields ()&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sequence&amp;lt;br&amp;gt;  &amp;quot;Coerces coll to a (possibly empty) sequence, if it is not already&amp;lt;br&amp;gt;  one. Will not force a lazy seq. (sequence nil) yields ()&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;   (if (seq? coll) coll&amp;lt;br&amp;gt;    (or (seq coll) ())))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sequence</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;sequential?&lt;/b&gt; ([coll])&lt;br&gt; Returns true if coll implements Sequential&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sequential?&amp;lt;br&amp;gt; &amp;quot;Returns true if coll implements Sequential&amp;quot;&amp;lt;br&amp;gt; {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;  :static true}&amp;lt;br&amp;gt;  [coll] (instance? clojure.lang.Sequential coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sequential?</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;set&lt;/b&gt; ([coll])&lt;br&gt; Returns a set of the distinct elements of coll.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set&amp;lt;br&amp;gt;  &amp;quot;Returns a set of the distinct elements of coll.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll] (clojure.lang.PersistentHashSet/create (seq coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;set-agent-send-executor!&lt;/b&gt; ([executor])&lt;br&gt; Sets the ExecutorService to be used by send&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-agent-send-executor!&amp;lt;br&amp;gt;  &amp;quot;Sets the ExecutorService to be used by send&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [executor]&amp;lt;br&amp;gt;  (set! clojure.lang.Agent/pooledExecutor executor))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-agent-send-executor!</a>[executor]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;set-agent-send-off-executor!&lt;/b&gt; ([executor])&lt;br&gt; Sets the ExecutorService to be used by send-off&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-agent-send-off-executor!&amp;lt;br&amp;gt;  &amp;quot;Sets the ExecutorService to be used by send-off&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [executor]&amp;lt;br&amp;gt;  (set! clojure.lang.Agent/soloExecutor executor))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-agent-send-off-executor!</a>[executor]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;set-error-handler!&lt;/b&gt; ([a handler-fn])&lt;br&gt; Sets the error-handler of agent a to handler-fn.  If an action&lt;br&gt;  being run by the agent throws an exception or doesn't pass the&lt;br&gt;  validator fn, handler-fn will be called with two arguments: the&lt;br&gt;  agent and the exception.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-error-handler!&amp;lt;br&amp;gt;  &amp;quot;Sets the error-handler of agent a to handler-fn.  If an action&amp;lt;br&amp;gt;  being run by the agent throws an exception or doesn't pass the&amp;lt;br&amp;gt;  validator fn, handler-fn will be called with two arguments: the&amp;lt;br&amp;gt;  agent and the exception.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Agent a, handler-fn]&amp;lt;br&amp;gt;  (.setErrorHandler a handler-fn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-error-handler!</a>[a handler-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;set-error-mode!&lt;/b&gt; ([a mode-keyword])&lt;br&gt; Sets the error-mode of agent a to mode-keyword, which must be&lt;br&gt;  either :fail or :continue.  If an action being run by the agent&lt;br&gt;  throws an exception or doesn't pass the validator fn, an&lt;br&gt;  error-handler may be called (see set-error-handler!), after which,&lt;br&gt;  if the mode is :continue, the agent will continue as if neither the&lt;br&gt;  action that caused the error nor the error itself ever happened.&lt;br&gt;  &lt;br&gt;  If the mode is :fail, the agent will become failed and will stop&lt;br&gt;  accepting new 'send' and 'send-off' actions, and any previously&lt;br&gt;  queued actions will be held until a 'restart-agent'.  Deref will&lt;br&gt;  still work, returning the state of the agent before the error.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-error-mode!&amp;lt;br&amp;gt;  &amp;quot;Sets the error-mode of agent a to mode-keyword, which must be&amp;lt;br&amp;gt;  either :fail or :continue.  If an action being run by the agent&amp;lt;br&amp;gt;  throws an exception or doesn't pass the validator fn, an&amp;lt;br&amp;gt;  error-handler may be called (see set-error-handler!), after which,&amp;lt;br&amp;gt;  if the mode is :continue, the agent will continue as if neither the&amp;lt;br&amp;gt;  action that caused the error nor the error itself ever happened.&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  If the mode is :fail, the agent will become failed and will stop&amp;lt;br&amp;gt;  accepting new 'send' and 'send-off' actions, and any previously&amp;lt;br&amp;gt;  queued actions will be held until a 'restart-agent'.  Deref will&amp;lt;br&amp;gt;  still work, returning the state of the agent before the error.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Agent a, mode-keyword]&amp;lt;br&amp;gt;  (.setErrorMode a mode-keyword))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-error-mode!</a>[a mode-keyword]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;set-validator!&lt;/b&gt; ([iref validator-fn])&lt;br&gt; Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a&lt;br&gt;  side-effect-free fn of one argument, which will be passed the intended&lt;br&gt;  new state on any state change. If the new state is unacceptable, the&lt;br&gt;  validator-fn should return false or throw an exception. If the current state (root&lt;br&gt;  value if var) is not acceptable to the new validator, an exception&lt;br&gt;  will be thrown and the validator will not be changed.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-validator!&amp;lt;br&amp;gt;  &amp;quot;Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a&amp;lt;br&amp;gt;  side-effect-free fn of one argument, which will be passed the intended&amp;lt;br&amp;gt;  new state on any state change. If the new state is unacceptable, the&amp;lt;br&amp;gt;  validator-fn should return false or throw an exception. If the current state (root&amp;lt;br&amp;gt;  value if var) is not acceptable to the new validator, an exception&amp;lt;br&amp;gt;  will be thrown and the validator will not be changed.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.IRef iref validator-fn] (. iref (setValidator validator-fn)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-validator!</a>[iref validator-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;set?&lt;/b&gt; ([x])&lt;br&gt; Returns true if x implements IPersistentSet&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set?&amp;lt;br&amp;gt;  &amp;quot;Returns true if x implements IPersistentSet&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (instance? clojure.lang.IPersistentSet x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;short&lt;/b&gt; ([x])&lt;br&gt; Coerce to short&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn short&amp;lt;br&amp;gt;  &amp;quot;Coerce to short&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedShortCast 'shortCast) ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [^Number x] (clojure.lang.RT/shortCast x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">short</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;short-array&lt;/b&gt; ([size-or-seq] [size init-val-or-seq])&lt;br&gt; Creates an array of shorts&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn short-array&amp;lt;br&amp;gt;  &amp;quot;Creates an array of shorts&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [&amp;amp; args] `(. clojure.lang.Numbers short_array ~@args))&amp;lt;br&amp;gt;   :inline-arities #{1 2}&amp;lt;br&amp;gt;   :added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  ([size-or-seq] (. clojure.lang.Numbers short_array size-or-seq))&amp;lt;br&amp;gt;  ([size init-val-or-seq] (. clojure.lang.Numbers short_array size init-val-or-seq)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">short-array</a>[size-or-seq] [size init-val-or-seq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;shorts&lt;/b&gt; ([xs])&lt;br&gt; Casts to shorts[]&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(definline shorts&amp;lt;br&amp;gt;  &amp;quot;Casts to shorts[]&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [xs] `(. clojure.lang.Numbers shorts ~xs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">shorts</a>[xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;shuffle&lt;/b&gt; ([coll])&lt;br&gt; Return a random permutation of coll&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn shuffle&amp;lt;br&amp;gt;  &amp;quot;Return a random permutation of coll&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^java.util.Collection coll]&amp;lt;br&amp;gt;  (let [al (java.util.ArrayList. coll)]&amp;lt;br&amp;gt;    (java.util.Collections/shuffle al)&amp;lt;br&amp;gt;    (clojure.lang.RT/vector (.toArray al))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">shuffle</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;shutdown-agents&lt;/b&gt; ([])&lt;br&gt; Initiates a shutdown of the thread pools that back the agent&lt;br&gt;  system. Running actions will complete, but no new actions will be&lt;br&gt;  accepted&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn shutdown-agents&amp;lt;br&amp;gt;  &amp;quot;Initiates a shutdown of the thread pools that back the agent&amp;lt;br&amp;gt;  system. Running actions will complete, but no new actions will be&amp;lt;br&amp;gt;  accepted&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [] (. clojure.lang.Agent shutdown))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">shutdown-agents</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;slurp&lt;/b&gt; ([f &amp; opts])&lt;br&gt; Opens a reader on f and reads all its contents, returning a string.&lt;br&gt;  See clojure.java.io/reader for a complete list of supported arguments.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn slurp&amp;lt;br&amp;gt;  &amp;quot;Opens a reader on f and reads all its contents, returning a string.&amp;lt;br&amp;gt;  See clojure.java.io/reader for a complete list of supported arguments.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([f &amp;amp; opts]&amp;lt;br&amp;gt;     (let [opts (normalize-slurp-opts opts)&amp;lt;br&amp;gt;           sb (StringBuilder.)]&amp;lt;br&amp;gt;       (with-open [#^java.io.Reader r (apply jio/reader f opts)]&amp;lt;br&amp;gt;         (loop [c (.read r)]&amp;lt;br&amp;gt;           (if (neg? c)&amp;lt;br&amp;gt;             (str sb)&amp;lt;br&amp;gt;             (do&amp;lt;br&amp;gt;               (.append sb (char c))&amp;lt;br&amp;gt;               (recur (.read r)))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">slurp</a>[f & opts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;some&lt;/b&gt; ([pred coll])&lt;br&gt; Returns the first logical true value of (pred x) for any x in coll,&lt;br&gt;  else nil.  One common idiom is to use a set as pred, for example&lt;br&gt;  this will return :fred if :fred is in the sequence, otherwise nil:&lt;br&gt;  (some #{:fred} coll)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn some&amp;lt;br&amp;gt;  &amp;quot;Returns the first logical true value of (pred x) for any x in coll,&amp;lt;br&amp;gt;  else nil.  One common idiom is to use a set as pred, for example&amp;lt;br&amp;gt;  this will return :fred if :fred is in the sequence, otherwise nil:&amp;lt;br&amp;gt;  (some #{:fred} coll)&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [pred coll]&amp;lt;br&amp;gt;    (when (seq coll)&amp;lt;br&amp;gt;      (or (pred (first coll)) (recur pred (next coll)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">some</a>[pred coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;some-&gt;&lt;/b&gt; ([expr &amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; When expr is not nil, threads it into the first form (via -&gt;),&lt;br&gt;  and when that result is not nil, through the next etc&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro some-&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;When expr is not nil, threads it into the first form (via -&amp;gt;),&amp;lt;br&amp;gt;  and when that result is not nil, through the next etc&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [expr &amp;amp; forms]&amp;lt;br&amp;gt;  (let [g (gensym)&amp;lt;br&amp;gt;        pstep (fn [step] `(if (nil? ~g) nil (-&amp;gt; ~g ~step)))]&amp;lt;br&amp;gt;    `(let [~g ~expr&amp;lt;br&amp;gt;           ~@(interleave (repeat g) (map pstep forms))]&amp;lt;br&amp;gt;       ~g)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">some-></a>[expr & forms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;some-&gt;&gt;&lt;/b&gt; ([expr &amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; When expr is not nil, threads it into the first form (via -&gt;&gt;),&lt;br&gt;  and when that result is not nil, through the next etc&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro some-&amp;gt;&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;When expr is not nil, threads it into the first form (via -&amp;gt;&amp;gt;),&amp;lt;br&amp;gt;  and when that result is not nil, through the next etc&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [expr &amp;amp; forms]&amp;lt;br&amp;gt;  (let [g (gensym)&amp;lt;br&amp;gt;        pstep (fn [step] `(if (nil? ~g) nil (-&amp;gt;&amp;gt; ~g ~step)))]&amp;lt;br&amp;gt;    `(let [~g ~expr&amp;lt;br&amp;gt;           ~@(interleave (repeat g) (map pstep forms))]&amp;lt;br&amp;gt;       ~g)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">some->></a>[expr & forms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;some-fn&lt;/b&gt; ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 &amp; ps])&lt;br&gt; Takes a set of predicates and returns a function f that returns the first logical true value&lt;br&gt;  returned by one of its composing predicates against any of its arguments, else it returns&lt;br&gt;  logical false. Note that f is short-circuiting in that it will stop execution on the first&lt;br&gt;  argument that triggers a logical true result against the original predicates.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn some-fn&amp;lt;br&amp;gt;  &amp;quot;Takes a set of predicates and returns a function f that returns the first logical true value&amp;lt;br&amp;gt;  returned by one of its composing predicates against any of its arguments, else it returns&amp;lt;br&amp;gt;  logical false. Note that f is short-circuiting in that it will stop execution on the first&amp;lt;br&amp;gt;  argument that triggers a logical true result against the original predicates.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  ([p]&amp;lt;br&amp;gt;     (fn sp1&amp;lt;br&amp;gt;       ([] nil)&amp;lt;br&amp;gt;       ([x] (p x))&amp;lt;br&amp;gt;       ([x y] (or (p x) (p y)))&amp;lt;br&amp;gt;       ([x y z] (or (p x) (p y) (p z)))&amp;lt;br&amp;gt;       ([x y z &amp;amp; args] (or (sp1 x y z)&amp;lt;br&amp;gt;                           (some p args)))))&amp;lt;br&amp;gt;  ([p1 p2]&amp;lt;br&amp;gt;     (fn sp2&amp;lt;br&amp;gt;       ([] nil)&amp;lt;br&amp;gt;       ([x] (or (p1 x) (p2 x)))&amp;lt;br&amp;gt;       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))&amp;lt;br&amp;gt;       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))&amp;lt;br&amp;gt;       ([x y z &amp;amp; args] (or (sp2 x y z)&amp;lt;br&amp;gt;                           (some #(or (p1 %) (p2 %)) args)))))&amp;lt;br&amp;gt;  ([p1 p2 p3]&amp;lt;br&amp;gt;     (fn sp3&amp;lt;br&amp;gt;       ([] nil)&amp;lt;br&amp;gt;       ([x] (or (p1 x) (p2 x) (p3 x)))&amp;lt;br&amp;gt;       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))&amp;lt;br&amp;gt;       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))&amp;lt;br&amp;gt;       ([x y z &amp;amp; args] (or (sp3 x y z)&amp;lt;br&amp;gt;                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))&amp;lt;br&amp;gt;  ([p1 p2 p3 &amp;amp; ps]&amp;lt;br&amp;gt;     (let [ps (list* p1 p2 p3 ps)]&amp;lt;br&amp;gt;       (fn spn&amp;lt;br&amp;gt;         ([] nil)&amp;lt;br&amp;gt;         ([x] (some #(% x) ps))&amp;lt;br&amp;gt;         ([x y] (some #(or (% x) (% y)) ps))&amp;lt;br&amp;gt;         ([x y z] (some #(or (% x) (% y) (% z)) ps))&amp;lt;br&amp;gt;         ([x y z &amp;amp; args] (or (spn x y z)&amp;lt;br&amp;gt;                             (some #(some % args) ps)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">some-fn</a>[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;sort&lt;/b&gt; ([coll] [comp coll])&lt;br&gt; Returns a sorted sequence of the items in coll. If no comparator is&lt;br&gt;  supplied, uses compare.  comparator must implement&lt;br&gt;  java.util.Comparator.  If coll is a Java array, it will be modified.&lt;br&gt;  To avoid this, sort a copy of the array.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sort&amp;lt;br&amp;gt;  &amp;quot;Returns a sorted sequence of the items in coll. If no comparator is&amp;lt;br&amp;gt;  supplied, uses compare.  comparator must implement&amp;lt;br&amp;gt;  java.util.Comparator.  If coll is a Java array, it will be modified.&amp;lt;br&amp;gt;  To avoid this, sort a copy of the array.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([coll]&amp;lt;br&amp;gt;   (sort compare coll))&amp;lt;br&amp;gt;  ([^java.util.Comparator comp coll]&amp;lt;br&amp;gt;   (if (seq coll)&amp;lt;br&amp;gt;     (let [a (to-array coll)]&amp;lt;br&amp;gt;       (. java.util.Arrays (sort a comp))&amp;lt;br&amp;gt;       (seq a))&amp;lt;br&amp;gt;     ())))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sort</a>[coll] [comp coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;sort-by&lt;/b&gt; ([keyfn coll] [keyfn comp coll])&lt;br&gt; Returns a sorted sequence of the items in coll, where the sort&lt;br&gt;  order is determined by comparing (keyfn item).  If no comparator is&lt;br&gt;  supplied, uses compare.  comparator must implement&lt;br&gt;  java.util.Comparator.  If coll is a Java array, it will be modified.&lt;br&gt;  To avoid this, sort a copy of the array.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sort-by&amp;lt;br&amp;gt;  &amp;quot;Returns a sorted sequence of the items in coll, where the sort&amp;lt;br&amp;gt;  order is determined by comparing (keyfn item).  If no comparator is&amp;lt;br&amp;gt;  supplied, uses compare.  comparator must implement&amp;lt;br&amp;gt;  java.util.Comparator.  If coll is a Java array, it will be modified.&amp;lt;br&amp;gt;  To avoid this, sort a copy of the array.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([keyfn coll]&amp;lt;br&amp;gt;   (sort-by keyfn compare coll))&amp;lt;br&amp;gt;  ([keyfn ^java.util.Comparator comp coll]&amp;lt;br&amp;gt;   (sort (fn [x y] (. comp (compare (keyfn x) (keyfn y)))) coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sort-by</a>[keyfn coll] [keyfn comp coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;sorted-map&lt;/b&gt; ([&amp; keyvals])&lt;br&gt; keyval =&gt; key val&lt;br&gt;  Returns a new sorted map with supplied mappings.  If any keys are&lt;br&gt;  equal, they are handled as if by repeated uses of assoc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sorted-map&amp;lt;br&amp;gt;  &amp;quot;keyval =&amp;gt; key val&amp;lt;br&amp;gt;  Returns a new sorted map with supplied mappings.  If any keys are&amp;lt;br&amp;gt;  equal, they are handled as if by repeated uses of assoc.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([&amp;amp; keyvals]&amp;lt;br&amp;gt;   (clojure.lang.PersistentTreeMap/create keyvals)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sorted-map</a>[& keyvals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;sorted-map-by&lt;/b&gt; ([comparator &amp; keyvals])&lt;br&gt; keyval =&gt; key val&lt;br&gt;  Returns a new sorted map with supplied mappings, using the supplied&lt;br&gt;  comparator.  If any keys are equal, they are handled as if by&lt;br&gt;  repeated uses of assoc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sorted-map-by&amp;lt;br&amp;gt;  &amp;quot;keyval =&amp;gt; key val&amp;lt;br&amp;gt;  Returns a new sorted map with supplied mappings, using the supplied&amp;lt;br&amp;gt;  comparator.  If any keys are equal, they are handled as if by&amp;lt;br&amp;gt;  repeated uses of assoc.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([comparator &amp;amp; keyvals]&amp;lt;br&amp;gt;   (clojure.lang.PersistentTreeMap/create comparator keyvals)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sorted-map-by</a>[comparator & keyvals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;sorted-set&lt;/b&gt; ([&amp; keys])&lt;br&gt; Returns a new sorted set with supplied keys.  Any equal keys are&lt;br&gt;  handled as if by repeated uses of conj.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sorted-set&amp;lt;br&amp;gt;  &amp;quot;Returns a new sorted set with supplied keys.  Any equal keys are&amp;lt;br&amp;gt;  handled as if by repeated uses of conj.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([&amp;amp; keys]&amp;lt;br&amp;gt;   (clojure.lang.PersistentTreeSet/create keys)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sorted-set</a>[& keys]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;sorted-set-by&lt;/b&gt; ([comparator &amp; keys])&lt;br&gt; Returns a new sorted set with supplied keys, using the supplied&lt;br&gt;  comparator.  Any equal keys are handled as if by repeated uses of&lt;br&gt;  conj.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sorted-set-by&amp;lt;br&amp;gt;  &amp;quot;Returns a new sorted set with supplied keys, using the supplied&amp;lt;br&amp;gt;  comparator.  Any equal keys are handled as if by repeated uses of&amp;lt;br&amp;gt;  conj.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true} &amp;lt;br&amp;gt;  ([comparator &amp;amp; keys]&amp;lt;br&amp;gt;   (clojure.lang.PersistentTreeSet/create comparator keys)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sorted-set-by</a>[comparator & keys]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;sorted?&lt;/b&gt; ([coll])&lt;br&gt; Returns true if coll implements Sorted&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sorted?&amp;lt;br&amp;gt; &amp;quot;Returns true if coll implements Sorted&amp;quot;&amp;lt;br&amp;gt; {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll] (instance? clojure.lang.Sorted coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sorted?</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;special-symbol?&lt;/b&gt; ([s])&lt;br&gt; Returns true if s names a special form&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn special-symbol?&amp;lt;br&amp;gt;  &amp;quot;Returns true if s names a special form&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [s]&amp;lt;br&amp;gt;    (contains? (. clojure.lang.Compiler specials) s))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">special-symbol?</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;spit&lt;/b&gt; ([f content &amp; options])&lt;br&gt; Opposite of slurp.  Opens f with writer, writes content, then&lt;br&gt;  closes f. Options passed to clojure.java.io/writer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn spit&amp;lt;br&amp;gt;  &amp;quot;Opposite of slurp.  Opens f with writer, writes content, then&amp;lt;br&amp;gt;  closes f. Options passed to clojure.java.io/writer.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [f content &amp;amp; options]&amp;lt;br&amp;gt;  (with-open [#^java.io.Writer w (apply jio/writer f options)]&amp;lt;br&amp;gt;    (.write w (str content))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">spit</a>[f content & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;split-at&lt;/b&gt; ([n coll])&lt;br&gt; Returns a vector of [(take n coll) (drop n coll)]&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn split-at&amp;lt;br&amp;gt;  &amp;quot;Returns a vector of [(take n coll) (drop n coll)]&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [n coll]&amp;lt;br&amp;gt;    [(take n coll) (drop n coll)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">split-at</a>[n coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;split-with&lt;/b&gt; ([pred coll])&lt;br&gt; Returns a vector of [(take-while pred coll) (drop-while pred coll)]&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn split-with&amp;lt;br&amp;gt;  &amp;quot;Returns a vector of [(take-while pred coll) (drop-while pred coll)]&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [pred coll]&amp;lt;br&amp;gt;    [(take-while pred coll) (drop-while pred coll)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">split-with</a>[pred coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;str&lt;/b&gt; ([] [x] [x &amp; ys])&lt;br&gt; With no args, returns the empty string. With one arg x, returns&lt;br&gt;  x.toString().  (str nil) returns the empty string. With more than&lt;br&gt;  one arg, returns the concatenation of the str values of the args.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn str&amp;lt;br&amp;gt;  &amp;quot;With no args, returns the empty string. With one arg x, returns&amp;lt;br&amp;gt;  x.toString().  (str nil) returns the empty string. With more than&amp;lt;br&amp;gt;  one arg, returns the concatenation of the str values of the args.&amp;quot;&amp;lt;br&amp;gt;  {:tag String&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  (^String [] &amp;quot;&amp;quot;)&amp;lt;br&amp;gt;  (^String [^Object x]&amp;lt;br&amp;gt;   (if (nil? x) &amp;quot;&amp;quot; (. x (toString))))&amp;lt;br&amp;gt;  (^String [x &amp;amp; ys]&amp;lt;br&amp;gt;     ((fn [^StringBuilder sb more]&amp;lt;br&amp;gt;          (if more&amp;lt;br&amp;gt;            (recur (. sb  (append (str (first more)))) (next more))&amp;lt;br&amp;gt;            (str sb)))&amp;lt;br&amp;gt;      (new StringBuilder (str x)) ys)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">str</a>[] [x] [x & ys]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;string?&lt;/b&gt; ([x])&lt;br&gt; Return true if x is a String&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([x])&amp;lt;br&amp;gt;   :doc &amp;quot;Return true if x is a String&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; string? (fn ^:static string? [x] (instance? String x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">string?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;struct&lt;/b&gt; ([s &amp; vals])&lt;br&gt; Returns a new structmap instance with the keys of the&lt;br&gt;  structure-basis. vals must be supplied for basis keys in order -&lt;br&gt;  where values are not supplied they will default to nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn struct&amp;lt;br&amp;gt;  &amp;quot;Returns a new structmap instance with the keys of the&amp;lt;br&amp;gt;  structure-basis. vals must be supplied for basis keys in order -&amp;lt;br&amp;gt;  where values are not supplied they will default to nil.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [s &amp;amp; vals]&amp;lt;br&amp;gt;    (. clojure.lang.PersistentStructMap (construct s vals)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">struct</a>[s & vals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;struct-map&lt;/b&gt; ([s &amp; inits])&lt;br&gt; Returns a new structmap instance with the keys of the&lt;br&gt;  structure-basis. keyvals may contain all, some or none of the basis&lt;br&gt;  keys - where values are not supplied they will default to nil.&lt;br&gt;  keyvals can also contain keys not in the basis.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn struct-map&amp;lt;br&amp;gt;  &amp;quot;Returns a new structmap instance with the keys of the&amp;lt;br&amp;gt;  structure-basis. keyvals may contain all, some or none of the basis&amp;lt;br&amp;gt;  keys - where values are not supplied they will default to nil.&amp;lt;br&amp;gt;  keyvals can also contain keys not in the basis.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [s &amp;amp; inits]&amp;lt;br&amp;gt;    (. clojure.lang.PersistentStructMap (create s inits)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">struct-map</a>[s & inits]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;subs&lt;/b&gt; ([s start] [s start end])&lt;br&gt; Returns the substring of s beginning at start inclusive, and ending&lt;br&gt;  at end (defaults to length of string), exclusive.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subs&amp;lt;br&amp;gt;  &amp;quot;Returns the substring of s beginning at start inclusive, and ending&amp;lt;br&amp;gt;  at end (defaults to length of string), exclusive.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  (^String [^String s start] (. s (substring start)))&amp;lt;br&amp;gt;  (^String [^String s start end] (. s (substring start end))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subs</a>[s start] [s start end]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;subseq&lt;/b&gt; ([sc test key] [sc start-test start-key end-test end-key])&lt;br&gt; sc must be a sorted collection, test(s) one of &lt;, &lt;=, &gt; or&lt;br&gt;  &gt;=. Returns a seq of those entries with keys ek for&lt;br&gt;  which (test (.. sc comparator (compare ek key)) 0) is true&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subseq&amp;lt;br&amp;gt;  &amp;quot;sc must be a sorted collection, test(s) one of &amp;lt;, &amp;lt;=, &amp;gt; or&amp;lt;br&amp;gt;  &amp;gt;=. Returns a seq of those entries with keys ek for&amp;lt;br&amp;gt;  which (test (.. sc comparator (compare ek key)) 0) is true&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([^clojure.lang.Sorted sc test key]&amp;lt;br&amp;gt;   (let [include (mk-bound-fn sc test key)]&amp;lt;br&amp;gt;     (if (#{&amp;gt; &amp;gt;=} test)&amp;lt;br&amp;gt;       (when-let [[e :as s] (. sc seqFrom key true)]&amp;lt;br&amp;gt;         (if (include e) s (next s)))&amp;lt;br&amp;gt;       (take-while include (. sc seq true)))))&amp;lt;br&amp;gt;  ([^clojure.lang.Sorted sc start-test start-key end-test end-key]&amp;lt;br&amp;gt;   (when-let [[e :as s] (. sc seqFrom start-key true)]&amp;lt;br&amp;gt;     (take-while (mk-bound-fn sc end-test end-key)&amp;lt;br&amp;gt;                 (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subseq</a>[sc test key] [sc start-test start-key end-test end-key]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;subvec&lt;/b&gt; ([v start] [v start end])&lt;br&gt; Returns a persistent vector of the items in vector from&lt;br&gt;  start (inclusive) to end (exclusive).  If end is not supplied,&lt;br&gt;  defaults to (count vector). This operation is O(1) and very fast, as&lt;br&gt;  the resulting vector shares structure with the original and no&lt;br&gt;  trimming is done.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subvec&amp;lt;br&amp;gt;  &amp;quot;Returns a persistent vector of the items in vector from&amp;lt;br&amp;gt;  start (inclusive) to end (exclusive).  If end is not supplied,&amp;lt;br&amp;gt;  defaults to (count vector). This operation is O(1) and very fast, as&amp;lt;br&amp;gt;  the resulting vector shares structure with the original and no&amp;lt;br&amp;gt;  trimming is done.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([v start]&amp;lt;br&amp;gt;   (subvec v start (count v)))&amp;lt;br&amp;gt;  ([v start end]&amp;lt;br&amp;gt;   (. clojure.lang.RT (subvec v start end))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subvec</a>[v start] [v start end]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;supers&lt;/b&gt; ([class])&lt;br&gt; Returns the immediate and indirect superclasses and interfaces of c, if any&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn supers&amp;lt;br&amp;gt;  &amp;quot;Returns the immediate and indirect superclasses and interfaces of c, if any&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^Class class]&amp;lt;br&amp;gt;  (loop [ret (set (bases class)) cs ret]&amp;lt;br&amp;gt;    (if (seq cs)&amp;lt;br&amp;gt;      (let [c (first cs) bs (bases c)]&amp;lt;br&amp;gt;        (recur (into1 ret bs) (into1 (disj cs c) bs)))&amp;lt;br&amp;gt;      (not-empty ret))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">supers</a>[class]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;swap!&lt;/b&gt; ([atom f] [atom f x] [atom f x y] [atom f x y &amp; args])&lt;br&gt; Atomically swaps the value of atom to be:&lt;br&gt;  (apply f current-value-of-atom args). Note that f may be called&lt;br&gt;  multiple times, and thus should be free of side effects.  Returns&lt;br&gt;  the value that was swapped in.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn swap!&amp;lt;br&amp;gt;  &amp;quot;Atomically swaps the value of atom to be:&amp;lt;br&amp;gt;  (apply f current-value-of-atom args). Note that f may be called&amp;lt;br&amp;gt;  multiple times, and thus should be free of side effects.  Returns&amp;lt;br&amp;gt;  the value that was swapped in.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([^clojure.lang.Atom atom f] (.swap atom f))&amp;lt;br&amp;gt;  ([^clojure.lang.Atom atom f x] (.swap atom f x))&amp;lt;br&amp;gt;  ([^clojure.lang.Atom atom f x y] (.swap atom f x y))&amp;lt;br&amp;gt;  ([^clojure.lang.Atom atom f x y &amp;amp; args] (.swap atom f x y args)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">swap!</a>[atom f] [atom f x] [atom f x y] [atom f x y & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;symbol&lt;/b&gt; ([name] [ns name])&lt;br&gt; Returns a Symbol with the given namespace and name.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn symbol&amp;lt;br&amp;gt;  &amp;quot;Returns a Symbol with the given namespace and name.&amp;quot;&amp;lt;br&amp;gt;  {:tag clojure.lang.Symbol&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([name] (if (symbol? name) name (clojure.lang.Symbol/intern name)))&amp;lt;br&amp;gt;  ([ns name] (clojure.lang.Symbol/intern ns name)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">symbol</a>[name] [ns name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;symbol?&lt;/b&gt; ([x])&lt;br&gt; Return true if x is a Symbol&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn symbol?&amp;lt;br&amp;gt;  &amp;quot;Return true if x is a Symbol&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (instance? clojure.lang.Symbol x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">symbol?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;sync&lt;/b&gt; ([flags-ignored-for-now &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; transaction-flags =&gt; TBD, pass nil for now&lt;br&gt;&lt;br&gt;  Runs the exprs (in an implicit do) in a transaction that encompasses&lt;br&gt;  exprs and any nested calls.  Starts a transaction if none is already&lt;br&gt;  running on this thread. Any uncaught exception will abort the&lt;br&gt;  transaction and flow out of sync. The exprs may be run more than&lt;br&gt;  once, but any effects on Refs will be atomic.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro sync&amp;lt;br&amp;gt;  &amp;quot;transaction-flags =&amp;gt; TBD, pass nil for now&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Runs the exprs (in an implicit do) in a transaction that encompasses&amp;lt;br&amp;gt;  exprs and any nested calls.  Starts a transaction if none is already&amp;lt;br&amp;gt;  running on this thread. Any uncaught exception will abort the&amp;lt;br&amp;gt;  transaction and flow out of sync. The exprs may be run more than&amp;lt;br&amp;gt;  once, but any effects on Refs will be atomic.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [flags-ignored-for-now &amp;amp; body]&amp;lt;br&amp;gt;  `(. clojure.lang.LockingTransaction&amp;lt;br&amp;gt;      (runInTransaction (fn [] ~@body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sync</a>[flags-ignored-for-now & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;take&lt;/b&gt; ([n coll])&lt;br&gt; Returns a lazy sequence of the first n items in coll, or all items if&lt;br&gt;  there are fewer than n.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn take&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of the first n items in coll, or all items if&amp;lt;br&amp;gt;  there are fewer than n.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [n coll]&amp;lt;br&amp;gt;  (lazy-seq&amp;lt;br&amp;gt;   (when (pos? n) &amp;lt;br&amp;gt;     (when-let [s (seq coll)]&amp;lt;br&amp;gt;      (cons (first s) (take (dec n) (rest s)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">take</a>[n coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;take-last&lt;/b&gt; ([n coll])&lt;br&gt; Returns a seq of the last n items in coll.  Depending on the type&lt;br&gt;  of coll may be no better than linear time.  For vectors, see also subvec.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn take-last&amp;lt;br&amp;gt;  &amp;quot;Returns a seq of the last n items in coll.  Depending on the type&amp;lt;br&amp;gt;  of coll may be no better than linear time.  For vectors, see also subvec.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [n coll]&amp;lt;br&amp;gt;  (loop [s (seq coll), lead (seq (drop n coll))]&amp;lt;br&amp;gt;    (if lead&amp;lt;br&amp;gt;      (recur (next s) (next lead))&amp;lt;br&amp;gt;      s)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">take-last</a>[n coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;take-nth&lt;/b&gt; ([n coll])&lt;br&gt; Returns a lazy seq of every nth item in coll.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn take-nth&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy seq of every nth item in coll.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [n coll]&amp;lt;br&amp;gt;    (lazy-seq&amp;lt;br&amp;gt;     (when-let [s (seq coll)]&amp;lt;br&amp;gt;       (cons (first s) (take-nth n (drop n s))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">take-nth</a>[n coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;take-while&lt;/b&gt; ([pred coll])&lt;br&gt; Returns a lazy sequence of successive items from coll while&lt;br&gt;  (pred item) returns true. pred must be free of side-effects.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn take-while&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of successive items from coll while&amp;lt;br&amp;gt;  (pred item) returns true. pred must be free of side-effects.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [pred coll]&amp;lt;br&amp;gt;  (lazy-seq&amp;lt;br&amp;gt;   (when-let [s (seq coll)]&amp;lt;br&amp;gt;       (when (pred (first s))&amp;lt;br&amp;gt;         (cons (first s) (take-while pred (rest s)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">take-while</a>[pred coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;test&lt;/b&gt; ([v])&lt;br&gt; test [v] finds fn at key :test in var metadata and calls it,&lt;br&gt;  presuming failure will throw exception&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn test&amp;lt;br&amp;gt;  &amp;quot;test [v] finds fn at key :test in var metadata and calls it,&amp;lt;br&amp;gt;  presuming failure will throw exception&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [v]&amp;lt;br&amp;gt;    (let [f (:test (meta v))]&amp;lt;br&amp;gt;      (if f&amp;lt;br&amp;gt;        (do (f) :ok)&amp;lt;br&amp;gt;        :no-test)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">test</a>[v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;the-ns&lt;/b&gt; ([x])&lt;br&gt; If passed a namespace, returns it. Else, when passed a symbol,&lt;br&gt;  returns the namespace named by it, throwing an exception if not&lt;br&gt;  found.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn the-ns&amp;lt;br&amp;gt;  &amp;quot;If passed a namespace, returns it. Else, when passed a symbol,&amp;lt;br&amp;gt;  returns the namespace named by it, throwing an exception if not&amp;lt;br&amp;gt;  found.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ^clojure.lang.Namespace [x]&amp;lt;br&amp;gt;  (if (instance? clojure.lang.Namespace x)&amp;lt;br&amp;gt;    x&amp;lt;br&amp;gt;    (or (find-ns x) (throw (Exception. (str &amp;quot;No namespace: &amp;quot; x &amp;quot; found&amp;quot;))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">the-ns</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;thread-bound?&lt;/b&gt; ([&amp; vars])&lt;br&gt; Returns true if all of the vars provided as arguments have thread-local bindings.&lt;br&gt;   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn thread-bound?&amp;lt;br&amp;gt;  &amp;quot;Returns true if all of the vars provided as arguments have thread-local bindings.&amp;lt;br&amp;gt;   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [&amp;amp; vars]&amp;lt;br&amp;gt;  (every? #(.getThreadBinding ^clojure.lang.Var %) vars))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">thread-bound?</a>[& vars]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;time&lt;/b&gt; ([expr])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates expr and prints the time it took.  Returns the value of&lt;br&gt; expr.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro time&amp;lt;br&amp;gt;  &amp;quot;Evaluates expr and prints the time it took.  Returns the value of&amp;lt;br&amp;gt; expr.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [expr]&amp;lt;br&amp;gt;  `(let [start# (. System (nanoTime))&amp;lt;br&amp;gt;         ret# ~expr]&amp;lt;br&amp;gt;     (prn (str &amp;quot;Elapsed time: &amp;quot; (/ (double (- (. System (nanoTime)) start#)) 1000000.0) &amp;quot; msecs&amp;quot;))&amp;lt;br&amp;gt;     ret#))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">time</a>[expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;to-array&lt;/b&gt; ([coll])&lt;br&gt; Returns an array of Objects containing the contents of coll, which&lt;br&gt;  can be any Collection.  Maps to java.util.Collection.toArray().&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn to-array&amp;lt;br&amp;gt;  &amp;quot;Returns an array of Objects containing the contents of coll, which&amp;lt;br&amp;gt;  can be any Collection.  Maps to java.util.Collection.toArray().&amp;quot;&amp;lt;br&amp;gt;  {:tag &amp;quot;[Ljava.lang.Object;&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [coll] (. clojure.lang.RT (toArray coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">to-array</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;to-array-2d&lt;/b&gt; ([coll])&lt;br&gt; Returns a (potentially-ragged) 2-dimensional array of Objects&lt;br&gt;  containing the contents of coll, which can be any Collection of any&lt;br&gt;  Collection.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn to-array-2d&amp;lt;br&amp;gt;  &amp;quot;Returns a (potentially-ragged) 2-dimensional array of Objects&amp;lt;br&amp;gt;  containing the contents of coll, which can be any Collection of any&amp;lt;br&amp;gt;  Collection.&amp;quot;&amp;lt;br&amp;gt;  {:tag &amp;quot;[[Ljava.lang.Object;&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^java.util.Collection coll]&amp;lt;br&amp;gt;    (let [ret (make-array (. Class (forName &amp;quot;[Ljava.lang.Object;&amp;quot;)) (. coll (size)))]&amp;lt;br&amp;gt;      (loop [i 0 xs (seq coll)]&amp;lt;br&amp;gt;        (when xs&amp;lt;br&amp;gt;          (aset ret i (to-array (first xs)))&amp;lt;br&amp;gt;          (recur (inc i) (next xs))))&amp;lt;br&amp;gt;      ret))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">to-array-2d</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;trampoline&lt;/b&gt; ([f] [f &amp; args])&lt;br&gt; trampoline can be used to convert algorithms requiring mutual&lt;br&gt;  recursion without stack consumption. Calls f with supplied args, if&lt;br&gt;  any. If f returns a fn, calls that fn with no arguments, and&lt;br&gt;  continues to repeat, until the return value is not a fn, then&lt;br&gt;  returns that non-fn value. Note that if you want to return a fn as a&lt;br&gt;  final value, you must wrap it in some data structure and unpack it&lt;br&gt;  after trampoline returns.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn trampoline&amp;lt;br&amp;gt;  &amp;quot;trampoline can be used to convert algorithms requiring mutual&amp;lt;br&amp;gt;  recursion without stack consumption. Calls f with supplied args, if&amp;lt;br&amp;gt;  any. If f returns a fn, calls that fn with no arguments, and&amp;lt;br&amp;gt;  continues to repeat, until the return value is not a fn, then&amp;lt;br&amp;gt;  returns that non-fn value. Note that if you want to return a fn as a&amp;lt;br&amp;gt;  final value, you must wrap it in some data structure and unpack it&amp;lt;br&amp;gt;  after trampoline returns.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([f]&amp;lt;br&amp;gt;     (let [ret (f)]&amp;lt;br&amp;gt;       (if (fn? ret)&amp;lt;br&amp;gt;         (recur ret)&amp;lt;br&amp;gt;         ret)))&amp;lt;br&amp;gt;  ([f &amp;amp; args]&amp;lt;br&amp;gt;     (trampoline #(apply f args))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trampoline</a>[f] [f & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;transient&lt;/b&gt; ([coll])&lt;br&gt; Alpha - subject to change.&lt;br&gt;  Returns a new, transient version of the collection, in constant time.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn transient &amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;  Returns a new, transient version of the collection, in constant time.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.IEditableCollection coll] &amp;lt;br&amp;gt;  (.asTransient coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">transient</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;tree-seq&lt;/b&gt; ([branch? children root])&lt;br&gt; Returns a lazy sequence of the nodes in a tree, via a depth-first walk.&lt;br&gt;   branch? must be a fn of one arg that returns true if passed a node&lt;br&gt;   that can have children (but may not).  children must be a fn of one&lt;br&gt;   arg that returns a sequence of the children. Will only be called on&lt;br&gt;   nodes for which branch? returns true. Root is the root node of the&lt;br&gt;  tree.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tree-seq&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of the nodes in a tree, via a depth-first walk.&amp;lt;br&amp;gt;   branch? must be a fn of one arg that returns true if passed a node&amp;lt;br&amp;gt;   that can have children (but may not).  children must be a fn of one&amp;lt;br&amp;gt;   arg that returns a sequence of the children. Will only be called on&amp;lt;br&amp;gt;   nodes for which branch? returns true. Root is the root node of the&amp;lt;br&amp;gt;  tree.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;   [branch? children root]&amp;lt;br&amp;gt;   (let [walk (fn walk [node]&amp;lt;br&amp;gt;                (lazy-seq&amp;lt;br&amp;gt;                 (cons node&amp;lt;br&amp;gt;                  (when (branch? node)&amp;lt;br&amp;gt;                    (mapcat walk (children node))))))]&amp;lt;br&amp;gt;     (walk root)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tree-seq</a>[branch? children root]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;true?&lt;/b&gt; ([x])&lt;br&gt; Returns true if x is the value true, false otherwise.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn true?&amp;lt;br&amp;gt;  &amp;quot;Returns true if x is the value true, false otherwise.&amp;quot;&amp;lt;br&amp;gt;  {:tag Boolean,&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x] (clojure.lang.Util/identical x true))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">true?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;type&lt;/b&gt; ([x])&lt;br&gt; Returns the :type metadata of x, or its Class if none&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn type &amp;lt;br&amp;gt;  &amp;quot;Returns the :type metadata of x, or its Class if none&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [x]&amp;lt;br&amp;gt;  (or (get (meta x) :type) (class x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">type</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-add&lt;/b&gt; ([x y])&lt;br&gt; Returns the sum of x and y, both long.&lt;br&gt;  Note - uses a primitive operator subject to overflow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-add&amp;lt;br&amp;gt;  &amp;quot;Returns the sum of x and y, both long.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to overflow.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_add ~x ~y)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x y] (. clojure.lang.Numbers (unchecked_add x y)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-add</a>[x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-add-int&lt;/b&gt; ([x y])&lt;br&gt; Returns the sum of x and y, both int.&lt;br&gt;  Note - uses a primitive operator subject to overflow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-add-int&amp;lt;br&amp;gt;  &amp;quot;Returns the sum of x and y, both int.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to overflow.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_add ~x ~y)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x y] (. clojure.lang.Numbers (unchecked_int_add x y)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-add-int</a>[x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-byte&lt;/b&gt; ([x])&lt;br&gt; Coerce to byte. Subject to rounding or truncation.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-byte&amp;lt;br&amp;gt;  &amp;quot;Coerce to byte. Subject to rounding or truncation.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedByteCast ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [^Number x] (clojure.lang.RT/uncheckedByteCast x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-byte</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-char&lt;/b&gt; ([x])&lt;br&gt; Coerce to char. Subject to rounding or truncation.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-char&amp;lt;br&amp;gt;  &amp;quot;Coerce to char. Subject to rounding or truncation.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedCharCast ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.RT (uncheckedCharCast x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-char</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-dec&lt;/b&gt; ([x])&lt;br&gt; Returns a number one less than x, a long.&lt;br&gt;  Note - uses a primitive operator subject to overflow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-dec&amp;lt;br&amp;gt;  &amp;quot;Returns a number one less than x, a long.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to overflow.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_dec ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (unchecked_dec x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-dec</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-dec-int&lt;/b&gt; ([x])&lt;br&gt; Returns a number one less than x, an int.&lt;br&gt;  Note - uses a primitive operator subject to overflow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-dec-int&amp;lt;br&amp;gt;  &amp;quot;Returns a number one less than x, an int.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to overflow.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_int_dec ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (unchecked_int_dec x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-dec-int</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-divide-int&lt;/b&gt; ([x y])&lt;br&gt; Returns the division of x by y, both int.&lt;br&gt;  Note - uses a primitive operator subject to truncation.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-divide-int&amp;lt;br&amp;gt;  &amp;quot;Returns the division of x by y, both int.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to truncation.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_divide ~x ~y)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x y] (. clojure.lang.Numbers (unchecked_int_divide x y)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-divide-int</a>[x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-double&lt;/b&gt; ([x])&lt;br&gt; Coerce to double. Subject to rounding.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-double&amp;lt;br&amp;gt;  &amp;quot;Coerce to double. Subject to rounding.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedDoubleCast ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [^Number x] (clojure.lang.RT/uncheckedDoubleCast x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-double</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-float&lt;/b&gt; ([x])&lt;br&gt; Coerce to float. Subject to rounding.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-float&amp;lt;br&amp;gt;  &amp;quot;Coerce to float. Subject to rounding.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedFloatCast ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [^Number x] (clojure.lang.RT/uncheckedFloatCast x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-float</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-inc&lt;/b&gt; ([x])&lt;br&gt; Returns a number one greater than x, a long.&lt;br&gt;  Note - uses a primitive operator subject to overflow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-inc&amp;lt;br&amp;gt;  &amp;quot;Returns a number one greater than x, a long.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to overflow.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_inc ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (unchecked_inc x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-inc</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-inc-int&lt;/b&gt; ([x])&lt;br&gt; Returns a number one greater than x, an int.&lt;br&gt;  Note - uses a primitive operator subject to overflow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-inc-int&amp;lt;br&amp;gt;  &amp;quot;Returns a number one greater than x, an int.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to overflow.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_int_inc ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (unchecked_int_inc x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-inc-int</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-int&lt;/b&gt; ([x])&lt;br&gt; Coerce to int. Subject to rounding or truncation.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-int&amp;lt;br&amp;gt;  &amp;quot;Coerce to int. Subject to rounding or truncation.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedIntCast ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [^Number x] (clojure.lang.RT/uncheckedIntCast x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-int</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-long&lt;/b&gt; ([x])&lt;br&gt; Coerce to long. Subject to rounding or truncation.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-long&amp;lt;br&amp;gt;  &amp;quot;Coerce to long. Subject to rounding or truncation.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedLongCast ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [^Number x] (clojure.lang.RT/uncheckedLongCast x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-long</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-multiply&lt;/b&gt; ([x y])&lt;br&gt; Returns the product of x and y, both long.&lt;br&gt;  Note - uses a primitive operator subject to overflow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-multiply&amp;lt;br&amp;gt;  &amp;quot;Returns the product of x and y, both long.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to overflow.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_multiply ~x ~y)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x y] (. clojure.lang.Numbers (unchecked_multiply x y)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-multiply</a>[x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-multiply-int&lt;/b&gt; ([x y])&lt;br&gt; Returns the product of x and y, both int.&lt;br&gt;  Note - uses a primitive operator subject to overflow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-multiply-int&amp;lt;br&amp;gt;  &amp;quot;Returns the product of x and y, both int.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to overflow.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_multiply ~x ~y)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x y] (. clojure.lang.Numbers (unchecked_int_multiply x y)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-multiply-int</a>[x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-negate&lt;/b&gt; ([x])&lt;br&gt; Returns the negation of x, a long.&lt;br&gt;  Note - uses a primitive operator subject to overflow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-negate&amp;lt;br&amp;gt;  &amp;quot;Returns the negation of x, a long.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to overflow.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_minus ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (unchecked_minus x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-negate</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-negate-int&lt;/b&gt; ([x])&lt;br&gt; Returns the negation of x, an int.&lt;br&gt;  Note - uses a primitive operator subject to overflow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-negate-int&amp;lt;br&amp;gt;  &amp;quot;Returns the negation of x, an int.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to overflow.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_int_negate ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (unchecked_int_negate x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-negate-int</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-remainder-int&lt;/b&gt; ([x y])&lt;br&gt; Returns the remainder of division of x by y, both int.&lt;br&gt;  Note - uses a primitive operator subject to truncation.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-remainder-int&amp;lt;br&amp;gt;  &amp;quot;Returns the remainder of division of x by y, both int.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to truncation.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_remainder ~x ~y)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x y] (. clojure.lang.Numbers (unchecked_int_remainder x y)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-remainder-int</a>[x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-short&lt;/b&gt; ([x])&lt;br&gt; Coerce to short. Subject to rounding or truncation.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-short&amp;lt;br&amp;gt;  &amp;quot;Coerce to short. Subject to rounding or truncation.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedShortCast ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [^Number x] (clojure.lang.RT/uncheckedShortCast x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-short</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-subtract&lt;/b&gt; ([x y])&lt;br&gt; Returns the difference of x and y, both long.&lt;br&gt;  Note - uses a primitive operator subject to overflow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-subtract&amp;lt;br&amp;gt;  &amp;quot;Returns the difference of x and y, both long.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to overflow.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_minus ~x ~y)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x y] (. clojure.lang.Numbers (unchecked_minus x y)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-subtract</a>[x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;unchecked-subtract-int&lt;/b&gt; ([x y])&lt;br&gt; Returns the difference of x and y, both int.&lt;br&gt;  Note - uses a primitive operator subject to overflow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unchecked-subtract-int&amp;lt;br&amp;gt;  &amp;quot;Returns the difference of x and y, both int.&amp;lt;br&amp;gt;  Note - uses a primitive operator subject to overflow.&amp;quot;&amp;lt;br&amp;gt;  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_subtract ~x ~y)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x y] (. clojure.lang.Numbers (unchecked_int_subtract x y)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unchecked-subtract-int</a>[x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;underive&lt;/b&gt; ([tag parent] [h tag parent])&lt;br&gt; Removes a parent/child relationship between parent and&lt;br&gt;  tag. h must be a hierarchy obtained from make-hierarchy, if not&lt;br&gt;  supplied defaults to, and modifies, the global hierarchy.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn underive&amp;lt;br&amp;gt;  &amp;quot;Removes a parent/child relationship between parent and&amp;lt;br&amp;gt;  tag. h must be a hierarchy obtained from make-hierarchy, if not&amp;lt;br&amp;gt;  supplied defaults to, and modifies, the global hierarchy.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([tag parent] (alter-var-root #'global-hierarchy underive tag parent) nil)&amp;lt;br&amp;gt;  ([h tag parent]&amp;lt;br&amp;gt;    (let [parentMap (:parents h)&amp;lt;br&amp;gt;	  childsParents (if (parentMap tag)&amp;lt;br&amp;gt;			  (disj (parentMap tag) parent) #{})&amp;lt;br&amp;gt;	  newParents (if (not-empty childsParents)&amp;lt;br&amp;gt;		       (assoc parentMap tag childsParents)&amp;lt;br&amp;gt;		       (dissoc parentMap tag))&amp;lt;br&amp;gt;	  deriv-seq (flatten (map #(cons (key %) (interpose (key %) (val %)))&amp;lt;br&amp;gt;				       (seq newParents)))]&amp;lt;br&amp;gt;      (if (contains? (parentMap tag) parent)&amp;lt;br&amp;gt;	(reduce1 #(apply derive %1 %2) (make-hierarchy)&amp;lt;br&amp;gt;		(partition 2 deriv-seq))&amp;lt;br&amp;gt;	h))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">underive</a>[tag parent] [h tag parent]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;update-in&lt;/b&gt; ([m [k &amp; ks] f &amp; args])&lt;br&gt; 'Updates' a value in a nested associative structure, where ks is a&lt;br&gt;  sequence of keys and f is a function that will take the old value&lt;br&gt;  and any supplied args and return the new value, and returns a new&lt;br&gt;  nested structure.  If any levels do not exist, hash-maps will be&lt;br&gt;  created.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn update-in&amp;lt;br&amp;gt;  &amp;quot;'Updates' a value in a nested associative structure, where ks is a&amp;lt;br&amp;gt;  sequence of keys and f is a function that will take the old value&amp;lt;br&amp;gt;  and any supplied args and return the new value, and returns a new&amp;lt;br&amp;gt;  nested structure.  If any levels do not exist, hash-maps will be&amp;lt;br&amp;gt;  created.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([m [k &amp;amp; ks] f &amp;amp; args]&amp;lt;br&amp;gt;   (if ks&amp;lt;br&amp;gt;     (assoc m k (apply update-in (get m k) ks f args))&amp;lt;br&amp;gt;     (assoc m k (apply f (get m k) args)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">update-in</a>[m [k & ks] f & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;update-proxy&lt;/b&gt; ([proxy mappings])&lt;br&gt; Takes a proxy instance and a map of strings (which must&lt;br&gt;  correspond to methods of the proxy superclass/superinterfaces) to&lt;br&gt;  fns (which must take arguments matching the corresponding method,&lt;br&gt;  plus an additional (explicit) first arg corresponding to this, and&lt;br&gt;  updates (via assoc) the proxy's fn map. nil can be passed instead of&lt;br&gt;  a fn, in which case the corresponding method will revert to the&lt;br&gt;  default behavior. Note that this function can be used to update the&lt;br&gt;  behavior of an existing instance without changing its identity.&lt;br&gt;  Returns the proxy.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn update-proxy&amp;lt;br&amp;gt;  &amp;quot;Takes a proxy instance and a map of strings (which must&amp;lt;br&amp;gt;  correspond to methods of the proxy superclass/superinterfaces) to&amp;lt;br&amp;gt;  fns (which must take arguments matching the corresponding method,&amp;lt;br&amp;gt;  plus an additional (explicit) first arg corresponding to this, and&amp;lt;br&amp;gt;  updates (via assoc) the proxy's fn map. nil can be passed instead of&amp;lt;br&amp;gt;  a fn, in which case the corresponding method will revert to the&amp;lt;br&amp;gt;  default behavior. Note that this function can be used to update the&amp;lt;br&amp;gt;  behavior of an existing instance without changing its identity.&amp;lt;br&amp;gt;  Returns the proxy.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [^IProxy proxy mappings]&amp;lt;br&amp;gt;    (. proxy (__updateClojureFnMappings mappings))&amp;lt;br&amp;gt;    proxy)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">update-proxy</a>[proxy mappings]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;use&lt;/b&gt; ([&amp; args])&lt;br&gt; Like 'require, but also refers to each lib's namespace using&lt;br&gt;  clojure.core/refer. Use :use in the ns macro in preference to calling&lt;br&gt;  this directly.&lt;br&gt;&lt;br&gt;  'use accepts additional options in libspecs: :exclude, :only, :rename.&lt;br&gt;  The arguments and semantics for :exclude, :only, and :rename are the same&lt;br&gt;  as those documented for clojure.core/refer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn use&amp;lt;br&amp;gt;  &amp;quot;Like 'require, but also refers to each lib's namespace using&amp;lt;br&amp;gt;  clojure.core/refer. Use :use in the ns macro in preference to calling&amp;lt;br&amp;gt;  this directly.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  'use accepts additional options in libspecs: :exclude, :only, :rename.&amp;lt;br&amp;gt;  The arguments and semantics for :exclude, :only, and :rename are the same&amp;lt;br&amp;gt;  as those documented for clojure.core/refer.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; args] (apply load-libs :require :use args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">use</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;val&lt;/b&gt; ([e])&lt;br&gt; Returns the value in the map entry.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn val&amp;lt;br&amp;gt;  &amp;quot;Returns the value in the map entry.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^java.util.Map$Entry e]&amp;lt;br&amp;gt;    (. e (getValue)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">val</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;vals&lt;/b&gt; ([map])&lt;br&gt; Returns a sequence of the map's values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn vals&amp;lt;br&amp;gt;  &amp;quot;Returns a sequence of the map's values.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [map] (. clojure.lang.RT (vals map)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">vals</a>[map]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;var-get&lt;/b&gt; ([x])&lt;br&gt; Gets the value in the var object&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn var-get&amp;lt;br&amp;gt;  &amp;quot;Gets the value in the var object&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Var x] (. x (get)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">var-get</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;var-set&lt;/b&gt; ([x val])&lt;br&gt; Sets the value in the var object to val. The var must be&lt;br&gt; thread-locally bound.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn var-set&amp;lt;br&amp;gt;  &amp;quot;Sets the value in the var object to val. The var must be&amp;lt;br&amp;gt; thread-locally bound.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [^clojure.lang.Var x val] (. x (set val)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">var-set</a>[x val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;var?&lt;/b&gt; ([v])&lt;br&gt; Returns true if v is of type clojure.lang.Var&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn var?&amp;lt;br&amp;gt;  &amp;quot;Returns true if v is of type clojure.lang.Var&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [v] (instance? clojure.lang.Var v))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">var?</a>[v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;vary-meta&lt;/b&gt; ([obj f &amp; args])&lt;br&gt; Returns an object of the same type and value as obj, with&lt;br&gt;  (apply f (meta obj) args) as its metadata.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn vary-meta&amp;lt;br&amp;gt; &amp;quot;Returns an object of the same type and value as obj, with&amp;lt;br&amp;gt;  (apply f (meta obj) args) as its metadata.&amp;quot;&amp;lt;br&amp;gt; {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; [obj f &amp;amp; args]&amp;lt;br&amp;gt;  (with-meta obj (apply f (meta obj) args)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">vary-meta</a>[obj f & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;vec&lt;/b&gt; ([coll])&lt;br&gt; Creates a new vector containing the contents of coll. Java arrays&lt;br&gt;  will be aliased and should not be modified.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn vec&amp;lt;br&amp;gt;  &amp;quot;Creates a new vector containing the contents of coll. Java arrays&amp;lt;br&amp;gt;  will be aliased and should not be modified.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([coll]&amp;lt;br&amp;gt;   (if (instance? java.util.Collection coll)&amp;lt;br&amp;gt;     (clojure.lang.LazilyPersistentVector/create coll)&amp;lt;br&amp;gt;     (. clojure.lang.LazilyPersistentVector (createOwning (to-array coll))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">vec</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;vector&lt;/b&gt; ([] [a] [a b] [a b c] [a b c d] [a b c d &amp; args])&lt;br&gt; Creates a new vector containing the args.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn vector&amp;lt;br&amp;gt;  &amp;quot;Creates a new vector containing the args.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  ([] [])&amp;lt;br&amp;gt;  ([a] [a])&amp;lt;br&amp;gt;  ([a b] [a b])&amp;lt;br&amp;gt;  ([a b c] [a b c])&amp;lt;br&amp;gt;  ([a b c d] [a b c d])&amp;lt;br&amp;gt;  ([a b c d &amp;amp; args]&amp;lt;br&amp;gt;     (. clojure.lang.LazilyPersistentVector (create (cons a (cons b (cons c (cons d args))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">vector</a>[] [a] [a b] [a b c] [a b c d] [a b c d & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;vector-of&lt;/b&gt; ([t] [t &amp; elements])&lt;br&gt; Creates a new vector of a single primitive type t, where t is one&lt;br&gt;  of :int :long :float :double :byte :short :char or :boolean. The&lt;br&gt;  resulting vector complies with the interface of vectors in general,&lt;br&gt;  but stores the values unboxed internally.&lt;br&gt;&lt;br&gt;  Optionally takes one or more elements to populate the vector.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn vector-of &amp;lt;br&amp;gt;  &amp;quot;Creates a new vector of a single primitive type t, where t is one&amp;lt;br&amp;gt;  of :int :long :float :double :byte :short :char or :boolean. The&amp;lt;br&amp;gt;  resulting vector complies with the interface of vectors in general,&amp;lt;br&amp;gt;  but stores the values unboxed internally.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Optionally takes one or more elements to populate the vector.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;&amp;lt;br&amp;gt;   :arglists '([t] [t &amp;amp; elements])}&amp;lt;br&amp;gt;  ([t]&amp;lt;br&amp;gt;   (let [am ^clojure.core.ArrayManager (ams t)]&amp;lt;br&amp;gt;     (Vec. am 0 5 EMPTY-NODE (.array am 0) nil)))&amp;lt;br&amp;gt;  ([t x1]&amp;lt;br&amp;gt;   (let [am ^clojure.core.ArrayManager (ams t)&amp;lt;br&amp;gt;         arr (.array am 1)]&amp;lt;br&amp;gt;     (.aset am arr 0 x1)&amp;lt;br&amp;gt;     (Vec. am 1 5 EMPTY-NODE arr nil)))&amp;lt;br&amp;gt;  ([t x1 x2]&amp;lt;br&amp;gt;   (let [am ^clojure.core.ArrayManager (ams t)&amp;lt;br&amp;gt;         arr (.array am 2)]&amp;lt;br&amp;gt;     (.aset am arr 0 x1)&amp;lt;br&amp;gt;     (.aset am arr 1 x2)&amp;lt;br&amp;gt;     (Vec. am 2 5 EMPTY-NODE arr nil)))&amp;lt;br&amp;gt;  ([t x1 x2 x3]&amp;lt;br&amp;gt;   (let [am ^clojure.core.ArrayManager (ams t)&amp;lt;br&amp;gt;         arr (.array am 3)]&amp;lt;br&amp;gt;     (.aset am arr 0 x1)&amp;lt;br&amp;gt;     (.aset am arr 1 x2)&amp;lt;br&amp;gt;     (.aset am arr 2 x3)&amp;lt;br&amp;gt;     (Vec. am 3 5 EMPTY-NODE arr nil)))&amp;lt;br&amp;gt;  ([t x1 x2 x3 x4]&amp;lt;br&amp;gt;   (let [am ^clojure.core.ArrayManager (ams t)&amp;lt;br&amp;gt;         arr (.array am 4)]&amp;lt;br&amp;gt;     (.aset am arr 0 x1)&amp;lt;br&amp;gt;     (.aset am arr 1 x2)&amp;lt;br&amp;gt;     (.aset am arr 2 x3)&amp;lt;br&amp;gt;     (.aset am arr 3 x4)&amp;lt;br&amp;gt;     (Vec. am 4 5 EMPTY-NODE arr nil)))&amp;lt;br&amp;gt;  ([t x1 x2 x3 x4 &amp;amp; xn]&amp;lt;br&amp;gt;   (loop [v  (vector-of t x1 x2 x3 x4)&amp;lt;br&amp;gt;          xn xn]&amp;lt;br&amp;gt;     (if xn&amp;lt;br&amp;gt;       (recur (.cons v (first xn)) (next xn))&amp;lt;br&amp;gt;       v))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">vector-of</a>[t] [t & elements]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;vector?&lt;/b&gt; ([x])&lt;br&gt; Return true if x implements IPersistentVector&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([x])&amp;lt;br&amp;gt;   :doc &amp;quot;Return true if x implements IPersistentVector&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; vector? (fn ^:static vector? [x] (instance? clojure.lang.IPersistentVector x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">vector?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;when&lt;/b&gt; ([test &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates test. If logical true, evaluates body in an implicit do.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro when&amp;lt;br&amp;gt;  &amp;quot;Evaluates test. If logical true, evaluates body in an implicit do.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [test &amp;amp; body]&amp;lt;br&amp;gt;  (list 'if test (cons 'do body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">when</a>[test & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;when-first&lt;/b&gt; ([bindings &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; bindings =&gt; x xs&lt;br&gt;&lt;br&gt;  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro when-first&amp;lt;br&amp;gt;  &amp;quot;bindings =&amp;gt; x xs&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [bindings &amp;amp; body]&amp;lt;br&amp;gt;  (assert-args&amp;lt;br&amp;gt;     (vector? bindings) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;     (= 2 (count bindings)) &amp;quot;exactly 2 forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;  (let [[x xs] bindings]&amp;lt;br&amp;gt;    `(when-let [xs# (seq ~xs)]&amp;lt;br&amp;gt;       (let [~x (first xs#)]&amp;lt;br&amp;gt;           ~@body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">when-first</a>[bindings & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;when-let&lt;/b&gt; ([bindings &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; bindings =&gt; binding-form test&lt;br&gt;&lt;br&gt;  When test is true, evaluates body with binding-form bound to the value of test&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro when-let&amp;lt;br&amp;gt;  &amp;quot;bindings =&amp;gt; binding-form test&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  When test is true, evaluates body with binding-form bound to the value of test&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [bindings &amp;amp; body]&amp;lt;br&amp;gt;  (assert-args&amp;lt;br&amp;gt;     (vector? bindings) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;     (= 2 (count bindings)) &amp;quot;exactly 2 forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;   (let [form (bindings 0) tst (bindings 1)]&amp;lt;br&amp;gt;    `(let [temp# ~tst]&amp;lt;br&amp;gt;       (when temp#&amp;lt;br&amp;gt;         (let [~form temp#]&amp;lt;br&amp;gt;           ~@body)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">when-let</a>[bindings & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;when-not&lt;/b&gt; ([test &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates test. If logical false, evaluates body in an implicit do.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro when-not&amp;lt;br&amp;gt;  &amp;quot;Evaluates test. If logical false, evaluates body in an implicit do.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [test &amp;amp; body]&amp;lt;br&amp;gt;    (list 'if test nil (cons 'do body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">when-not</a>[test & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;while&lt;/b&gt; ([test &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Repeatedly executes body while test expression is true. Presumes&lt;br&gt;  some side-effect will cause test to become false/nil. Returns nil&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro while&amp;lt;br&amp;gt;  &amp;quot;Repeatedly executes body while test expression is true. Presumes&amp;lt;br&amp;gt;  some side-effect will cause test to become false/nil. Returns nil&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [test &amp;amp; body]&amp;lt;br&amp;gt;  `(loop []&amp;lt;br&amp;gt;     (when ~test&amp;lt;br&amp;gt;       ~@body&amp;lt;br&amp;gt;       (recur))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">while</a>[test & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;with-bindings&lt;/b&gt; ([binding-map &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Takes a map of Var/value pairs. Installs for the given Vars the associated&lt;br&gt;  values as thread-local bindings. The executes body. Pops the installed&lt;br&gt;  bindings after body was evaluated. Returns the value of body.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-bindings&amp;lt;br&amp;gt;  &amp;quot;Takes a map of Var/value pairs. Installs for the given Vars the associated&amp;lt;br&amp;gt;  values as thread-local bindings. The executes body. Pops the installed&amp;lt;br&amp;gt;  bindings after body was evaluated. Returns the value of body.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [binding-map &amp;amp; body]&amp;lt;br&amp;gt;  `(with-bindings* ~binding-map (fn [] ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-bindings</a>[binding-map & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;with-bindings*&lt;/b&gt; ([binding-map f &amp; args])&lt;br&gt; Takes a map of Var/value pairs. Installs for the given Vars the associated&lt;br&gt;  values as thread-local bindings. Then calls f with the supplied arguments.&lt;br&gt;  Pops the installed bindings after f returned. Returns whatever f returns.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn with-bindings*&amp;lt;br&amp;gt;  &amp;quot;Takes a map of Var/value pairs. Installs for the given Vars the associated&amp;lt;br&amp;gt;  values as thread-local bindings. Then calls f with the supplied arguments.&amp;lt;br&amp;gt;  Pops the installed bindings after f returned. Returns whatever f returns.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [binding-map f &amp;amp; args]&amp;lt;br&amp;gt;  (push-thread-bindings binding-map)&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;    (apply f args)&amp;lt;br&amp;gt;    (finally&amp;lt;br&amp;gt;      (pop-thread-bindings))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-bindings*</a>[binding-map f & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;with-in-str&lt;/b&gt; ([s &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates body in a context in which *in* is bound to a fresh&lt;br&gt;  StringReader initialized with the string s.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-in-str&amp;lt;br&amp;gt;  &amp;quot;Evaluates body in a context in which *in* is bound to a fresh&amp;lt;br&amp;gt;  StringReader initialized with the string s.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [s &amp;amp; body]&amp;lt;br&amp;gt;  `(with-open [s# (-&amp;gt; (java.io.StringReader. ~s) clojure.lang.LineNumberingPushbackReader.)]&amp;lt;br&amp;gt;     (binding [*in* s#]&amp;lt;br&amp;gt;       ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-in-str</a>[s & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;with-loading-context&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-loading-context [&amp;amp; body]&amp;lt;br&amp;gt;  `((fn loading# [] &amp;lt;br&amp;gt;        (. clojure.lang.Var (pushThreadBindings {clojure.lang.Compiler/LOADER  &amp;lt;br&amp;gt;                                                 (.getClassLoader (.getClass ^Object loading#))}))&amp;lt;br&amp;gt;        (try&amp;lt;br&amp;gt;         ~@body&amp;lt;br&amp;gt;         (finally&amp;lt;br&amp;gt;          (. clojure.lang.Var (popThreadBindings)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-loading-context</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;with-local-vars&lt;/b&gt; ([name-vals-vec &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; varbinding=&gt; symbol init-expr&lt;br&gt;&lt;br&gt;  Executes the exprs in a context in which the symbols are bound to&lt;br&gt;  vars with per-thread bindings to the init-exprs.  The symbols refer&lt;br&gt;  to the var objects themselves, and must be accessed with var-get and&lt;br&gt;  var-set&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-local-vars&amp;lt;br&amp;gt;  &amp;quot;varbinding=&amp;gt; symbol init-expr&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Executes the exprs in a context in which the symbols are bound to&amp;lt;br&amp;gt;  vars with per-thread bindings to the init-exprs.  The symbols refer&amp;lt;br&amp;gt;  to the var objects themselves, and must be accessed with var-get and&amp;lt;br&amp;gt;  var-set&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [name-vals-vec &amp;amp; body]&amp;lt;br&amp;gt;  (assert-args&amp;lt;br&amp;gt;     (vector? name-vals-vec) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;     (even? (count name-vals-vec)) &amp;quot;an even number of forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;  `(let [~@(interleave (take-nth 2 name-vals-vec)&amp;lt;br&amp;gt;                       (repeat '(.. clojure.lang.Var create setDynamic)))]&amp;lt;br&amp;gt;     (. clojure.lang.Var (pushThreadBindings (hash-map ~@name-vals-vec)))&amp;lt;br&amp;gt;     (try&amp;lt;br&amp;gt;      ~@body&amp;lt;br&amp;gt;      (finally (. clojure.lang.Var (popThreadBindings))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-local-vars</a>[name-vals-vec & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;with-meta&lt;/b&gt; ([obj m])&lt;br&gt; Returns an object of the same type and value as obj, with&lt;br&gt;    map m as its metadata.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def&amp;lt;br&amp;gt; ^{:arglists '([^clojure.lang.IObj obj m])&amp;lt;br&amp;gt;   :doc &amp;quot;Returns an object of the same type and value as obj, with&amp;lt;br&amp;gt;    map m as its metadata.&amp;quot;&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt; with-meta (fn ^:static with-meta [^clojure.lang.IObj x m]&amp;lt;br&amp;gt;             (. x (withMeta m))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-meta</a>[obj m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;with-open&lt;/b&gt; ([bindings &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; bindings =&gt; [name init ...]&lt;br&gt;&lt;br&gt;  Evaluates body in a try expression with names bound to the values&lt;br&gt;  of the inits, and a finally clause that calls (.close name) on each&lt;br&gt;  name in reverse order.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-open&amp;lt;br&amp;gt;  &amp;quot;bindings =&amp;gt; [name init ...]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Evaluates body in a try expression with names bound to the values&amp;lt;br&amp;gt;  of the inits, and a finally clause that calls (.close name) on each&amp;lt;br&amp;gt;  name in reverse order.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [bindings &amp;amp; body]&amp;lt;br&amp;gt;  (assert-args&amp;lt;br&amp;gt;     (vector? bindings) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;     (even? (count bindings)) &amp;quot;an even number of forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (= (count bindings) 0) `(do ~@body)&amp;lt;br&amp;gt;    (symbol? (bindings 0)) `(let ~(subvec bindings 0 2)&amp;lt;br&amp;gt;                              (try&amp;lt;br&amp;gt;                                (with-open ~(subvec bindings 2) ~@body)&amp;lt;br&amp;gt;                                (finally&amp;lt;br&amp;gt;                                  (. ~(bindings 0) close))))&amp;lt;br&amp;gt;    :else (throw (IllegalArgumentException.&amp;lt;br&amp;gt;                   &amp;quot;with-open only allows Symbols in bindings&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-open</a>[bindings & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;with-out-str&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates exprs in a context in which *out* is bound to a fresh&lt;br&gt;  StringWriter.  Returns the string created by any nested printing&lt;br&gt;  calls.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-out-str&amp;lt;br&amp;gt;  &amp;quot;Evaluates exprs in a context in which *out* is bound to a fresh&amp;lt;br&amp;gt;  StringWriter.  Returns the string created by any nested printing&amp;lt;br&amp;gt;  calls.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;  `(let [s# (new java.io.StringWriter)]&amp;lt;br&amp;gt;     (binding [*out* s#]&amp;lt;br&amp;gt;       ~@body&amp;lt;br&amp;gt;       (str s#))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-out-str</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;with-precision&lt;/b&gt; ([precision &amp; exprs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Sets the precision and rounding mode to be used for BigDecimal operations.&lt;br&gt;&lt;br&gt;  Usage: (with-precision 10 (/ 1M 3))&lt;br&gt;  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))&lt;br&gt;&lt;br&gt;  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,&lt;br&gt;  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-precision&amp;lt;br&amp;gt;  &amp;quot;Sets the precision and rounding mode to be used for BigDecimal operations.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Usage: (with-precision 10 (/ 1M 3))&amp;lt;br&amp;gt;  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,&amp;lt;br&amp;gt;  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [precision &amp;amp; exprs]&amp;lt;br&amp;gt;    (let [[body rm] (if (= (first exprs) :rounding)&amp;lt;br&amp;gt;                      [(next (next exprs))&amp;lt;br&amp;gt;                       `((. java.math.RoundingMode ~(second exprs)))]&amp;lt;br&amp;gt;                      [exprs nil])]&amp;lt;br&amp;gt;      `(binding [*math-context* (java.math.MathContext. ~precision ~@rm)]&amp;lt;br&amp;gt;         ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-precision</a>[precision & exprs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;with-redefs&lt;/b&gt; ([bindings &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; binding =&gt; var-symbol temp-value-expr&lt;br&gt;&lt;br&gt;  Temporarily redefines Vars while executing the body.  The&lt;br&gt;  temp-value-exprs will be evaluated and each resulting value will&lt;br&gt;  replace in parallel the root value of its Var.  After the body is&lt;br&gt;  executed, the root values of all the Vars will be set back to their&lt;br&gt;  old values.  These temporary changes will be visible in all threads.&lt;br&gt;  Useful for mocking out functions during testing.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-redefs&amp;lt;br&amp;gt;  &amp;quot;binding =&amp;gt; var-symbol temp-value-expr&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Temporarily redefines Vars while executing the body.  The&amp;lt;br&amp;gt;  temp-value-exprs will be evaluated and each resulting value will&amp;lt;br&amp;gt;  replace in parallel the root value of its Var.  After the body is&amp;lt;br&amp;gt;  executed, the root values of all the Vars will be set back to their&amp;lt;br&amp;gt;  old values.  These temporary changes will be visible in all threads.&amp;lt;br&amp;gt;  Useful for mocking out functions during testing.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [bindings &amp;amp; body]&amp;lt;br&amp;gt;  `(with-redefs-fn ~(zipmap (map #(list `var %) (take-nth 2 bindings))&amp;lt;br&amp;gt;                            (take-nth 2 (next bindings)))&amp;lt;br&amp;gt;                    (fn [] ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-redefs</a>[bindings & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;with-redefs-fn&lt;/b&gt; ([binding-map func])&lt;br&gt; Temporarily redefines Vars during a call to func.  Each val of&lt;br&gt;  binding-map will replace the root value of its key which must be&lt;br&gt;  a Var.  After func is called with no args, the root values of all&lt;br&gt;  the Vars will be set back to their old values.  These temporary&lt;br&gt;  changes will be visible in all threads.  Useful for mocking out&lt;br&gt;  functions during testing.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn with-redefs-fn&amp;lt;br&amp;gt;  &amp;quot;Temporarily redefines Vars during a call to func.  Each val of&amp;lt;br&amp;gt;  binding-map will replace the root value of its key which must be&amp;lt;br&amp;gt;  a Var.  After func is called with no args, the root values of all&amp;lt;br&amp;gt;  the Vars will be set back to their old values.  These temporary&amp;lt;br&amp;gt;  changes will be visible in all threads.  Useful for mocking out&amp;lt;br&amp;gt;  functions during testing.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [binding-map func]&amp;lt;br&amp;gt;  (let [root-bind (fn [m]&amp;lt;br&amp;gt;                    (doseq [[a-var a-val] m]&amp;lt;br&amp;gt;                      (.bindRoot ^clojure.lang.Var a-var a-val)))&amp;lt;br&amp;gt;        old-vals (zipmap (keys binding-map)&amp;lt;br&amp;gt;                         (map #(.getRawRoot ^clojure.lang.Var %) (keys binding-map)))]&amp;lt;br&amp;gt;    (try&amp;lt;br&amp;gt;      (root-bind binding-map)&amp;lt;br&amp;gt;      (func)&amp;lt;br&amp;gt;      (finally&amp;lt;br&amp;gt;        (root-bind old-vals)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-redefs-fn</a>[binding-map func]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;xml-seq&lt;/b&gt; ([root])&lt;br&gt; A tree seq on the xml elements as per xml/parse&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn xml-seq&amp;lt;br&amp;gt;  &amp;quot;A tree seq on the xml elements as per xml/parse&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [root]&amp;lt;br&amp;gt;    (tree-seq&amp;lt;br&amp;gt;     (complement string?)&amp;lt;br&amp;gt;     (comp seq :content)&amp;lt;br&amp;gt;     root))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">xml-seq</a>[root]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;zero?&lt;/b&gt; ([x])&lt;br&gt; Returns true if num is zero, else false&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn zero?&amp;lt;br&amp;gt;  &amp;quot;Returns true if num is zero, else false&amp;quot;&amp;lt;br&amp;gt;  {&amp;lt;br&amp;gt;   :inline (fn [x] `(. clojure.lang.Numbers (isZero ~x)))&amp;lt;br&amp;gt;   :added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x] (. clojure.lang.Numbers (isZero x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">zero?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core&lt;/i&gt;&lt;b&gt;zipmap&lt;/b&gt; ([keys vals])&lt;br&gt; Returns a map with the keys mapped to the corresponding vals.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn zipmap&amp;lt;br&amp;gt;  &amp;quot;Returns a map with the keys mapped to the corresponding vals.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;&amp;lt;br&amp;gt;   :static true}&amp;lt;br&amp;gt;  [keys vals]&amp;lt;br&amp;gt;    (loop [map {}&amp;lt;br&amp;gt;           ks (seq keys)&amp;lt;br&amp;gt;           vs (seq vals)]&amp;lt;br&amp;gt;      (if (and ks vs)&amp;lt;br&amp;gt;        (recur (assoc map (first ks) (first vs))&amp;lt;br&amp;gt;               (next ks)&amp;lt;br&amp;gt;               (next vs))&amp;lt;br&amp;gt;        map)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">zipmap</a>[keys vals]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.cache</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;-&gt;BasicCache&lt;/b&gt; ([cache])&lt;br&gt; Positional factory function for class clojure.core.cache.BasicCache.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcache BasicCache [cache]&amp;lt;br&amp;gt;  CacheProtocol&amp;lt;br&amp;gt;  (lookup [_ item]&amp;lt;br&amp;gt;    (get cache item))&amp;lt;br&amp;gt;  (lookup [_ item not-found]&amp;lt;br&amp;gt;    (get cache item not-found))&amp;lt;br&amp;gt;  (has? [_ item]&amp;lt;br&amp;gt;    (contains? cache item))&amp;lt;br&amp;gt;  (hit [this item] this)&amp;lt;br&amp;gt;  (miss [_ item result]&amp;lt;br&amp;gt;    (BasicCache. (assoc cache item result)))&amp;lt;br&amp;gt;  (evict [_ key]&amp;lt;br&amp;gt;    (BasicCache. (dissoc cache key)))&amp;lt;br&amp;gt;  (seed [_ base]&amp;lt;br&amp;gt;    (BasicCache. base))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_] (str cache)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->BasicCache</a>[cache]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;-&gt;FIFOCache&lt;/b&gt; ([cache q limit])&lt;br&gt; Positional factory function for class clojure.core.cache.FIFOCache.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcache FIFOCache [cache q limit]&amp;lt;br&amp;gt;  CacheProtocol&amp;lt;br&amp;gt;  (lookup [_ item]&amp;lt;br&amp;gt;    (get cache item))&amp;lt;br&amp;gt;  (lookup [_ item not-found]&amp;lt;br&amp;gt;    (get cache item not-found))&amp;lt;br&amp;gt;  (has? [_ item]&amp;lt;br&amp;gt;    (contains? cache item))&amp;lt;br&amp;gt;  (hit [this item]&amp;lt;br&amp;gt;    this)&amp;lt;br&amp;gt;  (miss [_ item result]&amp;lt;br&amp;gt;    (let [[kache qq] (let [k (peek q)]&amp;lt;br&amp;gt;                       (if (&amp;gt;= (count cache) limit)&amp;lt;br&amp;gt;                         [(dissoc cache k) (pop q)]&amp;lt;br&amp;gt;                         [cache (pop q)]))]&amp;lt;br&amp;gt;      (FIFOCache. (assoc kache item result)&amp;lt;br&amp;gt;                  (conj qq item)&amp;lt;br&amp;gt;                  limit)))&amp;lt;br&amp;gt;  (evict [this key]&amp;lt;br&amp;gt;    (let [v (get cache key ::miss)]&amp;lt;br&amp;gt;      (if (= v ::miss)&amp;lt;br&amp;gt;        this&amp;lt;br&amp;gt;        (FIFOCache. (dissoc cache key)&amp;lt;br&amp;gt;                    (prune-queue q [key])&amp;lt;br&amp;gt;                    limit))))&amp;lt;br&amp;gt;  (seed [_ base]&amp;lt;br&amp;gt;    (let [{dropping :dropping&amp;lt;br&amp;gt;           q :queue} (describe-layout base limit)]&amp;lt;br&amp;gt;      (FIFOCache. (dissoc-keys base dropping)&amp;lt;br&amp;gt;                  q&amp;lt;br&amp;gt;                  limit)))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (str cache \, \space (pr-str q))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->FIFOCache</a>[cache q limit]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;-&gt;FnCache&lt;/b&gt; ([cache f])&lt;br&gt; Positional factory function for class clojure.core.cache.FnCache.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcache FnCache [cache f]&amp;lt;br&amp;gt;  CacheProtocol&amp;lt;br&amp;gt;  (lookup [_ item]&amp;lt;br&amp;gt;    (f (get cache item)))&amp;lt;br&amp;gt;  (lookup [_ item not-found]&amp;lt;br&amp;gt;    (let [ret (get cache item not-found)]&amp;lt;br&amp;gt;      (if (= ret not-found)&amp;lt;br&amp;gt;        not-found&amp;lt;br&amp;gt;        (f ret))))&amp;lt;br&amp;gt;  (has? [_ item]&amp;lt;br&amp;gt;    (contains? cache item))&amp;lt;br&amp;gt;  (hit [this item] this)&amp;lt;br&amp;gt;  (miss [_ item result]&amp;lt;br&amp;gt;    (BasicCache. (assoc cache item result)))&amp;lt;br&amp;gt;  (evict [_ key]&amp;lt;br&amp;gt;    (BasicCache. (dissoc cache key)))&amp;lt;br&amp;gt;  (seed [_ base]&amp;lt;br&amp;gt;    (BasicCache. base))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_] (str cache)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->FnCache</a>[cache f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;-&gt;LIRSCache&lt;/b&gt; ([cache lruS lruQ tick limitS limitQ])&lt;br&gt; Positional factory function for class clojure.core.cache.LIRSCache.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcache LIRSCache [cache lruS lruQ tick limitS limitQ]&amp;lt;br&amp;gt;  CacheProtocol&amp;lt;br&amp;gt;  (lookup [_ item]&amp;lt;br&amp;gt;    (get cache item))&amp;lt;br&amp;gt;  (lookup [_ item not-found]&amp;lt;br&amp;gt;    (get cache item not-found))&amp;lt;br&amp;gt;  (has? [_ item]&amp;lt;br&amp;gt;    (contains? cache item))&amp;lt;br&amp;gt;  (hit [_ item]&amp;lt;br&amp;gt;    (let [tick+ (inc tick)]&amp;lt;br&amp;gt;      (if (not (contains? lruS item))&amp;lt;br&amp;gt;                                        ; (2.3) item  S  item  Q&amp;lt;br&amp;gt;        (LIRSCache. cache (assoc lruS item tick+) (assoc lruQ item tick+) tick+ limitS limitQ)&amp;lt;br&amp;gt;        (let [k (apply min-key lruS (keys lruS))]&amp;lt;br&amp;gt;          (if (contains? lruQ item)&amp;lt;br&amp;gt;                                        ; (2.2) item  S  item  Q&amp;lt;br&amp;gt;            (let [new-lruQ (-&amp;gt; lruQ (dissoc item) (assoc k tick+))]&amp;lt;br&amp;gt;              (LIRSCache. cache&amp;lt;br&amp;gt;                          (-&amp;gt; lruS (dissoc k) (assoc item tick+) (prune-stack new-lruQ cache))&amp;lt;br&amp;gt;                          new-lruQ&amp;lt;br&amp;gt;                          tick+&amp;lt;br&amp;gt;                          limitS&amp;lt;br&amp;gt;                          limitQ))&amp;lt;br&amp;gt;                                        ; (2.1) item  S  item  Q&amp;lt;br&amp;gt;            (LIRSCache. cache&amp;lt;br&amp;gt;                        (-&amp;gt; lruS (assoc item tick+) (prune-stack lruQ cache))&amp;lt;br&amp;gt;                        lruQ&amp;lt;br&amp;gt;                        tick+&amp;lt;br&amp;gt;                        limitS&amp;lt;br&amp;gt;                        limitQ))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (miss [_ item result]&amp;lt;br&amp;gt;    (let [tick+ (inc tick)]&amp;lt;br&amp;gt;      (if (&amp;lt; (count cache) limitS)&amp;lt;br&amp;gt;                                        ; (1.1)&amp;lt;br&amp;gt;        (let [k (apply min-key lruS (keys lruS))]&amp;lt;br&amp;gt;          (LIRSCache. (assoc cache item result)&amp;lt;br&amp;gt;                      (-&amp;gt; lruS (dissoc k) (assoc item tick+))&amp;lt;br&amp;gt;                      lruQ&amp;lt;br&amp;gt;                      tick+&amp;lt;br&amp;gt;                      limitS&amp;lt;br&amp;gt;                      limitQ))&amp;lt;br&amp;gt;        (let [k (apply min-key lruQ (keys lruQ))&amp;lt;br&amp;gt;              new-lruQ (dissoc lruQ k)&amp;lt;br&amp;gt;              new-cache (-&amp;gt; cache  (dissoc k) (assoc item result))]&amp;lt;br&amp;gt;          (if (contains? lruS item)&amp;lt;br&amp;gt;                                        ; (1.3)&amp;lt;br&amp;gt;            (let [lastS (apply min-key lruS (keys lruS))]&amp;lt;br&amp;gt;              (LIRSCache. new-cache&amp;lt;br&amp;gt;                          (-&amp;gt; lruS (dissoc lastS) (assoc item tick+) (prune-stack new-lruQ new-cache))&amp;lt;br&amp;gt;                          (assoc new-lruQ lastS tick+)&amp;lt;br&amp;gt;                          tick+&amp;lt;br&amp;gt;                          limitS&amp;lt;br&amp;gt;                          limitQ))&amp;lt;br&amp;gt;                                        ; (1.2)&amp;lt;br&amp;gt;            (LIRSCache. new-cache&amp;lt;br&amp;gt;                        (assoc lruS item tick+)&amp;lt;br&amp;gt;                        (assoc new-lruQ item tick+)&amp;lt;br&amp;gt;                        tick+&amp;lt;br&amp;gt;                        limitS&amp;lt;br&amp;gt;                        limitQ))))))&amp;lt;br&amp;gt;  (seed [_ base]&amp;lt;br&amp;gt;    (LIRSCache. base&amp;lt;br&amp;gt;                (into {} (for [x (range (- limitS) 0)] [x x]))&amp;lt;br&amp;gt;                (into {} (for [x (range (- limitQ) 0)] [x x]))&amp;lt;br&amp;gt;                0&amp;lt;br&amp;gt;                limitS&amp;lt;br&amp;gt;                limitQ))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (str cache \, \space lruS \, \space lruQ \, \space tick \, \space limitS \, \space limitQ)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->LIRSCache</a>[cache lruS lruQ tick limitS limitQ]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;-&gt;LRUCache&lt;/b&gt; ([cache lru tick limit])&lt;br&gt; Positional factory function for class clojure.core.cache.LRUCache.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcache LRUCache [cache lru tick limit]&amp;lt;br&amp;gt;  CacheProtocol&amp;lt;br&amp;gt;  (lookup [_ item]&amp;lt;br&amp;gt;    (get cache item))&amp;lt;br&amp;gt;  (lookup [_ item not-found]&amp;lt;br&amp;gt;    (get cache item not-found))&amp;lt;br&amp;gt;  (has? [_ item]&amp;lt;br&amp;gt;    (contains? cache item))&amp;lt;br&amp;gt;  (hit [_ item]&amp;lt;br&amp;gt;    (let [tick+ (inc tick)]&amp;lt;br&amp;gt;      (LRUCache. cache&amp;lt;br&amp;gt;                 (assoc lru item tick+)&amp;lt;br&amp;gt;                 tick+&amp;lt;br&amp;gt;                 limit)))&amp;lt;br&amp;gt;  (miss [_ item result]&amp;lt;br&amp;gt;    (let [tick+ (inc tick)]&amp;lt;br&amp;gt;      (if (&amp;gt;= (count lru) limit)&amp;lt;br&amp;gt;        (let [k (if (contains? lru item)&amp;lt;br&amp;gt;                  item&amp;lt;br&amp;gt;                  (first (peek lru))) ;; minimum-key, maybe evict case&amp;lt;br&amp;gt;              c (-&amp;gt; cache (dissoc k) (assoc item result))&amp;lt;br&amp;gt;              l (-&amp;gt; lru (dissoc k) (assoc item tick+))]&amp;lt;br&amp;gt;          (LRUCache. c l tick+ limit))&amp;lt;br&amp;gt;        (LRUCache. (assoc cache item result)  ;; no change case&amp;lt;br&amp;gt;                   (assoc lru item tick+)&amp;lt;br&amp;gt;                   tick+&amp;lt;br&amp;gt;                   limit))))&amp;lt;br&amp;gt;  (evict [this key]&amp;lt;br&amp;gt;    (let [v (get cache key ::miss)]&amp;lt;br&amp;gt;      (if (= v ::miss)&amp;lt;br&amp;gt;        this&amp;lt;br&amp;gt;        (LRUCache. (dissoc cache key)&amp;lt;br&amp;gt;                   (dissoc lru key)&amp;lt;br&amp;gt;                   (inc tick)&amp;lt;br&amp;gt;                   limit))))&amp;lt;br&amp;gt;  (seed [_ base]&amp;lt;br&amp;gt;    (LRUCache. base&amp;lt;br&amp;gt;               (build-leastness-queue base limit 0)&amp;lt;br&amp;gt;               0&amp;lt;br&amp;gt;               limit))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (str cache \, \space lru \, \space tick \, \space limit)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->LRUCache</a>[cache lru tick limit]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;-&gt;LUCache&lt;/b&gt; ([cache lu limit])&lt;br&gt; Positional factory function for class clojure.core.cache.LUCache.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcache LUCache [cache lu limit]&amp;lt;br&amp;gt;  CacheProtocol&amp;lt;br&amp;gt;  (lookup [_ item]&amp;lt;br&amp;gt;    (get cache item))&amp;lt;br&amp;gt;  (lookup [_ item not-found]&amp;lt;br&amp;gt;    (get cache item not-found))&amp;lt;br&amp;gt;  (has? [_ item]&amp;lt;br&amp;gt;    (contains? cache item))&amp;lt;br&amp;gt;  (hit [_ item]&amp;lt;br&amp;gt;    (LUCache. cache (update-in lu [item] inc) limit))&amp;lt;br&amp;gt;  (miss [_ item result]&amp;lt;br&amp;gt;    (if (&amp;gt;= (count lu) limit) ;; need to evict?&amp;lt;br&amp;gt;      (let [min-key (if (contains? lu item)&amp;lt;br&amp;gt;                    ::nope&amp;lt;br&amp;gt;                    (first (peek lu))) ;; maybe evict case&amp;lt;br&amp;gt;            c (-&amp;gt; cache (dissoc min-key) (assoc item result))&amp;lt;br&amp;gt;            l (-&amp;gt; lu (dissoc min-key) (update-in [item] (fnil inc 0)))]&amp;lt;br&amp;gt;        (LUCache. c l limit))&amp;lt;br&amp;gt;      (LUCache. (assoc cache item result)  ;; no change case&amp;lt;br&amp;gt;                (assoc lu item 0)&amp;lt;br&amp;gt;                limit)))&amp;lt;br&amp;gt;  (evict [this key]&amp;lt;br&amp;gt;    (let [v (get cache key ::miss)]&amp;lt;br&amp;gt;      (if (= v ::miss)&amp;lt;br&amp;gt;        this&amp;lt;br&amp;gt;        (LUCache. (dissoc cache key)&amp;lt;br&amp;gt;                   (dissoc lu key)&amp;lt;br&amp;gt;                   limit))))&amp;lt;br&amp;gt;  (seed [_ base]&amp;lt;br&amp;gt;    (LUCache. base&amp;lt;br&amp;gt;              (build-leastness-queue base limit 0)&amp;lt;br&amp;gt;              limit))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (str cache \, \space lu \, \space limit)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->LUCache</a>[cache lu limit]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;-&gt;SoftCache&lt;/b&gt; ([cache rcache rq])&lt;br&gt; Positional factory function for class clojure.core.cache.SoftCache.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcache SoftCache [^java.util.Map cache ^java.util.Map rcache rq]&amp;lt;br&amp;gt;  CacheProtocol&amp;lt;br&amp;gt;  (lookup [_ item]&amp;lt;br&amp;gt;    (when-let [^SoftReference r (get cache (or item ::nil))]&amp;lt;br&amp;gt;      (if (= ::nil (.get r))&amp;lt;br&amp;gt;        nil&amp;lt;br&amp;gt;        (.get r))))&amp;lt;br&amp;gt;  (lookup [_ item not-found]&amp;lt;br&amp;gt;    (if-let [^SoftReference r (get cache (or item ::nil))]&amp;lt;br&amp;gt;      (if-let [v (.get r)]&amp;lt;br&amp;gt;        (if (= ::nil v)&amp;lt;br&amp;gt;          nil&amp;lt;br&amp;gt;          v)&amp;lt;br&amp;gt;        not-found)&amp;lt;br&amp;gt;      not-found))&amp;lt;br&amp;gt;  (has? [_ item]&amp;lt;br&amp;gt;    (let [item (or item ::nil)&amp;lt;br&amp;gt;          ^SoftReference cell (get cache item)]&amp;lt;br&amp;gt;      (and (contains? cache item)&amp;lt;br&amp;gt;           (not (nil? (.get cell))))))&amp;lt;br&amp;gt;  (hit [this item]&amp;lt;br&amp;gt;    (clear-soft-cache! cache rcache rq)&amp;lt;br&amp;gt;    this)&amp;lt;br&amp;gt;  (miss [this item result]&amp;lt;br&amp;gt;    (let [item (or item ::nil)&amp;lt;br&amp;gt;          r (make-reference result rq)]&amp;lt;br&amp;gt;      (.put cache item r)&amp;lt;br&amp;gt;      (.put rcache r item)&amp;lt;br&amp;gt;      (clear-soft-cache! cache rcache rq)&amp;lt;br&amp;gt;      this))&amp;lt;br&amp;gt;  (evict [this key]&amp;lt;br&amp;gt;    (let [key (or key ::nil)&amp;lt;br&amp;gt;          r (get cache key)]&amp;lt;br&amp;gt;      (when r&amp;lt;br&amp;gt;        (.remove cache key)&amp;lt;br&amp;gt;        (.remove rcache r))&amp;lt;br&amp;gt;      (clear-soft-cache! cache rcache rq)&amp;lt;br&amp;gt;      this))&amp;lt;br&amp;gt;  (seed [_ base]&amp;lt;br&amp;gt;    (let [soft-cache? (instance? SoftCache base)&amp;lt;br&amp;gt;          cache (ConcurrentHashMap.)&amp;lt;br&amp;gt;          rcache (ConcurrentHashMap.)&amp;lt;br&amp;gt;          rq (ReferenceQueue.)]&amp;lt;br&amp;gt;      (if (seq base)&amp;lt;br&amp;gt;        (doseq [[k ^SoftReference v] base]&amp;lt;br&amp;gt;          (let [k (or k ::nil)&amp;lt;br&amp;gt;                r (if soft-cache?&amp;lt;br&amp;gt;                    (make-reference (.get v) rq)&amp;lt;br&amp;gt;                    (make-reference v rq))]&amp;lt;br&amp;gt;            (.put cache k r)&amp;lt;br&amp;gt;            (.put rcache r k))))&amp;lt;br&amp;gt;      (SoftCache. cache rcache rq)))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_] (str cache)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->SoftCache</a>[cache rcache rq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;-&gt;TTLCache&lt;/b&gt; ([cache ttl ttl-ms])&lt;br&gt; Positional factory function for class clojure.core.cache.TTLCache.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcache TTLCache [cache ttl ttl-ms]&amp;lt;br&amp;gt;  CacheProtocol&amp;lt;br&amp;gt;  (lookup [this item]&amp;lt;br&amp;gt;    (let [ret (lookup this item ::nope)]&amp;lt;br&amp;gt;      (when-not (= ret ::nope) ret)))&amp;lt;br&amp;gt;  (lookup [this item not-found]&amp;lt;br&amp;gt;    (if (has? this item)&amp;lt;br&amp;gt;      (get cache item)&amp;lt;br&amp;gt;      not-found))&amp;lt;br&amp;gt;  (has? [_ item]&amp;lt;br&amp;gt;    (let [t (get ttl item (- ttl-ms))]&amp;lt;br&amp;gt;      (&amp;lt; (- (System/currentTimeMillis)&amp;lt;br&amp;gt;            t)&amp;lt;br&amp;gt;         ttl-ms)))&amp;lt;br&amp;gt;  (hit [this item] this)&amp;lt;br&amp;gt;  (miss [this item result]&amp;lt;br&amp;gt;    (let [now  (System/currentTimeMillis)&amp;lt;br&amp;gt;          kill-old (key-killer ttl ttl-ms now)]&amp;lt;br&amp;gt;      (TTLCache. (assoc (kill-old cache) item result)&amp;lt;br&amp;gt;                 (assoc (kill-old ttl) item now)&amp;lt;br&amp;gt;                 ttl-ms)))&amp;lt;br&amp;gt;  (seed [_ base]&amp;lt;br&amp;gt;    (let [now (System/currentTimeMillis)]&amp;lt;br&amp;gt;      (TTLCache. base&amp;lt;br&amp;gt;                 (into {} (for [x base] [(key x) now]))&amp;lt;br&amp;gt;                 ttl-ms)))&amp;lt;br&amp;gt;  (evict [_ key]&amp;lt;br&amp;gt;    (TTLCache. (dissoc cache key)&amp;lt;br&amp;gt;               (dissoc ttl key)&amp;lt;br&amp;gt;               ttl-ms))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (str cache \, \space ttl \, \space ttl-ms)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->TTLCache</a>[cache ttl ttl-ms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;basic-cache-factory&lt;/b&gt; ([base])&lt;br&gt; Returns a pluggable basic cache initialied to `base`&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn basic-cache-factory&amp;lt;br&amp;gt;  &amp;quot;Returns a pluggable basic cache initialied to `base`&amp;quot;&amp;lt;br&amp;gt;  [base]&amp;lt;br&amp;gt;  {:pre [(map? base)]}&amp;lt;br&amp;gt;  (BasicCache. base))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">basic-cache-factory</a>[base]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;clear-soft-cache!&lt;/b&gt; ([cache rcache rq])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn clear-soft-cache! [^java.util.Map cache ^java.util.Map rcache ^ReferenceQueue rq]&amp;lt;br&amp;gt;  (loop [r (.poll rq)]&amp;lt;br&amp;gt;    (when r&amp;lt;br&amp;gt;      (.remove cache (get rcache r))&amp;lt;br&amp;gt;      (.remove rcache r)&amp;lt;br&amp;gt;      (recur (.poll rq)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">clear-soft-cache!</a>[cache rcache rq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;defcache&lt;/b&gt; ([type-name fields &amp; specifics])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defcache&amp;lt;br&amp;gt;  [type-name fields &amp;amp; specifics]&amp;lt;br&amp;gt;  (let [[base-field &amp;amp; _] fields]&amp;lt;br&amp;gt;    `(deftype ~type-name [~@fields]&amp;lt;br&amp;gt;       ~@specifics&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       clojure.lang.ILookup&amp;lt;br&amp;gt;       (valAt [this# key#]&amp;lt;br&amp;gt;              (lookup this# key#))&amp;lt;br&amp;gt;       (valAt [this# key# not-found#]&amp;lt;br&amp;gt;              (if (has? this# key#)&amp;lt;br&amp;gt;                (lookup this# key#)&amp;lt;br&amp;gt;                not-found#))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       clojure.lang.IPersistentMap&amp;lt;br&amp;gt;       (assoc [this# k# v#]&amp;lt;br&amp;gt;         (miss this# k# v#))&amp;lt;br&amp;gt;       (without [this# k#]&amp;lt;br&amp;gt;         (evict this# k#))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       clojure.lang.Associative&amp;lt;br&amp;gt;       (containsKey [this# k#]&amp;lt;br&amp;gt;         (has? this# k#))&amp;lt;br&amp;gt;       (entryAt [this# k#]&amp;lt;br&amp;gt;         (when (has? this# k#)&amp;lt;br&amp;gt;           (clojure.lang.MapEntry. k# (lookup this# k#))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       clojure.lang.Counted&amp;lt;br&amp;gt;       (count [this#]&amp;lt;br&amp;gt;         (clojure.core/count ~base-field))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       clojure.lang.IPersistentCollection&amp;lt;br&amp;gt;       (cons [_# elem#]&amp;lt;br&amp;gt;         (clojure.core/cons ~base-field elem#))&amp;lt;br&amp;gt;       (empty [this#]&amp;lt;br&amp;gt;         (seed this# (empty ~base-field)))&amp;lt;br&amp;gt;       (equiv [_# other#]&amp;lt;br&amp;gt;         (clojure.lang.Util/equiv ~base-field other#))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       clojure.lang.Seqable&amp;lt;br&amp;gt;       (seq [_#]&amp;lt;br&amp;gt;         (seq ~base-field)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defcache</a>[type-name fields & specifics]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;evict&lt;/b&gt; ([cache e])&lt;br&gt; Removes an entry from the cache&lt;/div&gt;" data-placement="right">evict</a>[cache e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;fifo-cache-factory&lt;/b&gt; ([base &amp; {threshold :threshold, :or {threshold 32}}])&lt;br&gt; Returns a FIFO cache with the cache and FIFO queue initialized to `base` --&lt;br&gt;   the queue is filled as the values are pulled out of `base`.  If the associative&lt;br&gt;   structure can guarantee ordering, then the said ordering will define the&lt;br&gt;   eventual eviction order.  Otherwise, there are no guarantees for the eventual&lt;br&gt;   eviction ordering.&lt;br&gt;&lt;br&gt;   This function takes an optional `:threshold` argument that defines the maximum number&lt;br&gt;   of elements in the cache before the FIFO semantics apply (default is 32).&lt;br&gt;&lt;br&gt;   If the number of elements in `base` is greater than the limit then some items&lt;br&gt;   in `base` will be dropped from the resulting cache.  If the associative&lt;br&gt;   structure used as `base` can guarantee sorting, then the last `limit` elements&lt;br&gt;   will be used as the cache seed values.  Otherwise, there are no guarantees about&lt;br&gt;   the elements in the resulting cache.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fifo-cache-factory&amp;lt;br&amp;gt;  &amp;quot;Returns a FIFO cache with the cache and FIFO queue initialized to `base` --&amp;lt;br&amp;gt;   the queue is filled as the values are pulled out of `base`.  If the associative&amp;lt;br&amp;gt;   structure can guarantee ordering, then the said ordering will define the&amp;lt;br&amp;gt;   eventual eviction order.  Otherwise, there are no guarantees for the eventual&amp;lt;br&amp;gt;   eviction ordering.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   This function takes an optional `:threshold` argument that defines the maximum number&amp;lt;br&amp;gt;   of elements in the cache before the FIFO semantics apply (default is 32).&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   If the number of elements in `base` is greater than the limit then some items&amp;lt;br&amp;gt;   in `base` will be dropped from the resulting cache.  If the associative&amp;lt;br&amp;gt;   structure used as `base` can guarantee sorting, then the last `limit` elements&amp;lt;br&amp;gt;   will be used as the cache seed values.  Otherwise, there are no guarantees about&amp;lt;br&amp;gt;   the elements in the resulting cache.&amp;quot;&amp;lt;br&amp;gt;  [base &amp;amp; {threshold :threshold :or {threshold 32}}]&amp;lt;br&amp;gt;  {:pre [(number? threshold) (&amp;lt; 0 threshold)&amp;lt;br&amp;gt;         (map? base)]&amp;lt;br&amp;gt;   :post [(== threshold (count (.q ^FIFOCache %)))]}&amp;lt;br&amp;gt;  (clojure.core.cache/seed (FIFOCache. {} clojure.lang.PersistentQueue/EMPTY threshold) base))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fifo-cache-factory</a>[base & {threshold :threshold, :or {threshold 32}}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;has?&lt;/b&gt; ([cache e])&lt;br&gt; Checks if the cache contains a value associtaed with `e`&lt;/div&gt;" data-placement="right">has?</a>[cache e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;hit&lt;/b&gt; ([cache e])&lt;br&gt; Is meant to be called if the cache is determined to contain a value&lt;br&gt;   associated with `e`&lt;/div&gt;" data-placement="right">hit</a>[cache e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;lirs-cache-factory&lt;/b&gt; ([base &amp; {:keys [s-history-limit q-history-limit], :or {s-history-limit 32, q-history-limit 32}}])&lt;br&gt; Returns an LIRS cache with the S &amp; R LRU lists set to the indicated&lt;br&gt;   limits.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lirs-cache-factory&amp;lt;br&amp;gt;  &amp;quot;Returns an LIRS cache with the S &amp;amp; R LRU lists set to the indicated&amp;lt;br&amp;gt;   limits.&amp;quot;&amp;lt;br&amp;gt;  [base &amp;amp; {:keys [s-history-limit q-history-limit]&amp;lt;br&amp;gt;           :or {s-history-limit 32&amp;lt;br&amp;gt;                q-history-limit 32}}]&amp;lt;br&amp;gt;  {:pre [(number? s-history-limit) (&amp;lt; 0 s-history-limit)&amp;lt;br&amp;gt;         (number? q-history-limit) (&amp;lt; 0 q-history-limit)&amp;lt;br&amp;gt;         (map? base)]}&amp;lt;br&amp;gt;  (seed (LIRSCache. {} {} {} 0 s-history-limit q-history-limit) base))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lirs-cache-factory</a>[base & {:keys [s-history-limit q-history-limit], :or {s-history-limit 32, q-history-limit 32}}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;lookup&lt;/b&gt; ([cache e] [cache e not-found])&lt;br&gt; Retrieve the value associated with `e` if it exists, else `nil` in&lt;br&gt;   the 2-arg case.  Retrieve the value associated with `e` if it exists,&lt;br&gt;   else `not-found` in the 3-arg case.&lt;/div&gt;" data-placement="right">lookup</a>[cache e] [cache e not-found]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;lru-cache-factory&lt;/b&gt; ([base &amp; {threshold :threshold, :or {threshold 32}}])&lt;br&gt; Returns an LRU cache with the cache and usage-table initialied to `base` --&lt;br&gt;   each entry is initialized with the same usage value.&lt;br&gt;&lt;br&gt;   This function takes an optional `:threshold` argument that defines the maximum number&lt;br&gt;   of elements in the cache before the LRU semantics apply (default is 32).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lru-cache-factory&amp;lt;br&amp;gt;  &amp;quot;Returns an LRU cache with the cache and usage-table initialied to `base` --&amp;lt;br&amp;gt;   each entry is initialized with the same usage value.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   This function takes an optional `:threshold` argument that defines the maximum number&amp;lt;br&amp;gt;   of elements in the cache before the LRU semantics apply (default is 32).&amp;quot;&amp;lt;br&amp;gt;  [base &amp;amp; {threshold :threshold :or {threshold 32}}]&amp;lt;br&amp;gt;  {:pre [(number? threshold) (&amp;lt; 0 threshold)&amp;lt;br&amp;gt;         (map? base)]}&amp;lt;br&amp;gt;  (clojure.core.cache/seed (LRUCache. {} (clojure.data.priority-map/priority-map) 0 threshold) base))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lru-cache-factory</a>[base & {threshold :threshold, :or {threshold 32}}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;lu-cache-factory&lt;/b&gt; ([base &amp; {threshold :threshold, :or {threshold 32}}])&lt;br&gt; Returns an LU cache with the cache and usage-table initialied to `base`.&lt;br&gt;&lt;br&gt;   This function takes an optional `:threshold` argument that defines the maximum number&lt;br&gt;   of elements in the cache before the LU semantics apply (default is 32).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lu-cache-factory&amp;lt;br&amp;gt;  &amp;quot;Returns an LU cache with the cache and usage-table initialied to `base`.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   This function takes an optional `:threshold` argument that defines the maximum number&amp;lt;br&amp;gt;   of elements in the cache before the LU semantics apply (default is 32).&amp;quot;&amp;lt;br&amp;gt;  [base &amp;amp; {threshold :threshold :or {threshold 32}}]&amp;lt;br&amp;gt;  {:pre [(number? threshold) (&amp;lt; 0 threshold)&amp;lt;br&amp;gt;         (map? base)]}&amp;lt;br&amp;gt;  (clojure.core.cache/seed (LUCache. {} (clojure.data.priority-map/priority-map) threshold) base))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lu-cache-factory</a>[base & {threshold :threshold, :or {threshold 32}}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;make-reference&lt;/b&gt; ([v rq])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^{:dynamic true} make-reference [v rq]&amp;lt;br&amp;gt;  (if (nil? v)&amp;lt;br&amp;gt;    (SoftReference. ::nil rq)&amp;lt;br&amp;gt;    (SoftReference. v rq)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-reference</a>[v rq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;miss&lt;/b&gt; ([cache e ret])&lt;br&gt; Is meant to be called if the cache is determined to **not** contain a&lt;br&gt;   value associated with `e`&lt;/div&gt;" data-placement="right">miss</a>[cache e ret]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;seed&lt;/b&gt; ([cache base])&lt;br&gt; Is used to signal that the cache should be created with a seed.&lt;br&gt;   The contract is that said cache should return an instance of its&lt;br&gt;   own type.&lt;/div&gt;" data-placement="right">seed</a>[cache base]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;soft-cache-factory&lt;/b&gt; ([base])&lt;br&gt; Returns a SoftReference cache.  Cached values will be referred to with&lt;br&gt;  SoftReferences, allowing the values to be garbage collected when there is&lt;br&gt;  memory pressure on the JVM.&lt;br&gt;&lt;br&gt;  SoftCache is a mutable cache, since it is always based on a&lt;br&gt;  ConcurrentHashMap.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn soft-cache-factory&amp;lt;br&amp;gt;  &amp;quot;Returns a SoftReference cache.  Cached values will be referred to with&amp;lt;br&amp;gt;  SoftReferences, allowing the values to be garbage collected when there is&amp;lt;br&amp;gt;  memory pressure on the JVM.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  SoftCache is a mutable cache, since it is always based on a&amp;lt;br&amp;gt;  ConcurrentHashMap.&amp;quot;&amp;lt;br&amp;gt;  [base]&amp;lt;br&amp;gt;  {:pre [(map? base)]}&amp;lt;br&amp;gt;  (seed (SoftCache. (ConcurrentHashMap.) (ConcurrentHashMap.) (ReferenceQueue.))&amp;lt;br&amp;gt;        base))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">soft-cache-factory</a>[base]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;through&lt;/b&gt; ([cache item] [value-fn cache item] [wrap-fn value-fn cache item])&lt;br&gt; The basic hit/miss logic for the cache system.  Expects a wrap function and&lt;br&gt;  value function.  The wrap function takes the value function and the item in question&lt;br&gt;  and is expected to run the value function with the item whenever a cache&lt;br&gt;  miss occurs.  The intent is to hide any cache-specific cells from leaking&lt;br&gt;  into the cache logic itelf.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn through&amp;lt;br&amp;gt;  &amp;quot;The basic hit/miss logic for the cache system.  Expects a wrap function and&amp;lt;br&amp;gt;  value function.  The wrap function takes the value function and the item in question&amp;lt;br&amp;gt;  and is expected to run the value function with the item whenever a cache&amp;lt;br&amp;gt;  miss occurs.  The intent is to hide any cache-specific cells from leaking&amp;lt;br&amp;gt;  into the cache logic itelf.&amp;quot;&amp;lt;br&amp;gt;  ([cache item] (through default-wrapper-fn identity cache item))&amp;lt;br&amp;gt;  ([value-fn cache item] (through default-wrapper-fn value-fn cache item))&amp;lt;br&amp;gt;  ([wrap-fn value-fn cache item]&amp;lt;br&amp;gt;    (if (clojure.core.cache/has? cache item)&amp;lt;br&amp;gt;      (clojure.core.cache/hit cache item)&amp;lt;br&amp;gt;      (clojure.core.cache/miss cache item (wrap-fn #(value-fn %) item)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">through</a>[cache item] [value-fn cache item] [wrap-fn value-fn cache item]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.cache&lt;/i&gt;&lt;b&gt;ttl-cache-factory&lt;/b&gt; ([base &amp; {ttl :ttl, :or {ttl 2000}}])&lt;br&gt; Returns a TTL cache with the cache and expiration-table initialied to `base` --&lt;br&gt;   each with the same time-to-live.&lt;br&gt;&lt;br&gt;   This function also allows an optional `:ttl` argument that defines the default&lt;br&gt;   time in milliseconds that entries are allowed to reside in the cache.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ttl-cache-factory&amp;lt;br&amp;gt;  &amp;quot;Returns a TTL cache with the cache and expiration-table initialied to `base` --&amp;lt;br&amp;gt;   each with the same time-to-live.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   This function also allows an optional `:ttl` argument that defines the default&amp;lt;br&amp;gt;   time in milliseconds that entries are allowed to reside in the cache.&amp;quot;&amp;lt;br&amp;gt;  [base &amp;amp; {ttl :ttl :or {ttl 2000}}]&amp;lt;br&amp;gt;  {:pre [(number? ttl) (&amp;lt;= 0 ttl)&amp;lt;br&amp;gt;         (map? base)]}&amp;lt;br&amp;gt;  (clojure.core.cache/seed (TTLCache. {} {} ttl) base))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ttl-cache-factory</a>[base & {ttl :ttl, :or {ttl 2000}}]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.contracts</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts&lt;/i&gt;&lt;b&gt;_&lt;/b&gt; ([a b &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro _&amp;lt;br&amp;gt;  [a b &amp;amp; body]&amp;lt;br&amp;gt;  (let [name (if (symbol? a) a (gensym &amp;quot;hoc&amp;quot;))&amp;lt;br&amp;gt;        args (if (symbol? a) b a)&amp;lt;br&amp;gt;        body (if (symbol? a) body (list* b body))]&amp;lt;br&amp;gt;    `(contract ~name &amp;quot;TBD&amp;quot; ~args ~(vec body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">_</a>[a b & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts&lt;/i&gt;&lt;b&gt;contract&lt;/b&gt; ([name docstring &amp; constraints])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro contract&amp;lt;br&amp;gt;  [name docstring &amp;amp; constraints]&amp;lt;br&amp;gt;  (tools/assert-w-message (string? docstring) &amp;quot;Sorry, but contracts require docstrings&amp;quot;)&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  `(with-meta &amp;lt;br&amp;gt;     ~(build-contract-fn-body name docstring constraints)&amp;lt;br&amp;gt;     {:docstring ~docstring&amp;lt;br&amp;gt;      ::constraints :TBD}))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">contract</a>[name docstring & constraints]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts&lt;/i&gt;&lt;b&gt;provide&lt;/b&gt; ([&amp; kontracts])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Provides the Var manipulation macro offering ex post facto application of contracts&lt;br&gt;   to existing functions.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro provide&amp;lt;br&amp;gt;  &amp;quot;Provides the Var manipulation macro offering ex post facto application of contracts&amp;lt;br&amp;gt;   to existing functions.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; kontracts]&amp;lt;br&amp;gt;  (let [fn-names  (map first kontracts)&amp;lt;br&amp;gt;        kontracts (for [[n ds &amp;amp; more] kontracts]&amp;lt;br&amp;gt;                    (if (vector? (first more))&amp;lt;br&amp;gt;                      (list* `contract n ds more)&amp;lt;br&amp;gt;                      (first more)))]&amp;lt;br&amp;gt;    `(do&amp;lt;br&amp;gt;       ~@(for [[n# c#] (zipmap fn-names kontracts)]&amp;lt;br&amp;gt;           (list `alter-var-root (list `var n#)&amp;lt;br&amp;gt;                 (list `fn '[f c] (list `with-constraints 'f 'c)) c#))&amp;lt;br&amp;gt;       nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">provide</a>[& kontracts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts&lt;/i&gt;&lt;b&gt;require-with-constraints&lt;/b&gt; ([name inv-description invariants])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro require-with-constraints&amp;lt;br&amp;gt;  [name inv-description invariants]&amp;lt;br&amp;gt;  `(do&amp;lt;br&amp;gt;     (require ~(quote name))&amp;lt;br&amp;gt;     (set-validator! (var ~name) (partial (contract ~(symbol (str &amp;quot;chk-&amp;quot; name))&amp;lt;br&amp;gt;                                            ~inv-description&amp;lt;br&amp;gt;                                            [~name]&amp;lt;br&amp;gt;                                            ~invariants)&amp;lt;br&amp;gt;                                          (fn [x#] true)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">require-with-constraints</a>[name inv-description invariants]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts&lt;/i&gt;&lt;b&gt;with-constraints&lt;/b&gt; ([f] [f c] [f c &amp; more])&lt;br&gt; A contract combinator.&lt;br&gt;&lt;br&gt;   Takes a target function and a number of contracts and returns a function with the contracts&lt;br&gt;   applied to the original.  This is the preferred way to apply a contract previously created&lt;br&gt;   using `contract` as the use of `partial` may not work as implementation details change.&lt;br&gt;  &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn with-constraints&amp;lt;br&amp;gt;  &amp;quot;A contract combinator.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Takes a target function and a number of contracts and returns a function with the contracts&amp;lt;br&amp;gt;   applied to the original.  This is the preferred way to apply a contract previously created&amp;lt;br&amp;gt;   using `contract` as the use of `partial` may not work as implementation details change.&amp;lt;br&amp;gt;  &amp;quot;&amp;lt;br&amp;gt;  ([f] f)&amp;lt;br&amp;gt;  ([f c] (partial c f))&amp;lt;br&amp;gt;  ([f c &amp;amp; more]&amp;lt;br&amp;gt;     (apply with-constraints (with-constraints f c) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-constraints</a>[f] [f c] [f c & more]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.contracts.constraints</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;&lt;-&lt;/b&gt; ([p q])&lt;br&gt; Converse implication&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn &amp;lt;-&amp;lt;br&amp;gt;  &amp;quot;Converse implication&amp;quot;&amp;lt;br&amp;gt;  [p q]&amp;lt;br&amp;gt;  (implies q p))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;"><-</a>[p q]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;&lt;=&gt;&lt;/b&gt; ([p q])&lt;br&gt; Logical equality&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn &amp;lt;=&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;Logical equality&amp;quot;&amp;lt;br&amp;gt;  [p q]&amp;lt;br&amp;gt;  (and (implies p q)&amp;lt;br&amp;gt;       (&amp;lt;- p q)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;"><=></a>[p q]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;=&lt;/b&gt; ([l__3571__auto__] [l__3571__auto__ r__3572__auto__])&lt;br&gt; Curried version of #'clojure.core/=&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcurry-from clojure.core&amp;lt;br&amp;gt;  == = not=)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">=</a>[l__3571__auto__] [l__3571__auto__ r__3572__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;==&lt;/b&gt; ([l__3571__auto__] [l__3571__auto__ r__3572__auto__])&lt;br&gt; Curried version of #'clojure.core/==&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcurry-from clojure.core&amp;lt;br&amp;gt;  == = not=)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">==</a>[l__3571__auto__] [l__3571__auto__ r__3572__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;anything&lt;/b&gt; ([&amp; _])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn anything [&amp;amp; _] true)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">anything</a>[& _]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;defconstrainedfn&lt;/b&gt; ([name &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Defines a function using the `contract` vector appearing after the arguments.&lt;br&gt;&lt;br&gt;       (defconstrainedfn sqr&lt;br&gt;         [n] [number? (not= 0 n) =&gt; pos? number?]&lt;br&gt;         (* n n))&lt;br&gt;&lt;br&gt;   Like the `contract` macro, multiple arity functions can be defined where each argument vector&lt;br&gt;   is immediately followed by the relevent arity expectations.  This macro will also detect&lt;br&gt;   if a map is in that constraints position and use that instead under the assumption that&lt;br&gt;   Clojure's `:pre`/`:post` map is used instead.&lt;br&gt;  &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defconstrainedfn&amp;lt;br&amp;gt;  &amp;quot;Defines a function using the `contract` vector appearing after the arguments.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (defconstrainedfn sqr&amp;lt;br&amp;gt;         [n] [number? (not= 0 n) =&amp;gt; pos? number?]&amp;lt;br&amp;gt;         (* n n))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Like the `contract` macro, multiple arity functions can be defined where each argument vector&amp;lt;br&amp;gt;   is immediately followed by the relevent arity expectations.  This macro will also detect&amp;lt;br&amp;gt;   if a map is in that constraints position and use that instead under the assumption that&amp;lt;br&amp;gt;   Clojure's `:pre`/`:post` map is used instead.&amp;lt;br&amp;gt;  &amp;quot;&amp;lt;br&amp;gt;  [name &amp;amp; body]&amp;lt;br&amp;gt;  (let [mdata (if (string? (first body))&amp;lt;br&amp;gt;                {:doc (first body)}&amp;lt;br&amp;gt;                {})&amp;lt;br&amp;gt;        body  (if (:doc mdata)&amp;lt;br&amp;gt;                (next body)&amp;lt;br&amp;gt;                body)&amp;lt;br&amp;gt;        body  (if (vector? (first body))&amp;lt;br&amp;gt;                (list body)&amp;lt;br&amp;gt;                body)&amp;lt;br&amp;gt;        body  (for [[args cnstr &amp;amp; bd] body]&amp;lt;br&amp;gt;                (list* args&amp;lt;br&amp;gt;                       (if (vector? cnstr)&amp;lt;br&amp;gt;                         (second (#'clojure.core.contracts.impl.transformers/build-constraints-description args cnstr (:doc mdata)))&amp;lt;br&amp;gt;                         cnstr)&amp;lt;br&amp;gt;                       bd))]&amp;lt;br&amp;gt;    `(defn ~name&amp;lt;br&amp;gt;       ~(str (:doc mdata))&amp;lt;br&amp;gt;       ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defconstrainedfn</a>[name & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;defconstrainedrecord&lt;/b&gt; ([name slots inv-description invariants &amp; etc])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defconstrainedrecord&amp;lt;br&amp;gt;  [name slots inv-description invariants &amp;amp; etc]&amp;lt;br&amp;gt;  (let [fields (vec slots)&amp;lt;br&amp;gt;        ns-part (namespace-munge *ns*)&amp;lt;br&amp;gt;        classname (symbol (str ns-part &amp;quot;.&amp;quot; name))&amp;lt;br&amp;gt;        ctor-name (symbol (str name \.))&amp;lt;br&amp;gt;        positional-factory-name (symbol (str &amp;quot;-&amp;gt;&amp;quot; name))&amp;lt;br&amp;gt;        map-arrow-factory-name (symbol (str &amp;quot;map-&amp;gt;&amp;quot; name))&amp;lt;br&amp;gt;        chk `(clojure.core.contracts/contract&amp;lt;br&amp;gt;                ~(symbol (str &amp;quot;chk-&amp;quot; name))&amp;lt;br&amp;gt;                ~inv-description&amp;lt;br&amp;gt;                [{:keys ~fields :as m#}]&amp;lt;br&amp;gt;                ~invariants)]&amp;lt;br&amp;gt;    `(do&amp;lt;br&amp;gt;       (let [t# (defrecord ~name ~fields ~@etc)]&amp;lt;br&amp;gt;         (defn ~(symbol (str name \?)) [r#]&amp;lt;br&amp;gt;           (= t# (type r#))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       ~(build-positional-factory name classname fields invariants chk)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (defconstrainedfn ~map-arrow-factory-name&amp;lt;br&amp;gt;         ([{:keys ~fields :as m#}]&amp;lt;br&amp;gt;            ~invariants&amp;lt;br&amp;gt;            (with-meta&amp;lt;br&amp;gt;              (merge (new ~name ~@(for [e fields] nil)) m#)&amp;lt;br&amp;gt;              {:contract ~chk})))&amp;lt;br&amp;gt;       ~name)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defconstrainedrecord</a>[name slots inv-description invariants & etc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;except&lt;/b&gt; ([p q])&lt;br&gt; P except Q&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn except&amp;lt;br&amp;gt;  &amp;quot;P except Q&amp;quot;&amp;lt;br&amp;gt;  [p q]&amp;lt;br&amp;gt;  (not (implies p q)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">except</a>[p q]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;implies&lt;/b&gt; ([p q])&lt;br&gt; Logical implication&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn implies&amp;lt;br&amp;gt;  &amp;quot;Logical implication&amp;quot;&amp;lt;br&amp;gt;  [p q]&amp;lt;br&amp;gt;  (or (not p) q))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">implies</a>[p q]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;in&lt;/b&gt; ([e &amp; args])&lt;br&gt; Takes an item and determines if it falls in the listed args.  This can be&lt;br&gt;   used most effectively for numbers since any numbers in a vector represent&lt;br&gt;   a range of values determined by the same arguments as given to `range`.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn in&amp;lt;br&amp;gt;  &amp;quot;Takes an item and determines if it falls in the listed args.  This can be&amp;lt;br&amp;gt;   used most effectively for numbers since any numbers in a vector represent&amp;lt;br&amp;gt;   a range of values determined by the same arguments as given to `range`.&amp;quot;&amp;lt;br&amp;gt;  [e &amp;amp; args]&amp;lt;br&amp;gt;  (boolean&amp;lt;br&amp;gt;   (some #{e}&amp;lt;br&amp;gt;         (mapcat #(if (vector? %)&amp;lt;br&amp;gt;                    (apply range %)&amp;lt;br&amp;gt;                    [%])&amp;lt;br&amp;gt;                 args))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">in</a>[e & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;not=&lt;/b&gt; ([l__3571__auto__] [l__3571__auto__ r__3572__auto__])&lt;br&gt; Curried version of #'clojure.core/not=&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcurry-from clojure.core&amp;lt;br&amp;gt;  == = not=)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">not=</a>[l__3571__auto__] [l__3571__auto__ r__3572__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;whitelist&lt;/b&gt; ([wl things])&lt;br&gt; Takes a thing with keys (i.e. maps or sets) and checks if it contains only&lt;br&gt;   the keys listed in the given whitelist.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn whitelist&amp;lt;br&amp;gt;  &amp;quot;Takes a thing with keys (i.e. maps or sets) and checks if it contains only&amp;lt;br&amp;gt;   the keys listed in the given whitelist.&amp;quot;&amp;lt;br&amp;gt;  [wl things]&amp;lt;br&amp;gt;  (set/subset? (set (keys things))&amp;lt;br&amp;gt;               (set wl)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">whitelist</a>[wl things]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.constraints&lt;/i&gt;&lt;b&gt;xor&lt;/b&gt; ([p q])&lt;br&gt; Exclusive or&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn xor&amp;lt;br&amp;gt;  &amp;quot;Exclusive or&amp;quot;&amp;lt;br&amp;gt;  [p q]&amp;lt;br&amp;gt;    (not (&amp;lt;=&amp;gt; p q)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">xor</a>[p q]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.contracts.impl.funcify</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.funcify&lt;/i&gt;&lt;b&gt;funcify&lt;/b&gt; ([args cnstr])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn funcify&amp;lt;br&amp;gt;  [args cnstr]&amp;lt;br&amp;gt;  (vec (map #(funcify* % args) cnstr)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">funcify</a>[args cnstr]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.contracts.impl.transformers</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.transformers&lt;/i&gt;&lt;b&gt;-&gt;Hoc&lt;/b&gt; ([field desc])&lt;br&gt; Positional factory function for class clojure.core.contracts.impl.transformers.Hoc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Hoc [field desc])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Hoc</a>[field desc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.transformers&lt;/i&gt;&lt;b&gt;build-contract-fn-body&lt;/b&gt; ([name docstring raw-constraints])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn build-contract-fn-body&amp;lt;br&amp;gt;  [name docstring raw-constraints]&amp;lt;br&amp;gt;  (let [raw-cnstr   (partition 2 raw-constraints)&amp;lt;br&amp;gt;        cnstr-descrs (for [[a c] raw-cnstr]&amp;lt;br&amp;gt;                       (build-constraints-description a c docstring))] ;; needs work&amp;lt;br&amp;gt;    (-&amp;gt;&amp;gt; cnstr-descrs&amp;lt;br&amp;gt;         build-contract-bodies&amp;lt;br&amp;gt;         (list* `fn name))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">build-contract-fn-body</a>[name docstring raw-constraints]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.transformers&lt;/i&gt;&lt;b&gt;map-&gt;Hoc&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.core.contracts.impl.transformers.Hoc, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Hoc [field desc])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Hoc</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.transformers&lt;/i&gt;&lt;b&gt;prepare-args&lt;/b&gt; ([args hocs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn prepare-args [args hocs]&amp;lt;br&amp;gt;  (let [vargs? #{'&amp;amp;}&amp;lt;br&amp;gt;        has-vargs (boolean (some vargs? args))]&amp;lt;br&amp;gt;    (with-meta &amp;lt;br&amp;gt;      (vec&amp;lt;br&amp;gt;       (map (fn [arg]&amp;lt;br&amp;gt;              (if-let [hoc (get hocs arg)]&amp;lt;br&amp;gt;                (list `partial (list* `fn (build-contract-body (:desc hoc))) arg)&amp;lt;br&amp;gt;                (if (map? arg)&amp;lt;br&amp;gt;                  (:as arg)&amp;lt;br&amp;gt;                  arg)))&amp;lt;br&amp;gt;            (-&amp;gt;&amp;gt; args (remove vargs?))))&amp;lt;br&amp;gt;      {::vargs has-vargs})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">prepare-args</a>[args hocs]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.contracts.impl.utils</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.utils&lt;/i&gt;&lt;b&gt;assert-w-message&lt;/b&gt; ([check message])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro assert-w-message&amp;lt;br&amp;gt;  [check message]&amp;lt;br&amp;gt;  `(when-not ~check&amp;lt;br&amp;gt;     (throw (new AssertionError (str &amp;quot;Assertion failure: &amp;quot; ~message &amp;quot;\n&amp;quot;&amp;lt;br&amp;gt;                                     (pr-str '~check))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">assert-w-message</a>[check message]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.utils&lt;/i&gt;&lt;b&gt;check-args!&lt;/b&gt; ([name slots inv-description invariants])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-args!&amp;lt;br&amp;gt;  [name slots inv-description invariants]&amp;lt;br&amp;gt;  (assert-w-message (and inv-description (string? inv-description))&amp;lt;br&amp;gt;                    (str &amp;quot;Expecting an invariant description for &amp;quot; name))&amp;lt;br&amp;gt;  (assert-w-message (and invariants (or (map? invariants) (vector? invariants)))&amp;lt;br&amp;gt;                    (str &amp;quot;Expecting invariants of the form &amp;quot;&amp;lt;br&amp;gt;                         &amp;quot;[pre-conditions =&amp;gt; post-conditions] or &amp;quot;&amp;lt;br&amp;gt;                         &amp;quot;{:pre [pre-conditions]}&amp;quot;&amp;lt;br&amp;gt;                         &amp;quot;for record type &amp;quot; name)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-args!</a>[name slots inv-description invariants]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.utils&lt;/i&gt;&lt;b&gt;constraint?&lt;/b&gt; ([sym])&lt;br&gt; Determines if a symbol represents a&lt;br&gt;  core.contracts constraint.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn constraint?&amp;lt;br&amp;gt;  &amp;quot;Determines if a symbol represents a&amp;lt;br&amp;gt;  core.contracts constraint.&amp;quot;&amp;lt;br&amp;gt;  [sym]&amp;lt;br&amp;gt;  (-&amp;gt; sym&amp;lt;br&amp;gt;      resolve&amp;lt;br&amp;gt;      meta&amp;lt;br&amp;gt;      :clojure.core.contracts/original&amp;lt;br&amp;gt;      boolean))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">constraint?</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.utils&lt;/i&gt;&lt;b&gt;defcurried&lt;/b&gt; ([name doc meta args &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Builds another arity of the fn that returns a fn awaiting the last&lt;br&gt;  param&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defcurried&amp;lt;br&amp;gt;  &amp;quot;Builds another arity of the fn that returns a fn awaiting the last&amp;lt;br&amp;gt;  param&amp;quot;&amp;lt;br&amp;gt;  [name doc meta args &amp;amp; body]&amp;lt;br&amp;gt;  (do-curried name doc meta args body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defcurried</a>[name doc meta args & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.utils&lt;/i&gt;&lt;b&gt;defcurry-from&lt;/b&gt; ([namespace &amp; names])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Builds a pass-through curried fn for each name.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defcurry-from&amp;lt;br&amp;gt;  &amp;quot;Builds a pass-through curried fn for each name.&amp;quot;&amp;lt;br&amp;gt;  [namespace &amp;amp; names]&amp;lt;br&amp;gt;  (-&amp;gt;&amp;gt; (for [n names]&amp;lt;br&amp;gt;         (let [v (ns-resolve namespace n)]&amp;lt;br&amp;gt;           `(defcurried ~n&amp;lt;br&amp;gt;              ~(str &amp;quot;Curried version of &amp;quot; v)&amp;lt;br&amp;gt;              {:clojure.core.contracts/original ~v}&amp;lt;br&amp;gt;              [l# r#]&amp;lt;br&amp;gt;              (~v l# r#))))&amp;lt;br&amp;gt;       (cons `do)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defcurry-from</a>[namespace & names]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.utils&lt;/i&gt;&lt;b&gt;do-curried&lt;/b&gt; ([name doc meta args body])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn do-curried&amp;lt;br&amp;gt;  [name doc meta args body]&amp;lt;br&amp;gt;  (let [cargs (vec (butlast args))]&amp;lt;br&amp;gt;    `(defn ~name ~doc ~meta&amp;lt;br&amp;gt;       (~cargs (fn [x#] (~name ~@cargs x#)))&amp;lt;br&amp;gt;       (~args ~@body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">do-curried</a>[name doc meta args body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.utils&lt;/i&gt;&lt;b&gt;keys-apply&lt;/b&gt; ([f ks m])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn keys-apply [f ks m]&amp;lt;br&amp;gt;  (let [only (select-keys m ks)]&amp;lt;br&amp;gt;    (zipmap (keys only) (map f (vals only)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">keys-apply</a>[f ks m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.contracts.impl.utils&lt;/i&gt;&lt;b&gt;manip-map&lt;/b&gt; ([f ks m])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn manip-map [f ks m]&amp;lt;br&amp;gt;  (conj m (keys-apply f ks m)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">manip-map</a>[f ks m]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.incubator</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.incubator&lt;/i&gt;&lt;b&gt;-?&gt;&lt;/b&gt; ([x form] [x form &amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Same as clojure.core/-&gt; but returns nil as soon as the threaded value is nil itself (thus short-circuiting any pending computation).&lt;br&gt;   Examples :&lt;br&gt;   (-?&gt; &quot;foo&quot; .toUpperCase (.substring 1)) returns &quot;OO&quot;&lt;br&gt;   (-?&gt; nil .toUpperCase (.substring 1)) returns nil&lt;br&gt;   &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defnilsafe &amp;lt;br&amp;gt;  &amp;quot;Same as clojure.core/-&amp;gt; but returns nil as soon as the threaded value is nil itself (thus short-circuiting any pending computation).&amp;lt;br&amp;gt;   Examples :&amp;lt;br&amp;gt;   (-?&amp;gt; \&amp;quot;foo\&amp;quot; .toUpperCase (.substring 1)) returns \&amp;quot;OO\&amp;quot;&amp;lt;br&amp;gt;   (-?&amp;gt; nil .toUpperCase (.substring 1)) returns nil&amp;lt;br&amp;gt;   &amp;quot;&amp;lt;br&amp;gt;   -&amp;gt; -?&amp;gt;)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-?></a>[x form] [x form & forms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.incubator&lt;/i&gt;&lt;b&gt;-?&gt;&gt;&lt;/b&gt; ([x form] [x form &amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Same as clojure.core/-&gt;&gt; but returns nil as soon as the threaded value is nil itself (thus short-circuiting any pending computation).&lt;br&gt;   Examples :&lt;br&gt;   (-?&gt;&gt; (range 5) (map inc)) returns (1 2 3 4 5)&lt;br&gt;   (-?&gt;&gt; [] seq (map inc)) returns nil&lt;br&gt;   &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defnilsafe&amp;lt;br&amp;gt;  &amp;quot;Same as clojure.core/-&amp;gt;&amp;gt; but returns nil as soon as the threaded value is nil itself (thus short-circuiting any pending computation).&amp;lt;br&amp;gt;   Examples :&amp;lt;br&amp;gt;   (-?&amp;gt;&amp;gt; (range 5) (map inc)) returns (1 2 3 4 5)&amp;lt;br&amp;gt;   (-?&amp;gt;&amp;gt; [] seq (map inc)) returns nil&amp;lt;br&amp;gt;   &amp;quot;&amp;lt;br&amp;gt;  -&amp;gt;&amp;gt; -?&amp;gt;&amp;gt;)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-?>></a>[x form] [x form & forms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.incubator&lt;/i&gt;&lt;b&gt;.?.&lt;/b&gt; ([x form] [x form &amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Same as clojure.core/.. but returns nil as soon as the threaded value is nil itself (thus short-circuiting any pending computation).&lt;br&gt;   Examples :&lt;br&gt;   (.?. &quot;foo&quot; .toUpperCase (.substring 1)) returns &quot;OO&quot;&lt;br&gt;   (.?. nil .toUpperCase (.substring 1)) returns nil&lt;br&gt;   &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defnilsafe &amp;lt;br&amp;gt;  &amp;quot;Same as clojure.core/.. but returns nil as soon as the threaded value is nil itself (thus short-circuiting any pending computation).&amp;lt;br&amp;gt;   Examples :&amp;lt;br&amp;gt;   (.?. \&amp;quot;foo\&amp;quot; .toUpperCase (.substring 1)) returns \&amp;quot;OO\&amp;quot;&amp;lt;br&amp;gt;   (.?. nil .toUpperCase (.substring 1)) returns nil&amp;lt;br&amp;gt;   &amp;quot;&amp;lt;br&amp;gt;   .. .?.)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">.?.</a>[x form] [x form & forms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.incubator&lt;/i&gt;&lt;b&gt;defmacro-&lt;/b&gt; ([name &amp; decls])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Same as defmacro but yields a private definition&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defmacro-&amp;lt;br&amp;gt;  &amp;quot;Same as defmacro but yields a private definition&amp;quot;&amp;lt;br&amp;gt;  [name &amp;amp; decls]&amp;lt;br&amp;gt;  (list* `defmacro (with-meta name (assoc (meta name) :private true)) decls))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defmacro-</a>[name & decls]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.incubator&lt;/i&gt;&lt;b&gt;dissoc-in&lt;/b&gt; ([m [k &amp; ks :as keys]])&lt;br&gt; Dissociates an entry from a nested associative structure returning a new&lt;br&gt;  nested structure. keys is a sequence of keys. Any empty maps that result&lt;br&gt;  will not be present in the new structure.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dissoc-in&amp;lt;br&amp;gt;  &amp;quot;Dissociates an entry from a nested associative structure returning a new&amp;lt;br&amp;gt;  nested structure. keys is a sequence of keys. Any empty maps that result&amp;lt;br&amp;gt;  will not be present in the new structure.&amp;quot;&amp;lt;br&amp;gt;  [m [k &amp;amp; ks :as keys]]&amp;lt;br&amp;gt;  (if ks&amp;lt;br&amp;gt;    (if-let [nextmap (get m k)]&amp;lt;br&amp;gt;      (let [newmap (dissoc-in nextmap ks)]&amp;lt;br&amp;gt;        (if (seq newmap)&amp;lt;br&amp;gt;          (assoc m k newmap)&amp;lt;br&amp;gt;          (dissoc m k)))&amp;lt;br&amp;gt;      m)&amp;lt;br&amp;gt;    (dissoc m k)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dissoc-in</a>[m [k & ks :as keys]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.incubator&lt;/i&gt;&lt;b&gt;new-by-name&lt;/b&gt; ([class-name &amp; args])&lt;br&gt; Constructs a Java object whose class is specified by a String.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn new-by-name&amp;lt;br&amp;gt;  &amp;quot;Constructs a Java object whose class is specified by a String.&amp;quot;&amp;lt;br&amp;gt;  [class-name &amp;amp; args]&amp;lt;br&amp;gt;  (clojure.lang.Reflector/invokeConstructor&amp;lt;br&amp;gt;   (clojure.lang.RT/classForName class-name)&amp;lt;br&amp;gt;   (into-array Object args)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">new-by-name</a>[class-name & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.incubator&lt;/i&gt;&lt;b&gt;seqable?&lt;/b&gt; ([x])&lt;br&gt; Returns true if (seq x) will succeed, false otherwise.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn seqable?&amp;lt;br&amp;gt;  &amp;quot;Returns true if (seq x) will succeed, false otherwise.&amp;quot;&amp;lt;br&amp;gt;  [x]&amp;lt;br&amp;gt;  (or (seq? x)&amp;lt;br&amp;gt;      (instance? clojure.lang.Seqable x)&amp;lt;br&amp;gt;      (nil? x)&amp;lt;br&amp;gt;      (instance? Iterable x)&amp;lt;br&amp;gt;      (-&amp;gt; x .getClass .isArray)&amp;lt;br&amp;gt;      (string? x)&amp;lt;br&amp;gt;      (instance? java.util.Map x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">seqable?</a>[x]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.logic</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;!=&lt;/b&gt; ([u v])&lt;br&gt; Disequality constraint. Ensures that u and v will never&lt;br&gt;   unify. u and v can be complex terms.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn !=&amp;lt;br&amp;gt;  &amp;quot;Disequality constraint. Ensures that u and v will never&amp;lt;br&amp;gt;   unify. u and v can be complex terms.&amp;quot;&amp;lt;br&amp;gt;  [u v]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (let [cs (disunify a u v)]&amp;lt;br&amp;gt;      (if-not (nil? cs)&amp;lt;br&amp;gt;        (let [p (:prefixc cs)]&amp;lt;br&amp;gt;          (when-not (empty? p)&amp;lt;br&amp;gt;            (if  (some (fn [[u v]] (nil? (unify a u v))) p)&amp;lt;br&amp;gt;              a&amp;lt;br&amp;gt;              ((cgoal (!=c p)) a))))&amp;lt;br&amp;gt;        a))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">!=</a>[u v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;!=c&lt;/b&gt; ([p])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn !=c&amp;lt;br&amp;gt;  [p]&amp;lt;br&amp;gt;  (reify&amp;lt;br&amp;gt;    ITreeConstraint&amp;lt;br&amp;gt;    clojure.lang.IFn&amp;lt;br&amp;gt;    (invoke [this a]&amp;lt;br&amp;gt;      (let [p (loop [sp (seq p) p p]&amp;lt;br&amp;gt;                (if sp&amp;lt;br&amp;gt;                  (let [[x v] (first sp)&amp;lt;br&amp;gt;                        ;; TODO: this seems expensive to walk* both sides&amp;lt;br&amp;gt;                        ;; and run an equality test there must be a better&amp;lt;br&amp;gt;                        ;; way - David&amp;lt;br&amp;gt;                        xv (walk* a x)&amp;lt;br&amp;gt;                        vv (walk* a v)]&amp;lt;br&amp;gt;                    (cond&amp;lt;br&amp;gt;                      (= xv vv) (recur (next sp) (dissoc p x))&amp;lt;br&amp;gt;                      (nil? (unify a xv vv)) nil&amp;lt;br&amp;gt;                      :else (recur (next sp) (assoc (dissoc p x) xv vv))))&amp;lt;br&amp;gt;                  p))]&amp;lt;br&amp;gt;        (if p&amp;lt;br&amp;gt;          (when-not (empty? p)&amp;lt;br&amp;gt;            #_((normalize-store (with-prefix this p)) a)&amp;lt;br&amp;gt;            ((composeg*&amp;lt;br&amp;gt;              (remcg this)&amp;lt;br&amp;gt;              (cgoal (!=c p))) a))&amp;lt;br&amp;gt;          ((remcg this) a))))&amp;lt;br&amp;gt;    IPrefix&amp;lt;br&amp;gt;    (prefix [_] p)&amp;lt;br&amp;gt;    IWithPrefix&amp;lt;br&amp;gt;    (with-prefix [_ p] (!=c p))&amp;lt;br&amp;gt;    IReifiableConstraint&amp;lt;br&amp;gt;    (reifyc [this v r a]&amp;lt;br&amp;gt;      (let [p* (-reify a (map (fn [[lhs rhs]] `(~lhs ~rhs)) p) r)]&amp;lt;br&amp;gt;        (if (empty? p*)&amp;lt;br&amp;gt;          '()&amp;lt;br&amp;gt;          `(~'!= ~@p*))))&amp;lt;br&amp;gt;    IConstraintOp&amp;lt;br&amp;gt;    (rator [_] `!=)&amp;lt;br&amp;gt;    (rands [_] (seq (recover-vars p)))&amp;lt;br&amp;gt;    IRunnable&amp;lt;br&amp;gt;    (runnable? [this s]&amp;lt;br&amp;gt;      (some #(not= (walk s %) %) (recover-vars p)))&amp;lt;br&amp;gt;    IRelevant&amp;lt;br&amp;gt;    (-relevant? [this s]&amp;lt;br&amp;gt;      (not (empty? p)))&amp;lt;br&amp;gt;    IConstraintWatchedStores&amp;lt;br&amp;gt;    (watched-stores [this] #{::subst})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">!=c</a>[p]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-&gt;AnswerCache&lt;/b&gt; ([ansl anss _meta])&lt;br&gt; Positional factory function for class clojure.core.logic.AnswerCache.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype AnswerCache [ansl anss _meta]&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [this]&amp;lt;br&amp;gt;    (str &amp;quot;&amp;lt;answer-cache:&amp;quot; (pr-str ansl) &amp;quot;&amp;gt;&amp;quot;))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [_] _meta)&amp;lt;br&amp;gt;  (withMeta [_ new-meta]&amp;lt;br&amp;gt;    (AnswerCache. ansl anss new-meta))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.ILookup&amp;lt;br&amp;gt;  (valAt [this k]&amp;lt;br&amp;gt;    (.valAt this k nil))&amp;lt;br&amp;gt;  (valAt [this k not-found]&amp;lt;br&amp;gt;    (case k&amp;lt;br&amp;gt;      :ansl ansl&amp;lt;br&amp;gt;      :anss anss&amp;lt;br&amp;gt;      not-found))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IAnswerCache&amp;lt;br&amp;gt;  (-add [this x]&amp;lt;br&amp;gt;    (AnswerCache. (conj ansl x) (conj anss x) _meta))&amp;lt;br&amp;gt;  (-cached? [_ x]&amp;lt;br&amp;gt;    (let [^clojure.lang.IPersistentSet anss anss]&amp;lt;br&amp;gt;      (.contains anss x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->AnswerCache</a>[ansl anss _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-&gt;Choice&lt;/b&gt; ([a f])&lt;br&gt; Positional factory function for class clojure.core.logic.Choice.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype Choice [a f]&amp;lt;br&amp;gt;  clojure.lang.ILookup&amp;lt;br&amp;gt;  (valAt [this k]&amp;lt;br&amp;gt;    (.valAt this k nil))&amp;lt;br&amp;gt;  (valAt [this k not-found]&amp;lt;br&amp;gt;    (case k&amp;lt;br&amp;gt;      :a a&amp;lt;br&amp;gt;      not-found))&amp;lt;br&amp;gt;  IBind&amp;lt;br&amp;gt;  (bind [this g]&amp;lt;br&amp;gt;    (mplus (g a) (fn [] (bind f g))))&amp;lt;br&amp;gt;  IMPlus&amp;lt;br&amp;gt;  (mplus [this fp]&amp;lt;br&amp;gt;    (Choice. a (fn [] (mplus (fp) f))))&amp;lt;br&amp;gt;  ITake&amp;lt;br&amp;gt;  (take* [this]&amp;lt;br&amp;gt;    (lazy-seq (cons (first a) (lazy-seq (take* f))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Choice</a>[a f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-&gt;ConstraintStore&lt;/b&gt; ([km cm cid running])&lt;br&gt; Positional factory function for class clojure.core.logic.ConstraintStore.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype ConstraintStore [km cm cid running]&amp;lt;br&amp;gt;  clojure.lang.ILookup&amp;lt;br&amp;gt;  (valAt [this k]&amp;lt;br&amp;gt;    (.valAt this k nil))&amp;lt;br&amp;gt;  (valAt [this k not-found]&amp;lt;br&amp;gt;    (case k&amp;lt;br&amp;gt;      :km km&amp;lt;br&amp;gt;      :cm cm&amp;lt;br&amp;gt;      :cid cid&amp;lt;br&amp;gt;      :running running&amp;lt;br&amp;gt;      not-found))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IConstraintStore&amp;lt;br&amp;gt;  (addc [this a c]&amp;lt;br&amp;gt;    (let [vars (var-rands a c)&amp;lt;br&amp;gt;          c (with-id c cid)&amp;lt;br&amp;gt;          cs (reduce (fn [cs v] (add-var cs v c)) this vars)]&amp;lt;br&amp;gt;      (ConstraintStore. (:km cs) (:cm cs) (inc cid) running)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (updatec [this a c]&amp;lt;br&amp;gt;    (let [oc (cm (id c))&amp;lt;br&amp;gt;          nkm (if (instance? clojure.core.logic.protocols.IRelevantVar c)&amp;lt;br&amp;gt;                (reduce (fn [km x]&amp;lt;br&amp;gt;                          (if-not (-relevant-var? c x)&amp;lt;br&amp;gt;                            (dissoc km x)&amp;lt;br&amp;gt;                            km))&amp;lt;br&amp;gt;                        km (var-rands a oc))&amp;lt;br&amp;gt;                km)]&amp;lt;br&amp;gt;      (ConstraintStore. nkm (assoc cm (id c) c) cid running)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (remc [this a c]&amp;lt;br&amp;gt;    (let [vs (var-rands a c)&amp;lt;br&amp;gt;          ocid (id c)&amp;lt;br&amp;gt;          nkm (reduce (fn [km v]&amp;lt;br&amp;gt;                        (let [vcs (disj (get km v) ocid)]&amp;lt;br&amp;gt;                          (if (empty? vcs)&amp;lt;br&amp;gt;                            (dissoc km v)&amp;lt;br&amp;gt;                            (assoc km v vcs))))&amp;lt;br&amp;gt;                      km vs)&amp;lt;br&amp;gt;          ncm (dissoc cm ocid)]&amp;lt;br&amp;gt;      (ConstraintStore. nkm ncm cid running)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (runc [this c state]&amp;lt;br&amp;gt;    (if state&amp;lt;br&amp;gt;      (ConstraintStore. km cm cid (conj running (id c)))&amp;lt;br&amp;gt;      (ConstraintStore. km cm cid (disj running (id c)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (constraints-for [this a x ws]&amp;lt;br&amp;gt;    (when-let [ids (get km (root-var a x))]&amp;lt;br&amp;gt;      (filter #((watched-stores %) ws) (map cm (remove running ids)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (migrate [this x root]&amp;lt;br&amp;gt;    (let [xcs    (km x)&amp;lt;br&amp;gt;          rootcs (km root #{})&amp;lt;br&amp;gt;          nkm    (assoc (dissoc km x) root (into rootcs xcs))]&amp;lt;br&amp;gt;      (ConstraintStore. nkm cm cid running)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.Counted&amp;lt;br&amp;gt;  (count [this]&amp;lt;br&amp;gt;    (count cm)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->ConstraintStore</a>[km cm cid running]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-&gt;LCons&lt;/b&gt; ([a d cache meta])&lt;br&gt; Positional factory function for class clojure.core.logic.LCons.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype LCons [a d ^{:unsynchronized-mutable true :tag int} cache meta]&amp;lt;br&amp;gt;  ITreeTerm&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [this]&amp;lt;br&amp;gt;    meta)&amp;lt;br&amp;gt;  (withMeta [this new-meta]&amp;lt;br&amp;gt;    (LCons. a d cache new-meta))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  LConsSeq&amp;lt;br&amp;gt;  (lfirst [_] a)&amp;lt;br&amp;gt;  (lnext [_] d)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  LConsPrint&amp;lt;br&amp;gt;  (toShortString [this]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;     (.. this getClass (isInstance d)) (str a &amp;quot; &amp;quot; (toShortString d))&amp;lt;br&amp;gt;     :else (str a &amp;quot; . &amp;quot; d )))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [this] (cond&amp;lt;br&amp;gt;                    (.. this getClass (isInstance d))&amp;lt;br&amp;gt;                      (str &amp;quot;(&amp;quot; a &amp;quot; &amp;quot; (toShortString d) &amp;quot;)&amp;quot;)&amp;lt;br&amp;gt;                    :else (str &amp;quot;(&amp;quot; a &amp;quot; . &amp;quot; d &amp;quot;)&amp;quot;)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (equals [this o]&amp;lt;br&amp;gt;    (or (identical? this o)&amp;lt;br&amp;gt;        (and (.. this getClass (isInstance o))&amp;lt;br&amp;gt;             (loop [me this&amp;lt;br&amp;gt;                    you o]&amp;lt;br&amp;gt;               (cond&amp;lt;br&amp;gt;                (nil? me) (nil? you)&amp;lt;br&amp;gt;                (lvar? me) true&amp;lt;br&amp;gt;                (lvar? you) true&amp;lt;br&amp;gt;                (and (lcons? me) (lcons? you))&amp;lt;br&amp;gt;                  (let [mef  (lfirst me)&amp;lt;br&amp;gt;                        youf (lfirst you)]&amp;lt;br&amp;gt;                    (and (or (= mef youf)&amp;lt;br&amp;gt;                             (lvar? mef)&amp;lt;br&amp;gt;                             (lvar? youf))&amp;lt;br&amp;gt;                         (recur (lnext me) (lnext you))))&amp;lt;br&amp;gt;                :else (= me you))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (hashCode [this]&amp;lt;br&amp;gt;    (if (= cache -1)&amp;lt;br&amp;gt;      (do&amp;lt;br&amp;gt;        (set! cache (uai (umi (int 31) (clojure.lang.Util/hash d))&amp;lt;br&amp;gt;                         (clojure.lang.Util/hash a)))&amp;lt;br&amp;gt;        cache)&amp;lt;br&amp;gt;      cache))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IUnifyTerms&amp;lt;br&amp;gt;  (unify-terms [u v s]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (sequential? v)&amp;lt;br&amp;gt;      (loop [u u v v s s]&amp;lt;br&amp;gt;        (if (seq v)&amp;lt;br&amp;gt;          (if (lcons? u)&amp;lt;br&amp;gt;            (if-let [s (unify s (lfirst u) (first v))]&amp;lt;br&amp;gt;              (recur (lnext u) (next v) s)&amp;lt;br&amp;gt;              nil)&amp;lt;br&amp;gt;            (unify s u v))&amp;lt;br&amp;gt;          (if (lvar? u)&amp;lt;br&amp;gt;            (if-let [s (unify s u '())]&amp;lt;br&amp;gt;              s&amp;lt;br&amp;gt;              (unify s u nil))&amp;lt;br&amp;gt;            nil)))&amp;lt;br&amp;gt;      &amp;lt;br&amp;gt;      (lcons? v)&amp;lt;br&amp;gt;      (loop [u u v v s s]&amp;lt;br&amp;gt;        (if (lvar? u)&amp;lt;br&amp;gt;          (unify s u v)&amp;lt;br&amp;gt;          (cond&amp;lt;br&amp;gt;            (lvar? v) (unify s v u)&amp;lt;br&amp;gt;            (and (lcons? u) (lcons? v))&amp;lt;br&amp;gt;            (if-let [s (unify s (lfirst u) (lfirst v))]&amp;lt;br&amp;gt;              (recur (lnext u) (lnext v) s)&amp;lt;br&amp;gt;              nil)&amp;lt;br&amp;gt;            :else (unify s u v))))&amp;lt;br&amp;gt;      &amp;lt;br&amp;gt;      :else nil))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IReifyTerm&amp;lt;br&amp;gt;  (reify-term [v s]&amp;lt;br&amp;gt;    (loop [v v s s]&amp;lt;br&amp;gt;      (if (lcons? v)&amp;lt;br&amp;gt;        (recur (lnext v) (-reify* s (lfirst v)))&amp;lt;br&amp;gt;        (-reify* s v))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  ;; TODO: no way to make this non-stack consuming w/o a lot more thinking&amp;lt;br&amp;gt;  ;; we could use continuation passing style and trampoline&amp;lt;br&amp;gt;  IWalkTerm&amp;lt;br&amp;gt;  (walk-term [v f]&amp;lt;br&amp;gt;    (lcons (f (lfirst v))&amp;lt;br&amp;gt;           (f (lnext v))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IOccursCheckTerm&amp;lt;br&amp;gt;  (occurs-check-term [v x s]&amp;lt;br&amp;gt;    (loop [v v x x s s]&amp;lt;br&amp;gt;      (if (lcons? v)&amp;lt;br&amp;gt;        (or (occurs-check s x (lfirst v))&amp;lt;br&amp;gt;            (recur (lnext v) x s))&amp;lt;br&amp;gt;        (occurs-check s x v))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IBuildTerm&amp;lt;br&amp;gt;  (build-term [u s]&amp;lt;br&amp;gt;    (loop [u u s s]&amp;lt;br&amp;gt;      (if (lcons? u)&amp;lt;br&amp;gt;        (recur (lnext u) (build s (lfirst u)))&amp;lt;br&amp;gt;        (build s u)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->LCons</a>[a d cache meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-&gt;LVar&lt;/b&gt; ([name oname hash meta])&lt;br&gt; Positional factory function for class clojure.core.logic.LVar.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype LVar [name oname hash meta]&amp;lt;br&amp;gt;  IVar&amp;lt;br&amp;gt;  clojure.lang.ILookup&amp;lt;br&amp;gt;  (valAt [this k]&amp;lt;br&amp;gt;    (.valAt this k nil))&amp;lt;br&amp;gt;  (valAt [this k not-found]&amp;lt;br&amp;gt;    (case k&amp;lt;br&amp;gt;      :name name&amp;lt;br&amp;gt;      :oname oname&amp;lt;br&amp;gt;      not-found))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [this]&amp;lt;br&amp;gt;    meta)&amp;lt;br&amp;gt;  (withMeta [this new-meta]&amp;lt;br&amp;gt;    (LVar. name oname hash new-meta))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_] (str &amp;quot;&amp;lt;lvar:&amp;quot; name &amp;quot;&amp;gt;&amp;quot;))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (equals [this o]&amp;lt;br&amp;gt;    (and (instance? IVar o)&amp;lt;br&amp;gt;      (identical? name (:name o))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (hashCode [_] hash)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IUnifyTerms&amp;lt;br&amp;gt;  (unify-terms [u v s]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (lvar? v)&amp;lt;br&amp;gt;      (let [repoint (cond&amp;lt;br&amp;gt;                      (-&amp;gt; u clojure.core/meta ::unbound) [u v]&amp;lt;br&amp;gt;                      (-&amp;gt; v clojure.core/meta ::unbound) [v u]&amp;lt;br&amp;gt;                      :else nil)]&amp;lt;br&amp;gt;        (if repoint&amp;lt;br&amp;gt;          (let [[root other] repoint&amp;lt;br&amp;gt;                s (assoc s :cs (migrate (:cs s) other root))&amp;lt;br&amp;gt;                s (if (-&amp;gt; other clojure.core/meta ::unbound)&amp;lt;br&amp;gt;                    (merge-with-root s other root)&amp;lt;br&amp;gt;                    s)]&amp;lt;br&amp;gt;            (when s&amp;lt;br&amp;gt;              (ext-no-check s other root)))&amp;lt;br&amp;gt;          (ext-no-check s u v)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (non-storable? v)&amp;lt;br&amp;gt;      (throw (Exception. (str v &amp;quot; is non-storable&amp;quot;)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (not= v ::not-found)&amp;lt;br&amp;gt;      (if (tree-term? v)&amp;lt;br&amp;gt;        (ext s u v)&amp;lt;br&amp;gt;        (if (-&amp;gt; u clojure.core/meta ::unbound)&amp;lt;br&amp;gt;          (ext-no-check s u (assoc (root-val s u) :v v))&amp;lt;br&amp;gt;          (ext-no-check s u v)))&amp;lt;br&amp;gt;      &amp;lt;br&amp;gt;      :else nil))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IReifyTerm&amp;lt;br&amp;gt;  (reify-term [v s]&amp;lt;br&amp;gt;    (let [rf (-&amp;gt; s clojure.core/meta :reify-vars)]&amp;lt;br&amp;gt;      (if (fn? rf)&amp;lt;br&amp;gt;        (rf v s)&amp;lt;br&amp;gt;        (if rf&amp;lt;br&amp;gt;          (ext s v (reify-lvar-name s))&amp;lt;br&amp;gt;          (ext s v (:oname v))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IWalkTerm&amp;lt;br&amp;gt;  (walk-term [v f] (f v))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IOccursCheckTerm&amp;lt;br&amp;gt;  (occurs-check-term [v x s] (= (walk s v) x))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IBuildTerm&amp;lt;br&amp;gt;  (build-term [u s]&amp;lt;br&amp;gt;    (let [m (:s s)&amp;lt;br&amp;gt;          cs (:cs s)&amp;lt;br&amp;gt;          lv (lvar 'ignore) ]&amp;lt;br&amp;gt;      (if (contains? m u)&amp;lt;br&amp;gt;        s&amp;lt;br&amp;gt;        (make-s (assoc m u lv) cs)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->LVar</a>[name oname hash meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-&gt;PMap&lt;/b&gt; ([])&lt;br&gt; Positional factory function for class clojure.core.logic.PMap.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord PMap []&amp;lt;br&amp;gt;  INonStorable&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IUnifyTerms&amp;lt;br&amp;gt;  (unify-terms [u v s]&amp;lt;br&amp;gt;    (if (map? v)&amp;lt;br&amp;gt;      (unify-with-pmap* u v s)&amp;lt;br&amp;gt;      nil))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IUnifyWithRecord&amp;lt;br&amp;gt;  (unify-with-record [u v s]&amp;lt;br&amp;gt;    (if (map? v)&amp;lt;br&amp;gt;      (unify-with-pmap* u v s)&amp;lt;br&amp;gt;      nil))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IUninitialized&amp;lt;br&amp;gt;  (-uninitialized [_] (PMap.)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->PMap</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-&gt;Pair&lt;/b&gt; ([lhs rhs])&lt;br&gt; Positional factory function for class clojure.core.logic.Pair.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype Pair [lhs rhs]&amp;lt;br&amp;gt;  clojure.lang.ILookup&amp;lt;br&amp;gt;  (valAt [this k]&amp;lt;br&amp;gt;    (.valAt this k nil))&amp;lt;br&amp;gt;  (valAt [this k not-found]&amp;lt;br&amp;gt;    (case k&amp;lt;br&amp;gt;      :lhs lhs&amp;lt;br&amp;gt;      :rhs rhs&amp;lt;br&amp;gt;      not-found))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.Counted&amp;lt;br&amp;gt;  (count [_] 2)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.Indexed&amp;lt;br&amp;gt;  (nth [_ i] (case i&amp;lt;br&amp;gt;                   0 lhs&amp;lt;br&amp;gt;                   1 rhs&amp;lt;br&amp;gt;                   (throw (IndexOutOfBoundsException.))))&amp;lt;br&amp;gt;  (nth [_ i not-found] (case i&amp;lt;br&amp;gt;                             0 lhs&amp;lt;br&amp;gt;                             1 rhs&amp;lt;br&amp;gt;                             not-found))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  java.util.Map$Entry&amp;lt;br&amp;gt;  (getKey [_] lhs)&amp;lt;br&amp;gt;  (getValue [_] rhs)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (str &amp;quot;(&amp;quot; lhs &amp;quot; . &amp;quot; rhs &amp;quot;)&amp;quot;))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (equals [_ o]&amp;lt;br&amp;gt;    (if (instance? Pair o)&amp;lt;br&amp;gt;      (and (= lhs (:lhs o))&amp;lt;br&amp;gt;           (= rhs (:rhs o)))&amp;lt;br&amp;gt;      false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Pair</a>[lhs rhs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-&gt;Rel&lt;/b&gt; ([name indexes meta f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 &amp; overage])&lt;br&gt; Positional factory function for class clojure.core.logic.Rel.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(RelHelper 20)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Rel</a>[name indexes meta f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 & overage]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-&gt;SubstValue&lt;/b&gt; ([v doms eset])&lt;br&gt; Positional factory function for class clojure.core.logic.SubstValue.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord SubstValue [v doms eset]&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (str v)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->SubstValue</a>[v doms eset]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-&gt;Substitutions&lt;/b&gt; ([s vs ts cs cq cqs oc _meta])&lt;br&gt; Positional factory function for class clojure.core.logic.Substitutions.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype Substitutions [s vs ts cs cq cqs oc _meta]&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (equals [this o]&amp;lt;br&amp;gt;    (or (identical? this o)&amp;lt;br&amp;gt;        (and (.. this getClass (isInstance o))&amp;lt;br&amp;gt;             (= s (:s o)))))&amp;lt;br&amp;gt;  ;; TODO: prn doesn't work anymore on empty-s, why not?&amp;lt;br&amp;gt;  (toString [_] (str s))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.Counted&amp;lt;br&amp;gt;  (count [this] (count s))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [this] _meta)&amp;lt;br&amp;gt;  (withMeta [this new-meta]&amp;lt;br&amp;gt;    (Substitutions. s vs ts cs cq cqs oc new-meta))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.ILookup&amp;lt;br&amp;gt;  (valAt [this k]&amp;lt;br&amp;gt;    (.valAt this k nil))&amp;lt;br&amp;gt;  (valAt [this k not-found]&amp;lt;br&amp;gt;    (case k&amp;lt;br&amp;gt;      :s   s&amp;lt;br&amp;gt;      :vs  vs&amp;lt;br&amp;gt;      :ts  ts&amp;lt;br&amp;gt;      :cs  cs&amp;lt;br&amp;gt;      :cq  cq&amp;lt;br&amp;gt;      :cqs cqs&amp;lt;br&amp;gt;      :oc  oc&amp;lt;br&amp;gt;      not-found))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IPersistentCollection&amp;lt;br&amp;gt;  (cons [this [k v]]&amp;lt;br&amp;gt;    (if (lvar? k)&amp;lt;br&amp;gt;      (assoc this k v)&amp;lt;br&amp;gt;      (throw (Exception. (str &amp;quot;key must be a logic var&amp;quot;)))))&amp;lt;br&amp;gt;  (empty [this] empty-s)&amp;lt;br&amp;gt;  (equiv [this o]&amp;lt;br&amp;gt;    (.equals this o))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.Associative&amp;lt;br&amp;gt;  (containsKey [this k]&amp;lt;br&amp;gt;    (contains? #{:s :vs :cs :cq :cqs :oc} k))&amp;lt;br&amp;gt;  (entryAt [this k]&amp;lt;br&amp;gt;    (case k&amp;lt;br&amp;gt;      :s   [:s s]&amp;lt;br&amp;gt;      :vs  [:vs vs]&amp;lt;br&amp;gt;      :ts  [:ts ts]&amp;lt;br&amp;gt;      :cs  [:cs cs]&amp;lt;br&amp;gt;      :cq  [:cq cq]&amp;lt;br&amp;gt;      :cqs [:cqs cqs]&amp;lt;br&amp;gt;      :oc  [:oc cqs]&amp;lt;br&amp;gt;      nil))&amp;lt;br&amp;gt;  (assoc [this k v]&amp;lt;br&amp;gt;    (case k&amp;lt;br&amp;gt;      :s   (Substitutions. v vs ts cs cq cqs oc _meta)&amp;lt;br&amp;gt;      :vs  (Substitutions. s  v ts cs cq cqs oc _meta)&amp;lt;br&amp;gt;      :ts  (Substitutions. s vs  v cs cq cqs oc _meta)&amp;lt;br&amp;gt;      :cs  (Substitutions. s vs ts  v cq cqs oc _meta)&amp;lt;br&amp;gt;      :cq  (Substitutions. s vs ts cs  v cqs oc _meta)&amp;lt;br&amp;gt;      :cqs (Substitutions. s vs ts cs cq   v oc _meta)&amp;lt;br&amp;gt;      :oc  (Substitutions. s vs ts cs cq cqs  v _meta)&amp;lt;br&amp;gt;      (throw (Exception. (str &amp;quot;Substitutions has no field for key&amp;quot; k)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  ISubstitutions&amp;lt;br&amp;gt;  (ext-no-check [this u v]&amp;lt;br&amp;gt;    (let [u (if-not (lvar? v)&amp;lt;br&amp;gt;              (assoc-meta u ::root true)&amp;lt;br&amp;gt;              u)]&amp;lt;br&amp;gt;      (Substitutions. (assoc s u v) (if vs (conj vs u)) ts cs cq cqs oc _meta)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (walk [this v]&amp;lt;br&amp;gt;    (if (bindable? v)&amp;lt;br&amp;gt;      (loop [lv v [v vp :as me] (find s v)]&amp;lt;br&amp;gt;        (cond&amp;lt;br&amp;gt;          (nil? me) lv&amp;lt;br&amp;gt;          &amp;lt;br&amp;gt;          (not (bindable? vp))&amp;lt;br&amp;gt;          (if (subst-val? vp)&amp;lt;br&amp;gt;            (let [sv (:v vp)]&amp;lt;br&amp;gt;              (if (= sv ::unbound)&amp;lt;br&amp;gt;                (with-meta v (assoc (meta vp) ::unbound true))&amp;lt;br&amp;gt;                sv))&amp;lt;br&amp;gt;            vp)&amp;lt;br&amp;gt;          &amp;lt;br&amp;gt;          :else (recur vp (find s vp))))&amp;lt;br&amp;gt;      v))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  ISubstitutionsCLP&amp;lt;br&amp;gt;  (root-val [this v]&amp;lt;br&amp;gt;    (if (lvar? v)&amp;lt;br&amp;gt;      (loop [lv v [v vp :as me] (find s v)]&amp;lt;br&amp;gt;        (cond&amp;lt;br&amp;gt;          (nil? me) lv&amp;lt;br&amp;gt;          (not (lvar? vp)) vp&amp;lt;br&amp;gt;          :else (recur vp (find s vp))))&amp;lt;br&amp;gt;      v))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (root-var [this v]&amp;lt;br&amp;gt;    (if (lvar? v)&amp;lt;br&amp;gt;      (if (-&amp;gt; v meta ::root)&amp;lt;br&amp;gt;        v&amp;lt;br&amp;gt;        (loop [lv v [v vp :as me] (find s v)]&amp;lt;br&amp;gt;          (cond&amp;lt;br&amp;gt;            (nil? me) lv&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;            (not (lvar? vp))&amp;lt;br&amp;gt;            (if (subst-val? vp)&amp;lt;br&amp;gt;              (with-meta v (meta vp))&amp;lt;br&amp;gt;              v)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;            :else (recur vp (find s vp)))))&amp;lt;br&amp;gt;      v))&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  (ext-run-cs [this x v]&amp;lt;br&amp;gt;    (let [x  (root-var this x)&amp;lt;br&amp;gt;          xs (if (lvar? v)&amp;lt;br&amp;gt;               [x (root-var this v)]&amp;lt;br&amp;gt;               [x])&amp;lt;br&amp;gt;          s  (if oc&amp;lt;br&amp;gt;               (ext this x v)&amp;lt;br&amp;gt;               (ext-no-check this x v))]&amp;lt;br&amp;gt;      (when s&amp;lt;br&amp;gt;        ((run-constraints* xs cs ::subst) s))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (queue [this c]&amp;lt;br&amp;gt;    (let [id (id c)]&amp;lt;br&amp;gt;      (if-not (cqs id)&amp;lt;br&amp;gt;        (-&amp;gt; this&amp;lt;br&amp;gt;          (assoc :cq (conj (or cq []) c))&amp;lt;br&amp;gt;          (assoc :cqs (conj cqs id)))&amp;lt;br&amp;gt;        this)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (update-var [this x v]&amp;lt;br&amp;gt;    (assoc this :s (assoc (:s this) x v)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IBind&amp;lt;br&amp;gt;  (bind [this g]&amp;lt;br&amp;gt;    (g this))&amp;lt;br&amp;gt;  IMPlus&amp;lt;br&amp;gt;  (mplus [this f]&amp;lt;br&amp;gt;    (choice this f))&amp;lt;br&amp;gt;  ITake&amp;lt;br&amp;gt;  (take* [this] this))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Substitutions</a>[s vs ts cs cq cqs oc _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-&gt;SuspendedStream&lt;/b&gt; ([cache ansv* f])&lt;br&gt; Positional factory function for class clojure.core.logic.SuspendedStream.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord SuspendedStream [cache ansv* f]&amp;lt;br&amp;gt;  ISuspendedStream&amp;lt;br&amp;gt;  (ready? [this]&amp;lt;br&amp;gt;    (not (identical? (:ansl @cache) ansv*))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->SuspendedStream</a>[cache ansv* f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-&gt;feature&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -&amp;gt;feature [x]&amp;lt;br&amp;gt;  (-feature&amp;lt;br&amp;gt;    (walk-term x&amp;lt;br&amp;gt;      (fn [y]&amp;lt;br&amp;gt;        (if (tree-term? y)&amp;lt;br&amp;gt;          (-&amp;gt;feature y)&amp;lt;br&amp;gt;          y)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->feature</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-featurec&lt;/b&gt; ([x fs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -featurec&amp;lt;br&amp;gt;  [x fs]&amp;lt;br&amp;gt;  (reify&amp;lt;br&amp;gt;    clojure.lang.IFn&amp;lt;br&amp;gt;    (invoke [this a]&amp;lt;br&amp;gt;      ((composeg&amp;lt;br&amp;gt;        (== fs x)&amp;lt;br&amp;gt;        (remcg this)) a))&amp;lt;br&amp;gt;    IConstraintOp&amp;lt;br&amp;gt;    (rator [_] `featurec)&amp;lt;br&amp;gt;    (rands [_] [x])&amp;lt;br&amp;gt;    IReifiableConstraint&amp;lt;br&amp;gt;    (reifyc [_ v r a]&amp;lt;br&amp;gt;      (let [fs (into {} fs)&amp;lt;br&amp;gt;            r  (-reify* r (walk* a fs))]&amp;lt;br&amp;gt;        `(featurec ~(walk* r x) ~(walk* r fs))))&amp;lt;br&amp;gt;    IRunnable&amp;lt;br&amp;gt;    (runnable? [_ a]&amp;lt;br&amp;gt;      (not (lvar? (walk a x))))&amp;lt;br&amp;gt;    IConstraintWatchedStores&amp;lt;br&amp;gt;    (watched-stores [this] #{::subst})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-featurec</a>[x fs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-fixc&lt;/b&gt; ([x f reifier] [x f runnable reifier])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -fixc&amp;lt;br&amp;gt;  ([x f reifier] (-fixc x f nil reifier))&amp;lt;br&amp;gt;  ([x f runnable reifier]&amp;lt;br&amp;gt;     (reify&amp;lt;br&amp;gt;       clojure.lang.IFn&amp;lt;br&amp;gt;       (invoke [this a]&amp;lt;br&amp;gt;         (let [x (walk a x)]&amp;lt;br&amp;gt;           ((composeg (f x a reifier) (remcg this)) a)))&amp;lt;br&amp;gt;       IConstraintOp&amp;lt;br&amp;gt;       (rator [_] `fixc)&amp;lt;br&amp;gt;       (rands [_] (if (vector? x) x [x]))&amp;lt;br&amp;gt;       IReifiableConstraint&amp;lt;br&amp;gt;       (reifyc [c v r a]&amp;lt;br&amp;gt;         (if (fn? reifier)&amp;lt;br&amp;gt;           (reifier c x v r a)&amp;lt;br&amp;gt;           (let [x (walk* r x)]&amp;lt;br&amp;gt;             `(fixc ~x ~reifier))))&amp;lt;br&amp;gt;       IRunnable&amp;lt;br&amp;gt;       (runnable? [_ a]&amp;lt;br&amp;gt;         (if (fn? runnable)&amp;lt;br&amp;gt;           (runnable x a)&amp;lt;br&amp;gt;           (not (lvar? (walk a x)))))&amp;lt;br&amp;gt;       IConstraintWatchedStores&amp;lt;br&amp;gt;       (watched-stores [this] #{::subst}))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-fixc</a>[x f reifier] [x f runnable reifier]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-inc&lt;/b&gt; ([&amp; rest])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro -inc [&amp;amp; rest]&amp;lt;br&amp;gt;  `(fn -inc [] ~@rest))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-inc</a>[& rest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-predc&lt;/b&gt; ([x p] [x p pform])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -predc&amp;lt;br&amp;gt;  ([x p] (-predc x p p))&amp;lt;br&amp;gt;  ([x p pform]&amp;lt;br&amp;gt;     (reify&amp;lt;br&amp;gt;       clojure.lang.IFn&amp;lt;br&amp;gt;       (invoke [this a]&amp;lt;br&amp;gt;         (let [x (walk a x)]&amp;lt;br&amp;gt;           (when (p x)&amp;lt;br&amp;gt;             ((remcg this) a))))&amp;lt;br&amp;gt;       IConstraintOp&amp;lt;br&amp;gt;       (rator [_] (if (seq? pform)&amp;lt;br&amp;gt;                    `(predc ~pform)&amp;lt;br&amp;gt;                    `predc))&amp;lt;br&amp;gt;       (rands [_] [x])&amp;lt;br&amp;gt;       IReifiableConstraint&amp;lt;br&amp;gt;       (reifyc [c v r a]&amp;lt;br&amp;gt;         (if (and (not= p pform) (fn? pform))&amp;lt;br&amp;gt;           (pform c v r a)&amp;lt;br&amp;gt;           pform))&amp;lt;br&amp;gt;       IRunnable&amp;lt;br&amp;gt;       (runnable? [_ a]&amp;lt;br&amp;gt;         (not (lvar? (walk a x))))&amp;lt;br&amp;gt;       IConstraintWatchedStores&amp;lt;br&amp;gt;       (watched-stores [this] #{::subst}))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-predc</a>[x p] [x p pform]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-reify&lt;/b&gt; ([s v] [s v r])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -reify&amp;lt;br&amp;gt;  ([s v]&amp;lt;br&amp;gt;     (let [v (walk* s v)]&amp;lt;br&amp;gt;       (walk* (-reify* (with-meta empty-s (meta s)) v) v)))&amp;lt;br&amp;gt;  ([s v r]&amp;lt;br&amp;gt;     (let [v (walk* s v)]&amp;lt;br&amp;gt;       (walk* (-reify* r v) v))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-reify</a>[s v] [s v r]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-reify*&lt;/b&gt; ([s v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -reify* [s v]&amp;lt;br&amp;gt;  (let [v (walk s v)]&amp;lt;br&amp;gt;    (reify-term v s)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-reify*</a>[s v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;-run&lt;/b&gt; ([opts [x :as bindings] &amp; goals])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro -run [opts [x :as bindings] &amp;amp; goals]&amp;lt;br&amp;gt;  (if (&amp;gt; (count bindings) 1)&amp;lt;br&amp;gt;    (let [[rbindings as-key [as]] (partition-by #{:as} bindings)]&amp;lt;br&amp;gt;      (if (seq as-key)&amp;lt;br&amp;gt;        `(-run ~opts [~as] (fresh [~@rbindings] (== ~as [~@rbindings]) ~@goals))&amp;lt;br&amp;gt;        `(-run ~opts [q#] (fresh ~bindings (== q# ~bindings) ~@goals))))&amp;lt;br&amp;gt;    `(let [opts# ~opts&amp;lt;br&amp;gt;           xs# (take* (fn []&amp;lt;br&amp;gt;                        ((fresh [~x]&amp;lt;br&amp;gt;                           ~@goals&amp;lt;br&amp;gt;                           (reifyg ~x))&amp;lt;br&amp;gt;                         (tabled-s (:occurs-check opts#)&amp;lt;br&amp;gt;                            (merge {:reify-vars true} opts#)))))]&amp;lt;br&amp;gt;       (if-let [n# (:n opts#)]&amp;lt;br&amp;gt;         (take n# xs#)&amp;lt;br&amp;gt;         xs#))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-run</a>[opts [x :as bindings] & goals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;==&lt;/b&gt; ([u v])&lt;br&gt; A goal that attempts to unify terms u and v.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ==&amp;lt;br&amp;gt;  &amp;quot;A goal that attempts to unify terms u and v.&amp;quot;&amp;lt;br&amp;gt;  [u v]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (let [has-cs? (pos? (count (:cs a)))]&amp;lt;br&amp;gt;      (let [ap (unify (if has-cs? (assoc a :vs []) a) u v)&amp;lt;br&amp;gt;            vs (if has-cs? (:vs ap))&amp;lt;br&amp;gt;            changed? (pos? (count vs))]&amp;lt;br&amp;gt;        (if changed?&amp;lt;br&amp;gt;          ((run-constraints* vs (:cs ap) ::subst) (assoc ap :vs nil))&amp;lt;br&amp;gt;          ap)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">==</a>[u v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;RelHelper&lt;/b&gt; ([arity])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro RelHelper [arity]&amp;lt;br&amp;gt;  (let [r (range 1 (+ arity 2))&amp;lt;br&amp;gt;        fs (map f-sym r)&amp;lt;br&amp;gt;        mfs (map #(with-meta % {:volatile-mutable true :tag clojure.lang.IFn})&amp;lt;br&amp;gt;                 fs)&amp;lt;br&amp;gt;        create-sig (fn [n]&amp;lt;br&amp;gt;                     (let [args (map a-sym (range 1 (clojure.core/inc n)))]&amp;lt;br&amp;gt;                       `(invoke [~'_ ~@args]&amp;lt;br&amp;gt;                                  (~(f-sym n) ~@args))))&amp;lt;br&amp;gt;        set-case (fn [[f arity]]&amp;lt;br&amp;gt;                   `(~arity (set! ~f ~'f)))]&amp;lt;br&amp;gt;    `(do&amp;lt;br&amp;gt;       (deftype ~'Rel [~'name ~'indexes ~'meta&amp;lt;br&amp;gt;                       ~@mfs]&amp;lt;br&amp;gt;         clojure.lang.IObj&amp;lt;br&amp;gt;         (~'withMeta [~'_ ~'meta]&amp;lt;br&amp;gt;           (~'Rel. ~'name ~'indexes ~'meta ~@fs))&amp;lt;br&amp;gt;         (~'meta [~'_]&amp;lt;br&amp;gt;           ~'meta)&amp;lt;br&amp;gt;         clojure.lang.IFn&amp;lt;br&amp;gt;         ~@(map create-sig r)&amp;lt;br&amp;gt;         (~'applyTo [~'this ~'arglist]&amp;lt;br&amp;gt;            (~'apply-to-helper ~'this ~'arglist))&amp;lt;br&amp;gt;         ~'IRel&amp;lt;br&amp;gt;         (~'setfn [~'_ ~'arity ~'f]&amp;lt;br&amp;gt;           (case ~'arity&amp;lt;br&amp;gt;                 ~@(mapcat set-case (map vector fs r))))&amp;lt;br&amp;gt;         (~'indexes-for [~'_ ~'arity]&amp;lt;br&amp;gt;           ((deref ~'indexes) ~'arity))&amp;lt;br&amp;gt;         (~'add-indexes [~'_ ~'arity ~'index]&amp;lt;br&amp;gt;           (swap! ~'indexes assoc ~'arity ~'index)))&amp;lt;br&amp;gt;       (defmacro ~'defrel &amp;lt;br&amp;gt;         &amp;quot;Define a relation for adding facts. Takes a name and some fields.&amp;lt;br&amp;gt;         Use fact/facts to add facts and invoke the relation to query it.&amp;quot;&amp;lt;br&amp;gt;         [~'name ~'&amp;amp; ~'rest]&amp;lt;br&amp;gt;         (defrel-helper ~'name ~arity ~'rest)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">RelHelper</a>[arity]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;add-attr&lt;/b&gt; ([s x attr attrv])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-attr [s x attr attrv]&amp;lt;br&amp;gt;  (let [x (root-var s x)&amp;lt;br&amp;gt;        v (root-val s x)]&amp;lt;br&amp;gt;    (if (subst-val? v)&amp;lt;br&amp;gt;      (update-var s x (assoc-meta v attr attrv))&amp;lt;br&amp;gt;      (let [v (if (lvar? v) ::unbound v)]&amp;lt;br&amp;gt;        (ext-no-check s x (with-meta (subst-val v) {attr attrv}))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-attr</a>[s x attr attrv]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;add-dom&lt;/b&gt; ([s x dom domv] [s x dom domv seenset])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-dom&amp;lt;br&amp;gt;  ([s x dom domv]&amp;lt;br&amp;gt;     (let [x (root-var s x)]&amp;lt;br&amp;gt;       (add-dom s x dom domv nil)))&amp;lt;br&amp;gt;  ([s x dom domv seenset]&amp;lt;br&amp;gt;     (let [v (root-val s x)&amp;lt;br&amp;gt;           s (if (subst-val? v)&amp;lt;br&amp;gt;               (update-var s x (assoc-dom v dom domv))&amp;lt;br&amp;gt;               (let [v (if (lvar? v) ::unbound v)]&amp;lt;br&amp;gt;                 (ext-no-check s x (subst-val v {dom domv}))))]&amp;lt;br&amp;gt;       (sync-eset s v seenset&amp;lt;br&amp;gt;         (fn [s y] (add-dom s y dom domv (conj (or seenset #{}) x)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-dom</a>[s x dom domv] [s x dom domv seenset]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;add-var&lt;/b&gt; ([cs x c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-var [cs x c]&amp;lt;br&amp;gt;  (when-not (lvar? x)&amp;lt;br&amp;gt;    (throw (Error. (str &amp;quot;constraint store assoc expected logic var key: &amp;quot; x))))&amp;lt;br&amp;gt;  (let [cm (:cm cs)&amp;lt;br&amp;gt;        km (:km cs)&amp;lt;br&amp;gt;        cid (:cid cs)&amp;lt;br&amp;gt;        nkm (update-in km [x] (fnil (fn [s] (conj s cid)) #{}))&amp;lt;br&amp;gt;        ncm (assoc cm cid c)]&amp;lt;br&amp;gt;    (ConstraintStore. nkm ncm cid (:running cs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-var</a>[cs x c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;addcg&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn addcg [c]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (let [a (reduce (fn [a x]&amp;lt;br&amp;gt;                      (ext-no-check a x (subst-val ::unbound)))&amp;lt;br&amp;gt;              a (unbound-rands a c))]&amp;lt;br&amp;gt;      (assoc a :cs (addc (:cs a) a c)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">addcg</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;all&lt;/b&gt; ([] [&amp; goals])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Like fresh but does does not create logic variables.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro all&amp;lt;br&amp;gt;  &amp;quot;Like fresh but does does not create logic variables.&amp;quot;&amp;lt;br&amp;gt;  ([] `clojure.core.logic/s#)&amp;lt;br&amp;gt;  ([&amp;amp; goals] `(fn [a#] (bind* a# ~@goals))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">all</a>[] [& goals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;annotate&lt;/b&gt; ([k v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn annotate [k v]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (vary-meta a assoc k v)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">annotate</a>[k v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;answer-cache&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn answer-cache [] (AnswerCache. () #{} nil))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">answer-cache</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;appendo&lt;/b&gt; ([x y z])&lt;br&gt; A relation where x, y, and z are proper collections, &lt;br&gt;  such that z is x appended to y&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defne appendo &amp;lt;br&amp;gt;  &amp;quot;A relation where x, y, and z are proper collections, &amp;lt;br&amp;gt;  such that z is x appended to y&amp;quot;&amp;lt;br&amp;gt;  [x y z]&amp;lt;br&amp;gt;  ([() _ y])&amp;lt;br&amp;gt;  ([[a . d] _ [a . r]] (appendo d y r)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">appendo</a>[x y z]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;apply-to-helper&lt;/b&gt; ([ifn arglist])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def-apply-to-helper 20)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">apply-to-helper</a>[ifn arglist]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;arity-exc-helper&lt;/b&gt; ([name n])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def-arity-exc-helper)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">arity-exc-helper</a>[name n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;assoc-dom&lt;/b&gt; ([x k v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn assoc-dom [x k v]&amp;lt;br&amp;gt;  (assoc x :doms (assoc (:doms x) k v)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">assoc-dom</a>[x k v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;assoc-meta&lt;/b&gt; ([x k v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn assoc-meta [x k v]&amp;lt;br&amp;gt;  (with-meta x (assoc (meta x) k v)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">assoc-meta</a>[x k v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;bind*&lt;/b&gt; ([a g] [a g &amp; g-rest])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro bind*&amp;lt;br&amp;gt;  ([a g] `(bind ~a ~g))&amp;lt;br&amp;gt;  ([a g &amp;amp; g-rest]&amp;lt;br&amp;gt;     `(bind* (bind ~a ~g) ~@g-rest)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bind*</a>[a g] [a g & g-rest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;bindable?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bindable? [x]&amp;lt;br&amp;gt;  (or (lvar? x)&amp;lt;br&amp;gt;    (instance? IBindable x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bindable?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;build&lt;/b&gt; ([s u])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn build [s u]&amp;lt;br&amp;gt;  (build-term u s))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">build</a>[s u]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;cgoal&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cgoal [c]&amp;lt;br&amp;gt;  (reify&amp;lt;br&amp;gt;    clojure.lang.IFn&amp;lt;br&amp;gt;    (invoke [_ a]&amp;lt;br&amp;gt;      (if (runnable? c a)&amp;lt;br&amp;gt;        (when-let [a (c a)]&amp;lt;br&amp;gt;          (if (and (irelevant? c) (relevant? c a))&amp;lt;br&amp;gt;            ((addcg c) a)&amp;lt;br&amp;gt;            a))&amp;lt;br&amp;gt;        ((addcg c) a)))&amp;lt;br&amp;gt;    IUnwrapConstraint&amp;lt;br&amp;gt;    (unwrap [_] c)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cgoal</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;choice&lt;/b&gt; ([a f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn choice [a f]&amp;lt;br&amp;gt;  (Choice. a f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">choice</a>[a f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;composeg&lt;/b&gt; ([] [g0 g1])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn composeg&amp;lt;br&amp;gt;  ([] identity)&amp;lt;br&amp;gt;  ([g0 g1]&amp;lt;br&amp;gt;     (fn [a]&amp;lt;br&amp;gt;       (let [a (g0 a)]&amp;lt;br&amp;gt;         (and a (g1 a))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">composeg</a>[] [g0 g1]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;composeg*&lt;/b&gt; ([g0] [g0 &amp; gs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro composeg*&amp;lt;br&amp;gt;  ([g0] g0)&amp;lt;br&amp;gt;  ([g0 &amp;amp; gs]&amp;lt;br&amp;gt;     `(composeg&amp;lt;br&amp;gt;       ~g0&amp;lt;br&amp;gt;       (composeg* ~@gs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">composeg*</a>[g0] [g0 & gs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;conda&lt;/b&gt; ([&amp; clauses])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Soft cut. Once the head of a clause has succeeded&lt;br&gt;  all other clauses will be ignored. Non-relational.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro conda&amp;lt;br&amp;gt;  &amp;quot;Soft cut. Once the head of a clause has succeeded&amp;lt;br&amp;gt;  all other clauses will be ignored. Non-relational.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; clauses]&amp;lt;br&amp;gt;  (let [a (gensym &amp;quot;a&amp;quot;)]&amp;lt;br&amp;gt;    `(fn [~a]&amp;lt;br&amp;gt;       (ifa* ~@(map (cond-clauses a) clauses)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">conda</a>[& clauses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;conde&lt;/b&gt; ([&amp; clauses])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Logical disjunction of the clauses. The first goal in&lt;br&gt;  a clause is considered the head of that clause. Interleaves the&lt;br&gt;  execution of the clauses.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro conde&amp;lt;br&amp;gt;  &amp;quot;Logical disjunction of the clauses. The first goal in&amp;lt;br&amp;gt;  a clause is considered the head of that clause. Interleaves the&amp;lt;br&amp;gt;  execution of the clauses.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; clauses]&amp;lt;br&amp;gt;  (let [a (gensym &amp;quot;a&amp;quot;)]&amp;lt;br&amp;gt;    `(fn [~a]&amp;lt;br&amp;gt;       (-inc&amp;lt;br&amp;gt;        (mplus* ~@(bind-conde-clauses a clauses))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">conde</a>[& clauses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;condu&lt;/b&gt; ([&amp; clauses])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Committed choice. Once the head (first goal) of a clause &lt;br&gt;  has succeeded, remaining goals of the clause will only&lt;br&gt;  be run once. Non-relational.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro condu&amp;lt;br&amp;gt;  &amp;quot;Committed choice. Once the head (first goal) of a clause &amp;lt;br&amp;gt;  has succeeded, remaining goals of the clause will only&amp;lt;br&amp;gt;  be run once. Non-relational.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; clauses]&amp;lt;br&amp;gt;  (let [a (gensym &amp;quot;a&amp;quot;)]&amp;lt;br&amp;gt;    `(fn [~a]&amp;lt;br&amp;gt;       (ifu* ~@(map (cond-clauses a) clauses)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">condu</a>[& clauses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;conso&lt;/b&gt; ([a d l])&lt;br&gt; A relation where l is a collection, such that a is the first of l &lt;br&gt;  and d is the rest of l&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn conso&amp;lt;br&amp;gt;  &amp;quot;A relation where l is a collection, such that a is the first of l &amp;lt;br&amp;gt;  and d is the rest of l&amp;quot;&amp;lt;br&amp;gt;  [a d l]&amp;lt;br&amp;gt;  (== (lcons a d) l))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">conso</a>[a d l]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;constrain-tree&lt;/b&gt; ([t fc])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn constrain-tree [t fc]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (-constrain-tree t fc a)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">constrain-tree</a>[t fc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;contains-lvar?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn contains-lvar? [x]&amp;lt;br&amp;gt;  (some lvar? (tree-seq coll? seq x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">contains-lvar?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;copy-term&lt;/b&gt; ([u v])&lt;br&gt; Copies a term u into v. Non-relational.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn copy-term&amp;lt;br&amp;gt;  &amp;quot;Copies a term u into v. Non-relational.&amp;quot;&amp;lt;br&amp;gt;  [u v]&amp;lt;br&amp;gt;  (project [u]&amp;lt;br&amp;gt;    (== (walk* (build empty-s u) u) v)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">copy-term</a>[u v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;def-apply-to-helper&lt;/b&gt; ([n])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro def-apply-to-helper [n]&amp;lt;br&amp;gt;  (let [r (range 1 (clojure.core/inc n))&amp;lt;br&amp;gt;        args (map a-sym r)&amp;lt;br&amp;gt;        arg-binds (fn [n]&amp;lt;br&amp;gt;                    (mapcat (fn [a]&amp;lt;br&amp;gt;                              `(~a (first ~'arglist)&amp;lt;br&amp;gt;                                   ~'arglist (next ~'arglist)))&amp;lt;br&amp;gt;                            (take n args)))&amp;lt;br&amp;gt;        case-clause (fn [n]&amp;lt;br&amp;gt;                      `(~n (let [~@(arg-binds (dec n))]&amp;lt;br&amp;gt;                            (.invoke ~'ifn ~@(take (dec n) args)&amp;lt;br&amp;gt;                                     (clojure.lang.Util/ret1&amp;lt;br&amp;gt;                                      (first ~'arglist) nil)))))]&amp;lt;br&amp;gt;   `(defn ~'apply-to-helper&amp;lt;br&amp;gt;      [~(with-meta 'ifn {:tag clojure.lang.IFn}) ~'arglist]&amp;lt;br&amp;gt;      (case (clojure.lang.RT/boundedLength ~'arglist 20)&amp;lt;br&amp;gt;            ~@(mapcat case-clause r)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">def-apply-to-helper</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;def-arity-exc-helper&lt;/b&gt; ([])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro def-arity-exc-helper []&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;    (Class/forName &amp;quot;clojure.lang.ArityException&amp;quot;)&amp;lt;br&amp;gt;    `(defn arity-exc-helper [~'name ~'n]&amp;lt;br&amp;gt;       (fn [~'&amp;amp; ~'args]&amp;lt;br&amp;gt;         (throw (clojure.lang.ArityException. ~'n (str ~'name)))))&amp;lt;br&amp;gt;    (catch java.lang.ClassNotFoundException e&amp;lt;br&amp;gt;     `(defn ~'arity-exc-helper [~'name ~'n]&amp;lt;br&amp;gt;        (fn [~'&amp;amp; ~'args]&amp;lt;br&amp;gt;          (throw&amp;lt;br&amp;gt;           (java.lang.IllegalArgumentException.&amp;lt;br&amp;gt;            (str &amp;quot;Wrong number of args (&amp;quot; ~'n &amp;quot;) passed to:&amp;quot; ~'name))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">def-arity-exc-helper</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;defna&lt;/b&gt; ([&amp; rest])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a soft cut goal. See conda.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defna&amp;lt;br&amp;gt;  &amp;quot;Define a soft cut goal. See conda.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; rest]&amp;lt;br&amp;gt;  `(defnm conda ~@rest))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defna</a>[& rest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;defnc&lt;/b&gt; ([name args &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defnc [name args &amp;amp; body]&amp;lt;br&amp;gt;  `(def ~name (fnc ~args ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defnc</a>[name args & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;defne&lt;/b&gt; ([&amp; rest])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a goal fn. Supports pattern matching. All&lt;br&gt;   patterns will be tried. See conde.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defne&amp;lt;br&amp;gt;  &amp;quot;Define a goal fn. Supports pattern matching. All&amp;lt;br&amp;gt;   patterns will be tried. See conde.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; rest]&amp;lt;br&amp;gt;  `(defnm conde ~@rest))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defne</a>[& rest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;defnm&lt;/b&gt; ([t n &amp; rest])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defnm [t n &amp;amp; rest]&amp;lt;br&amp;gt;  (let [[n [as &amp;amp; cs]] (name-with-attributes n rest)]&amp;lt;br&amp;gt;    (binding [*locals* (env-locals as (keys &amp;amp;env))]&amp;lt;br&amp;gt;     (if-let [tabled? (-&amp;gt; n meta :tabled)]&amp;lt;br&amp;gt;       `(def ~n (tabled [~@as] ~(handle-clauses t as cs)))&amp;lt;br&amp;gt;       `(defn ~n [~@as] ~(handle-clauses t as cs))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defnm</a>[t n & rest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;defnu&lt;/b&gt; ([&amp; rest])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a committed choice goal. See condu.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defnu&amp;lt;br&amp;gt;  &amp;quot;Define a committed choice goal. See condu.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; rest]&amp;lt;br&amp;gt;  `(defnm condu ~@rest))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defnu</a>[& rest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;defrel&lt;/b&gt; ([name &amp; rest])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a relation for adding facts. Takes a name and some fields.&lt;br&gt;         Use fact/facts to add facts and invoke the relation to query it.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(RelHelper 20)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defrel</a>[name & rest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;difference-with&lt;/b&gt; ([f &amp; maps])&lt;br&gt; Returns a map that consists of the first map with the rest of the maps&lt;br&gt;   removed from it. When a key is found in the first map and a later map,&lt;br&gt;   the value from the later map will be combined with the value in the first&lt;br&gt;   map by calling (f val-in-first val-in-later). If this function returns nil&lt;br&gt;   then the key will be removed completely.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn difference-with&amp;lt;br&amp;gt;  &amp;quot;Returns a map that consists of the first map with the rest of the maps&amp;lt;br&amp;gt;   removed from it. When a key is found in the first map and a later map,&amp;lt;br&amp;gt;   the value from the later map will be combined with the value in the first&amp;lt;br&amp;gt;   map by calling (f val-in-first val-in-later). If this function returns nil&amp;lt;br&amp;gt;   then the key will be removed completely.&amp;quot;&amp;lt;br&amp;gt;  [f &amp;amp; maps]&amp;lt;br&amp;gt;  (when (some identity maps)&amp;lt;br&amp;gt;    (let [empty-is-nil (fn [s] (if (empty? s) nil s))&amp;lt;br&amp;gt;          merge-entry (fn [m [k v]]&amp;lt;br&amp;gt;                         (if (contains? m k)&amp;lt;br&amp;gt;                           (if-let [nv (empty-is-nil (f (get m k) v))]&amp;lt;br&amp;gt;                             (assoc m k nv)&amp;lt;br&amp;gt;                             (dissoc m k))&amp;lt;br&amp;gt;                           m))&amp;lt;br&amp;gt;          merge-map (fn [m1 m2] (reduce merge-entry (or m1 {}) (seq m2)))]&amp;lt;br&amp;gt;      (reduce merge-map maps))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">difference-with</a>[f & maps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;dissoc-dom&lt;/b&gt; ([x k])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dissoc-dom [x k]&amp;lt;br&amp;gt;  (assoc x :doms (dissoc (:doms x) k)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dissoc-dom</a>[x k]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;dissoc-meta&lt;/b&gt; ([x k])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dissoc-meta [x k]&amp;lt;br&amp;gt;  (with-meta x (dissoc (meta x) k)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dissoc-meta</a>[x k]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;distincto&lt;/b&gt; ([l])&lt;br&gt; A relation which guarantees no element of l will unify&lt;br&gt;   with another element of l.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defne distincto&amp;lt;br&amp;gt;  &amp;quot;A relation which guarantees no element of l will unify&amp;lt;br&amp;gt;   with another element of l.&amp;quot;&amp;lt;br&amp;gt;  [l]&amp;lt;br&amp;gt;  ([()])&amp;lt;br&amp;gt;  ([[h]])&amp;lt;br&amp;gt;  ([[h0 h1 . t]]&amp;lt;br&amp;gt;     (!= h0 h1)&amp;lt;br&amp;gt;     (distincto (lcons h0 t))&amp;lt;br&amp;gt;     (distincto (lcons h1 t))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">distincto</a>[l]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;distribute&lt;/b&gt; ([v* strategy])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn distribute [v* strategy]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (add-attr a v* ::strategy ::ff)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">distribute</a>[v* strategy]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;disunify&lt;/b&gt; ([s u v] [s u v cs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn disunify&amp;lt;br&amp;gt;  ([s u v] (disunify s u v {:prefixc {}}))&amp;lt;br&amp;gt;  ([s u v cs]&amp;lt;br&amp;gt;     (if (identical? u v)&amp;lt;br&amp;gt;       cs&amp;lt;br&amp;gt;       (let [u (walk s u)&amp;lt;br&amp;gt;             v (walk s v)]&amp;lt;br&amp;gt;         (if (identical? u v)&amp;lt;br&amp;gt;           cs&amp;lt;br&amp;gt;           (if (and (not (lvar? u)) (lvar? v))&amp;lt;br&amp;gt;             (disunify-terms v u s cs)&amp;lt;br&amp;gt;             (disunify-terms u v s cs)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">disunify</a>[s u v] [s u v cs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;emptyo&lt;/b&gt; ([a])&lt;br&gt; A relation where a is the empty list&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emptyo&amp;lt;br&amp;gt;  &amp;quot;A relation where a is the empty list&amp;quot;&amp;lt;br&amp;gt;  [a]&amp;lt;br&amp;gt;  (== '() a))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emptyo</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;enforce-constraints&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn enforce-constraints [x]&amp;lt;br&amp;gt;  (all&amp;lt;br&amp;gt;   (force-ans x)&amp;lt;br&amp;gt;   (fn [a]&amp;lt;br&amp;gt;     (let [constrained (enforceable-constrained a)]&amp;lt;br&amp;gt;       (verify-all-bound a constrained)&amp;lt;br&amp;gt;       ((onceo (force-ans constrained)) a)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">enforce-constraints</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;enforceable-constrained&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn enforceable-constrained [a]&amp;lt;br&amp;gt;  (let [cs (:cs a)&amp;lt;br&amp;gt;        km (:km cs)&amp;lt;br&amp;gt;        cm (:cm cs)&amp;lt;br&amp;gt;        vs (keys km)]&amp;lt;br&amp;gt;    (filter (fn [v]&amp;lt;br&amp;gt;              (some (fn [cid]&amp;lt;br&amp;gt;                      (when-let [c (get cm cid)]&amp;lt;br&amp;gt;                        (enforceable? c)))&amp;lt;br&amp;gt;                    (get km v)))&amp;lt;br&amp;gt;            vs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">enforceable-constrained</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;entangle&lt;/b&gt; ([s x y])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn entangle [s x y]&amp;lt;br&amp;gt;  (let [x  (root-var s x)&amp;lt;br&amp;gt;        y  (root-var s y)&amp;lt;br&amp;gt;        xv (to-subst-val (root-val s x))&amp;lt;br&amp;gt;        yv (to-subst-val (root-val s y))]&amp;lt;br&amp;gt;    (-&amp;gt; s&amp;lt;br&amp;gt;      (update-var x (assoc xv :eset (conj (or (:eset xv) #{}) y)))&amp;lt;br&amp;gt;      (update-var y (assoc yv :eset (conj (or (:eset yv) #{}) x))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">entangle</a>[s x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;env-locals&lt;/b&gt; ([&amp; syms])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn env-locals [&amp;amp; syms]&amp;lt;br&amp;gt;  (disj (set (apply concat syms)) '_))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">env-locals</a>[& syms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;everyg&lt;/b&gt; ([g coll])&lt;br&gt; A pseudo-relation that takes a coll and ensures that the goal g&lt;br&gt;   succeeds on every element of the collection.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn everyg&amp;lt;br&amp;gt;  &amp;quot;A pseudo-relation that takes a coll and ensures that the goal g&amp;lt;br&amp;gt;   succeeds on every element of the collection.&amp;quot;&amp;lt;br&amp;gt;  [g coll]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (let [coll (walk a coll)]&amp;lt;br&amp;gt;      (((fn everyg* [g coll]&amp;lt;br&amp;gt;          (if (seq coll)&amp;lt;br&amp;gt;            (all&amp;lt;br&amp;gt;             (g (first coll))&amp;lt;br&amp;gt;             (everyg* g (next coll)))&amp;lt;br&amp;gt;            s#)) g coll) a))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">everyg</a>[g coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;ext&lt;/b&gt; ([s u v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ext [s u v]&amp;lt;br&amp;gt;  (if (and (:oc s) (occurs-check s u (if (subst-val? v) (:v v) v)))&amp;lt;br&amp;gt;    nil&amp;lt;br&amp;gt;    (ext-no-check s u v)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ext</a>[s u v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;ext-run-csg&lt;/b&gt; ([u v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ext-run-csg [u v]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (ext-run-cs a u v)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ext-run-csg</a>[u v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;extend-rel&lt;/b&gt; ([name &amp; args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro extend-rel [name &amp;amp; args]&amp;lt;br&amp;gt;  (let [arity (count args)&amp;lt;br&amp;gt;        r (range 1 (clojure.core/inc arity))&amp;lt;br&amp;gt;        as (map a-sym r)&amp;lt;br&amp;gt;        indexed (vec (filter (fn [[a i]]&amp;lt;br&amp;gt;                               (-&amp;gt; a meta :index))&amp;lt;br&amp;gt;                             (map vector&amp;lt;br&amp;gt;                                  args&amp;lt;br&amp;gt;                                  (range 1 (clojure.core/inc arity)))))&amp;lt;br&amp;gt;        check-lvar (fn [[o i]]&amp;lt;br&amp;gt;                     (let [a (a-sym i)]&amp;lt;br&amp;gt;                       `((not (clojure.core.logic/contains-lvar? (clojure.core.logic/walk* ~'a ~a)))&amp;lt;br&amp;gt;                         ((deref ~(index-sym name arity o)) (clojure.core.logic/walk* ~'a ~a)))))&amp;lt;br&amp;gt;        indexed-set (fn [[o i]]&amp;lt;br&amp;gt;                      `(def ~(index-sym name arity o) (atom {})))]&amp;lt;br&amp;gt;    (if (&amp;lt;= arity 20)&amp;lt;br&amp;gt;     `(do&amp;lt;br&amp;gt;        (def ~(set-sym name arity) (atom #{}))&amp;lt;br&amp;gt;        ~@(map indexed-set indexed)&amp;lt;br&amp;gt;        (add-indexes ~name ~arity '~indexed)&amp;lt;br&amp;gt;        (setfn ~name ~arity&amp;lt;br&amp;gt;               (fn [~@as]&amp;lt;br&amp;gt;                 (fn [~'a]&amp;lt;br&amp;gt;                   (let [set# (cond&amp;lt;br&amp;gt;                               ~@(mapcat check-lvar indexed)&amp;lt;br&amp;gt;                               :else (deref ~(set-sym name arity)))]&amp;lt;br&amp;gt;                     (to-stream&amp;lt;br&amp;gt;                      (-&amp;gt;&amp;gt; set#&amp;lt;br&amp;gt;                           (map (fn [cand#]&amp;lt;br&amp;gt;                                  (when-let [~'a (clojure.core.logic/unify ~'a [~@as] cand#)]&amp;lt;br&amp;gt;                                    ~'a)))))))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">extend-rel</a>[name & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;fact&lt;/b&gt; ([rel &amp; tuple])&lt;br&gt; Add a fact to a relation defined with defrel.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fact&amp;lt;br&amp;gt;  &amp;quot;Add a fact to a relation defined with defrel.&amp;quot;&amp;lt;br&amp;gt;  [rel &amp;amp; tuple]&amp;lt;br&amp;gt;  (facts rel [(vec tuple)]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fact</a>[rel & tuple]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;facts&lt;/b&gt; ([rel [f :as tuples]] [rel arity tuples])&lt;br&gt; Define a series of facts. Takes a vector of vectors where each vector&lt;br&gt;   represents a fact tuple, all with the same number of elements.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn facts&amp;lt;br&amp;gt;  &amp;quot;Define a series of facts. Takes a vector of vectors where each vector&amp;lt;br&amp;gt;   represents a fact tuple, all with the same number of elements.&amp;quot;&amp;lt;br&amp;gt;  ([rel [f :as tuples]] (facts rel (count f) tuples))&amp;lt;br&amp;gt;  ([^Rel rel arity tuples]&amp;lt;br&amp;gt;     (let [rel-ns (:ns (meta rel))&amp;lt;br&amp;gt;           rel-set (var-get (ns-resolve rel-ns (set-sym (.name rel) arity)))&amp;lt;br&amp;gt;           tuples (map vec tuples)]&amp;lt;br&amp;gt;       (swap! rel-set (fn [s] (into s tuples)))&amp;lt;br&amp;gt;       (let [indexes (indexes-for rel arity)]&amp;lt;br&amp;gt;         (doseq [[o i] indexes]&amp;lt;br&amp;gt;           (let [index (var-get (ns-resolve rel-ns (index-sym (.name rel) arity o)))]&amp;lt;br&amp;gt;             (let [indexed-tuples (map (fn [t]&amp;lt;br&amp;gt;                                         {(nth t (dec i)) #{t}})&amp;lt;br&amp;gt;                                       tuples)]&amp;lt;br&amp;gt;               (swap! index&amp;lt;br&amp;gt;                      (fn [i]&amp;lt;br&amp;gt;                        (apply merge-with set/union i indexed-tuples))))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">facts</a>[rel [f :as tuples]] [rel arity tuples]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;fail&lt;/b&gt; ([a])&lt;br&gt; A goal that always fails.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fail&amp;lt;br&amp;gt;  &amp;quot;A goal that always fails.&amp;quot;&amp;lt;br&amp;gt;  [a] nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fail</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;featurec&lt;/b&gt; ([x fs])&lt;br&gt; Ensure that a map contains at least the key-value pairs&lt;br&gt;  in the map fs. fs must be partially instantiated - that is, &lt;br&gt;  it may contain values which are logic variables to support &lt;br&gt;  feature extraction.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn featurec&amp;lt;br&amp;gt;  &amp;quot;Ensure that a map contains at least the key-value pairs&amp;lt;br&amp;gt;  in the map fs. fs must be partially instantiated - that is, &amp;lt;br&amp;gt;  it may contain values which are logic variables to support &amp;lt;br&amp;gt;  feature extraction.&amp;quot;&amp;lt;br&amp;gt;  [x fs]&amp;lt;br&amp;gt;  (cgoal (-featurec x (-&amp;gt;feature fs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">featurec</a>[x fs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;firsto&lt;/b&gt; ([l a])&lt;br&gt; A relation where l is a collection, such that a is the first of l&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn firsto&amp;lt;br&amp;gt;  &amp;quot;A relation where l is a collection, such that a is the first of l&amp;quot;&amp;lt;br&amp;gt;  [l a]&amp;lt;br&amp;gt;  (fresh [d]&amp;lt;br&amp;gt;    (conso a d l)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">firsto</a>[l a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;fix-constraints&lt;/b&gt; ([a])&lt;br&gt; A goal to run the constraints in cq until it is empty. Of&lt;br&gt;   course running a constraint may grow cq so this function&lt;br&gt;   finds the fixpoint.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fix-constraints&amp;lt;br&amp;gt;  &amp;quot;A goal to run the constraints in cq until it is empty. Of&amp;lt;br&amp;gt;   course running a constraint may grow cq so this function&amp;lt;br&amp;gt;   finds the fixpoint.&amp;quot;&amp;lt;br&amp;gt;  [a]&amp;lt;br&amp;gt;  (loop [a a]&amp;lt;br&amp;gt;    (when a&amp;lt;br&amp;gt;      (let [cq (:cq a)]&amp;lt;br&amp;gt;        (if (zero? (count cq))&amp;lt;br&amp;gt;          (assoc a :cq nil)&amp;lt;br&amp;gt;          (let [c (first cq)]&amp;lt;br&amp;gt;            (recur&amp;lt;br&amp;gt;              ((run-constraint c)&amp;lt;br&amp;gt;               (-&amp;gt; a&amp;lt;br&amp;gt;                 (assoc :cq (subvec (:cq a) 1))&amp;lt;br&amp;gt;                 (assoc :cqs (disj (:cqs a) (id c))))))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fix-constraints</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;fixc&lt;/b&gt; ([x f reifier] [x f runnable reifier])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fixc&amp;lt;br&amp;gt;  ([x f reifier] (fixc x f nil reifier))&amp;lt;br&amp;gt;  ([x f runnable reifier]&amp;lt;br&amp;gt;     (cgoal (-fixc x f runnable reifier))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fixc</a>[x f reifier] [x f runnable reifier]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;fnc&lt;/b&gt; ([args &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define an anonymous constraint that can be used with the unifier:&lt;br&gt;&lt;br&gt;     (let [oddc (fnc [x] (odd? x))]&lt;br&gt;&lt;br&gt;       (unifier {:a '?a} {:a 1} :when {'?a oddc})&lt;br&gt;         ;;=&gt; {:a 1}&lt;br&gt;&lt;br&gt;       (unifier {:a '?a} {:a 2} :when {'?a oddc})&lt;br&gt;         ;;=&gt; nil&lt;br&gt;     )&lt;br&gt;&lt;br&gt;  Note, the constraint will not run until all arguments are fully ground.&lt;br&gt;&lt;br&gt;  Use defnc to define a constraint and assign a toplevel var.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro fnc&amp;lt;br&amp;gt;  &amp;quot;Define an anonymous constraint that can be used with the unifier:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     (let [oddc (fnc [x] (odd? x))]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (unifier {:a '?a} {:a 1} :when {'?a oddc})&amp;lt;br&amp;gt;         ;;=&amp;gt; {:a 1}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (unifier {:a '?a} {:a 2} :when {'?a oddc})&amp;lt;br&amp;gt;         ;;=&amp;gt; nil&amp;lt;br&amp;gt;     )&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Note, the constraint will not run until all arguments are fully ground.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Use defnc to define a constraint and assign a toplevel var.&amp;quot;&amp;lt;br&amp;gt;  [args &amp;amp; body]&amp;lt;br&amp;gt;  (let [name (symbol (gensym &amp;quot;fnc&amp;quot;))]&amp;lt;br&amp;gt;    `(fn ~args&amp;lt;br&amp;gt;       (letfn [(~name [~@args]&amp;lt;br&amp;gt;                 (reify&amp;lt;br&amp;gt;                   ~'clojure.lang.IFn&amp;lt;br&amp;gt;                   (~'invoke [this# a#]&amp;lt;br&amp;gt;                     (let [[~@args :as args#] (map #(clojure.core.logic/walk* a# %) ~args)&amp;lt;br&amp;gt;                           test# (do ~@body)]&amp;lt;br&amp;gt;                       (when test#&amp;lt;br&amp;gt;                         ((clojure.core.logic/remcg this#) a#))))&amp;lt;br&amp;gt;                   clojure.core.logic.protocols/IConstraintOp&amp;lt;br&amp;gt;                   (~'rator [_#] '~name)&amp;lt;br&amp;gt;                   (~'rands [_#] (filter clojure.core.logic/lvar? (flatten ~args)))&amp;lt;br&amp;gt;                   clojure.core.logic.protocols/IReifiableConstraint&amp;lt;br&amp;gt;                   (~'reifyc [_# _# r# a#]&amp;lt;br&amp;gt;                     (list '~name (map #(clojure.core.logic/-reify r# %) ~args)))&amp;lt;br&amp;gt;                   clojure.core.logic.protocols/IRunnable&amp;lt;br&amp;gt;                   (~'runnable? [_# s#]&amp;lt;br&amp;gt;                     (clojure.core.logic/ground-term? ~args s#))&amp;lt;br&amp;gt;                   clojure.core.logic.protocols/IConstraintWatchedStores&amp;lt;br&amp;gt;                   (~'watched-stores [_#] #{:clojure.core.logic/subst})))]&amp;lt;br&amp;gt;         (cgoal (~name ~@args))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fnc</a>[args & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;force-ans&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn force-ans [x]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    ((let [v (walk a x)]&amp;lt;br&amp;gt;       (if (lvar? v)&amp;lt;br&amp;gt;         (-force-ans (get-dom-fd a x) v)&amp;lt;br&amp;gt;         (let [x (root-var a x)]&amp;lt;br&amp;gt;           (if (sequential? v)&amp;lt;br&amp;gt;             (-force-ans (sort-by-strategy v x a) x)&amp;lt;br&amp;gt;             (-force-ans v x))))) a)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">force-ans</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;fresh&lt;/b&gt; ([[&amp; lvars] &amp; goals])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Creates fresh variables. Goals occuring within form a logical &lt;br&gt;  conjunction.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro fresh&amp;lt;br&amp;gt;  &amp;quot;Creates fresh variables. Goals occuring within form a logical &amp;lt;br&amp;gt;  conjunction.&amp;quot;&amp;lt;br&amp;gt;  [[&amp;amp; lvars] &amp;amp; goals]&amp;lt;br&amp;gt;  `(fn [a#]&amp;lt;br&amp;gt;     (-inc&amp;lt;br&amp;gt;      (let [~@(lvar-binds lvars)]&amp;lt;br&amp;gt;        (bind* a# ~@goals)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fresh</a>[[& lvars] & goals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;get-attr&lt;/b&gt; ([s x attr])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-attr [s x attr]&amp;lt;br&amp;gt;  (let [v (root-val s x)]&amp;lt;br&amp;gt;    (if (subst-val? v)&amp;lt;br&amp;gt;      (-&amp;gt; v meta attr))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-attr</a>[s x attr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;get-dom&lt;/b&gt; ([s x dom])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-dom [s x dom]&amp;lt;br&amp;gt;  (let [v (root-val s x)]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (subst-val? v) (let [v' (:v v)]&amp;lt;br&amp;gt;                       (if (not= v' ::unbound)&amp;lt;br&amp;gt;                         v'&amp;lt;br&amp;gt;                         (-&amp;gt; v :doms dom)))&amp;lt;br&amp;gt;      (not (lvar? v)) v&amp;lt;br&amp;gt;      ;; :else ::no-dom ;; NOTE: this doesn't work, some assumptions about nil - David&amp;lt;br&amp;gt;      )))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-dom</a>[s x dom]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;get-dom-fd&lt;/b&gt; ([a x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-dom-fd&amp;lt;br&amp;gt;  [a x]&amp;lt;br&amp;gt;  (if (lvar? x)&amp;lt;br&amp;gt;    (get-dom a x ::fd)&amp;lt;br&amp;gt;    x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-dom-fd</a>[a x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;ground-term?&lt;/b&gt; ([x s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ground-term? [x s]&amp;lt;br&amp;gt;  (letfn [(-ground-term? [x s]&amp;lt;br&amp;gt;            (let [x (walk s x)]&amp;lt;br&amp;gt;              (if (lvar? x)&amp;lt;br&amp;gt;                (throw fk)&amp;lt;br&amp;gt;                (walk-term x&amp;lt;br&amp;gt;                  (fn [x]&amp;lt;br&amp;gt;                    (let [x (walk s x)]&amp;lt;br&amp;gt;                      (cond&amp;lt;br&amp;gt;                        (lvar? x) (throw fk)&amp;lt;br&amp;gt;                        (tree-term? x) (-ground-term? x s)&amp;lt;br&amp;gt;                        :else x)))))))]&amp;lt;br&amp;gt;    (try&amp;lt;br&amp;gt;      (-ground-term? x s)&amp;lt;br&amp;gt;      true&amp;lt;br&amp;gt;      (catch Exception e&amp;lt;br&amp;gt;        false))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ground-term?</a>[x s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;ifa*&lt;/b&gt; ([] [[e &amp; gs] &amp; grest])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ifa*&amp;lt;br&amp;gt;  ([])&amp;lt;br&amp;gt;  ([[e &amp;amp; gs] &amp;amp; grest]&amp;lt;br&amp;gt;     `(ifa ~e [~@gs]&amp;lt;br&amp;gt;           ~(if (seq grest)&amp;lt;br&amp;gt;              `(delay (ifa* ~@grest))&amp;lt;br&amp;gt;              nil))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ifa*</a>[] [[e & gs] & grest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;ifu*&lt;/b&gt; ([] [[e &amp; gs] &amp; grest])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ifu*&amp;lt;br&amp;gt;  ([])&amp;lt;br&amp;gt;  ([[e &amp;amp; gs] &amp;amp; grest]&amp;lt;br&amp;gt;     `(ifu ~e [~@gs]&amp;lt;br&amp;gt;           ~(if (seq grest)&amp;lt;br&amp;gt;              `(delay (ifu* ~@grest))&amp;lt;br&amp;gt;              nil))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ifu*</a>[] [[e & gs] & grest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;irelevant?&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn irelevant? [c]&amp;lt;br&amp;gt;  (instance? clojure.core.logic.protocols.IRelevant c))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">irelevant?</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;is&lt;/b&gt; ([u v op])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Set the value of a var to value of another var with the operation&lt;br&gt;   applied. Non-relational.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro is&amp;lt;br&amp;gt;  &amp;quot;Set the value of a var to value of another var with the operation&amp;lt;br&amp;gt;   applied. Non-relational.&amp;quot;&amp;lt;br&amp;gt;  [u v op]&amp;lt;br&amp;gt;  `(project [~v]&amp;lt;br&amp;gt;     (== ~u (~op ~v))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">is</a>[u v op]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;lcons&lt;/b&gt; ([a d])&lt;br&gt; Constructs a sequence a with an improper tail d if d is a logic variable.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lcons&amp;lt;br&amp;gt;  &amp;quot;Constructs a sequence a with an improper tail d if d is a logic variable.&amp;quot;&amp;lt;br&amp;gt;  [a d]&amp;lt;br&amp;gt;  (if (or (coll? d) (nil? d))&amp;lt;br&amp;gt;    (cons a (seq d))&amp;lt;br&amp;gt;    (LCons. a d -1 nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lcons</a>[a d]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;lcons?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lcons? [x]&amp;lt;br&amp;gt;  (instance? LCons x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lcons?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;let-dom&lt;/b&gt; ([a vars &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro let-dom&amp;lt;br&amp;gt;  [a vars &amp;amp; body]&amp;lt;br&amp;gt;  (let [get-var-dom (fn [a [v b]]&amp;lt;br&amp;gt;                      `(~b (get-dom-fd ~a ~v)))]&amp;lt;br&amp;gt;   `(let [~@(mapcat (partial get-var-dom a) (partition 2 vars))]&amp;lt;br&amp;gt;      ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">let-dom</a>[a vars & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;llist&lt;/b&gt; ([f s] [f s &amp; rest])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Constructs a sequence from 2 or more arguments, with the last argument as the&lt;br&gt;   tail. The tail is improper if the last argument is a logic variable.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro llist&amp;lt;br&amp;gt;  &amp;quot;Constructs a sequence from 2 or more arguments, with the last argument as the&amp;lt;br&amp;gt;   tail. The tail is improper if the last argument is a logic variable.&amp;quot;&amp;lt;br&amp;gt;  ([f s] `(lcons ~f ~s))&amp;lt;br&amp;gt;  ([f s &amp;amp; rest] `(lcons ~f (llist ~s ~@rest))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">llist</a>[f s] [f s & rest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;log&lt;/b&gt; ([&amp; s])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro log [&amp;amp; s]&amp;lt;br&amp;gt;  &amp;quot;Goal for println&amp;quot;&amp;lt;br&amp;gt;  `(fn [a#]&amp;lt;br&amp;gt;     (println ~@s)&amp;lt;br&amp;gt;     a#))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">log</a>[& s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;lvar&lt;/b&gt; ([] [name] [name gensym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lvar&amp;lt;br&amp;gt;  ([]&amp;lt;br&amp;gt;     (let [name (str (. clojure.lang.RT (nextID)))]&amp;lt;br&amp;gt;       (LVar. name nil (.hashCode name) nil)))&amp;lt;br&amp;gt;  ([name]&amp;lt;br&amp;gt;     (lvar name true))&amp;lt;br&amp;gt;  ([name gensym]&amp;lt;br&amp;gt;     (let [oname name&amp;lt;br&amp;gt;           name (if gensym&amp;lt;br&amp;gt;                  (str name &amp;quot;__&amp;quot; (. clojure.lang.RT (nextID)))&amp;lt;br&amp;gt;                  (str name))]&amp;lt;br&amp;gt;       (LVar. name oname (.hashCode name) nil))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lvar</a>[] [name] [name gensym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;lvar?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lvar? [x]&amp;lt;br&amp;gt;  (instance? IVar x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lvar?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;lvaro&lt;/b&gt; ([v])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Goal to test whether a logic var is ground. Non-relational.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro lvaro&amp;lt;br&amp;gt;  &amp;quot;Goal to test whether a logic var is ground. Non-relational.&amp;quot;&amp;lt;br&amp;gt;  [v]&amp;lt;br&amp;gt;  `(fn [a#]&amp;lt;br&amp;gt;     (if (lvar? (walk a# ~v))&amp;lt;br&amp;gt;       a# nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lvaro</a>[v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;lvars&lt;/b&gt; ([n])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lvars [n]&amp;lt;br&amp;gt;  (repeatedly n lvar))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lvars</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;make-cs&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-cs []&amp;lt;br&amp;gt;  (ConstraintStore. {} {} 0 #{}))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-cs</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;make-suspended-stream&lt;/b&gt; ([cache ansv* f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-suspended-stream [cache ansv* f]&amp;lt;br&amp;gt;  (SuspendedStream. cache ansv* f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-suspended-stream</a>[cache ansv* f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;map-&gt;PMap&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.core.logic.PMap, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord PMap []&amp;lt;br&amp;gt;  INonStorable&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IUnifyTerms&amp;lt;br&amp;gt;  (unify-terms [u v s]&amp;lt;br&amp;gt;    (if (map? v)&amp;lt;br&amp;gt;      (unify-with-pmap* u v s)&amp;lt;br&amp;gt;      nil))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IUnifyWithRecord&amp;lt;br&amp;gt;  (unify-with-record [u v s]&amp;lt;br&amp;gt;    (if (map? v)&amp;lt;br&amp;gt;      (unify-with-pmap* u v s)&amp;lt;br&amp;gt;      nil))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IUninitialized&amp;lt;br&amp;gt;  (-uninitialized [_] (PMap.)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->PMap</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;map-&gt;SubstValue&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.core.logic.SubstValue, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord SubstValue [v doms eset]&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (str v)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->SubstValue</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;map-&gt;SuspendedStream&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.core.logic.SuspendedStream, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord SuspendedStream [cache ansv* f]&amp;lt;br&amp;gt;  ISuspendedStream&amp;lt;br&amp;gt;  (ready? [this]&amp;lt;br&amp;gt;    (not (identical? (:ansl @cache) ansv*))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->SuspendedStream</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;master&lt;/b&gt; ([argv cache])&lt;br&gt; Take the argument to the goal and check that we don't&lt;br&gt;   have an alpha equivalent cached answer term in the cache.&lt;br&gt;   If it doesn't already exist in the cache add the new&lt;br&gt;   answer term.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn master&amp;lt;br&amp;gt;  &amp;quot;Take the argument to the goal and check that we don't&amp;lt;br&amp;gt;   have an alpha equivalent cached answer term in the cache.&amp;lt;br&amp;gt;   If it doesn't already exist in the cache add the new&amp;lt;br&amp;gt;   answer term.&amp;quot;&amp;lt;br&amp;gt;  [argv cache]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (let [rargv (-reify a argv)]&amp;lt;br&amp;gt;      (when-not (-cached? @cache rargv)&amp;lt;br&amp;gt;        (swap! cache&amp;lt;br&amp;gt;          (fn [cache]&amp;lt;br&amp;gt;            (if (-cached? cache rargv)&amp;lt;br&amp;gt;              cache&amp;lt;br&amp;gt;              (-add cache (reify-tabled a argv)))))&amp;lt;br&amp;gt;        a))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">master</a>[argv cache]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;matcha&lt;/b&gt; ([xs &amp; cs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a soft cut pattern match. See conda.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro matcha&amp;lt;br&amp;gt;  &amp;quot;Define a soft cut pattern match. See conda.&amp;quot;&amp;lt;br&amp;gt;  [xs &amp;amp; cs]&amp;lt;br&amp;gt;  (binding [*locals* (env-locals xs (keys &amp;amp;env))]&amp;lt;br&amp;gt;    (handle-clauses `conda xs cs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">matcha</a>[xs & cs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;matche&lt;/b&gt; ([xs &amp; cs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Pattern matching macro. All patterns will be tried.&lt;br&gt;  See conde.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro matche&amp;lt;br&amp;gt;  &amp;quot;Pattern matching macro. All patterns will be tried.&amp;lt;br&amp;gt;  See conde.&amp;quot;&amp;lt;br&amp;gt;  [xs &amp;amp; cs]&amp;lt;br&amp;gt;  (binding [*locals* (env-locals xs (keys &amp;amp;env))]&amp;lt;br&amp;gt;    (handle-clauses `conde xs cs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">matche</a>[xs & cs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;matchu&lt;/b&gt; ([xs &amp; cs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a committed choice goal. See condu.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro matchu&amp;lt;br&amp;gt;  &amp;quot;Define a committed choice goal. See condu.&amp;quot;&amp;lt;br&amp;gt;  [xs &amp;amp; cs]&amp;lt;br&amp;gt;  (binding [*locals* (env-locals xs (keys &amp;amp;env))]&amp;lt;br&amp;gt;    (handle-clauses `condu xs cs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">matchu</a>[xs & cs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;membero&lt;/b&gt; ([x l])&lt;br&gt; A relation where l is a collection, such that l contains x&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defne membero &amp;lt;br&amp;gt;  &amp;quot;A relation where l is a collection, such that l contains x&amp;quot;&amp;lt;br&amp;gt;  [x l]&amp;lt;br&amp;gt;  ([_ [x . tail]])&amp;lt;br&amp;gt;  ([_ [head . tail]]&amp;lt;br&amp;gt;     (membero x tail)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">membero</a>[x l]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;merge-doms&lt;/b&gt; ([s x doms])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn merge-doms [s x doms]&amp;lt;br&amp;gt;  (let [xdoms (:doms (root-val s x))]&amp;lt;br&amp;gt;    (loop [doms (seq doms) s s]&amp;lt;br&amp;gt;      (if doms&amp;lt;br&amp;gt;        (let [[dom domv] (first doms)]&amp;lt;br&amp;gt;          (let [xdomv (get xdoms dom ::not-found)&amp;lt;br&amp;gt;                ndomv (if (= xdomv ::not-found)&amp;lt;br&amp;gt;                        domv&amp;lt;br&amp;gt;                        (-merge-doms domv xdomv))]&amp;lt;br&amp;gt;            (when ndomv&amp;lt;br&amp;gt;              (recur (next doms)&amp;lt;br&amp;gt;                (add-dom s x dom ndomv #{})))))&amp;lt;br&amp;gt;        s))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">merge-doms</a>[s x doms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;merge-with-root&lt;/b&gt; ([s x root])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn merge-with-root [s x root]&amp;lt;br&amp;gt;  (let [xv    (root-val s x)&amp;lt;br&amp;gt;        rootv (root-val s root)&amp;lt;br&amp;gt;        eset  (set/union (:eset rootv) (:eset xv))&amp;lt;br&amp;gt;        doms (loop [xd (seq (:doms xv)) rd (:doms rootv) r {}]&amp;lt;br&amp;gt;               (if xd&amp;lt;br&amp;gt;                 (let [[xk xv] (first xd)]&amp;lt;br&amp;gt;                   (if-let [[_ rv] (find rd xk)]&amp;lt;br&amp;gt;                     (let [nd (-merge-doms xv rv)]&amp;lt;br&amp;gt;                       (when nd&amp;lt;br&amp;gt;                         (recur (next xd)&amp;lt;br&amp;gt;                           (dissoc rd xk) (assoc r xk nd))))&amp;lt;br&amp;gt;                     (recur (next xd) rd (assoc r xk xv))))&amp;lt;br&amp;gt;                 (merge r rd)))&amp;lt;br&amp;gt;        nv (when doms&amp;lt;br&amp;gt;             (subst-val (:v rootv) doms eset&amp;lt;br&amp;gt;               (merge (meta xv) (meta rootv))))]&amp;lt;br&amp;gt;    (when nv&amp;lt;br&amp;gt;      (-&amp;gt; s&amp;lt;br&amp;gt;        (ext-no-check root nv)&amp;lt;br&amp;gt;        (update-eset doms eset)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">merge-with-root</a>[s x root]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;mplus*&lt;/b&gt; ([e] [e &amp; e-rest])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro mplus*&amp;lt;br&amp;gt;  ([e] e)&amp;lt;br&amp;gt;  ([e &amp;amp; e-rest]&amp;lt;br&amp;gt;     `(mplus ~e (fn [] (mplus* ~@e-rest)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mplus*</a>[e] [e & e-rest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;nilo&lt;/b&gt; ([a])&lt;br&gt; A relation where a is nil&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn nilo&amp;lt;br&amp;gt;  &amp;quot;A relation where a is nil&amp;quot;&amp;lt;br&amp;gt;  [a]&amp;lt;br&amp;gt;  (== nil a))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nilo</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;nonlvaro&lt;/b&gt; ([v])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Goal to test whether a logic var is ground. Non-relational.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro nonlvaro&amp;lt;br&amp;gt;  &amp;quot;Goal to test whether a logic var is ground. Non-relational.&amp;quot;&amp;lt;br&amp;gt;  [v]&amp;lt;br&amp;gt;  `(fn [a#]&amp;lt;br&amp;gt;     (if (not (lvar? (walk a# ~v)))&amp;lt;br&amp;gt;       a# nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nonlvaro</a>[v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;occurs-check&lt;/b&gt; ([s u v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn occurs-check [s u v]&amp;lt;br&amp;gt;  (let [v (walk s v)]&amp;lt;br&amp;gt;    (occurs-check-term v u s)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">occurs-check</a>[s u v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;onceo&lt;/b&gt; ([g])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn onceo [g] (condu (g)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">onceo</a>[g]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;partial-map&lt;/b&gt; ([m])&lt;br&gt; Given map m, returns partial map that unifies with maps even if it&lt;br&gt;   doesn't share all of the keys of that map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn partial-map&amp;lt;br&amp;gt;  &amp;quot;Given map m, returns partial map that unifies with maps even if it&amp;lt;br&amp;gt;   doesn't share all of the keys of that map.&amp;quot;&amp;lt;br&amp;gt;  [m]&amp;lt;br&amp;gt;  (map-&amp;gt;PMap m))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">partial-map</a>[m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;partial-map?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn partial-map? [x]&amp;lt;br&amp;gt;  (instance? PMap x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">partial-map?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;permuteo&lt;/b&gt; ([xl yl])&lt;br&gt; A relation that will permute xl into the yl. May not&lt;br&gt;   terminate if xl is not ground.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defne permuteo&amp;lt;br&amp;gt;  &amp;quot;A relation that will permute xl into the yl. May not&amp;lt;br&amp;gt;   terminate if xl is not ground.&amp;quot;&amp;lt;br&amp;gt;  [xl yl]&amp;lt;br&amp;gt;  ([() ()])&amp;lt;br&amp;gt;  ([[x . xs] _]&amp;lt;br&amp;gt;     (fresh [ys]&amp;lt;br&amp;gt;      (permuteo xs ys)&amp;lt;br&amp;gt;      (rembero x yl ys))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">permuteo</a>[xl yl]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;pred&lt;/b&gt; ([v f])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Check a predicate against the value logic var. Non-relational.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro pred&amp;lt;br&amp;gt;  &amp;quot;Check a predicate against the value logic var. Non-relational.&amp;quot;&amp;lt;br&amp;gt;  [v f]&amp;lt;br&amp;gt;  `(project [~v]&amp;lt;br&amp;gt;     (== (~f ~v) true)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pred</a>[v f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;predc&lt;/b&gt; ([x p] [x p pform])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn predc&amp;lt;br&amp;gt;  ([x p] (predc x p p))&amp;lt;br&amp;gt;  ([x p pform]&amp;lt;br&amp;gt;     (cgoal (-predc x p pform))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">predc</a>[x p] [x p pform]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;project&lt;/b&gt; ([[&amp; vars] &amp; goals])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Extract the values bound to the specified logic vars. Non-relational.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro project&amp;lt;br&amp;gt;  &amp;quot;Extract the values bound to the specified logic vars. Non-relational.&amp;quot;&amp;lt;br&amp;gt;  [[&amp;amp; vars] &amp;amp; goals]&amp;lt;br&amp;gt;  (let [a (gensym &amp;quot;a&amp;quot;)]&amp;lt;br&amp;gt;    `(fn [~a]&amp;lt;br&amp;gt;       (let [~@(project-bindings vars a)]&amp;lt;br&amp;gt;         ((fresh []&amp;lt;br&amp;gt;            ~@goals) ~a)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">project</a>[[& vars] & goals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;record?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn record? [x]&amp;lt;br&amp;gt;  (instance? clojure.lang.IRecord x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">record?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;recover-vars&lt;/b&gt; ([p])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn recover-vars [p]&amp;lt;br&amp;gt;  (loop [p (seq p) r #{}]&amp;lt;br&amp;gt;    (if p&amp;lt;br&amp;gt;      (let [[u v] (first p)]&amp;lt;br&amp;gt;        (recur (next p)&amp;lt;br&amp;gt;          (clojure.set/union&amp;lt;br&amp;gt;            r (recover-vars-from-term u) (recover-vars-from-term v))))&amp;lt;br&amp;gt;      r)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">recover-vars</a>[p]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;recover-vars-from-term&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn recover-vars-from-term [x]&amp;lt;br&amp;gt;  (let [r (atom #{})]&amp;lt;br&amp;gt;    (walk-term x&amp;lt;br&amp;gt;      (fn [x]&amp;lt;br&amp;gt;        (if (lvar? x)&amp;lt;br&amp;gt;          (do (swap! r conj x) x)&amp;lt;br&amp;gt;          x)))&amp;lt;br&amp;gt;    @r))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">recover-vars-from-term</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;reify-constraints&lt;/b&gt; ([v r a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reify-constraints [v r a]&amp;lt;br&amp;gt;  (let [cs  (:cs  a)&amp;lt;br&amp;gt;        rcs (-&amp;gt;&amp;gt; (vals (:cm cs))&amp;lt;br&amp;gt;                 (filter reifiable?)&amp;lt;br&amp;gt;                 (map #(reifyc % v r a))&amp;lt;br&amp;gt;                 (filter #(not (nil? %)))&amp;lt;br&amp;gt;                 (into #{}))]&amp;lt;br&amp;gt;    (if (empty? rcs)&amp;lt;br&amp;gt;      (choice (list v) empty-f)&amp;lt;br&amp;gt;      (choice (list `(~v :- ~@rcs)) empty-f))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reify-constraints</a>[v r a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;reify-lvar-name&lt;/b&gt; ([s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reify-lvar-name [s]&amp;lt;br&amp;gt;  (let [c (count s)]&amp;lt;br&amp;gt;    (if (&amp;lt; c 100)&amp;lt;br&amp;gt;      (unbound-names c)&amp;lt;br&amp;gt;      (symbol (str &amp;quot;_&amp;quot; (count s))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reify-lvar-name</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;reifyg&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reifyg [x]&amp;lt;br&amp;gt;  (all&amp;lt;br&amp;gt;   (enforce-constraints x)&amp;lt;br&amp;gt;   (fn [a]&amp;lt;br&amp;gt;     (let [v (walk* a x)&amp;lt;br&amp;gt;           r (-reify* (with-meta empty-s (meta a)) v)]&amp;lt;br&amp;gt;       (if (zero? (count r))&amp;lt;br&amp;gt;         (choice (list v) empty-f)&amp;lt;br&amp;gt;         (let [v (walk* r v)]&amp;lt;br&amp;gt;           (reify-constraints v r a)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reifyg</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;relevant?&lt;/b&gt; ([c a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn relevant? [c a]&amp;lt;br&amp;gt;  (let [id (id c)]&amp;lt;br&amp;gt;    (and (or ((-&amp;gt; a :cs :cm) id)&amp;lt;br&amp;gt;             (nil? id))&amp;lt;br&amp;gt;         (-relevant? c a))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">relevant?</a>[c a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;rem-attr&lt;/b&gt; ([s x attr])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rem-attr [s x attr]&amp;lt;br&amp;gt;  (let [x (root-var s x)&amp;lt;br&amp;gt;        v (root-val s x)]&amp;lt;br&amp;gt;    (if (subst-val? v)&amp;lt;br&amp;gt;      (let [new-meta (dissoc (meta v) attr)]&amp;lt;br&amp;gt;        (if (and (zero? (count new-meta)) (not= (:v v) ::unbound))&amp;lt;br&amp;gt;          (update-var s x (:v v))&amp;lt;br&amp;gt;          (update-var s x (with-meta v new-meta))))&amp;lt;br&amp;gt;      s)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rem-attr</a>[s x attr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;rem-dom&lt;/b&gt; ([s x dom] [s x dom seenset])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rem-dom&amp;lt;br&amp;gt;  ([s x dom]&amp;lt;br&amp;gt;     (let [x (root-var s x)]&amp;lt;br&amp;gt;       (rem-dom s x dom nil)))&amp;lt;br&amp;gt;  ([s x dom seenset]&amp;lt;br&amp;gt;     (let [v (root-val s x)&amp;lt;br&amp;gt;           s (if (subst-val? v)&amp;lt;br&amp;gt;               (let [new-doms (dissoc (:doms v) dom)]&amp;lt;br&amp;gt;                 (if (and (zero? (count new-doms)) (not= (:v v) ::unbound))&amp;lt;br&amp;gt;                   (update-var s x (:v v))&amp;lt;br&amp;gt;                   (update-var s x (assoc v :doms new-doms))))&amp;lt;br&amp;gt;               s)]&amp;lt;br&amp;gt;       (sync-eset s v seenset&amp;lt;br&amp;gt;         (fn [s y] (rem-dom s y dom (conj (or seenset #{}) x)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rem-dom</a>[s x dom] [s x dom seenset]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;rembero&lt;/b&gt; ([x l o])&lt;br&gt; A relation between l and o where is removed from&lt;br&gt;   l exactly one time.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defne rembero&amp;lt;br&amp;gt;  &amp;quot;A relation between l and o where is removed from&amp;lt;br&amp;gt;   l exactly one time.&amp;quot;&amp;lt;br&amp;gt;  [x l o]&amp;lt;br&amp;gt;  ([_ [x . xs] xs])&amp;lt;br&amp;gt;  ([_ [y . ys] [y . zs]]&amp;lt;br&amp;gt;     (!= y x)&amp;lt;br&amp;gt;     (rembero x ys zs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rembero</a>[x l o]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;remcg&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remcg [c]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (assoc a :cs (remc (:cs a) a c))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remcg</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;resto&lt;/b&gt; ([l d])&lt;br&gt; A relation where l is a collection, such that d is the rest of l&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resto&amp;lt;br&amp;gt;  &amp;quot;A relation where l is a collection, such that d is the rest of l&amp;quot;&amp;lt;br&amp;gt;  [l d]&amp;lt;br&amp;gt;  (fresh [a]&amp;lt;br&amp;gt;    (== (lcons a d) l)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resto</a>[l d]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;retraction&lt;/b&gt; ([rel &amp; tuple])&lt;br&gt; Remove a fact from a relation defined with defrel.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn retraction&amp;lt;br&amp;gt;  &amp;quot;Remove a fact from a relation defined with defrel.&amp;quot;&amp;lt;br&amp;gt;  [rel &amp;amp; tuple]&amp;lt;br&amp;gt;  (retractions rel [(vec tuple)]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">retraction</a>[rel & tuple]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;retractions&lt;/b&gt; ([rel [f :as tuples]] [rel arity tuples])&lt;br&gt; Retract a series of facts. Takes a vector of vectors where each vector&lt;br&gt;   represents a fact tuple, all with the same number of elements. It is not&lt;br&gt;   an error to retract a fact that isn't true.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn retractions&amp;lt;br&amp;gt;  &amp;quot;Retract a series of facts. Takes a vector of vectors where each vector&amp;lt;br&amp;gt;   represents a fact tuple, all with the same number of elements. It is not&amp;lt;br&amp;gt;   an error to retract a fact that isn't true.&amp;quot;&amp;lt;br&amp;gt;  ([rel [f :as tuples]]&amp;lt;br&amp;gt;     (when f (retractions rel (count f) tuples)))&amp;lt;br&amp;gt;  ([^Rel rel arity tuples]&amp;lt;br&amp;gt;     (let [rel-ns (:ns (meta rel))&amp;lt;br&amp;gt;           rel-set (var-get (ns-resolve rel-ns (set-sym (.name rel) arity)))&amp;lt;br&amp;gt;           tuples (map vec tuples)]&amp;lt;br&amp;gt;       (swap! rel-set (fn [s] (reduce disj s tuples)))&amp;lt;br&amp;gt;       (let [indexes (indexes-for rel arity)]&amp;lt;br&amp;gt;         (doseq [[o i] indexes]&amp;lt;br&amp;gt;           (let [index (var-get (ns-resolve rel-ns (index-sym (.name rel) arity o)))]&amp;lt;br&amp;gt;             (let [indexed-tuples (map (fn [t]&amp;lt;br&amp;gt;                                         {(nth t (dec i)) #{t}})&amp;lt;br&amp;gt;                                       tuples)]&amp;lt;br&amp;gt;               (swap! index&amp;lt;br&amp;gt;                      (fn [i]&amp;lt;br&amp;gt;                        (apply difference-with set/difference i indexed-tuples))))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">retractions</a>[rel [f :as tuples]] [rel arity tuples]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;run&lt;/b&gt; ([n bindings &amp; goals])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Executes goals until a maximum of n results are found.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro run&amp;lt;br&amp;gt;  &amp;quot;Executes goals until a maximum of n results are found.&amp;quot;&amp;lt;br&amp;gt;  [n bindings &amp;amp; goals]&amp;lt;br&amp;gt;  `(-run {:occurs-check true :n ~n} ~bindings ~@goals))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run</a>[n bindings & goals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;run*&lt;/b&gt; ([bindings &amp; goals])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Executes goals until results are exhausted.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro run*&amp;lt;br&amp;gt;  &amp;quot;Executes goals until results are exhausted.&amp;quot;&amp;lt;br&amp;gt;  [bindings &amp;amp; goals]&amp;lt;br&amp;gt;  `(-run {:occurs-check true :n false} ~bindings ~@goals))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run*</a>[bindings & goals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;run-constraint&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn run-constraint [c]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (if (or (not (irelevant? c)) (relevant? c a))&amp;lt;br&amp;gt;      (if (runnable? c a)&amp;lt;br&amp;gt;        ((composeg* (runcg c) c (stopcg c)) a)&amp;lt;br&amp;gt;        a)&amp;lt;br&amp;gt;      ((remcg c) a))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-constraint</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;run-constraints&lt;/b&gt; ([xcs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn run-constraints [xcs]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (let [cq (:cq a)&amp;lt;br&amp;gt;          a  (reduce (fn [a c]&amp;lt;br&amp;gt;                       (queue a c))&amp;lt;br&amp;gt;               (assoc a :cq (or cq [])) xcs)]&amp;lt;br&amp;gt;     (if cq&amp;lt;br&amp;gt;       a&amp;lt;br&amp;gt;       (fix-constraints a)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-constraints</a>[xcs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;run-constraints*&lt;/b&gt; ([xs cs ws])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn run-constraints* [xs cs ws]&amp;lt;br&amp;gt;  (if (or (zero? (count cs))&amp;lt;br&amp;gt;          (nil? (seq xs)))&amp;lt;br&amp;gt;    s#&amp;lt;br&amp;gt;    (fn [a]&amp;lt;br&amp;gt;      (let [xcs (constraints-for cs a (first xs) ws)]&amp;lt;br&amp;gt;        (if (seq xcs)&amp;lt;br&amp;gt;          ((composeg*&amp;lt;br&amp;gt;            (run-constraints xcs)&amp;lt;br&amp;gt;            (run-constraints* (next xs) cs ws)) a)&amp;lt;br&amp;gt;          ((run-constraints* (next xs) cs ws) a))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-constraints*</a>[xs cs ws]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;run-nc&lt;/b&gt; ([n bindings &amp; goals])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Executes goals until a maximum of n results are found. Does not &lt;br&gt;   occurs-check.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro run-nc&amp;lt;br&amp;gt;  &amp;quot;Executes goals until a maximum of n results are found. Does not &amp;lt;br&amp;gt;   occurs-check.&amp;quot;&amp;lt;br&amp;gt;  [n bindings &amp;amp; goals]&amp;lt;br&amp;gt;  `(-run {:occurs-check false :n ~n} ~bindings ~@goals))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-nc</a>[n bindings & goals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;run-nc*&lt;/b&gt; ([&amp; goals])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Executes goals until results are exhausted. Does not occurs-check.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro run-nc*&amp;lt;br&amp;gt;  &amp;quot;Executes goals until results are exhausted. Does not occurs-check.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; goals]&amp;lt;br&amp;gt;  `(run-nc false ~@goals))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-nc*</a>[& goals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;runcg&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn runcg [c]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (assoc a :cs (runc (:cs a) c true))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">runcg</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;seqc&lt;/b&gt; ([v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn seqc [v]&amp;lt;br&amp;gt;  (fixc v&amp;lt;br&amp;gt;    (fn [t _ _]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;        (sequential? t) succeed&amp;lt;br&amp;gt;        (lcons? t) (seqc (lnext t))&amp;lt;br&amp;gt;        :else fail))&amp;lt;br&amp;gt;    (fn [_ v _ r a]&amp;lt;br&amp;gt;      `(seqc ~(-reify a v r)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">seqc</a>[v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;solutions&lt;/b&gt; ([s g] [s q g])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn solutions&amp;lt;br&amp;gt;  ([s g]&amp;lt;br&amp;gt;     (solutions s (lvar) g))&amp;lt;br&amp;gt;  ([s q g]&amp;lt;br&amp;gt;     (take* ((all g (reifyg q)) s))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">solutions</a>[s g] [s q g]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;sort-by-member-count&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sort-by-member-count [a]&amp;lt;br&amp;gt;  (fn [x y]&amp;lt;br&amp;gt;    (let-dom a [x dx y dy]&amp;lt;br&amp;gt;      (&amp;lt; (member-count dx) (member-count dy)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sort-by-member-count</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;sort-by-strategy&lt;/b&gt; ([v x a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sort-by-strategy [v x a]&amp;lt;br&amp;gt;  (case (-&amp;gt; x meta ::strategy)&amp;lt;br&amp;gt;    ::ff (seq (sort (sort-by-member-count a) v))&amp;lt;br&amp;gt;    ;; TODO: throw on non-existant strategies&amp;lt;br&amp;gt;    v))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sort-by-strategy</a>[v x a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;stopcg&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn stopcg [c]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (assoc a :cs (runc (:cs a) c false))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">stopcg</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;subst-val&lt;/b&gt; ([x] [x doms] [x doms _meta] [x doms eset _meta])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subst-val&amp;lt;br&amp;gt;  ([x] (SubstValue. x nil nil))&amp;lt;br&amp;gt;  ([x doms] (SubstValue. x doms nil))&amp;lt;br&amp;gt;  ([x doms _meta] (with-meta (SubstValue. x doms nil) _meta))&amp;lt;br&amp;gt;  ([x doms eset _meta] (with-meta (SubstValue. x doms eset) _meta)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subst-val</a>[x] [x doms] [x doms _meta] [x doms eset _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;subst-val?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subst-val? [x]&amp;lt;br&amp;gt;  (instance? SubstValue x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subst-val?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;subst?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subst? [x]&amp;lt;br&amp;gt;  (instance? Substitutions x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subst?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;succeed&lt;/b&gt; ([a])&lt;br&gt; A goal that always succeeds.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn succeed&amp;lt;br&amp;gt;  &amp;quot;A goal that always succeeds.&amp;quot;&amp;lt;br&amp;gt;  [a] a)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">succeed</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;suspended-stream?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn suspended-stream? [x]&amp;lt;br&amp;gt;  (instance? SuspendedStream x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">suspended-stream?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;sync-eset&lt;/b&gt; ([s v seenset f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sync-eset [s v seenset f]&amp;lt;br&amp;gt;  (if (not= seenset ::no-prop)&amp;lt;br&amp;gt;    (reduce&amp;lt;br&amp;gt;      (fn [s y]&amp;lt;br&amp;gt;        (let [y (root-var s y)]&amp;lt;br&amp;gt;          (if-not (contains? seenset y)&amp;lt;br&amp;gt;            (f s y)&amp;lt;br&amp;gt;            s)))&amp;lt;br&amp;gt;      s&amp;lt;br&amp;gt;      (:eset v))&amp;lt;br&amp;gt;    s))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sync-eset</a>[s v seenset f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;tabled&lt;/b&gt; ([args &amp; grest])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Macro for defining a tabled goal. Prefer ^:tabled with the &lt;br&gt;  defne/a/u forms over using this directly.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro tabled&amp;lt;br&amp;gt;  &amp;quot;Macro for defining a tabled goal. Prefer ^:tabled with the &amp;lt;br&amp;gt;  defne/a/u forms over using this directly.&amp;quot;&amp;lt;br&amp;gt;  [args &amp;amp; grest]&amp;lt;br&amp;gt;  (let [uuid (symbol (str &amp;quot;tabled-&amp;quot; (UUID/randomUUID)))]&amp;lt;br&amp;gt;    `(fn ~uuid [~@args]&amp;lt;br&amp;gt;       (let [argv# ~args]&amp;lt;br&amp;gt;         (fn [a#]&amp;lt;br&amp;gt;           (let [key#    (-reify a# argv#)&amp;lt;br&amp;gt;                 tables# (:ts a#)&amp;lt;br&amp;gt;                 tables# (if-not (contains? @tables# ~uuid)&amp;lt;br&amp;gt;                           (swap! tables#&amp;lt;br&amp;gt;                             (fn [tables#]&amp;lt;br&amp;gt;                               (if (contains? tables# ~uuid)&amp;lt;br&amp;gt;                                 tables#&amp;lt;br&amp;gt;                                 (assoc tables# ~uuid (atom {})))))&amp;lt;br&amp;gt;                           @tables#)&amp;lt;br&amp;gt;                 table#  (get tables# ~uuid)]&amp;lt;br&amp;gt;             (if-not (contains? @table# key#)&amp;lt;br&amp;gt;               (let [table# (swap! table#&amp;lt;br&amp;gt;                              (fn [table#]&amp;lt;br&amp;gt;                                (if (contains? table# key#)&amp;lt;br&amp;gt;                                  table#&amp;lt;br&amp;gt;                                  (assoc table# key# (atom (answer-cache))))))&amp;lt;br&amp;gt;                     cache# (get table# key#)]&amp;lt;br&amp;gt;                 ((fresh []&amp;lt;br&amp;gt;                    ~@grest&amp;lt;br&amp;gt;                    (master argv# cache#)) a#))&amp;lt;br&amp;gt;               (let [cache# (get @table# key#)]&amp;lt;br&amp;gt;                 (reuse a# argv# cache# nil nil)))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tabled</a>[args & grest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;tabled-s&lt;/b&gt; ([] [oc] [oc meta])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tabled-s&amp;lt;br&amp;gt;  ([] (tabled-s false))&amp;lt;br&amp;gt;  ([oc] (tabled-s oc nil))&amp;lt;br&amp;gt;  ([oc meta]&amp;lt;br&amp;gt;     (-&amp;gt; (with-meta (make-s) meta)&amp;lt;br&amp;gt;       (assoc :oc oc)&amp;lt;br&amp;gt;       (assoc :ts (atom {})))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tabled-s</a>[] [oc] [oc meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;to-s&lt;/b&gt; ([v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn to-s [v]&amp;lt;br&amp;gt;  (let [s (reduce (fn [m [k v]] (assoc m k v)) {} v)]&amp;lt;br&amp;gt;    (make-s s (make-cs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">to-s</a>[v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;to-stream&lt;/b&gt; ([aseq])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn to-stream [aseq]&amp;lt;br&amp;gt;  (let [aseq (drop-while nil? aseq)]&amp;lt;br&amp;gt;    (when (seq aseq)&amp;lt;br&amp;gt;      (choice (first aseq)&amp;lt;br&amp;gt;              (fn [] (to-stream (next aseq)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">to-stream</a>[aseq]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;to-subst-val&lt;/b&gt; ([v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn to-subst-val [v]&amp;lt;br&amp;gt;  (if (subst-val? v)&amp;lt;br&amp;gt;    v&amp;lt;br&amp;gt;    (subst-val ::unbound)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">to-subst-val</a>[v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;trace-lvar&lt;/b&gt; ([a lvar])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn trace-lvar [a lvar]&amp;lt;br&amp;gt;  `(println (format &amp;quot;%5s = %s&amp;quot; (str '~lvar) (-reify ~a ~lvar))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-lvar</a>[a lvar]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;trace-lvars&lt;/b&gt; ([title &amp; lvars])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Goal for tracing the values of logic variables.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro trace-lvars&amp;lt;br&amp;gt;  &amp;quot;Goal for tracing the values of logic variables.&amp;quot;&amp;lt;br&amp;gt;  [title &amp;amp; lvars]&amp;lt;br&amp;gt;  (let [a (gensym &amp;quot;a&amp;quot;)]&amp;lt;br&amp;gt;    `(fn [~a]&amp;lt;br&amp;gt;       (println ~title)&amp;lt;br&amp;gt;       ~@(map (partial trace-lvar a) lvars)&amp;lt;br&amp;gt;       ~a)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-lvars</a>[title & lvars]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;trace-s&lt;/b&gt; ([])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro trace-s []&amp;lt;br&amp;gt;  &amp;quot;Goal that prints the current substitution&amp;quot;&amp;lt;br&amp;gt;  `(fn [a#]&amp;lt;br&amp;gt;     (println (str a#))&amp;lt;br&amp;gt;     a#))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-s</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;tree-term?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tree-term? [x]&amp;lt;br&amp;gt;  (or (coll? x)&amp;lt;br&amp;gt;      (instance? ITreeTerm x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tree-term?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;treec&lt;/b&gt; ([x fc reifier])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn treec [x fc reifier]&amp;lt;br&amp;gt;  (fixc x&amp;lt;br&amp;gt;    (fn loop [t a reifier]&amp;lt;br&amp;gt;      (if (tree-term? t)&amp;lt;br&amp;gt;        (composeg*&amp;lt;br&amp;gt;          (fc t)&amp;lt;br&amp;gt;          (constrain-tree t&amp;lt;br&amp;gt;            (fn [t a] ((fixc t loop reifier) a))))&amp;lt;br&amp;gt;        (fc t)))&amp;lt;br&amp;gt;    reifier))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">treec</a>[x fc reifier]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;uai&lt;/b&gt; ([&amp; args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro uai&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  (if (resolve 'unchecked-add-int)&amp;lt;br&amp;gt;    `(unchecked-add-int ~@args)&amp;lt;br&amp;gt;    `(unchecked-add ~@args)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">uai</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;umi&lt;/b&gt; ([&amp; args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro umi&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  (if (resolve 'unchecked-multiply-int)&amp;lt;br&amp;gt;    `(unchecked-multiply-int ~@args)&amp;lt;br&amp;gt;    `(unchecked-multiply ~@args)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">umi</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;unbound-rands&lt;/b&gt; ([a c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unbound-rands [a c]&amp;lt;br&amp;gt;  (-&amp;gt;&amp;gt; (var-rands a c)&amp;lt;br&amp;gt;    (filter #(lvar? (root-val a %)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unbound-rands</a>[a c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;unify&lt;/b&gt; ([s u v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unify [s u v]&amp;lt;br&amp;gt;  (if (identical? u v)&amp;lt;br&amp;gt;    s&amp;lt;br&amp;gt;    (let [u  (walk s u)&amp;lt;br&amp;gt;          v  (walk s v)]&amp;lt;br&amp;gt;      ;; TODO: we can't use an identical? check here at the moment&amp;lt;br&amp;gt;      ;; because we add metadata on vars in walk - David&amp;lt;br&amp;gt;      (if (and (lvar? u) (= u v))&amp;lt;br&amp;gt;        s&amp;lt;br&amp;gt;        (if (and (not (lvar? u)) (lvar? v))&amp;lt;br&amp;gt;          (unify-terms v u s)&amp;lt;br&amp;gt;          (unify-terms u v s))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unify</a>[s u v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;unify-with-map*&lt;/b&gt; ([u v s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unify-with-map* [u v s]&amp;lt;br&amp;gt;  (when (= (count u) (count v))&amp;lt;br&amp;gt;    (loop [ks (keys u) s s]&amp;lt;br&amp;gt;      (if (seq ks)&amp;lt;br&amp;gt;        (let [kf (first ks)&amp;lt;br&amp;gt;              vf (get v kf ::not-found)]&amp;lt;br&amp;gt;          (when-not (= vf ::not-found)&amp;lt;br&amp;gt;            (if-let [s (unify s (get u kf) vf)]&amp;lt;br&amp;gt;              (recur (next ks) s)&amp;lt;br&amp;gt;              nil)))&amp;lt;br&amp;gt;        s))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unify-with-map*</a>[u v s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;unify-with-pmap*&lt;/b&gt; ([u v s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unify-with-pmap* [u v s]&amp;lt;br&amp;gt;  (loop [ks (keys u) s s]&amp;lt;br&amp;gt;    (if (seq ks)&amp;lt;br&amp;gt;      (let [kf (first ks)&amp;lt;br&amp;gt;            vf (get v kf ::not-found)&amp;lt;br&amp;gt;            uf (get u kf)]&amp;lt;br&amp;gt;        (if (= vf ::not-found)&amp;lt;br&amp;gt;          (if (= uf ::not-found)&amp;lt;br&amp;gt;            (recur (next ks) s)&amp;lt;br&amp;gt;            nil)&amp;lt;br&amp;gt;          (if (= uf ::not-found)&amp;lt;br&amp;gt;            nil&amp;lt;br&amp;gt;            (if-let [s (unify s uf vf)]&amp;lt;br&amp;gt;              (recur (next ks) s)&amp;lt;br&amp;gt;              nil))))&amp;lt;br&amp;gt;      s)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unify-with-pmap*</a>[u v s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;unify-with-sequential*&lt;/b&gt; ([u v s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unify-with-sequential* [u v s]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (sequential? v)&amp;lt;br&amp;gt;    (if (and (counted? u) (counted? v)&amp;lt;br&amp;gt;          (not= (count u) (count v)))&amp;lt;br&amp;gt;      nil&amp;lt;br&amp;gt;      (loop [u u v v s s]&amp;lt;br&amp;gt;        (if (seq u)&amp;lt;br&amp;gt;          (if (seq v)&amp;lt;br&amp;gt;            (if-let [s (unify s (first u) (first v))]&amp;lt;br&amp;gt;              (recur (next u) (next v) s)&amp;lt;br&amp;gt;              nil)&amp;lt;br&amp;gt;            nil)&amp;lt;br&amp;gt;          (if (seq v) nil s))))&amp;lt;br&amp;gt;    &amp;lt;br&amp;gt;    (lcons? v) (unify-terms v u s)&amp;lt;br&amp;gt;    :else nil))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unify-with-sequential*</a>[u v s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;update-dom&lt;/b&gt; ([s x dom f] [s x dom f seenset])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn update-dom&amp;lt;br&amp;gt;  ([s x dom f]&amp;lt;br&amp;gt;     (let [x (root-var s x)]&amp;lt;br&amp;gt;       (update-dom s x dom f nil)))&amp;lt;br&amp;gt;  ([s x dom f seenset]&amp;lt;br&amp;gt;     (let [v (root-val s x)&amp;lt;br&amp;gt;           v (if (lvar? v)&amp;lt;br&amp;gt;               (subst-val ::unbound)&amp;lt;br&amp;gt;               v)&amp;lt;br&amp;gt;           doms (:doms v)&amp;lt;br&amp;gt;           s (update-var s x (assoc-dom v dom (f (get doms dom))))]&amp;lt;br&amp;gt;       (sync-eset s v seenset&amp;lt;br&amp;gt;         (fn [s y] (update-dom s y dom f (conj (or seenset #{}) x)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">update-dom</a>[s x dom f] [s x dom f seenset]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;update-eset&lt;/b&gt; ([s doms eset])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn update-eset [s doms eset]&amp;lt;br&amp;gt;  (loop [eset (seq eset) s s]&amp;lt;br&amp;gt;    (if eset&amp;lt;br&amp;gt;      (when-let [s (merge-doms s (root-var s (first eset)) doms)]&amp;lt;br&amp;gt;        (recur (next eset) s))&amp;lt;br&amp;gt;      s)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">update-eset</a>[s doms eset]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;update-pvars!&lt;/b&gt; ([x vars])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn update-pvars! [x vars]&amp;lt;br&amp;gt;  (if (lvar-sym? x)&amp;lt;br&amp;gt;    (do&amp;lt;br&amp;gt;      (swap! vars conj x)&amp;lt;br&amp;gt;      x)&amp;lt;br&amp;gt;    x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">update-pvars!</a>[x vars]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;updatecg&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn updatecg [c]&amp;lt;br&amp;gt;  (fn [a]&amp;lt;br&amp;gt;    (assoc a :cs (updatec (:cs a) a c))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">updatecg</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;var-rands&lt;/b&gt; ([a c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn var-rands [a c]&amp;lt;br&amp;gt;  (-&amp;gt;&amp;gt; (rands c)&amp;lt;br&amp;gt;    (map #(root-var a %))&amp;lt;br&amp;gt;    (filter lvar?)&amp;lt;br&amp;gt;    (into [])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">var-rands</a>[a c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;verify-all-bound&lt;/b&gt; ([a constrained])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn verify-all-bound [a constrained]&amp;lt;br&amp;gt;  (letfn [(verify-all-bound* [a constrained]&amp;lt;br&amp;gt;            (when constrained&amp;lt;br&amp;gt;              (let [x (first constrained)]&amp;lt;br&amp;gt;                (if (and (lvar? x)&amp;lt;br&amp;gt;                         (and (lvar? (walk a x))&amp;lt;br&amp;gt;                              (nil? (get-dom a x ::fd))))&amp;lt;br&amp;gt;                  (throw (Exception. (str &amp;quot;Constrained variable &amp;quot; x &amp;quot; without domain&amp;quot;)))&amp;lt;br&amp;gt;                  (recur a (next constrained))))))]&amp;lt;br&amp;gt;    (verify-all-bound* a (seq constrained))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">verify-all-bound</a>[a constrained]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;waiting-stream-check&lt;/b&gt; ([w success-cont failure-cont])&lt;br&gt; Take a waiting stream, a success continuation, and a failure continuation.&lt;br&gt;   If we don't find any ready suspended streams, invoke the failure continuation. &lt;br&gt;   If we find a ready suspended stream calculate the remainder of the waiting&lt;br&gt;   stream. If we've reached the fixpoint just call the thunk of the suspended&lt;br&gt;   stream, otherwise call mplus on the result of the thunk and the remainder&lt;br&gt;   of the waiting stream. Pass this result to the success contination.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn waiting-stream-check&amp;lt;br&amp;gt;  &amp;quot;Take a waiting stream, a success continuation, and a failure continuation.&amp;lt;br&amp;gt;   If we don't find any ready suspended streams, invoke the failure continuation. &amp;lt;br&amp;gt;   If we find a ready suspended stream calculate the remainder of the waiting&amp;lt;br&amp;gt;   stream. If we've reached the fixpoint just call the thunk of the suspended&amp;lt;br&amp;gt;   stream, otherwise call mplus on the result of the thunk and the remainder&amp;lt;br&amp;gt;   of the waiting stream. Pass this result to the success contination.&amp;quot;&amp;lt;br&amp;gt;  [w success-cont failure-cont]&amp;lt;br&amp;gt;  (loop [w w a []]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;     (nil? w) (failure-cont)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     (ready? (first w))&amp;lt;br&amp;gt;     (success-cont&amp;lt;br&amp;gt;       (fn []&amp;lt;br&amp;gt;         (let [ss (first w)&amp;lt;br&amp;gt;               f  (:f ss)&amp;lt;br&amp;gt;               w  (into a (next w))]&amp;lt;br&amp;gt;           (if (empty? w)&amp;lt;br&amp;gt;             (f)&amp;lt;br&amp;gt;             (mplus (f) (fn [] w))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     :else (recur (next w) (conj a (first w))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">waiting-stream-check</a>[w success-cont failure-cont]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;waiting-stream?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn waiting-stream? [x]&amp;lt;br&amp;gt;  (vector? x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">waiting-stream?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;walk*&lt;/b&gt; ([s v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn walk* [s v]&amp;lt;br&amp;gt;  (let [v (walk s v)]&amp;lt;br&amp;gt;    (walk-term v&amp;lt;br&amp;gt;      (fn [x]&amp;lt;br&amp;gt;        (let [x (walk s x)]&amp;lt;br&amp;gt;         (if (tree-term? x)&amp;lt;br&amp;gt;           (walk* s x)&amp;lt;br&amp;gt;           x))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">walk*</a>[s v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic&lt;/i&gt;&lt;b&gt;walk-record-term&lt;/b&gt; ([v f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn walk-record-term [v f]&amp;lt;br&amp;gt;  (with-meta&amp;lt;br&amp;gt;    (loop [v v r (-uninitialized v)]&amp;lt;br&amp;gt;      (if (seq v)&amp;lt;br&amp;gt;        (let [[vfk vfv] (first v)]&amp;lt;br&amp;gt;          (recur (next v) (assoc r (walk-term (f vfk) f)&amp;lt;br&amp;gt;                                 (walk-term (f vfv) f))))&amp;lt;br&amp;gt;        r))&amp;lt;br&amp;gt;    (meta v)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">walk-record-term</a>[v f]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.logic.protocols</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;-add&lt;/b&gt; ([this x])&lt;br&gt; &lt;/div&gt;" data-placement="right">-add</a>[this x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;-cached?&lt;/b&gt; ([this x])&lt;br&gt; &lt;/div&gt;" data-placement="right">-cached?</a>[this x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;-constrain-tree&lt;/b&gt; ([t fc s])&lt;br&gt; &lt;/div&gt;" data-placement="right">-constrain-tree</a>[t fc s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;-feature&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right">-feature</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;-force-ans&lt;/b&gt; ([v x])&lt;br&gt; &lt;/div&gt;" data-placement="right">-force-ans</a>[v x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;-id&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">-id</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;-merge-doms&lt;/b&gt; ([a b])&lt;br&gt; &lt;/div&gt;" data-placement="right">-merge-doms</a>[a b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;-reify-tabled&lt;/b&gt; ([this v])&lt;br&gt; &lt;/div&gt;" data-placement="right">-reify-tabled</a>[this v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;-relevant-var?&lt;/b&gt; ([this x])&lt;br&gt; &lt;/div&gt;" data-placement="right">-relevant-var?</a>[this x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;-relevant?&lt;/b&gt; ([this s])&lt;br&gt; &lt;/div&gt;" data-placement="right">-relevant?</a>[this s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;-uninitialized&lt;/b&gt; ([coll])&lt;br&gt; &lt;/div&gt;" data-placement="right">-uninitialized</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;-with-id&lt;/b&gt; ([this id])&lt;br&gt; &lt;/div&gt;" data-placement="right">-with-id</a>[this id]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;add-indexes&lt;/b&gt; ([this arity index])&lt;br&gt; &lt;/div&gt;" data-placement="right">add-indexes</a>[this arity index]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;addc&lt;/b&gt; ([this a c])&lt;br&gt; &lt;/div&gt;" data-placement="right">addc</a>[this a c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;bind&lt;/b&gt; ([this g])&lt;br&gt; &lt;/div&gt;" data-placement="right">bind</a>[this g]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;build-term&lt;/b&gt; ([u s])&lt;br&gt; &lt;/div&gt;" data-placement="right">build-term</a>[u s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;constraints-for&lt;/b&gt; ([this a x ws])&lt;br&gt; &lt;/div&gt;" data-placement="right">constraints-for</a>[this a x ws]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;disunify-terms&lt;/b&gt; ([u v s cs])&lt;br&gt; &lt;/div&gt;" data-placement="right">disunify-terms</a>[u v s cs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;enforceable?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn enforceable? [x]&amp;lt;br&amp;gt;  (instance? clojure.core.logic.protocols.IEnforceableConstraint x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">enforceable?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;ext-no-check&lt;/b&gt; ([this x v])&lt;br&gt; &lt;/div&gt;" data-placement="right">ext-no-check</a>[this x v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;ext-run-cs&lt;/b&gt; ([this x v])&lt;br&gt; &lt;/div&gt;" data-placement="right">ext-run-cs</a>[this x v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;id&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn id [c]&amp;lt;br&amp;gt;  (if (instance? clojure.core.logic.protocols.IConstraintId c)&amp;lt;br&amp;gt;    (-id c)&amp;lt;br&amp;gt;    (-&amp;gt; c meta ::id)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">id</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;ifa&lt;/b&gt; ([b gs c])&lt;br&gt; &lt;/div&gt;" data-placement="right">ifa</a>[b gs c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;ifu&lt;/b&gt; ([b gs c])&lt;br&gt; &lt;/div&gt;" data-placement="right">ifu</a>[b gs c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;indexes-for&lt;/b&gt; ([this arity])&lt;br&gt; &lt;/div&gt;" data-placement="right">indexes-for</a>[this arity]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;lfirst&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">lfirst</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;lnext&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">lnext</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;member-count&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">member-count</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;migrate&lt;/b&gt; ([this x root])&lt;br&gt; &lt;/div&gt;" data-placement="right">migrate</a>[this x root]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;mplus&lt;/b&gt; ([a f])&lt;br&gt; &lt;/div&gt;" data-placement="right">mplus</a>[a f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;non-storable?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn non-storable? [x]&amp;lt;br&amp;gt;  (instance? INonStorable x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">non-storable?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;occurs-check-term&lt;/b&gt; ([v x s])&lt;br&gt; &lt;/div&gt;" data-placement="right">occurs-check-term</a>[v x s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;prefix&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">prefix</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;queue&lt;/b&gt; ([this c])&lt;br&gt; &lt;/div&gt;" data-placement="right">queue</a>[this c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;rands&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">rands</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;rator&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">rator</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;ready?&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">ready?</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;reifiable?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reifiable? [x]&amp;lt;br&amp;gt;  (instance? clojure.core.logic.protocols.IReifiableConstraint x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reifiable?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;reify-tabled&lt;/b&gt; ([this v])&lt;br&gt; &lt;/div&gt;" data-placement="right">reify-tabled</a>[this v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;reify-term&lt;/b&gt; ([v s])&lt;br&gt; &lt;/div&gt;" data-placement="right">reify-term</a>[v s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;reifyc&lt;/b&gt; ([this v r a])&lt;br&gt; &lt;/div&gt;" data-placement="right">reifyc</a>[this v r a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;remc&lt;/b&gt; ([this a c])&lt;br&gt; &lt;/div&gt;" data-placement="right">remc</a>[this a c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;reuse&lt;/b&gt; ([this argv cache start end])&lt;br&gt; &lt;/div&gt;" data-placement="right">reuse</a>[this argv cache start end]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;root-val&lt;/b&gt; ([this x])&lt;br&gt; &lt;/div&gt;" data-placement="right">root-val</a>[this x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;root-var&lt;/b&gt; ([this x])&lt;br&gt; &lt;/div&gt;" data-placement="right">root-var</a>[this x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;runc&lt;/b&gt; ([this c state])&lt;br&gt; &lt;/div&gt;" data-placement="right">runc</a>[this c state]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;runnable?&lt;/b&gt; ([c s])&lt;br&gt; &lt;/div&gt;" data-placement="right">runnable?</a>[c s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;setfn&lt;/b&gt; ([this arity f])&lt;br&gt; &lt;/div&gt;" data-placement="right">setfn</a>[this arity f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;subunify&lt;/b&gt; ([this arg ans])&lt;br&gt; &lt;/div&gt;" data-placement="right">subunify</a>[this arg ans]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;take*&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right">take*</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;toShortString&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">toShortString</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;tree-constraint?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tree-constraint? [x]&amp;lt;br&amp;gt;  (instance? clojure.core.logic.protocols.ITreeConstraint x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tree-constraint?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;unify-terms&lt;/b&gt; ([u v s])&lt;br&gt; &lt;/div&gt;" data-placement="right">unify-terms</a>[u v s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;unify-with-pmap&lt;/b&gt; ([pmap u s])&lt;br&gt; &lt;/div&gt;" data-placement="right">unify-with-pmap</a>[pmap u s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;unify-with-record&lt;/b&gt; ([u v s])&lt;br&gt; &lt;/div&gt;" data-placement="right">unify-with-record</a>[u v s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;unwrap&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right">unwrap</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;update-var&lt;/b&gt; ([this x v])&lt;br&gt; &lt;/div&gt;" data-placement="right">update-var</a>[this x v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;updatec&lt;/b&gt; ([this a c])&lt;br&gt; &lt;/div&gt;" data-placement="right">updatec</a>[this a c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;walk&lt;/b&gt; ([this x])&lt;br&gt; &lt;/div&gt;" data-placement="right">walk</a>[this x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;walk-term&lt;/b&gt; ([v f])&lt;br&gt; &lt;/div&gt;" data-placement="right">walk-term</a>[v f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;watched-stores&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">watched-stores</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;with-id&lt;/b&gt; ([c id])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn with-id [c id]&amp;lt;br&amp;gt;  (if (instance? clojure.core.logic.protocols.IWithConstraintId c)&amp;lt;br&amp;gt;    (-with-id c id)&amp;lt;br&amp;gt;    (vary-meta c assoc ::id id)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-id</a>[c id]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.logic.protocols&lt;/i&gt;&lt;b&gt;with-prefix&lt;/b&gt; ([this p])&lt;br&gt; &lt;/div&gt;" data-placement="right">with-prefix</a>[this p]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.match</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;BindNode&lt;/b&gt; ([bindings node])&lt;br&gt; Positional factory function for class clojure.core.match.BindNode.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord BindNode [bindings node]&amp;lt;br&amp;gt;  INodeCompile&amp;lt;br&amp;gt;  (n-to-clj [this]&amp;lt;br&amp;gt;    `(let [~@bindings]&amp;lt;br&amp;gt;       ~(n-to-clj node))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->BindNode</a>[bindings node]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;FailNode&lt;/b&gt; ([])&lt;br&gt; Positional factory function for class clojure.core.match.FailNode.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FailNode []&amp;lt;br&amp;gt;  INodeCompile&amp;lt;br&amp;gt;  (n-to-clj [this]&amp;lt;br&amp;gt;    (if *recur-present*&amp;lt;br&amp;gt;      (if @*breadcrumbs*&amp;lt;br&amp;gt;        `(throw (error (str &amp;quot;No match found. &amp;quot; &amp;lt;br&amp;gt;                            &amp;quot;Followed &amp;quot; ~(count *match-breadcrumbs*)  &amp;quot; branches.&amp;quot;&amp;lt;br&amp;gt;                            &amp;quot; Breadcrumbs: &amp;quot; '~*match-breadcrumbs*)))&amp;lt;br&amp;gt;        `(throw (error (str &amp;quot;No match found.&amp;quot;))))&amp;lt;br&amp;gt;      (backtrack-expr))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->FailNode</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;GuardPattern&lt;/b&gt; ([p gs _meta])&lt;br&gt; Positional factory function for class clojure.core.match.GuardPattern.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype GuardPattern [p gs _meta]&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [_] _meta)&amp;lt;br&amp;gt;  (withMeta [_ new-meta]&amp;lt;br&amp;gt;    (GuardPattern. p gs new-meta))&amp;lt;br&amp;gt;  IPatternCompile&amp;lt;br&amp;gt;  (to-source* [this ocr]&amp;lt;br&amp;gt;    `(and ~@(map (fn [expr ocr]&amp;lt;br&amp;gt;                   (list expr ocr))&amp;lt;br&amp;gt;                 gs (repeat ocr))))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [this]&amp;lt;br&amp;gt;    (str p &amp;quot; :guard &amp;quot; gs))&amp;lt;br&amp;gt;  ISpecializeMatrix&amp;lt;br&amp;gt;  (specialize-matrix [this rows ocrs]&amp;lt;br&amp;gt;    (let [nrows (-&amp;gt;&amp;gt; rows&amp;lt;br&amp;gt;                     (map (fn [row]&amp;lt;br&amp;gt;                            (let [p (first row)]&amp;lt;br&amp;gt;                              (if (guard-pattern? p)&amp;lt;br&amp;gt;                                (let [^GuardPattern p p]&amp;lt;br&amp;gt;                                  (update-pattern row 0 (.p p)))&amp;lt;br&amp;gt;                                row))))&amp;lt;br&amp;gt;                     vec)&amp;lt;br&amp;gt;          _ (trace-dag &amp;quot;GuardPattern specialization&amp;quot;)]&amp;lt;br&amp;gt;      (pattern-matrix nrows ocrs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->GuardPattern</a>[p gs _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;LeafNode&lt;/b&gt; ([value bindings])&lt;br&gt; Positional factory function for class clojure.core.match.LeafNode.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord LeafNode [value bindings]&amp;lt;br&amp;gt;  INodeCompile&amp;lt;br&amp;gt;  (n-to-clj [this]&amp;lt;br&amp;gt;    (if (not (empty? bindings))&amp;lt;br&amp;gt;      (let [bindings (remove (fn [[sym _]] (= sym '_))&amp;lt;br&amp;gt;                             bindings)]&amp;lt;br&amp;gt;       `(let [~@(apply concat bindings)]&amp;lt;br&amp;gt;          ~value))&amp;lt;br&amp;gt;      value)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->LeafNode</a>[value bindings]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;LiteralPattern&lt;/b&gt; ([l _meta])&lt;br&gt; Positional factory function for class clojure.core.match.LiteralPattern.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype LiteralPattern [l _meta]&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [_] _meta)&amp;lt;br&amp;gt;  (withMeta [_ new-meta]&amp;lt;br&amp;gt;    (LiteralPattern. l new-meta))&amp;lt;br&amp;gt;  IPatternCompile&amp;lt;br&amp;gt;  (to-source* [this ocr]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;     (= l ()) `(empty? ~ocr)&amp;lt;br&amp;gt;     (and (symbol? l) (not (-&amp;gt; l meta :local))) `(= ~ocr '~l)&amp;lt;br&amp;gt;     :else `(= ~ocr ~l)))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (if (nil? l)&amp;lt;br&amp;gt;      &amp;quot;nil&amp;quot;&amp;lt;br&amp;gt;      (pr-str l))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->LiteralPattern</a>[l _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;MapPattern&lt;/b&gt; ([m _meta])&lt;br&gt; Positional factory function for class clojure.core.match.MapPattern.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype MapPattern [m _meta]&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [_] _meta)&amp;lt;br&amp;gt;  (withMeta [_ new-meta]&amp;lt;br&amp;gt;    (MapPattern. m new-meta))&amp;lt;br&amp;gt;  IPatternCompile&amp;lt;br&amp;gt;  (to-source* [this ocr]&amp;lt;br&amp;gt;    (if *clojurescript*&amp;lt;br&amp;gt;      `(satisfies? cljs.core/ILookup ~ocr)&amp;lt;br&amp;gt;      `(or (instance? clojure.lang.ILookup ~ocr) (satisfies? IMatchLookup ~ocr))))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (str m &amp;quot; :only &amp;quot; (or (:only _meta) [])))&amp;lt;br&amp;gt;  ISpecializeMatrix&amp;lt;br&amp;gt;  (specialize-matrix [this rows ocrs]&amp;lt;br&amp;gt;    (let [focr (first ocrs)&amp;lt;br&amp;gt;          only? (atom false)&amp;lt;br&amp;gt;          all-keys (-&amp;gt;&amp;gt; rows&amp;lt;br&amp;gt;                        (remove (comp wildcard-pattern? first))&amp;lt;br&amp;gt;                        (map (fn [row]&amp;lt;br&amp;gt;                               (let [^MapPattern p (first row)&amp;lt;br&amp;gt;                                     only (-&amp;gt; p meta :only)]&amp;lt;br&amp;gt;                                 (when (and (not @only?) (seq only))&amp;lt;br&amp;gt;                                   (reset! only? true))&amp;lt;br&amp;gt;                                 [(set (keys (.m p)))&amp;lt;br&amp;gt;                                  (set only)])))&amp;lt;br&amp;gt;                        (reduce concat)&amp;lt;br&amp;gt;                        (reduce set/union #{}))&amp;lt;br&amp;gt;          wcs (repeatedly wildcard-pattern)&amp;lt;br&amp;gt;          wc-map (zipmap all-keys wcs)&amp;lt;br&amp;gt;          nrows (-&amp;gt;&amp;gt; rows&amp;lt;br&amp;gt;                     (map (fn [row]&amp;lt;br&amp;gt;                            (let [p (first row)&amp;lt;br&amp;gt;                                  only (seq (-&amp;gt; p meta :only))&amp;lt;br&amp;gt;                                  ocr-map (if (map-pattern? p)&amp;lt;br&amp;gt;                                            (let [^MapPattern p p&amp;lt;br&amp;gt;                                                  m (.m p)&amp;lt;br&amp;gt;                                                  [not-found-map wc-map] (if only&amp;lt;br&amp;gt;                                                                           [(zipmap all-keys&amp;lt;br&amp;gt;                                                                                    (repeat (literal-pattern ::not-found)))&amp;lt;br&amp;gt;                                                                            (zipmap only wcs)]&amp;lt;br&amp;gt;                                                                           [{} wc-map])]&amp;lt;br&amp;gt;                                              (merge not-found-map wc-map m))&amp;lt;br&amp;gt;                                            wc-map)&amp;lt;br&amp;gt;                                  ps (map ocr-map all-keys)&amp;lt;br&amp;gt;                                  ps (if @only?&amp;lt;br&amp;gt;                                       (if only&amp;lt;br&amp;gt;                                         (let [a (with-meta (gensym) {:tag 'java.util.Map})]&amp;lt;br&amp;gt;                                           (cons (guard-pattern (wildcard-pattern)&amp;lt;br&amp;gt;                                                                (set [(if *clojurescript*&amp;lt;br&amp;gt;                                                                        `(fn [~a] (= (set (keys ~a)) #{~@only}))&amp;lt;br&amp;gt;                                                                        `(fn [~a] (= (.keySet ~a) #{~@only})))]))&amp;lt;br&amp;gt;                                                 ps))&amp;lt;br&amp;gt;                                         (cons (wildcard-pattern) ps))&amp;lt;br&amp;gt;                                       ps)]&amp;lt;br&amp;gt;                              (reduce prepend (drop-nth-bind row 0 focr)&amp;lt;br&amp;gt;                                      (reverse ps)))))&amp;lt;br&amp;gt;                     vec)&amp;lt;br&amp;gt;          nocrs (let [map-ocr focr&amp;lt;br&amp;gt;                      ocr-sym (fn ocr-sym [k]&amp;lt;br&amp;gt;                                (let [ocr (gensym (str (name map-ocr) &amp;quot;_&amp;quot; (name k) &amp;quot;__&amp;quot;))]&amp;lt;br&amp;gt;                                  (with-meta ocr&amp;lt;br&amp;gt;                                    {:occurrence-type :map&amp;lt;br&amp;gt;                                     :key k&amp;lt;br&amp;gt;                                     :map-sym map-ocr&amp;lt;br&amp;gt;                                     :bind-expr (val-at-expr map-ocr k ::not-found)})))&amp;lt;br&amp;gt;                      mocrs (map ocr-sym all-keys)&amp;lt;br&amp;gt;                      mocrs (if @only?&amp;lt;br&amp;gt;                              (cons map-ocr mocrs)&amp;lt;br&amp;gt;                              mocrs)]&amp;lt;br&amp;gt;                  (into (into [] mocrs)&amp;lt;br&amp;gt;                        (drop-nth ocrs 0)))&amp;lt;br&amp;gt;          _ (trace-dag &amp;quot;MapPattern specialization&amp;quot;)]&amp;lt;br&amp;gt;      (pattern-matrix nrows nocrs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->MapPattern</a>[m _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;OrPattern&lt;/b&gt; ([ps _meta])&lt;br&gt; Positional factory function for class clojure.core.match.OrPattern.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype OrPattern [ps _meta]&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [_] _meta)&amp;lt;br&amp;gt;  (withMeta [_ new-meta]&amp;lt;br&amp;gt;    (OrPattern. ps new-meta))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [this]&amp;lt;br&amp;gt;    (str ps))&amp;lt;br&amp;gt;  ISpecializeMatrix&amp;lt;br&amp;gt;  (specialize-matrix [this rows ocrs]&amp;lt;br&amp;gt;    (let [ps (.ps this)&amp;lt;br&amp;gt;          nrows (-&amp;gt;&amp;gt; rows&amp;lt;br&amp;gt;                     (map (fn [row]&amp;lt;br&amp;gt;                            (let [p (first row)]&amp;lt;br&amp;gt;                              ;; NOTE: hmm why can't we remove this - David&amp;lt;br&amp;gt;                              (if (and (pattern-equals this p)&amp;lt;br&amp;gt;                                       (not (wildcard-pattern? p)))&amp;lt;br&amp;gt;                                (map (fn [p]&amp;lt;br&amp;gt;                                       (update-pattern row 0 p)) ps)&amp;lt;br&amp;gt;                                [row]))))&amp;lt;br&amp;gt;                     (apply concat)&amp;lt;br&amp;gt;                     vec)&amp;lt;br&amp;gt;          _ (trace-dag &amp;quot;OrPattern specialization&amp;quot;)]&amp;lt;br&amp;gt;      (pattern-matrix nrows ocrs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->OrPattern</a>[ps _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;PatternMatrix&lt;/b&gt; ([rows ocrs _meta])&lt;br&gt; Positional factory function for class clojure.core.match.PatternMatrix.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype PatternMatrix [rows ocrs _meta]&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [_] _meta)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (withMeta [_ new-meta]&amp;lt;br&amp;gt;    (PatternMatrix. rows ocrs new-meta))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IPatternMatrix&amp;lt;br&amp;gt;  (width [_] (if (not (empty? rows))&amp;lt;br&amp;gt;               (count (rows 0))&amp;lt;br&amp;gt;               0))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (height [_] (count rows))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (dim [this] [(width this) (height this)])&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (specialize [this p rows* ocrs*]&amp;lt;br&amp;gt;    (if (satisfies? ISpecializeMatrix p)&amp;lt;br&amp;gt;     (specialize-matrix p rows* ocrs*)&amp;lt;br&amp;gt;     (default-specialize-matrix p rows* ocrs*)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (column [_ i] (vec (map #(nth % i) rows)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (compile [this]&amp;lt;br&amp;gt;    (letfn [(choose-column &amp;lt;br&amp;gt;              ;; Return a column number of a column which contains at least&amp;lt;br&amp;gt;              ;; one non-wildcard constructor&amp;lt;br&amp;gt;              [this]&amp;lt;br&amp;gt;              (let [col (necessary-column this)&amp;lt;br&amp;gt;                    _ (trace-dag &amp;quot;Pick column&amp;quot; col &amp;quot;as necessary column.&amp;quot;)]&amp;lt;br&amp;gt;                col))&amp;lt;br&amp;gt;            &amp;lt;br&amp;gt;            (first-column? [i]&amp;lt;br&amp;gt;              (zero? i))&amp;lt;br&amp;gt;            &amp;lt;br&amp;gt;            (empty-row? [row]&amp;lt;br&amp;gt;              (let [ps (patterns row)]&amp;lt;br&amp;gt;                (and (not (nil? ps))&amp;lt;br&amp;gt;                     (empty? ps))))]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;        (empty? rows) (empty-rows-case)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (empty-row? (first rows)) (first-row-empty-case rows (first ocrs))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (all-wildcards? (first rows)) (first-row-wildcards-case rows ocrs)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        :else (let [col (choose-column this)]&amp;lt;br&amp;gt;                (if (first-column? col)&amp;lt;br&amp;gt;                  (first-column-chosen-case this col ocrs)&amp;lt;br&amp;gt;                  (other-column-chosen-case this col))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (pattern-at [_ i j] ((rows j) i))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (row [_ j] (nth rows j))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (necessary-column [this]&amp;lt;br&amp;gt;    (letfn [(score-column [i col]&amp;lt;br&amp;gt;              [i (reduce (fn [score useful]&amp;lt;br&amp;gt;                           (if useful&amp;lt;br&amp;gt;                             (clojure.core/inc score)&amp;lt;br&amp;gt;                             score))&amp;lt;br&amp;gt;                         0 col)])]&amp;lt;br&amp;gt;      (first&amp;lt;br&amp;gt;       (-&amp;gt;&amp;gt; (apply map vector (useful-matrix this))&amp;lt;br&amp;gt;            (map-indexed score-column)&amp;lt;br&amp;gt;            (reduce (fn [[col score :as curr]&amp;lt;br&amp;gt;                         [ocol oscore :as cand]]&amp;lt;br&amp;gt;                      (if (&amp;gt; oscore score) cand curr))&amp;lt;br&amp;gt;                    [0 0])))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (useful-matrix [this]&amp;lt;br&amp;gt;    (vec (-&amp;gt;&amp;gt; (for [j (range (height this))&amp;lt;br&amp;gt;                    i (range (width this))]&amp;lt;br&amp;gt;                (useful-p? this i j))&amp;lt;br&amp;gt;              (partition (width this))&amp;lt;br&amp;gt;              (map vec))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (select [this]&amp;lt;br&amp;gt;    (swap this (necessary-column this)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (rows [_] rows)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (insert-row [_ i row]&amp;lt;br&amp;gt;    (PatternMatrix. (into (conj (subvec rows 0 i) row) (subvec rows i))&amp;lt;br&amp;gt;                    ocrs&amp;lt;br&amp;gt;                    _meta))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (insert-rows [_ i rows]&amp;lt;br&amp;gt;    (PatternMatrix. (into (into (subvec rows 0 i) rows) (subvec rows i))&amp;lt;br&amp;gt;                    ocrs&amp;lt;br&amp;gt;                    _meta))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (occurrences [_] ocrs)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (action-for-row [_ j]&amp;lt;br&amp;gt;    (action (rows j)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IVecMod&amp;lt;br&amp;gt;  (drop-nth [_ i]&amp;lt;br&amp;gt;    (PatternMatrix. (vec (map #(drop-nth % i) rows)) ocrs _meta))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  ;; Swap column number idx with the first column&amp;lt;br&amp;gt;  (swap [_ idx]&amp;lt;br&amp;gt;    (PatternMatrix. (vec (map #(swap % idx) rows))&amp;lt;br&amp;gt;                    (swap ocrs idx)&amp;lt;br&amp;gt;                    _meta)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->PatternMatrix</a>[rows ocrs _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;PatternRow&lt;/b&gt; ([ps action bindings])&lt;br&gt; Positional factory function for class clojure.core.match.PatternRow.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype PatternRow [ps action bindings]&amp;lt;br&amp;gt;  IPatternRow&amp;lt;br&amp;gt;  (action [_] action)&amp;lt;br&amp;gt;  (patterns [_] ps)&amp;lt;br&amp;gt;  (update-pattern [_ i p]&amp;lt;br&amp;gt;    (PatternRow. (assoc ps i p) action bindings))&amp;lt;br&amp;gt;  (bindings [_] bindings)&amp;lt;br&amp;gt;  (all-wildcards? [this]&amp;lt;br&amp;gt;    (every? wildcard-pattern? ps))&amp;lt;br&amp;gt;  (drop-nth-bind [this n ocr]&amp;lt;br&amp;gt;    (let [p (ps n)&amp;lt;br&amp;gt;          bind-expr (leaf-bind-expr ocr)&amp;lt;br&amp;gt;          bindings (or bindings [])&amp;lt;br&amp;gt;          bindings (if-let [sym (-&amp;gt; p meta :as)]&amp;lt;br&amp;gt;                     (conj bindings [sym bind-expr])&amp;lt;br&amp;gt;                     bindings)&amp;lt;br&amp;gt;          bindings (if (named-wildcard-pattern? p)&amp;lt;br&amp;gt;                       (conj bindings [(sym p) bind-expr])&amp;lt;br&amp;gt;                       bindings)]&amp;lt;br&amp;gt;      (PatternRow. (drop-nth ps n) action&amp;lt;br&amp;gt;                   bindings)))&amp;lt;br&amp;gt;  IVecMod&amp;lt;br&amp;gt;  (drop-nth [_ n]&amp;lt;br&amp;gt;    (PatternRow. (drop-nth ps n) action bindings))&amp;lt;br&amp;gt;  (prepend [_ x]&amp;lt;br&amp;gt;    (PatternRow. (into [x] ps) action bindings))&amp;lt;br&amp;gt;  (swap [_ n]&amp;lt;br&amp;gt;    (PatternRow. (swap ps n) action bindings))&amp;lt;br&amp;gt;  clojure.lang.Associative&amp;lt;br&amp;gt;  (assoc [this k v]&amp;lt;br&amp;gt;    (PatternRow. (assoc ps k v) action bindings))&amp;lt;br&amp;gt;  clojure.lang.Indexed&amp;lt;br&amp;gt;  (nth [_ i]&amp;lt;br&amp;gt;    (nth ps i))&amp;lt;br&amp;gt;  (nth [_ i x]&amp;lt;br&amp;gt;    (nth ps i x))&amp;lt;br&amp;gt;  clojure.lang.ISeq&amp;lt;br&amp;gt;  (first [_] (first ps))&amp;lt;br&amp;gt;  (next [_]&amp;lt;br&amp;gt;    (if-let [nps (next ps)]&amp;lt;br&amp;gt;      (PatternRow. nps action bindings)&amp;lt;br&amp;gt;      (PatternRow. [] action bindings)))&amp;lt;br&amp;gt;  (more [_]&amp;lt;br&amp;gt;    (if (empty? ps)&amp;lt;br&amp;gt;      nil&amp;lt;br&amp;gt;      (let [nps (rest ps)]&amp;lt;br&amp;gt;        (PatternRow. nps action bindings))))&amp;lt;br&amp;gt;  (seq [this]&amp;lt;br&amp;gt;    (seq ps))&amp;lt;br&amp;gt;  (count [_]&amp;lt;br&amp;gt;    (count ps))&amp;lt;br&amp;gt;  clojure.lang.IFn&amp;lt;br&amp;gt;  (invoke [_ n]&amp;lt;br&amp;gt;    (nth ps n))&amp;lt;br&amp;gt;  clojure.lang.IPersistentCollection&amp;lt;br&amp;gt;  (cons [_ x]&amp;lt;br&amp;gt;    (PatternRow. (conj ps x) action bindings)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->PatternRow</a>[ps action bindings]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;PredicatePattern&lt;/b&gt; ([p gs _meta])&lt;br&gt; Positional factory function for class clojure.core.match.PredicatePattern.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype PredicatePattern [p gs _meta]&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [_] _meta)&amp;lt;br&amp;gt;  (withMeta [_ new-meta]&amp;lt;br&amp;gt;    (PredicatePattern. p gs new-meta))&amp;lt;br&amp;gt;  IPatternCompile&amp;lt;br&amp;gt;  (to-source* [this ocr]&amp;lt;br&amp;gt;    `(and ~@(map (fn [expr ocr]&amp;lt;br&amp;gt;                   (list expr ocr))&amp;lt;br&amp;gt;                 gs (repeat ocr))))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [this]&amp;lt;br&amp;gt;    (str p &amp;quot; :when &amp;quot; gs))&amp;lt;br&amp;gt;  ISpecializeMatrix&amp;lt;br&amp;gt;  (specialize-matrix [this rows ocrs]&amp;lt;br&amp;gt;    (let [nrows (-&amp;gt;&amp;gt; rows&amp;lt;br&amp;gt;                     (map (fn [row]&amp;lt;br&amp;gt;                            (let [p (first row)]&amp;lt;br&amp;gt;                              (if (predicate-pattern? p)&amp;lt;br&amp;gt;                                (let [^PredicatePattern p p]&amp;lt;br&amp;gt;                                  (update-pattern row 0 (.p p)))&amp;lt;br&amp;gt;                                row))))&amp;lt;br&amp;gt;                     vec)&amp;lt;br&amp;gt;          _ (trace-dag &amp;quot;PredicatePattern specialization&amp;quot;)]&amp;lt;br&amp;gt;      (pattern-matrix nrows ocrs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->PredicatePattern</a>[p gs _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;RestPattern&lt;/b&gt; ([p _meta])&lt;br&gt; Positional factory function for class clojure.core.match.RestPattern.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype RestPattern [p _meta]&amp;lt;br&amp;gt;  IPatternContainer&amp;lt;br&amp;gt;  (pattern [_] p)&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [_] _meta)&amp;lt;br&amp;gt;  (withMeta [_ new-meta]&amp;lt;br&amp;gt;    (RestPattern. p new-meta))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    p))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->RestPattern</a>[p _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;SeqPattern&lt;/b&gt; ([s _meta])&lt;br&gt; Positional factory function for class clojure.core.match.SeqPattern.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype SeqPattern [s _meta]&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [_] _meta)&amp;lt;br&amp;gt;  (withMeta [_ new-meta]&amp;lt;br&amp;gt;    (SeqPattern. s new-meta))&amp;lt;br&amp;gt;  IPatternCompile&amp;lt;br&amp;gt;  (to-source* [this ocr]&amp;lt;br&amp;gt;    `(or (seq? ~ocr) (sequential? ~ocr)))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (str s))&amp;lt;br&amp;gt;  ISpecializeMatrix&amp;lt;br&amp;gt;  (specialize-matrix [this rows ocrs]&amp;lt;br&amp;gt;    (let [focr (first ocrs)&amp;lt;br&amp;gt;          nrows (-&amp;gt;&amp;gt; rows&amp;lt;br&amp;gt;                     (map (fn [row]&amp;lt;br&amp;gt;                            (let [p (first row)&amp;lt;br&amp;gt;                                  [h t] (if (seq-pattern? p)&amp;lt;br&amp;gt;                                          (let [^SeqPattern p p&amp;lt;br&amp;gt;                                                [h &amp;amp; t] (.s p)&amp;lt;br&amp;gt;                                                t (cond&amp;lt;br&amp;gt;                                                   (empty? t) (literal-pattern ())&amp;lt;br&amp;gt;                                                   (rest-pattern? (first t)) (pattern (first t))&amp;lt;br&amp;gt;                                                   :else (seq-pattern t))]&amp;lt;br&amp;gt;                                            [h t])&amp;lt;br&amp;gt;                                          [(wildcard-pattern) (wildcard-pattern)])]&amp;lt;br&amp;gt;                              (reduce prepend (drop-nth-bind row 0 focr)&amp;lt;br&amp;gt;                                      [t h]))))&amp;lt;br&amp;gt;                     vec)&amp;lt;br&amp;gt;          nocrs (let [seq-ocr focr&amp;lt;br&amp;gt;                      seq-sym (or (-&amp;gt; seq-ocr meta :seq-sym) seq-ocr)&amp;lt;br&amp;gt;                      sym-meta {:occurrence-type :seq&amp;lt;br&amp;gt;                                :seq-sym seq-ocr}&amp;lt;br&amp;gt;                      hsym (gensym (str (name seq-sym) &amp;quot;_head__&amp;quot;))&amp;lt;br&amp;gt;                      hsym (with-meta hsym&amp;lt;br&amp;gt;                             (assoc sym-meta :bind-expr `(first ~seq-ocr)))&amp;lt;br&amp;gt;                      tsym (gensym (str (name seq-sym) &amp;quot;_tail__&amp;quot;))&amp;lt;br&amp;gt;                      tsym (with-meta tsym&amp;lt;br&amp;gt;                             (assoc sym-meta :bind-expr `(rest ~seq-ocr)))]&amp;lt;br&amp;gt;                  (into [hsym tsym] (drop-nth ocrs 0)))&amp;lt;br&amp;gt;          _ (trace-dag &amp;quot;SeqPattern specialization on ocr &amp;quot; focr&amp;lt;br&amp;gt;                       &amp;quot;, new num ocrs&amp;quot; &amp;lt;br&amp;gt;                       (count ocrs) &amp;quot;-&amp;gt;&amp;quot; (count nocrs))]&amp;lt;br&amp;gt;      (pattern-matrix nrows nocrs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->SeqPattern</a>[s _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;SwitchNode&lt;/b&gt; ([occurrence cases default])&lt;br&gt; Positional factory function for class clojure.core.match.SwitchNode.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord SwitchNode [occurrence cases default]&amp;lt;br&amp;gt;  INodeCompile&amp;lt;br&amp;gt;  (n-to-clj [this]&amp;lt;br&amp;gt;    (let [clauses (doall (mapcat (partial apply dag-clause-to-clj occurrence) cases))&amp;lt;br&amp;gt;          bind-expr (-&amp;gt; occurrence meta :bind-expr)&amp;lt;br&amp;gt;          cond-expr (if *recur-present*&amp;lt;br&amp;gt;                      (doall (concat `(cond ~@clauses)&amp;lt;br&amp;gt;                                     `(:else ~(n-to-clj default))))&amp;lt;br&amp;gt;                      (doall (concat `(cond ~@clauses)&amp;lt;br&amp;gt;                                     `(:else ~(if @*backtrack-with-errors*&amp;lt;br&amp;gt;                                                `(throw (Exception. (str &amp;quot;Could not match&amp;quot; ~occurrence)))&amp;lt;br&amp;gt;                                                (backtrack-expr))))))]&amp;lt;br&amp;gt;      (if *recur-present*&amp;lt;br&amp;gt;        (if bind-expr&amp;lt;br&amp;gt;          `~(doall (concat `(let [~occurrence ~bind-expr]) (list cond-expr)))&amp;lt;br&amp;gt;          `~cond-expr)&amp;lt;br&amp;gt;        (if bind-expr&amp;lt;br&amp;gt;          `(try ~(doall (concat `(let [~occurrence ~bind-expr]) (list cond-expr)))&amp;lt;br&amp;gt;                ~(catch-error (n-to-clj default)))&amp;lt;br&amp;gt;          `(try ~cond-expr&amp;lt;br&amp;gt;                ~(catch-error (n-to-clj default))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->SwitchNode</a>[occurrence cases default]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;VectorPattern&lt;/b&gt; ([v t size offset rest? _meta])&lt;br&gt; Positional factory function for class clojure.core.match.VectorPattern.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype VectorPattern [v t size offset rest? _meta]&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [_] _meta)&amp;lt;br&amp;gt;  (withMeta [_ new-meta]&amp;lt;br&amp;gt;    (VectorPattern. v t size offset rest? new-meta))&amp;lt;br&amp;gt;  IPatternCompile&amp;lt;br&amp;gt;  (to-source* [this ocr]&amp;lt;br&amp;gt;    (if (and (touched? this) (not rest?) size (check-size? t))&amp;lt;br&amp;gt;      (test-with-size-inline t ocr size)&amp;lt;br&amp;gt;      (test-inline t ocr)))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (str v &amp;quot; &amp;quot; t))&amp;lt;br&amp;gt;  IContainsRestPattern&amp;lt;br&amp;gt;  (contains-rest-pattern? [_] rest?)&amp;lt;br&amp;gt;  IVectorPattern&amp;lt;br&amp;gt;  (split [this n]&amp;lt;br&amp;gt;    (let [lv (subvec v 0 n)&amp;lt;br&amp;gt;          rv (subvec v n)&amp;lt;br&amp;gt;          pl (VectorPattern. lv t n offset false _meta)&amp;lt;br&amp;gt;          pr (if (rest-pattern? (first rv))&amp;lt;br&amp;gt;               (let [^RestPattern p (first rv)] (.p p))&amp;lt;br&amp;gt;               (let [rest? (some rest-pattern? rv)&amp;lt;br&amp;gt;                     rvc (count rv)&amp;lt;br&amp;gt;                     size (if rest? (dec rvc) rvc)]&amp;lt;br&amp;gt;                 (VectorPattern. rv t size n rest? _meta)))]&amp;lt;br&amp;gt;      [pl pr]))&amp;lt;br&amp;gt;  ISpecializeMatrix&amp;lt;br&amp;gt;  (specialize-matrix [this rows ocrs]&amp;lt;br&amp;gt;    (if (not (touched? (ffirst rows)))&amp;lt;br&amp;gt;      (pattern-matrix (touch-all-first rows) ocrs)&amp;lt;br&amp;gt;      (let [focr (first ocrs)&amp;lt;br&amp;gt;            ^VectorPattern fp (ffirst rows)&amp;lt;br&amp;gt;            [rest? min-size] (-&amp;gt;&amp;gt; rows&amp;lt;br&amp;gt;                                 (reduce (fn [[rest? min-size] [p &amp;amp; ps]]&amp;lt;br&amp;gt;                                           (if (vector-pattern? p)&amp;lt;br&amp;gt;                                             [(or rest? (.rest? ^VectorPattern p))&amp;lt;br&amp;gt;                                              (min min-size (.size ^VectorPattern p))]&amp;lt;br&amp;gt;                                             [rest? min-size]))&amp;lt;br&amp;gt;                                         [false (.size ^VectorPattern fp)]))&amp;lt;br&amp;gt;           [nrows nocrs] (if rest?&amp;lt;br&amp;gt;                           [(-&amp;gt;&amp;gt; rows&amp;lt;br&amp;gt;                                 (map (fn [row]&amp;lt;br&amp;gt;                                        (let [p (first row)&amp;lt;br&amp;gt;                                              ps (cond&amp;lt;br&amp;gt;                                                  (vector-pattern? p) (split p min-size)&amp;lt;br&amp;gt;                                                  :else [(wildcard-pattern) (wildcard-pattern)])]&amp;lt;br&amp;gt;                                          (reduce prepend (drop-nth-bind row 0 focr) (reverse ps)))))&amp;lt;br&amp;gt;                                 vec)&amp;lt;br&amp;gt;                            (let [vec-ocr focr&amp;lt;br&amp;gt;                                  t (.t this)&amp;lt;br&amp;gt;                                  ocr-meta {:occurrence-type t&amp;lt;br&amp;gt;                                            :vec-sym vec-ocr}&amp;lt;br&amp;gt;                                  vl-ocr (gensym (str (name vec-ocr) &amp;quot;_left__&amp;quot;))&amp;lt;br&amp;gt;                                  vl-ocr (with-meta vl-ocr&amp;lt;br&amp;gt;                                           (assoc ocr-meta :bind-expr (subvec-inline t (with-tag t vec-ocr) 0 min-size )))&amp;lt;br&amp;gt;                                  vr-ocr (gensym (str (name vec-ocr) &amp;quot;_right__&amp;quot;))&amp;lt;br&amp;gt;                                  vr-ocr (with-meta vr-ocr&amp;lt;br&amp;gt;                                           (assoc ocr-meta :bind-expr (subvec-inline t (with-tag t vec-ocr) min-size)))]&amp;lt;br&amp;gt;                              (into [vl-ocr vr-ocr] (drop-nth ocrs 0)))]&amp;lt;br&amp;gt;                           [(-&amp;gt;&amp;gt; rows&amp;lt;br&amp;gt;                                 (map (fn [row]&amp;lt;br&amp;gt;                                        (let [p (first row)&amp;lt;br&amp;gt;                                              ps (if (vector-pattern? p)&amp;lt;br&amp;gt;                                                   (reverse (.v ^VectorPattern p))&amp;lt;br&amp;gt;                                                   (repeatedly min-size wildcard-pattern))]&amp;lt;br&amp;gt;                                          (reduce prepend (drop-nth-bind row 0 focr) ps))))&amp;lt;br&amp;gt;                                 vec)&amp;lt;br&amp;gt;                            (let [vec-ocr focr&amp;lt;br&amp;gt;                                  ocr-sym (fn [i]&amp;lt;br&amp;gt;                                            (let [ocr (gensym (str (name vec-ocr) &amp;quot;_&amp;quot; i &amp;quot;__&amp;quot;))&amp;lt;br&amp;gt;                                                  t (.t this)]&amp;lt;br&amp;gt;                                              (with-meta ocr&amp;lt;br&amp;gt;                                                {:occurrence-type t&amp;lt;br&amp;gt;                                                 :vec-sym vec-ocr&amp;lt;br&amp;gt;                                                 :index i&amp;lt;br&amp;gt;                                                 :bind-expr (if-let [offset (.offset this)]&amp;lt;br&amp;gt;                                                              (nth-offset-inline t (with-tag t vec-ocr) i offset)&amp;lt;br&amp;gt;                                                              (nth-inline t (with-tag t vec-ocr) i))})))]&amp;lt;br&amp;gt;                              (into (into [] (map ocr-sym (range min-size)))&amp;lt;br&amp;gt;                                (drop-nth ocrs 0)))])&amp;lt;br&amp;gt;           matrix (pattern-matrix nrows nocrs)]&amp;lt;br&amp;gt;       matrix))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->VectorPattern</a>[v t size offset rest? _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;-&gt;WildcardPattern&lt;/b&gt; ([sym _meta])&lt;br&gt; Positional factory function for class clojure.core.match.WildcardPattern.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype WildcardPattern [sym _meta]&amp;lt;br&amp;gt;  IWildcardPattern&amp;lt;br&amp;gt;  (sym [_] sym)&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  (meta [_] _meta)&amp;lt;br&amp;gt;  (withMeta [_ new-meta]&amp;lt;br&amp;gt;    (WildcardPattern. sym new-meta))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_]&amp;lt;br&amp;gt;    (str sym)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->WildcardPattern</a>[sym _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;action&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">action</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;action-for-row&lt;/b&gt; ([this j])&lt;br&gt; &lt;/div&gt;" data-placement="right">action-for-row</a>[this j]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;all-wildcards?&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">all-wildcards?</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;analyze-actions&lt;/b&gt; ([actions])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-actions [actions]&amp;lt;br&amp;gt;  (letfn [(analyze-action [action]&amp;lt;br&amp;gt;            (if (and (sequential? action)&amp;lt;br&amp;gt;                     (some '#{recur} (flatten action)))&amp;lt;br&amp;gt;              {:recur-present true} {}))]&amp;lt;br&amp;gt;    (map analyze-action actions)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-actions</a>[actions]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;backtrack-expr&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn backtrack-expr []&amp;lt;br&amp;gt;  (if *clojurescript*&amp;lt;br&amp;gt;    `(throw clojure.core.match/backtrack)&amp;lt;br&amp;gt;    `(throw clojure.core.match/backtrack)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">backtrack-expr</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;bind-node&lt;/b&gt; ([bindings node])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^BindNode bind-node [bindings node]&amp;lt;br&amp;gt;  (BindNode. bindings node))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bind-node</a>[bindings node]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;bindings&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">bindings</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;catch-error&lt;/b&gt; ([&amp; body])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn catch-error [&amp;amp; body]&amp;lt;br&amp;gt;  (if *clojurescript*&amp;lt;br&amp;gt;    `(catch js/Error e#&amp;lt;br&amp;gt;       (if (identical? e# clojure.core.match/backtrack)&amp;lt;br&amp;gt;         (do&amp;lt;br&amp;gt;           ~@body)&amp;lt;br&amp;gt;         (throw e#)))&amp;lt;br&amp;gt;    `(catch Exception e#&amp;lt;br&amp;gt;       (if (identical? e# clojure.core.match/backtrack)&amp;lt;br&amp;gt;         (do&amp;lt;br&amp;gt;           ~@body)&amp;lt;br&amp;gt;         (throw e#)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">catch-error</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;clj-form&lt;/b&gt; ([vars clauses])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn clj-form [vars clauses]&amp;lt;br&amp;gt;  (when @*syntax-check* (check-matrix-args vars clauses))&amp;lt;br&amp;gt;  (let [actions (map second (partition 2 clauses))&amp;lt;br&amp;gt;        recur-present (some :recur-present&amp;lt;br&amp;gt;                            (analyze-actions actions))]&amp;lt;br&amp;gt;    (binding [*recur-present* recur-present]&amp;lt;br&amp;gt;      (-&amp;gt; (emit-matrix vars clauses)&amp;lt;br&amp;gt;          compile&amp;lt;br&amp;gt;          executable-form))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">clj-form</a>[vars clauses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;column&lt;/b&gt; ([this i])&lt;br&gt; &lt;/div&gt;" data-placement="right">column</a>[this i]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;compile&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">compile</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;constructor?&lt;/b&gt; ([p])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn constructor? [p]&amp;lt;br&amp;gt;  (not (wildcard-pattern? p)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">constructor?</a>[p]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;contains-rest-pattern?&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">contains-rest-pattern?</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;dag-clause-to-clj&lt;/b&gt; ([occurrence pattern action])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dag-clause-to-clj [occurrence pattern action]&amp;lt;br&amp;gt;  (let [test (if (instance? clojure.core.match.IPatternCompile pattern)&amp;lt;br&amp;gt;               (to-source* pattern occurrence) &amp;lt;br&amp;gt;               (to-source pattern occurrence))]&amp;lt;br&amp;gt;    (if @*breadcrumbs*&amp;lt;br&amp;gt;      (binding [*match-breadcrumbs* (conj *match-breadcrumbs* test)]&amp;lt;br&amp;gt;        [test (n-to-clj action)])&amp;lt;br&amp;gt;      [test (n-to-clj action)])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dag-clause-to-clj</a>[occurrence pattern action]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;default-specialize-matrix&lt;/b&gt; ([p rows ocrs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn default-specialize-matrix [p rows ocrs]&amp;lt;br&amp;gt;  (let [focr (first ocrs)&amp;lt;br&amp;gt;        nrows (-&amp;gt;&amp;gt; rows&amp;lt;br&amp;gt;                   (filter #(pattern-equals p (first %)))&amp;lt;br&amp;gt;                   (map #(drop-nth-bind % 0 focr))&amp;lt;br&amp;gt;                   vec)&amp;lt;br&amp;gt;        nocrs (drop-nth ocrs 0)&amp;lt;br&amp;gt;        _ (trace-dag &amp;quot;Perform default matrix specialization on ocr&amp;quot; focr&amp;lt;br&amp;gt;                     &amp;quot;, new num ocrs: &amp;quot; &amp;lt;br&amp;gt;                     (count ocrs) &amp;quot;-&amp;gt;&amp;quot; (count nocrs))]&amp;lt;br&amp;gt;    (pattern-matrix nrows nocrs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">default-specialize-matrix</a>[p rows ocrs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;defpred&lt;/b&gt; ([name] [name f])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defpred&amp;lt;br&amp;gt;  ([name]&amp;lt;br&amp;gt;     (swap! preds assoc name name))&amp;lt;br&amp;gt;  ([name f]&amp;lt;br&amp;gt;     (swap! preds assoc name f)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defpred</a>[name] [name f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;dim&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">dim</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;drop-nth&lt;/b&gt; ([this n])&lt;br&gt; &lt;/div&gt;" data-placement="right">drop-nth</a>[this n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;drop-nth-bind&lt;/b&gt; ([this n bind-expr])&lt;br&gt; &lt;/div&gt;" data-placement="right">drop-nth-bind</a>[this n bind-expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;emit-clause&lt;/b&gt; ([[pat action]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-clause [[pat action]]&amp;lt;br&amp;gt;  (let [p (into [] (map emit-pattern (group-keywords pat)))]&amp;lt;br&amp;gt;    (pattern-row p action)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-clause</a>[[pat action]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;emit-matrix&lt;/b&gt; ([vars clauses])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-matrix [vars clauses]&amp;lt;br&amp;gt;  (let [cs (partition 2 clauses)&amp;lt;br&amp;gt;        cs (let [[p a] (last cs)]&amp;lt;br&amp;gt;             (if (= :else p)&amp;lt;br&amp;gt;               (do (trace-matrix &amp;quot;Convert :else clause to row of wildcards&amp;quot;)&amp;lt;br&amp;gt;                   (conj (vec (butlast cs)) [(-&amp;gt;&amp;gt; vars (map (fn [_] '_)) vec) a]))&amp;lt;br&amp;gt;               (conj (vec cs) [(-&amp;gt;&amp;gt; vars (map (fn [_] '_)) vec) nil])))&amp;lt;br&amp;gt;        clause-sources (into [] (map emit-clause cs))&amp;lt;br&amp;gt;        vars (vec (map (fn [var]&amp;lt;br&amp;gt;                         (if (not (symbol? var))&amp;lt;br&amp;gt;                           (let [nsym (gensym &amp;quot;ocr-&amp;quot;)&amp;lt;br&amp;gt;                                 _ (trace-dag &amp;quot;Bind ocr&amp;quot; var &amp;quot;to&amp;quot; nsym)]&amp;lt;br&amp;gt;                             (with-meta nsym {:ocr-expr var}))&amp;lt;br&amp;gt;                           var))&amp;lt;br&amp;gt;                     vars))]&amp;lt;br&amp;gt;    (pattern-matrix clause-sources vars)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-matrix</a>[vars clauses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;emit-patterns&lt;/b&gt; ([ps t] [ps t v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-patterns&amp;lt;br&amp;gt;  ([ps t] (emit-patterns ps t []))&amp;lt;br&amp;gt;  ([ps t v]&amp;lt;br&amp;gt;     (if (empty? ps)&amp;lt;br&amp;gt;       v&amp;lt;br&amp;gt;       (let [p (first ps)]&amp;lt;br&amp;gt;         (cond&amp;lt;br&amp;gt;          (= p '&amp;amp;) (let [p (second ps)&amp;lt;br&amp;gt;                         rp (if (and (vector? p) (= t :seq))&amp;lt;br&amp;gt;                              (seq-pattern (emit-patterns p t))&amp;lt;br&amp;gt;                              (emit-pattern p))]&amp;lt;br&amp;gt;                     (recur (nnext ps) t (conj v (rest-pattern rp)))) &amp;lt;br&amp;gt;          :else (recur (next ps) t (conj v (emit-pattern (first ps)))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-patterns</a>[ps t] [ps t v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;empty-matrix?&lt;/b&gt; ([pm])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn empty-matrix? [pm]&amp;lt;br&amp;gt;  (= (dim pm) [0 0]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">empty-matrix?</a>[pm]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;error&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro error [&amp;amp; body]&amp;lt;br&amp;gt;  (if *clojurescript*&amp;lt;br&amp;gt;    `(js/Error. ~@body)&amp;lt;br&amp;gt;    `(Exception. ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">error</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;executable-form&lt;/b&gt; ([node])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn executable-form [node]&amp;lt;br&amp;gt;  (n-to-clj node))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">executable-form</a>[node]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;fail-node&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^FailNode fail-node []&amp;lt;br&amp;gt;  (FailNode.))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fail-node</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;guard-pattern?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn guard-pattern? [x]&amp;lt;br&amp;gt;  (instance? GuardPattern x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">guard-pattern?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;height&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">height</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;insert-row&lt;/b&gt; ([this i row])&lt;br&gt; &lt;/div&gt;" data-placement="right">insert-row</a>[this i row]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;insert-rows&lt;/b&gt; ([this i rows])&lt;br&gt; &lt;/div&gt;" data-placement="right">insert-rows</a>[this i rows]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;leaf-node&lt;/b&gt; ([value] [value bindings])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^LeafNode leaf-node&amp;lt;br&amp;gt;  ([value] (LeafNode. value []))&amp;lt;br&amp;gt;  ([value bindings] (LeafNode. value bindings)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">leaf-node</a>[value] [value bindings]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;literal-pattern&lt;/b&gt; ([l])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^LiteralPattern literal-pattern [l] &amp;lt;br&amp;gt;  (LiteralPattern. l (meta l)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">literal-pattern</a>[l]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;literal-pattern?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn literal-pattern? [x]&amp;lt;br&amp;gt;  (instance? LiteralPattern x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">literal-pattern?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;map-&gt;BindNode&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.core.match.BindNode, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord BindNode [bindings node]&amp;lt;br&amp;gt;  INodeCompile&amp;lt;br&amp;gt;  (n-to-clj [this]&amp;lt;br&amp;gt;    `(let [~@bindings]&amp;lt;br&amp;gt;       ~(n-to-clj node))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->BindNode</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;map-&gt;FailNode&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.core.match.FailNode, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FailNode []&amp;lt;br&amp;gt;  INodeCompile&amp;lt;br&amp;gt;  (n-to-clj [this]&amp;lt;br&amp;gt;    (if *recur-present*&amp;lt;br&amp;gt;      (if @*breadcrumbs*&amp;lt;br&amp;gt;        `(throw (error (str &amp;quot;No match found. &amp;quot; &amp;lt;br&amp;gt;                            &amp;quot;Followed &amp;quot; ~(count *match-breadcrumbs*)  &amp;quot; branches.&amp;quot;&amp;lt;br&amp;gt;                            &amp;quot; Breadcrumbs: &amp;quot; '~*match-breadcrumbs*)))&amp;lt;br&amp;gt;        `(throw (error (str &amp;quot;No match found.&amp;quot;))))&amp;lt;br&amp;gt;      (backtrack-expr))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->FailNode</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;map-&gt;LeafNode&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.core.match.LeafNode, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord LeafNode [value bindings]&amp;lt;br&amp;gt;  INodeCompile&amp;lt;br&amp;gt;  (n-to-clj [this]&amp;lt;br&amp;gt;    (if (not (empty? bindings))&amp;lt;br&amp;gt;      (let [bindings (remove (fn [[sym _]] (= sym '_))&amp;lt;br&amp;gt;                             bindings)]&amp;lt;br&amp;gt;       `(let [~@(apply concat bindings)]&amp;lt;br&amp;gt;          ~value))&amp;lt;br&amp;gt;      value)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->LeafNode</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;map-&gt;SwitchNode&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.core.match.SwitchNode, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord SwitchNode [occurrence cases default]&amp;lt;br&amp;gt;  INodeCompile&amp;lt;br&amp;gt;  (n-to-clj [this]&amp;lt;br&amp;gt;    (let [clauses (doall (mapcat (partial apply dag-clause-to-clj occurrence) cases))&amp;lt;br&amp;gt;          bind-expr (-&amp;gt; occurrence meta :bind-expr)&amp;lt;br&amp;gt;          cond-expr (if *recur-present*&amp;lt;br&amp;gt;                      (doall (concat `(cond ~@clauses)&amp;lt;br&amp;gt;                                     `(:else ~(n-to-clj default))))&amp;lt;br&amp;gt;                      (doall (concat `(cond ~@clauses)&amp;lt;br&amp;gt;                                     `(:else ~(if @*backtrack-with-errors*&amp;lt;br&amp;gt;                                                `(throw (Exception. (str &amp;quot;Could not match&amp;quot; ~occurrence)))&amp;lt;br&amp;gt;                                                (backtrack-expr))))))]&amp;lt;br&amp;gt;      (if *recur-present*&amp;lt;br&amp;gt;        (if bind-expr&amp;lt;br&amp;gt;          `~(doall (concat `(let [~occurrence ~bind-expr]) (list cond-expr)))&amp;lt;br&amp;gt;          `~cond-expr)&amp;lt;br&amp;gt;        (if bind-expr&amp;lt;br&amp;gt;          `(try ~(doall (concat `(let [~occurrence ~bind-expr]) (list cond-expr)))&amp;lt;br&amp;gt;                ~(catch-error (n-to-clj default)))&amp;lt;br&amp;gt;          `(try ~cond-expr&amp;lt;br&amp;gt;                ~(catch-error (n-to-clj default))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->SwitchNode</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;map-occurrence?&lt;/b&gt; ([ocr])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn map-occurrence? [ocr]&amp;lt;br&amp;gt;  (= (-&amp;gt; ocr meta :occurrence-type) :map))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map-occurrence?</a>[ocr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;map-pattern&lt;/b&gt; ([] [m])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^MapPattern map-pattern&amp;lt;br&amp;gt;  ([] (MapPattern. {} nil))&amp;lt;br&amp;gt;  ([m] {:pre [(map? m)]}&amp;lt;br&amp;gt;     (MapPattern. m nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map-pattern</a>[] [m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;map-pattern?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn map-pattern? [x]&amp;lt;br&amp;gt;  (instance? MapPattern x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map-pattern?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;match&lt;/b&gt; ([vars &amp; clauses])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Pattern match a row of occurrences. Take a vector of occurrences, vars.&lt;br&gt;  Clause question-answer syntax is like `cond`. Questions must be&lt;br&gt;  wrapped in a vector, with same arity as vars. Last question can be :else,&lt;br&gt;  which expands to a row of wildcards.&lt;br&gt;  &lt;br&gt;  Example:&lt;br&gt;  (let [x 1&lt;br&gt;        y 2]&lt;br&gt;      (match [x y 3]&lt;br&gt;             [1 2 3] :answer1&lt;br&gt;             :else :default-answer))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro match &amp;lt;br&amp;gt;  &amp;quot;Pattern match a row of occurrences. Take a vector of occurrences, vars.&amp;lt;br&amp;gt;  Clause question-answer syntax is like `cond`. Questions must be&amp;lt;br&amp;gt;  wrapped in a vector, with same arity as vars. Last question can be :else,&amp;lt;br&amp;gt;  which expands to a row of wildcards.&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  Example:&amp;lt;br&amp;gt;  (let [x 1&amp;lt;br&amp;gt;        y 2]&amp;lt;br&amp;gt;      (match [x y 3]&amp;lt;br&amp;gt;             [1 2 3] :answer1&amp;lt;br&amp;gt;             :else :default-answer))&amp;quot;&amp;lt;br&amp;gt;  [vars &amp;amp; clauses]&amp;lt;br&amp;gt;  (let [[vars clauses] (if (vector? vars)&amp;lt;br&amp;gt;                         [vars clauses]&amp;lt;br&amp;gt;                         [(vector vars)&amp;lt;br&amp;gt;                          (mapcat (fn [[c a]]&amp;lt;br&amp;gt;                                    [(if (not= c :else) (vector c) c) a])&amp;lt;br&amp;gt;                                  (partition 2 clauses))])]&amp;lt;br&amp;gt;   (binding [*line* (-&amp;gt; &amp;amp;form meta :line)&amp;lt;br&amp;gt;             *locals* (dissoc &amp;amp;env '_)&amp;lt;br&amp;gt;             *warned* (atom false)]&amp;lt;br&amp;gt;     `~(clj-form vars clauses))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">match</a>[vars & clauses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;match-let&lt;/b&gt; ([bindings &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro match-let [bindings &amp;amp; body]&amp;lt;br&amp;gt;  (let [bindvars# (take-nth 2 bindings)]&amp;lt;br&amp;gt;    `(let ~bindings&amp;lt;br&amp;gt;       (match [~@bindvars#]&amp;lt;br&amp;gt;         ~@body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">match-let</a>[bindings & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;matchv&lt;/b&gt; ([type vars &amp; clauses])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro matchv [type vars &amp;amp; clauses]&amp;lt;br&amp;gt;  (binding [*vector-type* type&amp;lt;br&amp;gt;            *line* (-&amp;gt; &amp;amp;form meta :line)&amp;lt;br&amp;gt;            *locals* (dissoc &amp;amp;env '_)&amp;lt;br&amp;gt;            *warned* (atom false)]&amp;lt;br&amp;gt;    `~(clj-form vars clauses)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">matchv</a>[type vars & clauses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;n-to-clj&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">n-to-clj</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;named-wildcard-pattern?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn named-wildcard-pattern? [x]&amp;lt;br&amp;gt;  (when (instance? WildcardPattern x)&amp;lt;br&amp;gt;    (not= (.sym ^WildcardPattern x) '_)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">named-wildcard-pattern?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;necessary-column&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">necessary-column</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;occurrences&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">occurrences</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;or-pattern?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn or-pattern? [x]&amp;lt;br&amp;gt;  (instance? OrPattern x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">or-pattern?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;pattern&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">pattern</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;pattern-at&lt;/b&gt; ([this i j])&lt;br&gt; &lt;/div&gt;" data-placement="right">pattern-at</a>[this i j]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;pattern-equals&lt;/b&gt; ([a b])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pattern-equals [a b]&amp;lt;br&amp;gt;  (zero? (pattern-compare a b)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pattern-equals</a>[a b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;pattern-matrix&lt;/b&gt; ([rows ocrs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^PatternMatrix pattern-matrix [rows ocrs]&amp;lt;br&amp;gt;  {:pre [(vector rows) &amp;lt;br&amp;gt;         (vector ocrs)]}&amp;lt;br&amp;gt;  (PatternMatrix. rows ocrs nil))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pattern-matrix</a>[rows ocrs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;pattern-row&lt;/b&gt; ([ps action] [ps action bindings])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^PatternRow pattern-row&amp;lt;br&amp;gt;  ([ps action] &amp;lt;br&amp;gt;   {:pre [(vector? ps)]}&amp;lt;br&amp;gt;   (PatternRow. ps action nil))&amp;lt;br&amp;gt;  ([ps action bindings]&amp;lt;br&amp;gt;   {:pre [(vector? ps)]} ;; TODO: what can we expect bindings? (or (nil? bindings) (list? bindings))  ? - Ambrose&amp;lt;br&amp;gt;   (PatternRow. ps action bindings)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pattern-row</a>[ps action] [ps action bindings]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;patterns&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">patterns</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;predicate-pattern?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn predicate-pattern? [x]&amp;lt;br&amp;gt;  (instance? PredicatePattern x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">predicate-pattern?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;prepend&lt;/b&gt; ([this x])&lt;br&gt; &lt;/div&gt;" data-placement="right">prepend</a>[this x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;rest-pattern&lt;/b&gt; ([p])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^RestPattern rest-pattern [p]&amp;lt;br&amp;gt;  (RestPattern. p nil))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rest-pattern</a>[p]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;rest-pattern?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rest-pattern? [x]&amp;lt;br&amp;gt;  (instance? RestPattern x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rest-pattern?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;row&lt;/b&gt; ([this j])&lt;br&gt; &lt;/div&gt;" data-placement="right">row</a>[this j]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;rows&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">rows</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;select&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">select</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;seq-occurrence?&lt;/b&gt; ([ocr])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn seq-occurrence? [ocr]&amp;lt;br&amp;gt;  (= (-&amp;gt; ocr meta :occurrence-type) :seq))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">seq-occurrence?</a>[ocr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;seq-pattern&lt;/b&gt; ([s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^SeqPattern seq-pattern [s]&amp;lt;br&amp;gt;  {:pre [(sequential? s)&amp;lt;br&amp;gt;         (not (empty? s))]}&amp;lt;br&amp;gt;  (SeqPattern. s nil))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">seq-pattern</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;seq-pattern?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn seq-pattern? [x]&amp;lt;br&amp;gt;  (instance? SeqPattern x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">seq-pattern?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;set-breadcrumbs!&lt;/b&gt; ([b])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-breadcrumbs! [b]&amp;lt;br&amp;gt;  (reset! *breadcrumbs* b))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-breadcrumbs!</a>[b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;set-trace!&lt;/b&gt; ([b])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-trace! [b]&amp;lt;br&amp;gt;  (reset! *trace* b))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-trace!</a>[b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;specialize&lt;/b&gt; ([this c rows ocrs])&lt;br&gt; &lt;/div&gt;" data-placement="right">specialize</a>[this c rows ocrs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;specialize-matrix&lt;/b&gt; ([this rows ocrs])&lt;br&gt; &lt;/div&gt;" data-placement="right">specialize-matrix</a>[this rows ocrs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;split&lt;/b&gt; ([this n])&lt;br&gt; &lt;/div&gt;" data-placement="right">split</a>[this n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;swap&lt;/b&gt; ([this n])&lt;br&gt; &lt;/div&gt;" data-placement="right">swap</a>[this n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;switch-node&lt;/b&gt; ([occurrence cases default])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^SwitchNode switch-node&amp;lt;br&amp;gt;  ([occurrence cases default]&amp;lt;br&amp;gt;   {:pre [(sequential? cases)]}&amp;lt;br&amp;gt;   (SwitchNode. occurrence cases default)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">switch-node</a>[occurrence cases default]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;sym&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">sym</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;to-source*&lt;/b&gt; ([this ocr])&lt;br&gt; &lt;/div&gt;" data-placement="right">to-source*</a>[this ocr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;touch&lt;/b&gt; ([vp])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn touch [vp]&amp;lt;br&amp;gt;  (let [meta (meta vp)]&amp;lt;br&amp;gt;    (with-meta vp (assoc meta :touched true))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">touch</a>[vp]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;touch-all-first&lt;/b&gt; ([rows])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn touch-all-first [rows]&amp;lt;br&amp;gt;  (-&amp;gt;&amp;gt; rows&amp;lt;br&amp;gt;       (map (fn [[p &amp;amp; ps :as row]]&amp;lt;br&amp;gt;              (if (not (touched? p))&amp;lt;br&amp;gt;                (assoc row 0 (touch p))&amp;lt;br&amp;gt;                row)))&amp;lt;br&amp;gt;       (into [])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">touch-all-first</a>[rows]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;touched?&lt;/b&gt; ([vp])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn touched? [vp]&amp;lt;br&amp;gt;  (-&amp;gt; vp meta :touched))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">touched?</a>[vp]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;trace-dag&lt;/b&gt; ([&amp; p])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn trace-dag [&amp;amp; p]&amp;lt;br&amp;gt;  (when @*trace*&amp;lt;br&amp;gt;    (apply println &amp;quot;TRACE: DAG:&amp;quot; p)&amp;lt;br&amp;gt;    (flush)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-dag</a>[& p]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;trace-matrix&lt;/b&gt; ([&amp; p])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn trace-matrix [&amp;amp; p]&amp;lt;br&amp;gt;  (when @*trace*&amp;lt;br&amp;gt;    (apply println &amp;quot;TRACE: MATRIX:&amp;quot; p)&amp;lt;br&amp;gt;    (flush)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-matrix</a>[& p]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;update-pattern&lt;/b&gt; ([this i p])&lt;br&gt; &lt;/div&gt;" data-placement="right">update-pattern</a>[this i p]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;useful-matrix&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">useful-matrix</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;useful-p?&lt;/b&gt; ([pm i j])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn useful-p? [pm i j]&amp;lt;br&amp;gt;  (let [p (pattern-at pm i j)]&amp;lt;br&amp;gt;   (cond&amp;lt;br&amp;gt;    (constructor? p) (every? #(not (wildcard-pattern? %))&amp;lt;br&amp;gt;                             (take j (column pm i)))&amp;lt;br&amp;gt;    ;;(wildcard-pattern? p) (not (useful? (drop-nth pm i) j))&amp;lt;br&amp;gt;    ;;IMPORTANT NOTE: this calculation is very very slow,&amp;lt;br&amp;gt;    ;;we should look at this more closely - David&amp;lt;br&amp;gt;    :else false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">useful-p?</a>[pm i j]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;useful?&lt;/b&gt; ([pm j])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn useful? [pm j]&amp;lt;br&amp;gt;  (some #(useful-p? pm % j)&amp;lt;br&amp;gt;        (range (count (row pm j)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">useful?</a>[pm j]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;val-at&lt;/b&gt; ([this k not-found])&lt;br&gt; &lt;/div&gt;" data-placement="right">val-at</a>[this k not-found]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;val-at*&lt;/b&gt; ([m k] [m k not-found])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn val-at*&amp;lt;br&amp;gt;  ([m k] (let [val (val-at m k ::not-found)]&amp;lt;br&amp;gt;           (if (= val ::not-found)&amp;lt;br&amp;gt;             (throw backtrack)&amp;lt;br&amp;gt;             val)))&amp;lt;br&amp;gt;  ([m k not-found] (val-at m k not-found)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">val-at*</a>[m k] [m k not-found]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;val-at-expr&lt;/b&gt; ([&amp; args])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn val-at-expr [&amp;amp; args]&amp;lt;br&amp;gt;  (if *clojurescript* ;;then we need to inline the correct behavior&amp;lt;br&amp;gt;    (if (= 3 (count args))&amp;lt;br&amp;gt;      `(get ~@args)&amp;lt;br&amp;gt;      (let [[m k] args]&amp;lt;br&amp;gt;        `(let [val# (get ~m ~k ::not-found)]&amp;lt;br&amp;gt;           (if (= val# ::not-found)&amp;lt;br&amp;gt;             (throw 0)&amp;lt;br&amp;gt;             val#))))&amp;lt;br&amp;gt;    ;;If not ClojureScript, defer to val-at*&amp;lt;br&amp;gt;    `(val-at* ~@args)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">val-at-expr</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;vector-pattern?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn vector-pattern? [x]&amp;lt;br&amp;gt;  (instance? VectorPattern x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">vector-pattern?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;vector-type&lt;/b&gt; ([t &amp; r])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn vector-type [t &amp;amp; r] t)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">vector-type</a>[t & r]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;warn&lt;/b&gt; ([msg])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn warn [msg]&amp;lt;br&amp;gt;  (if (not @*warned*)&amp;lt;br&amp;gt;    (do&amp;lt;br&amp;gt;      (binding [*out* *err*] &amp;lt;br&amp;gt;        (println &amp;quot;WARNING:&amp;quot;&amp;lt;br&amp;gt;                 (str *ns* &amp;quot;, line &amp;quot; *line* &amp;quot;:&amp;quot;) &amp;lt;br&amp;gt;                 msg))&amp;lt;br&amp;gt;      (reset! *warned* true))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">warn</a>[msg]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;width&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right">width</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;wildcard-pattern&lt;/b&gt; ([] [sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^WildcardPattern wildcard-pattern&amp;lt;br&amp;gt;  ([] (WildcardPattern. '_ nil))&amp;lt;br&amp;gt;  ([sym] &amp;lt;br&amp;gt;     {:pre [(symbol? sym)]}&amp;lt;br&amp;gt;     (if (= sym '_)&amp;lt;br&amp;gt;       (WildcardPattern. (gensym) nil)&amp;lt;br&amp;gt;       (WildcardPattern. sym nil))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wildcard-pattern</a>[] [sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;wildcard-pattern?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wildcard-pattern? [x]&amp;lt;br&amp;gt;  (instance? WildcardPattern x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wildcard-pattern?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.match&lt;/i&gt;&lt;b&gt;with-tag&lt;/b&gt; ([t ocr])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn with-tag [t ocr]&amp;lt;br&amp;gt;  (let [the-tag (tag t)&amp;lt;br&amp;gt;        the-tag (if (.isArray ^Class the-tag)&amp;lt;br&amp;gt;                  (.getName ^Class the-tag)&amp;lt;br&amp;gt;                  the-tag)]&amp;lt;br&amp;gt;    (with-meta ocr (assoc (ocr meta) :tag the-tag))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-tag</a>[t ocr]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.memoize</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;-&gt;PluggableMemoization&lt;/b&gt; ([f cache])&lt;br&gt; Positional factory function for class clojure.core.memoize.PluggableMemoization.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype PluggableMemoization [f cache]&amp;lt;br&amp;gt;  CacheProtocol&amp;lt;br&amp;gt;  (has? [_ item]&amp;lt;br&amp;gt;    (clojure.core.cache/has? cache item))&amp;lt;br&amp;gt;  (hit  [_ item]&amp;lt;br&amp;gt;    (PluggableMemoization. f (clojure.core.cache/hit cache item)))&amp;lt;br&amp;gt;  (miss [_ item result]&amp;lt;br&amp;gt;    (PluggableMemoization. f (clojure.core.cache/miss cache item result)))&amp;lt;br&amp;gt;  (evict [_ key]&amp;lt;br&amp;gt;    (PluggableMemoization. f (clojure.core.cache/evict cache key)))&amp;lt;br&amp;gt;  (lookup [_ item]&amp;lt;br&amp;gt;    (clojure.core.cache/lookup cache item))&amp;lt;br&amp;gt;  (seed [_ base]&amp;lt;br&amp;gt;    (PluggableMemoization. f (clojure.core.cache/seed cache base)))&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [_] (str cache)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->PluggableMemoization</a>[f cache]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;build-memoizer&lt;/b&gt; ([cache-factory f &amp; args])&lt;br&gt; Builds a function that given a function, returns a pluggable memoized&lt;br&gt;   version of it.  `build-memoizer` Takes a cache factory function, a function&lt;br&gt;   to memoize, and the arguments to the factory.  At least one of those&lt;br&gt;   functions should be the function to be memoized.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn build-memoizer&amp;lt;br&amp;gt;  &amp;quot;Builds a function that given a function, returns a pluggable memoized&amp;lt;br&amp;gt;   version of it.  `build-memoizer` Takes a cache factory function, a function&amp;lt;br&amp;gt;   to memoize, and the arguments to the factory.  At least one of those&amp;lt;br&amp;gt;   functions should be the function to be memoized.&amp;quot;&amp;lt;br&amp;gt;  ([cache-factory f &amp;amp; args]&amp;lt;br&amp;gt;     (let [cache (atom (apply cache-factory f args))]&amp;lt;br&amp;gt;       (with-meta&amp;lt;br&amp;gt;        (fn [&amp;amp; args] &amp;lt;br&amp;gt;          (let [cs (swap! cache through* f args)]&amp;lt;br&amp;gt;            @(clojure.core.cache/lookup cs args)))&amp;lt;br&amp;gt;        {:unk cache&amp;lt;br&amp;gt;         :unk-orig f}))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">build-memoizer</a>[cache-factory f & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;memo&lt;/b&gt; ([f] [f seed])&lt;br&gt; Used as a more flexible alternative to Clojure's core `memoization`&lt;br&gt;   function.  Memoized functions built using `memo` will respond to&lt;br&gt;   the core unk manipulable memoization utilities.  As a nice bonus,&lt;br&gt;   you can use `memo` in place of `memoize` without any additional&lt;br&gt;   changes.&lt;br&gt;&lt;br&gt;   The default way to use this function is to simply apply a function&lt;br&gt;   that will be memoized.  Additionally, you may also supply a map&lt;br&gt;   of the form `'{[42] 42, [108] 108}` where keys are a vector &lt;br&gt;   mapping expected argument values to arity positions.  The map values&lt;br&gt;   are the return values of the memoized function.&lt;br&gt;&lt;br&gt;   You can access the memoization cache directly via the `:unk` key&lt;br&gt;   on the memoized function's metadata.  However, it is advised to&lt;br&gt;   use the unk primitives instead as implementation details may&lt;br&gt;   change over time.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn memo&amp;lt;br&amp;gt;  &amp;quot;Used as a more flexible alternative to Clojure's core `memoization`&amp;lt;br&amp;gt;   function.  Memoized functions built using `memo` will respond to&amp;lt;br&amp;gt;   the core unk manipulable memoization utilities.  As a nice bonus,&amp;lt;br&amp;gt;   you can use `memo` in place of `memoize` without any additional&amp;lt;br&amp;gt;   changes.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   The default way to use this function is to simply apply a function&amp;lt;br&amp;gt;   that will be memoized.  Additionally, you may also supply a map&amp;lt;br&amp;gt;   of the form `'{[42] 42, [108] 108}` where keys are a vector &amp;lt;br&amp;gt;   mapping expected argument values to arity positions.  The map values&amp;lt;br&amp;gt;   are the return values of the memoized function.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   You can access the memoization cache directly via the `:unk` key&amp;lt;br&amp;gt;   on the memoized function's metadata.  However, it is advised to&amp;lt;br&amp;gt;   use the unk primitives instead as implementation details may&amp;lt;br&amp;gt;   change over time.&amp;quot;&amp;lt;br&amp;gt;  ([f] (memo f {}))&amp;lt;br&amp;gt;  ([f seed]&amp;lt;br&amp;gt;     (build-memoizer&amp;lt;br&amp;gt;       #(PluggableMemoization. %1 (cache/basic-cache-factory %2))&amp;lt;br&amp;gt;       f&amp;lt;br&amp;gt;       seed)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">memo</a>[f] [f seed]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;memo-clear!&lt;/b&gt; ([f])&lt;br&gt; Reaches into an unk-memoized function and clears the cache.  This is a&lt;br&gt;   destructive operation and should be used with care.&lt;br&gt;&lt;br&gt;   Keep in mind that depending on what other threads or doing, an&lt;br&gt;   immediate call to `snapshot` may not yield an empty cache.  That's&lt;br&gt;   cool though, we've learned to deal with that stuff in Clojure by&lt;br&gt;   now.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn memo-clear!&amp;lt;br&amp;gt;  &amp;quot;Reaches into an unk-memoized function and clears the cache.  This is a&amp;lt;br&amp;gt;   destructive operation and should be used with care.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Keep in mind that depending on what other threads or doing, an&amp;lt;br&amp;gt;   immediate call to `snapshot` may not yield an empty cache.  That's&amp;lt;br&amp;gt;   cool though, we've learned to deal with that stuff in Clojure by&amp;lt;br&amp;gt;   now.&amp;quot;&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (when-let [cache (cache-id f)]&amp;lt;br&amp;gt;    (swap! cache (constantly (clojure.core.cache/seed @cache {})))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">memo-clear!</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;memo-fifo&lt;/b&gt; ([f] [f limit] [f limit base])&lt;br&gt; Works the same as the basic memoization function (i.e. `memo` and `core.memoize` except&lt;br&gt;   when a given threshold is breached.  Observe the following:&lt;br&gt;&lt;br&gt;       (def id (memo-fifo identity 2))&lt;br&gt;       &lt;br&gt;       (id 42)&lt;br&gt;       (id 43)&lt;br&gt;       (snapshot id)&lt;br&gt;       ;=&gt; {[42] 42, [43] 43}&lt;br&gt;&lt;br&gt;   As you see, the limit of `2` has not been breached yet, but if you call again with another&lt;br&gt;   value, then it will:&lt;br&gt;&lt;br&gt;       (id 44)&lt;br&gt;       (snapshot id)&lt;br&gt;       ;=&gt; {[44] 44, [43] 43}&lt;br&gt;&lt;br&gt;   That is, the oldest entry `42` is pushed out of the memoization cache.  This is the standard&lt;br&gt;   **F**irst **I**n **F**irst **O**ut behavior.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn memo-fifo&amp;lt;br&amp;gt;  &amp;quot;Works the same as the basic memoization function (i.e. `memo` and `core.memoize` except&amp;lt;br&amp;gt;   when a given threshold is breached.  Observe the following:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (def id (memo-fifo identity 2))&amp;lt;br&amp;gt;       &amp;lt;br&amp;gt;       (id 42)&amp;lt;br&amp;gt;       (id 43)&amp;lt;br&amp;gt;       (snapshot id)&amp;lt;br&amp;gt;       ;=&amp;gt; {[42] 42, [43] 43}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   As you see, the limit of `2` has not been breached yet, but if you call again with another&amp;lt;br&amp;gt;   value, then it will:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (id 44)&amp;lt;br&amp;gt;       (snapshot id)&amp;lt;br&amp;gt;       ;=&amp;gt; {[44] 44, [43] 43}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   That is, the oldest entry `42` is pushed out of the memoization cache.  This is the standard&amp;lt;br&amp;gt;   **F**irst **I**n **F**irst **O**ut behavior.&amp;quot;&amp;lt;br&amp;gt;  ([f] (memo-fifo f 32 {}))&amp;lt;br&amp;gt;  ([f limit] (memo-fifo f limit {}))&amp;lt;br&amp;gt;  ([f limit base]&amp;lt;br&amp;gt;     (build-memoizer&amp;lt;br&amp;gt;       #(PluggableMemoization. %1 (cache/fifo-cache-factory %3 :threshold %2))&amp;lt;br&amp;gt;       f&amp;lt;br&amp;gt;       limit&amp;lt;br&amp;gt;       base)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">memo-fifo</a>[f] [f limit] [f limit base]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;memo-lru&lt;/b&gt; ([f] [f limit] [f limit base])&lt;br&gt; Works the same as the basic memoization function (i.e. `memo` and `core.memoize` except&lt;br&gt;   when a given threshold is breached.  Observe the following:&lt;br&gt;&lt;br&gt;       (def id (memo-lru identity 2))&lt;br&gt;       &lt;br&gt;       (id 42)&lt;br&gt;       (id 43)&lt;br&gt;       (snapshot id)&lt;br&gt;       ;=&gt; {[42] 42, [43] 43}&lt;br&gt;    &lt;br&gt;   At this point the cache has not yet crossed the set threshold of `2`, but if you execute&lt;br&gt;   yet another call the story will change:&lt;br&gt;&lt;br&gt;       (id 44)&lt;br&gt;       (snapshot id)&lt;br&gt;       ;=&gt; {[44] 44, [43] 43}&lt;br&gt;&lt;br&gt;   At this point the operation of the LRU cache looks exactly the same at the FIFO cache.&lt;br&gt;   However, the difference becomes apparent on further use:&lt;br&gt;&lt;br&gt;       (id 43)&lt;br&gt;       (id 0)&lt;br&gt;       (snapshot id)&lt;br&gt;       ;=&gt; {[0] 0, [43] 43}&lt;br&gt;&lt;br&gt;   As you see, once again calling `id` with the argument `43` will expose the LRU nature&lt;br&gt;   of the underlying cache.  That is, when the threshold is passed, the cache will expel&lt;br&gt;   the **L**east **R**ecently **U**sed element in favor of the new.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn memo-lru&amp;lt;br&amp;gt;  &amp;quot;Works the same as the basic memoization function (i.e. `memo` and `core.memoize` except&amp;lt;br&amp;gt;   when a given threshold is breached.  Observe the following:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (def id (memo-lru identity 2))&amp;lt;br&amp;gt;       &amp;lt;br&amp;gt;       (id 42)&amp;lt;br&amp;gt;       (id 43)&amp;lt;br&amp;gt;       (snapshot id)&amp;lt;br&amp;gt;       ;=&amp;gt; {[42] 42, [43] 43}&amp;lt;br&amp;gt;    &amp;lt;br&amp;gt;   At this point the cache has not yet crossed the set threshold of `2`, but if you execute&amp;lt;br&amp;gt;   yet another call the story will change:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (id 44)&amp;lt;br&amp;gt;       (snapshot id)&amp;lt;br&amp;gt;       ;=&amp;gt; {[44] 44, [43] 43}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   At this point the operation of the LRU cache looks exactly the same at the FIFO cache.&amp;lt;br&amp;gt;   However, the difference becomes apparent on further use:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (id 43)&amp;lt;br&amp;gt;       (id 0)&amp;lt;br&amp;gt;       (snapshot id)&amp;lt;br&amp;gt;       ;=&amp;gt; {[0] 0, [43] 43}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   As you see, once again calling `id` with the argument `43` will expose the LRU nature&amp;lt;br&amp;gt;   of the underlying cache.  That is, when the threshold is passed, the cache will expel&amp;lt;br&amp;gt;   the **L**east **R**ecently **U**sed element in favor of the new.&amp;quot;&amp;lt;br&amp;gt;  ([f] (memo-lru f 32))&amp;lt;br&amp;gt;  ([f limit] (memo-lru f limit {}))&amp;lt;br&amp;gt;  ([f limit base]&amp;lt;br&amp;gt;     (build-memoizer&amp;lt;br&amp;gt;       #(PluggableMemoization. %1 (cache/lru-cache-factory %3 :threshold %2))&amp;lt;br&amp;gt;       f&amp;lt;br&amp;gt;       limit&amp;lt;br&amp;gt;       base)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">memo-lru</a>[f] [f limit] [f limit base]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;memo-lu&lt;/b&gt; ([f] [f limit] [f limit base])&lt;br&gt; Similar to the implementation of memo-lru, except that this function removes all cache&lt;br&gt;   values whose usage value is smallest.&lt;br&gt;&lt;br&gt;       (def id (memo-lu identity 3))&lt;br&gt;   &lt;br&gt;       (id 42)&lt;br&gt;       (id 42)&lt;br&gt;       (id 43)&lt;br&gt;       (id 44)&lt;br&gt;       (snapshot id)&lt;br&gt;       ;=&gt; {[44] 44, [42] 42}&lt;br&gt;&lt;br&gt;   The **L**east **U**sed values are cleared on cache misses.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn memo-lu&amp;lt;br&amp;gt;  &amp;quot;Similar to the implementation of memo-lru, except that this function removes all cache&amp;lt;br&amp;gt;   values whose usage value is smallest.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (def id (memo-lu identity 3))&amp;lt;br&amp;gt;   &amp;lt;br&amp;gt;       (id 42)&amp;lt;br&amp;gt;       (id 42)&amp;lt;br&amp;gt;       (id 43)&amp;lt;br&amp;gt;       (id 44)&amp;lt;br&amp;gt;       (snapshot id)&amp;lt;br&amp;gt;       ;=&amp;gt; {[44] 44, [42] 42}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   The **L**east **U**sed values are cleared on cache misses.&amp;quot;&amp;lt;br&amp;gt;  ([f] (memo-lu f 32))&amp;lt;br&amp;gt;  ([f limit] (memo-lu f limit {}))&amp;lt;br&amp;gt;  ([f limit base]&amp;lt;br&amp;gt;     (build-memoizer&amp;lt;br&amp;gt;       #(PluggableMemoization. %1 (cache/lu-cache-factory %3 :threshold %2))&amp;lt;br&amp;gt;       f&amp;lt;br&amp;gt;       limit&amp;lt;br&amp;gt;       base)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">memo-lu</a>[f] [f limit] [f limit base]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;memo-swap!&lt;/b&gt; ([f base])&lt;br&gt; Takes an unk-populated function and a map and replaces the memoization cache&lt;br&gt;   with the supplied map.  This is potentially some serious voodoo,&lt;br&gt;   since you can effectively change the semantics of a function on the fly.&lt;br&gt;&lt;br&gt;       (def id (memo identity))&lt;br&gt;       (memo-swap! id '{[13] :omg})&lt;br&gt;       (id 13)&lt;br&gt;       ;=&gt; :omg&lt;br&gt;&lt;br&gt;   With great power comes ... yadda yadda yadda.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn memo-swap!&amp;lt;br&amp;gt;  &amp;quot;Takes an unk-populated function and a map and replaces the memoization cache&amp;lt;br&amp;gt;   with the supplied map.  This is potentially some serious voodoo,&amp;lt;br&amp;gt;   since you can effectively change the semantics of a function on the fly.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (def id (memo identity))&amp;lt;br&amp;gt;       (memo-swap! id '{[13] :omg})&amp;lt;br&amp;gt;       (id 13)&amp;lt;br&amp;gt;       ;=&amp;gt; :omg&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   With great power comes ... yadda yadda yadda.&amp;quot;&amp;lt;br&amp;gt;  [f base]&amp;lt;br&amp;gt;  (when-let [cache (cache-id f)]&amp;lt;br&amp;gt;    (swap! cache&amp;lt;br&amp;gt;           (constantly (clojure.core.cache/seed @cache&amp;lt;br&amp;gt;                             (into {}&amp;lt;br&amp;gt;                                   (for [[k v] base]&amp;lt;br&amp;gt;                                     [k (reify&amp;lt;br&amp;gt;                                          clojure.lang.IDeref&amp;lt;br&amp;gt;                                          (deref [this] v))])))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">memo-swap!</a>[f base]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;memo-ttl&lt;/b&gt; ([f] [f limit] [f limit base])&lt;br&gt; Unlike many of the other unk memoization functions, `memo-ttl`'s cache policy is time-based&lt;br&gt;   rather than algortihmic or explicit.  When memoizing a function using `memo-ttl` you should&lt;br&gt;   should provide a **T**ime **T**o **L**ive parameter in milliseconds.&lt;br&gt;&lt;br&gt;       (def id (memo-ttl identity 5000))&lt;br&gt;   &lt;br&gt;       (id 42)&lt;br&gt;       (snapshot id)&lt;br&gt;       ;=&gt; {[42] 42}&lt;br&gt;   &lt;br&gt;       ... wait 5 seconds ...&lt;br&gt;       (id 43)&lt;br&gt;       (snapshot id)&lt;br&gt;       ;=&gt; {[43] 43}&lt;br&gt;&lt;br&gt;   The expired cache entries will be removed on each cache miss.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn memo-ttl&amp;lt;br&amp;gt;  &amp;quot;Unlike many of the other unk memoization functions, `memo-ttl`'s cache policy is time-based&amp;lt;br&amp;gt;   rather than algortihmic or explicit.  When memoizing a function using `memo-ttl` you should&amp;lt;br&amp;gt;   should provide a **T**ime **T**o **L**ive parameter in milliseconds.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       (def id (memo-ttl identity 5000))&amp;lt;br&amp;gt;   &amp;lt;br&amp;gt;       (id 42)&amp;lt;br&amp;gt;       (snapshot id)&amp;lt;br&amp;gt;       ;=&amp;gt; {[42] 42}&amp;lt;br&amp;gt;   &amp;lt;br&amp;gt;       ... wait 5 seconds ...&amp;lt;br&amp;gt;       (id 43)&amp;lt;br&amp;gt;       (snapshot id)&amp;lt;br&amp;gt;       ;=&amp;gt; {[43] 43}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   The expired cache entries will be removed on each cache miss.&amp;quot;&amp;lt;br&amp;gt;  ([f] (memo-ttl f 3000 {}))&amp;lt;br&amp;gt;  ([f limit] (memo-ttl f limit {}))&amp;lt;br&amp;gt;  ([f limit base]&amp;lt;br&amp;gt;     (build-memoizer&amp;lt;br&amp;gt;       #(PluggableMemoization. %1 (cache/ttl-cache-factory %3 :ttl %2))&amp;lt;br&amp;gt;       f&amp;lt;br&amp;gt;       limit&amp;lt;br&amp;gt;       {})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">memo-ttl</a>[f] [f limit] [f limit base]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;memo-unwrap&lt;/b&gt; ([f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn memo-unwrap&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (:unk-orig (meta f)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">memo-unwrap</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;memoized?&lt;/b&gt; ([f])&lt;br&gt; Returns true if a function has an unk-placed cache, false otherwise.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn memoized?&amp;lt;br&amp;gt;  &amp;quot;Returns true if a function has an unk-placed cache, false otherwise.&amp;quot;&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (boolean (:unk (meta f))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">memoized?</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;snapshot&lt;/b&gt; ([memoized-fn])&lt;br&gt; Returns a snapshot of an unk-placed memoization cache.  By snapshot&lt;br&gt;   you can infer that what you get is only the cache contents at a&lt;br&gt;   moment in time.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn snapshot&amp;lt;br&amp;gt;  &amp;quot;Returns a snapshot of an unk-placed memoization cache.  By snapshot&amp;lt;br&amp;gt;   you can infer that what you get is only the cache contents at a&amp;lt;br&amp;gt;   moment in time.&amp;quot;&amp;lt;br&amp;gt;  [memoized-fn]&amp;lt;br&amp;gt;  (when-let [cache (:unk (meta memoized-fn))]&amp;lt;br&amp;gt;    (into {}&amp;lt;br&amp;gt;          (for [[k v] (.cache @cache)]&amp;lt;br&amp;gt;            [(vec k) @v]))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">snapshot</a>[memoized-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.memoize&lt;/i&gt;&lt;b&gt;through*&lt;/b&gt; ([cache f item])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn through* [cache f item]&amp;lt;br&amp;gt;  &amp;quot;The basic hit/miss logic for the cache system based on `core.cache/through`.&amp;lt;br&amp;gt;  Clojure delays are used to hold the cache value.&amp;quot;&amp;lt;br&amp;gt;  (clojure.core.cache/through&amp;lt;br&amp;gt;    #(delay (%1 %2))&amp;lt;br&amp;gt;    #(clojure.core/apply f %)&amp;lt;br&amp;gt;    cache&amp;lt;br&amp;gt;    item))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">through*</a>[cache f item]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.protocols</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.protocols&lt;/i&gt;&lt;b&gt;coll-reduce&lt;/b&gt; ([coll f] [coll f val])&lt;br&gt; &lt;/div&gt;" data-placement="right">coll-reduce</a>[coll f] [coll f val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.protocols&lt;/i&gt;&lt;b&gt;emit-array-impls&lt;/b&gt; ([&amp; syms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro emit-array-impls&amp;lt;br&amp;gt;  [&amp;amp; syms]&amp;lt;br&amp;gt;  `(extend-protocol InternalReduce&amp;lt;br&amp;gt;     ~@(emit-array-impls* syms)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-array-impls</a>[& syms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.protocols&lt;/i&gt;&lt;b&gt;internal-reduce&lt;/b&gt; ([seq f start])&lt;br&gt; &lt;/div&gt;" data-placement="right">internal-reduce</a>[seq f start]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.protocols&lt;/i&gt;&lt;b&gt;kv-reduce&lt;/b&gt; ([amap f init])&lt;br&gt; &lt;/div&gt;" data-placement="right">kv-reduce</a>[amap f init]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.reducers</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;-&gt;Cat&lt;/b&gt; ([cnt left right])&lt;br&gt; Positional factory function for class clojure.core.reducers.Cat.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype Cat [cnt left right]&amp;lt;br&amp;gt;  clojure.lang.Counted&amp;lt;br&amp;gt;  (count [_] cnt)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.Seqable&amp;lt;br&amp;gt;  (seq [_] (concat (seq left) (seq right)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.core.protocols/CollReduce&amp;lt;br&amp;gt;  (coll-reduce [this f1] (clojure.core.protocols/coll-reduce this f1 (f1)))&amp;lt;br&amp;gt;  (coll-reduce&amp;lt;br&amp;gt;   [_  f1 init]&amp;lt;br&amp;gt;   (clojure.core.protocols/coll-reduce&amp;lt;br&amp;gt;    right f1&amp;lt;br&amp;gt;    (clojure.core.protocols/coll-reduce left f1 init)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  CollFold&amp;lt;br&amp;gt;  (coll-fold&amp;lt;br&amp;gt;   [_ n combinef reducef]&amp;lt;br&amp;gt;   (fjinvoke&amp;lt;br&amp;gt;    (fn []&amp;lt;br&amp;gt;      (let [rt (fjfork (fjtask #(coll-fold right n combinef reducef)))]&amp;lt;br&amp;gt;        (combinef&amp;lt;br&amp;gt;         (coll-fold left n combinef reducef)&amp;lt;br&amp;gt;         (fjjoin rt)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Cat</a>[cnt left right]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;append!&lt;/b&gt; ([acc x])&lt;br&gt; .adds x to acc and returns acc&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn append!&amp;lt;br&amp;gt;  &amp;quot;.adds x to acc and returns acc&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [^java.util.Collection acc x]&amp;lt;br&amp;gt;  (doto acc (.add x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">append!</a>[acc x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;cat&lt;/b&gt; ([] [ctor] [left right])&lt;br&gt; A high-performance combining fn that yields the catenation of the&lt;br&gt;  reduced values. The result is reducible, foldable, seqable and&lt;br&gt;  counted, providing the identity collections are reducible, seqable&lt;br&gt;  and counted. The single argument version will build a combining fn&lt;br&gt;  with the supplied identity constructor. Tests for identity&lt;br&gt;  with (zero? (count x)). See also foldcat.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cat&amp;lt;br&amp;gt;  &amp;quot;A high-performance combining fn that yields the catenation of the&amp;lt;br&amp;gt;  reduced values. The result is reducible, foldable, seqable and&amp;lt;br&amp;gt;  counted, providing the identity collections are reducible, seqable&amp;lt;br&amp;gt;  and counted. The single argument version will build a combining fn&amp;lt;br&amp;gt;  with the supplied identity constructor. Tests for identity&amp;lt;br&amp;gt;  with (zero? (count x)). See also foldcat.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  ([] (java.util.ArrayList.))&amp;lt;br&amp;gt;  ([ctor]&amp;lt;br&amp;gt;     (fn&amp;lt;br&amp;gt;       ([] (ctor))&amp;lt;br&amp;gt;       ([left right] (cat left right))))&amp;lt;br&amp;gt;  ([left right]&amp;lt;br&amp;gt;     (cond&amp;lt;br&amp;gt;      (zero? (count left)) right&amp;lt;br&amp;gt;      (zero? (count right)) left&amp;lt;br&amp;gt;      :else&amp;lt;br&amp;gt;      (Cat. (+ (count left) (count right)) left right))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cat</a>[] [ctor] [left right]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;coll-fold&lt;/b&gt; ([coll n combinef reducef])&lt;br&gt; &lt;/div&gt;" data-placement="right">coll-fold</a>[coll n combinef reducef]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;drop&lt;/b&gt; ([n] [n coll])&lt;br&gt; Elides the first n values from the reduction of coll.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcurried drop&amp;lt;br&amp;gt;  &amp;quot;Elides the first n values from the reduction of coll.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [n coll]&amp;lt;br&amp;gt;  (reducer coll&amp;lt;br&amp;gt;   (fn [f1]&amp;lt;br&amp;gt;     (let [cnt (atom n)]&amp;lt;br&amp;gt;       (rfn [f1 k]&amp;lt;br&amp;gt;         ([ret k v]&amp;lt;br&amp;gt;            (swap! cnt dec)&amp;lt;br&amp;gt;            (if (neg? @cnt)&amp;lt;br&amp;gt;              (f1 ret k v)&amp;lt;br&amp;gt;              ret)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">drop</a>[n] [n coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;filter&lt;/b&gt; ([pred] [pred coll])&lt;br&gt; Retains values in the reduction of coll for which (pred val)&lt;br&gt;  returns logical true. Foldable.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcurried filter&amp;lt;br&amp;gt;  &amp;quot;Retains values in the reduction of coll for which (pred val)&amp;lt;br&amp;gt;  returns logical true. Foldable.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [pred coll]&amp;lt;br&amp;gt;  (folder coll&amp;lt;br&amp;gt;   (fn [f1]&amp;lt;br&amp;gt;     (rfn [f1 k]&amp;lt;br&amp;gt;          ([ret k v]&amp;lt;br&amp;gt;             (if (pred k v)&amp;lt;br&amp;gt;               (f1 ret k v)&amp;lt;br&amp;gt;               ret))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">filter</a>[pred] [pred coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;fjtask&lt;/b&gt; ([f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;   (defn fjtask [^Callable f]&amp;lt;br&amp;gt;     (java.util.concurrent.ForkJoinTask/adapt f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fjtask</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;flatten&lt;/b&gt; ([] [coll])&lt;br&gt; Takes any nested combination of sequential things (lists, vectors,&lt;br&gt;  etc.) and returns their contents as a single, flat foldable&lt;br&gt;  collection.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcurried flatten&amp;lt;br&amp;gt;  &amp;quot;Takes any nested combination of sequential things (lists, vectors,&amp;lt;br&amp;gt;  etc.) and returns their contents as a single, flat foldable&amp;lt;br&amp;gt;  collection.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;  (folder coll&amp;lt;br&amp;gt;   (fn [f1]&amp;lt;br&amp;gt;     (fn&amp;lt;br&amp;gt;       ([] (f1))&amp;lt;br&amp;gt;       ([ret v]&amp;lt;br&amp;gt;          (if (sequential? v)&amp;lt;br&amp;gt;            (clojure.core.protocols/coll-reduce (flatten v) f1 ret)&amp;lt;br&amp;gt;            (f1 ret v)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">flatten</a>[] [coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;fold&lt;/b&gt; ([reducef coll] [combinef reducef coll] [n combinef reducef coll])&lt;br&gt; Reduces a collection using a (potentially parallel) reduce-combine&lt;br&gt;  strategy. The collection is partitioned into groups of approximately&lt;br&gt;  n (default 512), each of which is reduced with reducef (with a seed&lt;br&gt;  value obtained by calling (combinef) with no arguments). The results&lt;br&gt;  of these reductions are then reduced with combinef (default&lt;br&gt;  reducef). combinef must be associative, and, when called with no&lt;br&gt;  arguments, (combinef) must produce its identity element. These&lt;br&gt;  operations may be performed in parallel, but the results will&lt;br&gt;  preserve order.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fold&amp;lt;br&amp;gt;  &amp;quot;Reduces a collection using a (potentially parallel) reduce-combine&amp;lt;br&amp;gt;  strategy. The collection is partitioned into groups of approximately&amp;lt;br&amp;gt;  n (default 512), each of which is reduced with reducef (with a seed&amp;lt;br&amp;gt;  value obtained by calling (combinef) with no arguments). The results&amp;lt;br&amp;gt;  of these reductions are then reduced with combinef (default&amp;lt;br&amp;gt;  reducef). combinef must be associative, and, when called with no&amp;lt;br&amp;gt;  arguments, (combinef) must produce its identity element. These&amp;lt;br&amp;gt;  operations may be performed in parallel, but the results will&amp;lt;br&amp;gt;  preserve order.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  ([reducef coll] (fold reducef reducef coll))&amp;lt;br&amp;gt;  ([combinef reducef coll] (fold 512 combinef reducef coll))&amp;lt;br&amp;gt;  ([n combinef reducef coll]&amp;lt;br&amp;gt;     (coll-fold coll n combinef reducef)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fold</a>[reducef coll] [combinef reducef coll] [n combinef reducef coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;foldcat&lt;/b&gt; ([coll])&lt;br&gt; Equivalent to (fold cat append! coll)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn foldcat&amp;lt;br&amp;gt;  &amp;quot;Equivalent to (fold cat append! coll)&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;  (fold cat append! coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">foldcat</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;folder&lt;/b&gt; ([coll xf])&lt;br&gt; Given a foldable collection, and a transformation function xf,&lt;br&gt;  returns a foldable collection, where any supplied reducing&lt;br&gt;  fn will be transformed by xf. xf is a function of reducing fn to&lt;br&gt;  reducing fn.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn folder&amp;lt;br&amp;gt;  &amp;quot;Given a foldable collection, and a transformation function xf,&amp;lt;br&amp;gt;  returns a foldable collection, where any supplied reducing&amp;lt;br&amp;gt;  fn will be transformed by xf. xf is a function of reducing fn to&amp;lt;br&amp;gt;  reducing fn.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  ([coll xf]&amp;lt;br&amp;gt;     (reify&amp;lt;br&amp;gt;      clojure.core.protocols/CollReduce&amp;lt;br&amp;gt;      (coll-reduce [_ f1]&amp;lt;br&amp;gt;                   (clojure.core.protocols/coll-reduce coll (xf f1) (f1)))&amp;lt;br&amp;gt;      (coll-reduce [_ f1 init]&amp;lt;br&amp;gt;                   (clojure.core.protocols/coll-reduce coll (xf f1) init))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      CollFold&amp;lt;br&amp;gt;      (coll-fold [_ n combinef reducef]&amp;lt;br&amp;gt;                 (coll-fold coll n combinef (xf reducef))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">folder</a>[coll xf]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;map&lt;/b&gt; ([f] [f coll])&lt;br&gt; Applies f to every value in the reduction of coll. Foldable.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcurried map&amp;lt;br&amp;gt;  &amp;quot;Applies f to every value in the reduction of coll. Foldable.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [f coll]&amp;lt;br&amp;gt;  (folder coll&amp;lt;br&amp;gt;   (fn [f1]&amp;lt;br&amp;gt;     (rfn [f1 k]&amp;lt;br&amp;gt;          ([ret k v]&amp;lt;br&amp;gt;             (f1 ret (f k v)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map</a>[f] [f coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;mapcat&lt;/b&gt; ([f] [f coll])&lt;br&gt; Applies f to every value in the reduction of coll, concatenating the result&lt;br&gt;  colls of (f val). Foldable.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcurried mapcat&amp;lt;br&amp;gt;  &amp;quot;Applies f to every value in the reduction of coll, concatenating the result&amp;lt;br&amp;gt;  colls of (f val). Foldable.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [f coll]&amp;lt;br&amp;gt;  (folder coll&amp;lt;br&amp;gt;   (fn [f1]&amp;lt;br&amp;gt;     (rfn [f1 k]&amp;lt;br&amp;gt;          ([ret k v]&amp;lt;br&amp;gt;             (reduce f1 ret (f k v)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mapcat</a>[f] [f coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;monoid&lt;/b&gt; ([op ctor])&lt;br&gt; Builds a combining fn out of the supplied operator and identity&lt;br&gt;  constructor. op must be associative and ctor called with no args&lt;br&gt;  must return an identity value for it.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn monoid&amp;lt;br&amp;gt;  &amp;quot;Builds a combining fn out of the supplied operator and identity&amp;lt;br&amp;gt;  constructor. op must be associative and ctor called with no args&amp;lt;br&amp;gt;  must return an identity value for it.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [op ctor]&amp;lt;br&amp;gt;  (fn m&amp;lt;br&amp;gt;    ([] (ctor))&amp;lt;br&amp;gt;    ([a b] (op a b))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">monoid</a>[op ctor]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;reduce&lt;/b&gt; ([f coll] [f init coll])&lt;br&gt; Like core/reduce except:&lt;br&gt;     When init is not provided, (f) is used.&lt;br&gt;     Maps are reduced with reduce-kv&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reduce&amp;lt;br&amp;gt;  &amp;quot;Like core/reduce except:&amp;lt;br&amp;gt;     When init is not provided, (f) is used.&amp;lt;br&amp;gt;     Maps are reduced with reduce-kv&amp;quot;&amp;lt;br&amp;gt;  ([f coll] (reduce f (f) coll))&amp;lt;br&amp;gt;  ([f init coll]&amp;lt;br&amp;gt;     (if (instance? java.util.Map coll)&amp;lt;br&amp;gt;       (clojure.core.protocols/kv-reduce coll f init)&amp;lt;br&amp;gt;       (clojure.core.protocols/coll-reduce coll f init))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reduce</a>[f coll] [f init coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;reducer&lt;/b&gt; ([coll xf])&lt;br&gt; Given a reducible collection, and a transformation function xf,&lt;br&gt;  returns a reducible collection, where any supplied reducing&lt;br&gt;  fn will be transformed by xf. xf is a function of reducing fn to&lt;br&gt;  reducing fn.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reducer&amp;lt;br&amp;gt;  &amp;quot;Given a reducible collection, and a transformation function xf,&amp;lt;br&amp;gt;  returns a reducible collection, where any supplied reducing&amp;lt;br&amp;gt;  fn will be transformed by xf. xf is a function of reducing fn to&amp;lt;br&amp;gt;  reducing fn.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  ([coll xf]&amp;lt;br&amp;gt;     (reify&amp;lt;br&amp;gt;      clojure.core.protocols/CollReduce&amp;lt;br&amp;gt;      (coll-reduce [this f1]&amp;lt;br&amp;gt;                   (clojure.core.protocols/coll-reduce this f1 (f1)))&amp;lt;br&amp;gt;      (coll-reduce [_ f1 init]&amp;lt;br&amp;gt;                   (clojure.core.protocols/coll-reduce coll (xf f1) init)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reducer</a>[coll xf]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;remove&lt;/b&gt; ([pred] [pred coll])&lt;br&gt; Removes values in the reduction of coll for which (pred val)&lt;br&gt;  returns logical true. Foldable.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcurried remove&amp;lt;br&amp;gt;  &amp;quot;Removes values in the reduction of coll for which (pred val)&amp;lt;br&amp;gt;  returns logical true. Foldable.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [pred coll]&amp;lt;br&amp;gt;  (filter (complement pred) coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove</a>[pred] [pred coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;take&lt;/b&gt; ([n] [n coll])&lt;br&gt; Ends the reduction of coll after consuming n values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcurried take&amp;lt;br&amp;gt;  &amp;quot;Ends the reduction of coll after consuming n values.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [n coll]&amp;lt;br&amp;gt;  (reducer coll&amp;lt;br&amp;gt;   (fn [f1]&amp;lt;br&amp;gt;     (let [cnt (atom n)]&amp;lt;br&amp;gt;       (rfn [f1 k]&amp;lt;br&amp;gt;         ([ret k v]&amp;lt;br&amp;gt;            (swap! cnt dec)&amp;lt;br&amp;gt;            (if (neg? @cnt)&amp;lt;br&amp;gt;              (reduced ret)&amp;lt;br&amp;gt;              (f1 ret k v))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">take</a>[n] [n coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.reducers&lt;/i&gt;&lt;b&gt;take-while&lt;/b&gt; ([pred] [pred coll])&lt;br&gt; Ends the reduction of coll when (pred val) returns logical false.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defcurried take-while&amp;lt;br&amp;gt;  &amp;quot;Ends the reduction of coll when (pred val) returns logical false.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [pred coll]&amp;lt;br&amp;gt;  (reducer coll&amp;lt;br&amp;gt;   (fn [f1]&amp;lt;br&amp;gt;     (rfn [f1 k]&amp;lt;br&amp;gt;          ([ret k v]&amp;lt;br&amp;gt;             (if (pred k v)&amp;lt;br&amp;gt;               (f1 ret k v)&amp;lt;br&amp;gt;               (reduced ret)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">take-while</a>[pred] [pred coll]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.typed</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;AndFilter&lt;/b&gt; ([fs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord AndFilter [fs]&amp;lt;br&amp;gt;  &amp;quot;Logical conjunction of filters&amp;quot;&amp;lt;br&amp;gt;  [(set? fs)&amp;lt;br&amp;gt;   (seq fs)&amp;lt;br&amp;gt;   (every? Filter? fs)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->AndFilter</a>[fs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;AnyValue&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord AnyValue []&amp;lt;br&amp;gt;  &amp;quot;Any Value&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->AnyValue</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;App&lt;/b&gt; ([rator rands])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord App [rator rands]&amp;lt;br&amp;gt;  &amp;quot;An application of a polymorphic type to type arguments&amp;quot;&amp;lt;br&amp;gt;  [(Type? rator)&amp;lt;br&amp;gt;   (every? Type? rands)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->App</a>[rator rands]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;ArrayCLJS&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ArrayCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive array in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->ArrayCLJS</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;B&lt;/b&gt; ([idx])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord B [idx]&amp;lt;br&amp;gt;  &amp;quot;A bound variable. Should not appear outside this file&amp;quot;&amp;lt;br&amp;gt;  [(nat? idx)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->B</a>[idx]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;BooleanCLJS&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord BooleanCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive boolean in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->BooleanCLJS</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;BotFilter&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord BotFilter []&amp;lt;br&amp;gt;  &amp;quot;Always false proposition&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->BotFilter</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Bounds&lt;/b&gt; ([upper-bound lower-bound higher-kind])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Bounds [upper-bound lower-bound higher-kind]&amp;lt;br&amp;gt;  &amp;quot;A type bound or higher-kind bound on a variable&amp;quot;&amp;lt;br&amp;gt;  [(some-fn (and (every? (some-fn Type? Scope?) [upper-bound lower-bound])&amp;lt;br&amp;gt;                 (nil? higher-kind))&amp;lt;br&amp;gt;            (and (every? nil? [upper-bound lower-bound])&amp;lt;br&amp;gt;                 (TypeFn? higher-kind)))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Bounds</a>[upper-bound lower-bound higher-kind]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;ClassPE&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ClassPE []&amp;lt;br&amp;gt;  &amp;quot;A path calling clojure.core/class&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->ClassPE</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;CountPE&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord CountPE []&amp;lt;br&amp;gt;  &amp;quot;A path calling clojure.core/count&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->CountPE</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;CountRange&lt;/b&gt; ([lower upper])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord CountRange [lower upper]&amp;lt;br&amp;gt;  &amp;quot;A sequence of count between lower and upper.&amp;lt;br&amp;gt;  If upper is nil, between lower and infinity.&amp;quot;&amp;lt;br&amp;gt;  [(nat? lower)&amp;lt;br&amp;gt;   (or (nil? upper)&amp;lt;br&amp;gt;       (and (nat? upper)&amp;lt;br&amp;gt;            (&amp;lt;= lower upper)))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->CountRange</a>[lower upper]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;DataType&lt;/b&gt; ([the-class variances poly? fields])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord DataType [the-class variances poly? fields]&amp;lt;br&amp;gt;  &amp;quot;A Clojure datatype&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? variances)&amp;lt;br&amp;gt;       (and (seq variances)&amp;lt;br&amp;gt;            (every? variance? variances)))&amp;lt;br&amp;gt;   (or (nil? poly?)&amp;lt;br&amp;gt;       (and (seq poly?)&amp;lt;br&amp;gt;            (every? Type? poly?)))&amp;lt;br&amp;gt;   (symbol? the-class)&amp;lt;br&amp;gt;   ((array-map-c? symbol? (some-fn Scope? Type?)) fields)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->DataType</a>[the-class variances poly? fields]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;DottedPretype&lt;/b&gt; ([pre-type name])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord DottedPretype [pre-type name]&amp;lt;br&amp;gt;  &amp;quot;A dotted pre-type. Not a type&amp;quot;&amp;lt;br&amp;gt;  [(Type? pre-type)&amp;lt;br&amp;gt;   ((some-fn symbol? nat?) name)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->DottedPretype</a>[pre-type name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;EmptyObject&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord EmptyObject []&amp;lt;br&amp;gt;  &amp;quot;?&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->EmptyObject</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;F&lt;/b&gt; ([name])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord F [name]&amp;lt;br&amp;gt;  &amp;quot;A named free variable&amp;quot;&amp;lt;br&amp;gt;  [(symbol? name)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->F</a>[name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;FilterSet&lt;/b&gt; ([then else])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FilterSet [then else]&amp;lt;br&amp;gt;  &amp;quot;A set of filters: those true when the expression is a true value, and &amp;lt;br&amp;gt;  those when it is a false value.&amp;quot;&amp;lt;br&amp;gt;  [(and (or (BotFilter? then)&amp;lt;br&amp;gt;            (and (BotFilter? else)&amp;lt;br&amp;gt;               (TopFilter? then))&amp;lt;br&amp;gt;            (Filter? then))&amp;lt;br&amp;gt;        (or (BotFilter? else)&amp;lt;br&amp;gt;            (and (BotFilter? then)&amp;lt;br&amp;gt;                 (TopFilter? else))&amp;lt;br&amp;gt;            (Filter? else)))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->FilterSet</a>[then else]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;FirstPE&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FirstPE []&amp;lt;br&amp;gt;  &amp;quot;A path calling clojure.core/first&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->FirstPE</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;FlowSet&lt;/b&gt; ([normal])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FlowSet [normal]&amp;lt;br&amp;gt;  &amp;quot;The filter that is true when an expression returns normally ie. not an exception.&amp;quot;&amp;lt;br&amp;gt;  [(Filter? normal)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->FlowSet</a>[normal]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;FnIntersection&lt;/b&gt; ([types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FnIntersection [types]&amp;lt;br&amp;gt;  &amp;quot;An ordered intersection of Functions.&amp;quot;&amp;lt;br&amp;gt;  [(seq types)&amp;lt;br&amp;gt;   (sequential? types)&amp;lt;br&amp;gt;   (every? Function? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->FnIntersection</a>[types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;FnResult&lt;/b&gt; ([args kws rest drest body])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FnResult [args kws rest drest body]&amp;lt;br&amp;gt;  &amp;quot;Results of checking a fn method&amp;quot;&amp;lt;br&amp;gt;  [(every? symbol? (map first args))&amp;lt;br&amp;gt;   (every? Type? (map second args))&amp;lt;br&amp;gt;   (nil? kws)&amp;lt;br&amp;gt;   ((some-fn nil? (hvector-c? symbol? Type?)) rest)&amp;lt;br&amp;gt;   (nil? drest)&amp;lt;br&amp;gt;   (TCResult? body)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->FnResult</a>[args kws rest drest body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Function&lt;/b&gt; ([dom rng rest drest kws])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Function [dom rng rest drest kws]&amp;lt;br&amp;gt;  &amp;quot;A function arity, must be part of an intersection&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? dom)&amp;lt;br&amp;gt;       (sequential? dom))&amp;lt;br&amp;gt;   (every? Type? dom)&amp;lt;br&amp;gt;   (Result? rng)&amp;lt;br&amp;gt;   ;at most one of rest drest or kws can be provided&amp;lt;br&amp;gt;   (#{0 1} (count (filter identity [rest drest kws])))&amp;lt;br&amp;gt;   (or (nil? rest)&amp;lt;br&amp;gt;       (Type? rest))&amp;lt;br&amp;gt;   (or (nil? drest)&amp;lt;br&amp;gt;       (DottedPretype? drest))&amp;lt;br&amp;gt;   (or (nil? kws)&amp;lt;br&amp;gt;       (KwArgs? kws))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Function</a>[dom rng rest drest kws]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;FunctionCLJS&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FunctionCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive function in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->FunctionCLJS</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;GTRange&lt;/b&gt; ([n])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord GTRange [n]&amp;lt;br&amp;gt;  &amp;quot;The type of all numbers greater than n&amp;quot;&amp;lt;br&amp;gt;  [(number? n)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->GTRange</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;HeterogeneousList&lt;/b&gt; ([types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord HeterogeneousList [types]&amp;lt;br&amp;gt;  &amp;quot;A constant list, clojure.lang.IPersistentList&amp;quot;&amp;lt;br&amp;gt;  [(sequential? types)&amp;lt;br&amp;gt;   (every? Type? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->HeterogeneousList</a>[types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;HeterogeneousMap&lt;/b&gt; ([types other-keys?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord HeterogeneousMap [types other-keys?]&amp;lt;br&amp;gt;  &amp;quot;A constant map, clojure.lang.IPersistentMap&amp;quot;&amp;lt;br&amp;gt;  [((hash-c? Value? (some-fn Type? Result?))&amp;lt;br&amp;gt;     types)&amp;lt;br&amp;gt;   (boolean? other-keys?)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->HeterogeneousMap</a>[types other-keys?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;HeterogeneousSeq&lt;/b&gt; ([types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord HeterogeneousSeq [types]&amp;lt;br&amp;gt;  &amp;quot;A constant seq, clojure.lang.ISeq&amp;quot;&amp;lt;br&amp;gt;  [(sequential? types)&amp;lt;br&amp;gt;   (every? Type? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->HeterogeneousSeq</a>[types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;HeterogeneousVector&lt;/b&gt; ([types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord HeterogeneousVector [types]&amp;lt;br&amp;gt;  &amp;quot;A constant vector, clojure.lang.IPersistentVector&amp;quot;&amp;lt;br&amp;gt;  [(vector? types)&amp;lt;br&amp;gt;   (every? (some-fn Type? Result?) types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->HeterogeneousVector</a>[types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Intersection&lt;/b&gt; ([types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Intersection [types]&amp;lt;br&amp;gt;  &amp;quot;An unordered intersection of types.&amp;quot;&amp;lt;br&amp;gt;  [(seq types)&amp;lt;br&amp;gt;   (every? Type? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Intersection</a>[types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;KeyPE&lt;/b&gt; ([val])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord KeyPE [val]&amp;lt;br&amp;gt;  &amp;quot;A key in a hash-map&amp;quot;&amp;lt;br&amp;gt;  [(keyword? val)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->KeyPE</a>[val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;KwArgs&lt;/b&gt; ([mandatory optional])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord KwArgs [mandatory optional]&amp;lt;br&amp;gt;  &amp;quot;A set of mandatory and optional keywords&amp;quot;&amp;lt;br&amp;gt;  [(every? (hash-c? Value? Type?) [mandatory optional])])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->KwArgs</a>[mandatory optional]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;LTRange&lt;/b&gt; ([n])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord LTRange [n]&amp;lt;br&amp;gt;  &amp;quot;The type of all numbers less than n&amp;quot;&amp;lt;br&amp;gt;  [(number? n)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->LTRange</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;ListDots&lt;/b&gt; ([pre-type bound])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ListDots [pre-type bound]&amp;lt;br&amp;gt;  &amp;quot;A dotted list&amp;quot;&amp;lt;br&amp;gt;  [(Type? pre-type)&amp;lt;br&amp;gt;   ((some-fn F? B?) bound)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->ListDots</a>[pre-type bound]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Mu&lt;/b&gt; ([scope])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Mu [scope]&amp;lt;br&amp;gt;  &amp;quot;A recursive type containing one bound variable, itself&amp;quot;&amp;lt;br&amp;gt;  [(Scope? scope)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Mu</a>[scope]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Name&lt;/b&gt; ([id])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Name [id]&amp;lt;br&amp;gt;  &amp;quot;A late bound name&amp;quot;&amp;lt;br&amp;gt;  [((every-pred (some-fn namespace (fn [a] (some (fn [c] (= \. c)) (str a))))&amp;lt;br&amp;gt;                symbol?) &amp;lt;br&amp;gt;     id)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Name</a>[id]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;NextPE&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NextPE []&amp;lt;br&amp;gt;  &amp;quot;A path calling clojure.core/next&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->NextPE</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;NoFilter&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NoFilter []&amp;lt;br&amp;gt;  &amp;quot;Represents no info about filters, used for parsing types&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->NoFilter</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;NoObject&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NoObject []&amp;lt;br&amp;gt;  &amp;quot;Represents no info about the object of this expression&amp;lt;br&amp;gt;  should only be used for parsing type annotations and expected types&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->NoObject</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;NotType&lt;/b&gt; ([type])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NotType [type]&amp;lt;br&amp;gt;  &amp;quot;A type that does not include type&amp;quot;&amp;lt;br&amp;gt;  [(Type? type)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->NotType</a>[type]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;NotTypeFilter&lt;/b&gt; ([type path id])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NotTypeFilter [type path id]&amp;lt;br&amp;gt;  &amp;quot;A filter claiming looking up id, down the given path, is NOT of given type&amp;quot;&amp;lt;br&amp;gt;  [(Type? type)&amp;lt;br&amp;gt;   (every? PathElem? path)&amp;lt;br&amp;gt;   (name-ref? id)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->NotTypeFilter</a>[type path id]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;NumberCLJS&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NumberCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive number in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->NumberCLJS</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;ObjectCLJS&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ObjectCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive object in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->ObjectCLJS</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;OrFilter&lt;/b&gt; ([fs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord OrFilter [fs]&amp;lt;br&amp;gt;  &amp;quot;Logical disjunction of filters&amp;quot;&amp;lt;br&amp;gt;  [(seq fs)&amp;lt;br&amp;gt;   (set? fs)&amp;lt;br&amp;gt;   (every? Filter? fs)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->OrFilter</a>[fs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Path&lt;/b&gt; ([path id])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Path [path id]&amp;lt;br&amp;gt;  &amp;quot;A path to a variable. Paths grow to the right, with leftmost&amp;lt;br&amp;gt;  pathelem being applied first (think of -&amp;gt; threading operator).&amp;quot;&amp;lt;br&amp;gt;  [(or (and (seq path)&amp;lt;br&amp;gt;            (sequential? path))&amp;lt;br&amp;gt;       (nil? path))&amp;lt;br&amp;gt;   (every? PathElem? path)&amp;lt;br&amp;gt;   (name-ref? id)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Path</a>[path id]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Poly&lt;/b&gt; ([nbound bbnds scope actual-frees])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Poly [nbound bbnds scope actual-frees]&amp;lt;br&amp;gt;  &amp;quot;A polymorphic type containing n bound variables, with display names actual-frees&amp;quot;&amp;lt;br&amp;gt;  [(nat? nbound)&amp;lt;br&amp;gt;   (every? Bounds? bbnds)&amp;lt;br&amp;gt;   (every? symbol? actual-frees)&amp;lt;br&amp;gt;   (apply = nbound (map count [bbnds actual-frees]))&amp;lt;br&amp;gt;   (scope-depth? scope nbound)&amp;lt;br&amp;gt;   (Scope? scope)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Poly</a>[nbound bbnds scope actual-frees]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;PolyDots&lt;/b&gt; ([nbound bbnds scope])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord PolyDots [nbound bbnds ^Scope scope]&amp;lt;br&amp;gt;  &amp;quot;A polymorphic type containing n-1 bound variables and 1 ... variable&amp;quot;&amp;lt;br&amp;gt;  [(nat? nbound)&amp;lt;br&amp;gt;   (every? Bounds? bbnds)&amp;lt;br&amp;gt;   (= nbound (count bbnds))&amp;lt;br&amp;gt;   (scope-depth? scope nbound)&amp;lt;br&amp;gt;   (Scope? scope)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->PolyDots</a>[nbound bbnds scope]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;PrimitiveArray&lt;/b&gt; ([jtype input-type output-type])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord PrimitiveArray [jtype input-type output-type]&amp;lt;br&amp;gt;  &amp;quot;A Java Primitive array&amp;quot;&amp;lt;br&amp;gt;  [(class? jtype)&amp;lt;br&amp;gt;   (Type? input-type)&amp;lt;br&amp;gt;   (Type? output-type)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->PrimitiveArray</a>[jtype input-type output-type]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Projection&lt;/b&gt; ([afn ts])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Projection [afn ts]&amp;lt;br&amp;gt;  &amp;quot;Projects type variables as arguments to afn&amp;quot;&amp;lt;br&amp;gt;  [(fn? afn)&amp;lt;br&amp;gt;   (every? AnyType? ts)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Projection</a>[afn ts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;PropEnv&lt;/b&gt; ([l props])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord PropEnv [l props]&amp;lt;br&amp;gt;  &amp;quot;A lexical environment l, props is a list of known propositions&amp;quot;&amp;lt;br&amp;gt;  [(lex-env? l)&amp;lt;br&amp;gt;   (set? props)&amp;lt;br&amp;gt;   (every? Filter? props)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->PropEnv</a>[l props]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Protocol&lt;/b&gt; ([the-var variances poly? on-class methods])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Protocol [the-var variances poly? on-class methods]&amp;lt;br&amp;gt;  &amp;quot;A Clojure Protocol&amp;quot;&amp;lt;br&amp;gt;  [(symbol? the-var)&amp;lt;br&amp;gt;   (or (nil? variances)&amp;lt;br&amp;gt;       (and (seq variances)&amp;lt;br&amp;gt;            (every? variance? variances)))&amp;lt;br&amp;gt;   (or (nil? poly?)&amp;lt;br&amp;gt;       (and (seq poly?)&amp;lt;br&amp;gt;            (every? Type? poly?)))&amp;lt;br&amp;gt;   (= (count poly?) (count variances))&amp;lt;br&amp;gt;   (symbol? on-class)&amp;lt;br&amp;gt;   ((hash-c? (every-pred symbol? (complement namespace)) Type?) methods)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Protocol</a>[the-var variances poly? on-class methods]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;RClass&lt;/b&gt; ([variances poly? the-class replacements unchecked-ancestors])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord RClass [variances poly? the-class replacements unchecked-ancestors]&amp;lt;br&amp;gt;  &amp;quot;A restricted class, where ancestors are&amp;lt;br&amp;gt;  (replace replacements (ancestors the-class))&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? variances)&amp;lt;br&amp;gt;       (and (seq variances)&amp;lt;br&amp;gt;            (sequential? variances)&amp;lt;br&amp;gt;            (every? variance? variances)))&amp;lt;br&amp;gt;   (or (nil? poly?)&amp;lt;br&amp;gt;       (and (seq poly?)&amp;lt;br&amp;gt;            (sequential? poly?)&amp;lt;br&amp;gt;            (every? Type? poly?)))&amp;lt;br&amp;gt;   (symbol? the-class)&amp;lt;br&amp;gt;   ((hash-c? symbol? (some-fn Type? Scope?)) replacements)&amp;lt;br&amp;gt;   ((set-c? (some-fn Type? Scope?)) unchecked-ancestors)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->RClass</a>[variances poly? the-class replacements unchecked-ancestors]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Record&lt;/b&gt; ([the-class variances poly? fields])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Record [the-class variances poly? fields]&amp;lt;br&amp;gt;  &amp;quot;A Clojure record&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? variances)&amp;lt;br&amp;gt;       (and (seq variances)&amp;lt;br&amp;gt;            (every? variance? variances)))&amp;lt;br&amp;gt;   (or (nil? poly?)&amp;lt;br&amp;gt;       (and (seq poly?)&amp;lt;br&amp;gt;            (every? Type? poly?)))&amp;lt;br&amp;gt;   (symbol? the-class)&amp;lt;br&amp;gt;   ((array-map-c? symbol? (some-fn Scope? Type?)) fields)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Record</a>[the-class variances poly? fields]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;RecurTarget&lt;/b&gt; ([dom rest drest kws])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord RecurTarget [dom rest drest kws]&amp;lt;br&amp;gt;  &amp;quot;A target for recur&amp;quot;&amp;lt;br&amp;gt;  [(every? Type? dom)&amp;lt;br&amp;gt;   ((some-fn nil? Type?) rest)&amp;lt;br&amp;gt;   (nil? drest) ;TODO&amp;lt;br&amp;gt;   (nil? kws)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->RecurTarget</a>[dom rest drest kws]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Result&lt;/b&gt; ([t fl o])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Result [t fl o]&amp;lt;br&amp;gt;  &amp;quot;A result type with filter f and object o. NOT a type.&amp;quot;&amp;lt;br&amp;gt;  [(Type? t)&amp;lt;br&amp;gt;   (Filter? fl)&amp;lt;br&amp;gt;   (RObject? o)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Result</a>[t fl o]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Scope&lt;/b&gt; ([body])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Scope [body]&amp;lt;br&amp;gt;  &amp;quot;A scope that contains one bound variable, can be nested. Not used directly&amp;quot;&amp;lt;br&amp;gt;  [((some-fn Type? Scope?) body)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Scope</a>[body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;StringCLJS&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord StringCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive string in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->StringCLJS</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;SymbolCLJS&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord SymbolCLJS []&amp;lt;br&amp;gt;  &amp;quot;A type for Clojurescript symbols&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->SymbolCLJS</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;TApp&lt;/b&gt; ([rator rands])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TApp [rator rands]&amp;lt;br&amp;gt;  &amp;quot;An application of a type function to arguments.&amp;quot;&amp;lt;br&amp;gt;  [((some-fn Name? TypeFn? F? B?) rator)&amp;lt;br&amp;gt;   (every? (some-fn TypeFn? Type?) rands)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->TApp</a>[rator rands]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;TCResult&lt;/b&gt; ([t fl o flow])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TCResult [t fl o flow]&amp;lt;br&amp;gt;  &amp;quot;This record represents the result of typechecking an expression&amp;quot;&amp;lt;br&amp;gt;  [(Type? t)&amp;lt;br&amp;gt;   (FilterSet? fl)&amp;lt;br&amp;gt;   (RObject? o)&amp;lt;br&amp;gt;   (FlowSet? flow)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->TCResult</a>[t fl o flow]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Top&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Top []&amp;lt;br&amp;gt;  &amp;quot;The top type&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Top</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;TopFilter&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TopFilter []&amp;lt;br&amp;gt;  &amp;quot;Trivially true proposition&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->TopFilter</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;TopFunction&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TopFunction []&amp;lt;br&amp;gt;  &amp;quot;Supertype to all functions&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->TopFunction</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;TypeFilter&lt;/b&gt; ([type path id])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TypeFilter [type path id]&amp;lt;br&amp;gt;  &amp;quot;A filter claiming looking up id, down the given path, is of given type&amp;quot;&amp;lt;br&amp;gt;  [(Type? type)&amp;lt;br&amp;gt;   (every? PathElem? path)&amp;lt;br&amp;gt;   (name-ref? id)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->TypeFilter</a>[type path id]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;TypeFn&lt;/b&gt; ([nbound variances bbnds scope])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TypeFn [nbound variances bbnds scope]&amp;lt;br&amp;gt;  &amp;quot;A type function containing n bound variables with variances.&amp;lt;br&amp;gt;  It is of a higher kind&amp;quot;&amp;lt;br&amp;gt;  [(nat? nbound)&amp;lt;br&amp;gt;   (every? variance? variances)&amp;lt;br&amp;gt;   (every? Bounds? bbnds)&amp;lt;br&amp;gt;   (apply = nbound (map count [variances bbnds]))&amp;lt;br&amp;gt;   (scope-depth? scope nbound)&amp;lt;br&amp;gt;   (Scope? scope)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->TypeFn</a>[nbound variances bbnds scope]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Union&lt;/b&gt; ([types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Union [types]&amp;lt;br&amp;gt;  &amp;quot;An flattened, unordered union of types&amp;quot;&amp;lt;br&amp;gt;  [(set? types)&amp;lt;br&amp;gt;   (every? Type? types)&amp;lt;br&amp;gt;   (not (some Union? types))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Union</a>[types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;Value&lt;/b&gt; ([val])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Value [val]&amp;lt;br&amp;gt;  &amp;quot;A Clojure value&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Value</a>[val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;c&lt;/b&gt; ([S X T bnds])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord c [S X T bnds]&amp;lt;br&amp;gt;  &amp;quot;A type constraint on a variable within an upper and lower bound&amp;quot;&amp;lt;br&amp;gt;  [(Type? S)&amp;lt;br&amp;gt;   (symbol? X)&amp;lt;br&amp;gt;   (Type? T)&amp;lt;br&amp;gt;   (Bounds? bnds)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->c</a>[S X T bnds]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;cset&lt;/b&gt; ([maps])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord cset [maps]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? cset-entry? maps)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->cset</a>[maps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;cset-entry&lt;/b&gt; ([fixed dmap projections])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord cset-entry [fixed dmap projections]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [((hash-c? symbol? c?) fixed)&amp;lt;br&amp;gt;   (dmap? dmap)&amp;lt;br&amp;gt;   ((set-c? (hvector-c? (some-fn Type? Projection?)&amp;lt;br&amp;gt;                        (some-fn Type? Projection?)))&amp;lt;br&amp;gt;     projections)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->cset-entry</a>[fixed dmap projections]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;dcon&lt;/b&gt; ([fixed rest])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord dcon [fixed rest]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? c? fixed)&amp;lt;br&amp;gt;   (or (nil? rest)&amp;lt;br&amp;gt;       (c? rest))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->dcon</a>[fixed rest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;dcon-dotted&lt;/b&gt; ([fixed dc dbound])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord dcon-dotted [fixed dc dbound]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? c? fixed)&amp;lt;br&amp;gt;   (c? dc)&amp;lt;br&amp;gt;   (F? dbound)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->dcon-dotted</a>[fixed dc dbound]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;dcon-exact&lt;/b&gt; ([fixed rest])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord dcon-exact [fixed rest]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? c? fixed)&amp;lt;br&amp;gt;   (c? rest)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->dcon-exact</a>[fixed rest]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;dmap&lt;/b&gt; ([map])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord dmap [map]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [((hash-c? symbol? dcon-c?) map)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->dmap</a>[map]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;i-subst&lt;/b&gt; ([types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord i-subst [types]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? Type? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->i-subst</a>[types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;i-subst-dotted&lt;/b&gt; ([types dty dbound])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord i-subst-dotted [types dty dbound]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? types)&amp;lt;br&amp;gt;       (every? Type? types))&amp;lt;br&amp;gt;   (Type? dty)&amp;lt;br&amp;gt;   (F? dbound)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->i-subst-dotted</a>[types dty dbound]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;i-subst-starred&lt;/b&gt; ([types starred])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord i-subst-starred [types starred]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? Type? types)&amp;lt;br&amp;gt;   (Type? starred)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->i-subst-starred</a>[types starred]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-&gt;t-subst&lt;/b&gt; ([type bnds])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord t-subst [type bnds]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(Type? type)&amp;lt;br&amp;gt;   (Bounds? bnds)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->t-subst</a>[type bnds]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-FS&lt;/b&gt; ([+ -])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -FS [+ -]&amp;lt;br&amp;gt;  {:pre [(Filter? +)&amp;lt;br&amp;gt;         (Filter? -)]&amp;lt;br&amp;gt;   :post [(FilterSet? %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (BotFilter? +) (-&amp;gt;FilterSet -bot -top)&amp;lt;br&amp;gt;    (BotFilter? -) (-&amp;gt;FilterSet -top -bot)&amp;lt;br&amp;gt;    :else (-&amp;gt;FilterSet + -)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-FS</a>[+ -]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-PropEnv&lt;/b&gt; ([l props])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -PropEnv [l props]&amp;lt;br&amp;gt;  (-&amp;gt;PropEnv l (if (set? props)&amp;lt;br&amp;gt;                 props&amp;lt;br&amp;gt;                 (into #{} props))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-PropEnv</a>[l props]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-and&lt;/b&gt; ([&amp; args])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -and [&amp;amp; args]&amp;lt;br&amp;gt;  {:pre [(every? Filter? args)]&amp;lt;br&amp;gt;   :post [(Filter? %)]}&amp;lt;br&amp;gt;  (letfn [(mk [&amp;amp; fs]&amp;lt;br&amp;gt;            {:pre [(every? Filter? fs)]&amp;lt;br&amp;gt;             :post [(Filter? %)]}&amp;lt;br&amp;gt;            (cond&amp;lt;br&amp;gt;              (empty? fs) -top&amp;lt;br&amp;gt;              (= 1 (count fs)) (first fs)&amp;lt;br&amp;gt;              :else (-&amp;gt;AndFilter (set fs))))]&amp;lt;br&amp;gt;    (loop [fs (set args)&amp;lt;br&amp;gt;           result nil]&amp;lt;br&amp;gt;      (if (empty? fs)&amp;lt;br&amp;gt;        (cond&amp;lt;br&amp;gt;          (empty? result) -top&amp;lt;br&amp;gt;          (= 1 (count result)) (first result)&amp;lt;br&amp;gt;          ;; don't think this is useful here&amp;lt;br&amp;gt;          (= 2 (count result)) (let [[f1 f2] result]&amp;lt;br&amp;gt;                                 (if (opposite? f1 f2)&amp;lt;br&amp;gt;                                   -bot&amp;lt;br&amp;gt;                                   (if (= f1 f2)&amp;lt;br&amp;gt;                                     f1&amp;lt;br&amp;gt;                                     (apply mk (compact [f1 f2] false)))))&amp;lt;br&amp;gt;          :else&amp;lt;br&amp;gt;           ;; first, remove anything implied by the atomic propositions&amp;lt;br&amp;gt;           ;; We commonly see: (And (Or P Q) (Or P R) (Or P S) ... P), which this fixes&amp;lt;br&amp;gt;          (let [{atomic true not-atomic false} (group-by atomic-filter? result)&amp;lt;br&amp;gt;                not-atomic* (for [p not-atomic&amp;lt;br&amp;gt;                                  :when (some (fn [a] (implied-atomic? p a)) atomic)]&amp;lt;br&amp;gt;                              p)]&amp;lt;br&amp;gt;             ;; `compact' takes care of implications between atomic props&amp;lt;br&amp;gt;            (apply mk (compact (concat not-atomic* atomic) false))))&amp;lt;br&amp;gt;        (let [ffs (first fs)]&amp;lt;br&amp;gt;          (cond&amp;lt;br&amp;gt;            (BotFilter? ffs) ffs&amp;lt;br&amp;gt;            (AndFilter? ffs) (let [fs* (:fs ffs)]&amp;lt;br&amp;gt;                               (recur (next fs) (concat fs* result)))&amp;lt;br&amp;gt;            (TopFilter? ffs) (recur (next fs) result)&amp;lt;br&amp;gt;            :else (let [t ffs]&amp;lt;br&amp;gt;                    (cond&amp;lt;br&amp;gt;                      (some (fn [f] (opposite? f ffs)) (concat (rest fs) result)) &amp;lt;br&amp;gt;                      -bot&amp;lt;br&amp;gt;                      (some (fn [f] (or (= f t)&amp;lt;br&amp;gt;                                        (implied-atomic? t f))) result) &amp;lt;br&amp;gt;                      (recur (rest fs) result)&amp;lt;br&amp;gt;                      :else&amp;lt;br&amp;gt;                      (recur (rest fs) (cons t result))))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-and</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-complete-hmap&lt;/b&gt; ([types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -complete-hmap [types]&amp;lt;br&amp;gt;  (-hmap types false))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-complete-hmap</a>[types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-filter&lt;/b&gt; ([t i &amp; [p]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -filter [t i &amp;amp; [p]]&amp;lt;br&amp;gt;  {:pre [(Type? t)&amp;lt;br&amp;gt;         (name-ref? i)&amp;lt;br&amp;gt;         ((some-fn nil? #(every? PathElem? %)) p)]&amp;lt;br&amp;gt;   :post [(Filter? %)]}&amp;lt;br&amp;gt;  (if (or (= (-&amp;gt;Top) t) (and (symbol? i) (is-var-mutated? i)))&amp;lt;br&amp;gt;    -top&amp;lt;br&amp;gt;    (-&amp;gt;TypeFilter t p i)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-filter</a>[t i & [p]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-filter-at&lt;/b&gt; ([t o])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -filter-at [t o]&amp;lt;br&amp;gt;  (if (Path? o)&amp;lt;br&amp;gt;    (let [{p :path i :id} o]&amp;lt;br&amp;gt;      (-filter t i p))&amp;lt;br&amp;gt;    -top))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-filter-at</a>[t o]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-flow&lt;/b&gt; ([normal])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -flow [normal]&amp;lt;br&amp;gt;  (-&amp;gt;FlowSet normal))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-flow</a>[normal]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-hmap&lt;/b&gt; ([types] [types other-keys?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -hmap &amp;lt;br&amp;gt;  ([types] (-hmap types true))&amp;lt;br&amp;gt;  ([types other-keys?]&amp;lt;br&amp;gt;   (if (some #(= (Bottom) %) (concat (keys types) (vals types)))&amp;lt;br&amp;gt;     (Bottom)&amp;lt;br&amp;gt;     (-&amp;gt;HeterogeneousMap types other-keys?))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-hmap</a>[types] [types other-keys?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-hvec&lt;/b&gt; ([types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -hvec [types]&amp;lt;br&amp;gt;  (if (some Bottom? types)&amp;lt;br&amp;gt;    (Bottom)&amp;lt;br&amp;gt;    (-&amp;gt;HeterogeneousVector types)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-hvec</a>[types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-imp&lt;/b&gt; ([a c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -imp [a c]&amp;lt;br&amp;gt;  {:pre [(Filter? a)&amp;lt;br&amp;gt;         (Filter? c)]&amp;lt;br&amp;gt;   :post [(Filter? %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (BotFilter? a) -top&amp;lt;br&amp;gt;    (TopFilter? a) c&amp;lt;br&amp;gt;    ;; P -&amp;gt; tt = tt for any P&amp;lt;br&amp;gt;    (TopFilter? c) -top&amp;lt;br&amp;gt;    :else (-&amp;gt;ImpFilter a c)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-imp</a>[a c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-not-filter&lt;/b&gt; ([t i &amp; [p]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -not-filter [t i &amp;amp; [p]]&amp;lt;br&amp;gt;  {:pre [(Type? t)&amp;lt;br&amp;gt;         (name-ref? i)&amp;lt;br&amp;gt;         ((some-fn nil? #(every? PathElem? %)) p)]&amp;lt;br&amp;gt;   :post [(Filter? %)]}&amp;lt;br&amp;gt;  (if (or (= (Bottom) t) (and (symbol? i) (is-var-mutated? i)))&amp;lt;br&amp;gt;    -top&amp;lt;br&amp;gt;    (-&amp;gt;NotTypeFilter t p i)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-not-filter</a>[t i & [p]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-not-filter-at&lt;/b&gt; ([t o])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -not-filter-at [t o]&amp;lt;br&amp;gt;  (if (Path? o)&amp;lt;br&amp;gt;    (let [{p :path i :id} o]&amp;lt;br&amp;gt;      (-not-filter t i p))&amp;lt;br&amp;gt;    -top))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-not-filter-at</a>[t o]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-or&lt;/b&gt; ([&amp; args])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -or [&amp;amp; args]&amp;lt;br&amp;gt;  (loop [new-props (set args)&amp;lt;br&amp;gt;         atoms #{}&amp;lt;br&amp;gt;         last-props #{} ;stop iteration when (= (set/union new-props atoms) last-props)&amp;lt;br&amp;gt;         ]&amp;lt;br&amp;gt;    (assert ((set-c? atomic-filter?) atoms))&amp;lt;br&amp;gt;    (assert (every? (set-c? Filter?) [new-props last-props]))&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      ;reached fixed point&amp;lt;br&amp;gt;      (= (set/union new-props atoms) last-props)&amp;lt;br&amp;gt;      (case (count last-props)&amp;lt;br&amp;gt;        0 -bot&amp;lt;br&amp;gt;        1 (first last-props)&amp;lt;br&amp;gt;        (-&amp;gt;OrFilter last-props))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      :else&amp;lt;br&amp;gt;      (let [;flatten OrFilters&amp;lt;br&amp;gt;            original-props (set/union new-props atoms)&amp;lt;br&amp;gt;            original-atoms atoms&amp;lt;br&amp;gt;            fs (-&amp;gt; (apply concat&amp;lt;br&amp;gt;                          (for [a (set/union new-props atoms)]&amp;lt;br&amp;gt;                            (if (OrFilter? a)&amp;lt;br&amp;gt;                              (:fs a)&amp;lt;br&amp;gt;                              [a])))&amp;lt;br&amp;gt;                 set (disj -bot))&amp;lt;br&amp;gt;            {:keys [atoms] old-props :props} (group-by #(cond&amp;lt;br&amp;gt;                                                          ((some-fn TypeFilter? NotTypeFilter?) %) :atoms&amp;lt;br&amp;gt;                                                          :else :props)&amp;lt;br&amp;gt;                                                       fs)&amp;lt;br&amp;gt;            ;simplify AndFilters by removing atomic props directly inside the AndFilter&amp;lt;br&amp;gt;            ;if they are opposite of any atomic props we already have&amp;lt;br&amp;gt;            next-props (doall&amp;lt;br&amp;gt;                         (for [p old-props]&amp;lt;br&amp;gt;                           (reduce (fn [p a] (remove-opposite p a))&amp;lt;br&amp;gt;                                   p atoms)))&amp;lt;br&amp;gt;            {:keys [atoms] new-props :props} (group-by #(cond&amp;lt;br&amp;gt;                                                          ((some-fn TypeFilter? NotTypeFilter?) %) :atoms&amp;lt;br&amp;gt;                                                          :else :props)&amp;lt;br&amp;gt;                                                       (set/union (set next-props) (set atoms)))]&amp;lt;br&amp;gt;        (assert (&amp;lt;= (count original-atoms) (count atoms)))&amp;lt;br&amp;gt;        (recur (set new-props) (set atoms) (set original-props))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-or</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;-resolve&lt;/b&gt; ([ty])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -resolve [ty]&amp;lt;br&amp;gt;  {:pre [(AnyType? ty)]}&amp;lt;br&amp;gt;  (cond &amp;lt;br&amp;gt;    (Name? ty) (resolve-Name ty)&amp;lt;br&amp;gt;    (Mu? ty) (unfold ty)&amp;lt;br&amp;gt;    (App? ty) (resolve-App ty)&amp;lt;br&amp;gt;    (TApp? ty) (resolve-TApp ty)&amp;lt;br&amp;gt;    :else ty))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-resolve</a>[ty]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;AndFilter?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord AndFilter [fs]&amp;lt;br&amp;gt;  &amp;quot;Logical conjunction of filters&amp;quot;&amp;lt;br&amp;gt;  [(set? fs)&amp;lt;br&amp;gt;   (seq fs)&amp;lt;br&amp;gt;   (every? Filter? fs)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">AndFilter?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;AnyType?&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn AnyType? [a]&amp;lt;br&amp;gt;  (isa? (class a) AnyType))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">AnyType?</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;AnyValue?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord AnyValue []&amp;lt;br&amp;gt;  &amp;quot;Any Value&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">AnyValue?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;App?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord App [rator rands]&amp;lt;br&amp;gt;  &amp;quot;An application of a polymorphic type to type arguments&amp;quot;&amp;lt;br&amp;gt;  [(Type? rator)&amp;lt;br&amp;gt;   (every? Type? rands)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">App?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ArrayCLJS?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ArrayCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive array in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ArrayCLJS?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;B?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord B [idx]&amp;lt;br&amp;gt;  &amp;quot;A bound variable. Should not appear outside this file&amp;quot;&amp;lt;br&amp;gt;  [(nat? idx)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">B?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;BooleanCLJS?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord BooleanCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive boolean in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">BooleanCLJS?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;BotFilter?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord BotFilter []&amp;lt;br&amp;gt;  &amp;quot;Always false proposition&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">BotFilter?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Bottom&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Bottom []&amp;lt;br&amp;gt;  empty-union)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Bottom</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Bottom?&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Bottom? [a]&amp;lt;br&amp;gt;  (= empty-union a))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Bottom?</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Bounds?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Bounds [upper-bound lower-bound higher-kind]&amp;lt;br&amp;gt;  &amp;quot;A type bound or higher-kind bound on a variable&amp;quot;&amp;lt;br&amp;gt;  [(some-fn (and (every? (some-fn Type? Scope?) [upper-bound lower-bound])&amp;lt;br&amp;gt;                 (nil? higher-kind))&amp;lt;br&amp;gt;            (and (every? nil? [upper-bound lower-bound])&amp;lt;br&amp;gt;                 (TypeFn? higher-kind)))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Bounds?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ClassPE?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ClassPE []&amp;lt;br&amp;gt;  &amp;quot;A path calling clojure.core/class&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ClassPE?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;CountPE?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord CountPE []&amp;lt;br&amp;gt;  &amp;quot;A path calling clojure.core/count&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">CountPE?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;CountRange?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord CountRange [lower upper]&amp;lt;br&amp;gt;  &amp;quot;A sequence of count between lower and upper.&amp;lt;br&amp;gt;  If upper is nil, between lower and infinity.&amp;quot;&amp;lt;br&amp;gt;  [(nat? lower)&amp;lt;br&amp;gt;   (or (nil? upper)&amp;lt;br&amp;gt;       (and (nat? upper)&amp;lt;br&amp;gt;            (&amp;lt;= lower upper)))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">CountRange?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;DataType-ctor-type&lt;/b&gt; ([sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn DataType-ctor-type [sym]&amp;lt;br&amp;gt;  (let [dtp (@DATATYPE-ENV sym)]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      ((some-fn DataType? Record?) dtp) &amp;lt;br&amp;gt;      (let [dt dtp]&amp;lt;br&amp;gt;        (make-FnIntersection &amp;lt;br&amp;gt;          (make-Function (-&amp;gt; dt :fields vals) dt)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (Poly? dtp) (let [nms (repeatedly (:nbound dtp) gensym)&amp;lt;br&amp;gt;                        bbnds (Poly-bbnds* nms dtp)&amp;lt;br&amp;gt;                        dt (unwrap-datatype dtp nms)]&amp;lt;br&amp;gt;                    (Poly* nms&amp;lt;br&amp;gt;                           bbnds&amp;lt;br&amp;gt;                           (make-FnIntersection &amp;lt;br&amp;gt;                             (make-Function (-&amp;gt; dt :fields vals) dt))&amp;lt;br&amp;gt;                           (Poly-free-names* dtp)))&amp;lt;br&amp;gt;      :else (throw (Exception. (str &amp;quot;Cannot get DataType constructor of &amp;quot; sym))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">DataType-ctor-type</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;DataType?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord DataType [the-class variances poly? fields]&amp;lt;br&amp;gt;  &amp;quot;A Clojure datatype&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? variances)&amp;lt;br&amp;gt;       (and (seq variances)&amp;lt;br&amp;gt;            (every? variance? variances)))&amp;lt;br&amp;gt;   (or (nil? poly?)&amp;lt;br&amp;gt;       (and (seq poly?)&amp;lt;br&amp;gt;            (every? Type? poly?)))&amp;lt;br&amp;gt;   (symbol? the-class)&amp;lt;br&amp;gt;   ((array-map-c? symbol? (some-fn Scope? Type?)) fields)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">DataType?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;DottedPretype?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord DottedPretype [pre-type name]&amp;lt;br&amp;gt;  &amp;quot;A dotted pre-type. Not a type&amp;quot;&amp;lt;br&amp;gt;  [(Type? pre-type)&amp;lt;br&amp;gt;   ((some-fn symbol? nat?) name)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">DottedPretype?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;EmptyObject?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord EmptyObject []&amp;lt;br&amp;gt;  &amp;quot;?&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">EmptyObject?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;F?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord F [name]&amp;lt;br&amp;gt;  &amp;quot;A named free variable&amp;quot;&amp;lt;br&amp;gt;  [(symbol? name)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">F?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;False?&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn False? [a] (= -false a))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">False?</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Filter?&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Filter? [a]&amp;lt;br&amp;gt;  (isa? (class a) Filter))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Filter?</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;FirstPE?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FirstPE []&amp;lt;br&amp;gt;  &amp;quot;A path calling clojure.core/first&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">FirstPE?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;FlowSet?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FlowSet [normal]&amp;lt;br&amp;gt;  &amp;quot;The filter that is true when an expression returns normally ie. not an exception.&amp;quot;&amp;lt;br&amp;gt;  [(Filter? normal)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">FlowSet?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;FnIntersection?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FnIntersection [types]&amp;lt;br&amp;gt;  &amp;quot;An ordered intersection of Functions.&amp;quot;&amp;lt;br&amp;gt;  [(seq types)&amp;lt;br&amp;gt;   (sequential? types)&amp;lt;br&amp;gt;   (every? Function? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">FnIntersection?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;FnResult-&gt;Function&lt;/b&gt; ([{:keys [args kws rest drest body], :as fres}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn FnResult-&amp;gt;Function [{:keys [args kws rest drest body] :as fres}]&amp;lt;br&amp;gt;  {:pre [(FnResult? fres)]&amp;lt;br&amp;gt;   :post [(Function? %)]}&amp;lt;br&amp;gt;  (assert (not kws))&amp;lt;br&amp;gt;  (let [arg-names (doall&amp;lt;br&amp;gt;                    (concat (map first args)&amp;lt;br&amp;gt;                            (when rest&amp;lt;br&amp;gt;                              [(first rest)])&amp;lt;br&amp;gt;                            (when drest&amp;lt;br&amp;gt;                              [(first drest)]))) ;TODO kws&amp;lt;br&amp;gt;                            ]&amp;lt;br&amp;gt;    (-&amp;gt;Function&amp;lt;br&amp;gt;      (map second args)&amp;lt;br&amp;gt;      (abstract-result body arg-names)&amp;lt;br&amp;gt;      (when rest&amp;lt;br&amp;gt;        (second rest))&amp;lt;br&amp;gt;      (when drest&amp;lt;br&amp;gt;        (second drest))&amp;lt;br&amp;gt;      nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">FnResult->Function</a>[{:keys [args kws rest drest body], :as fres}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;FnResult?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FnResult [args kws rest drest body]&amp;lt;br&amp;gt;  &amp;quot;Results of checking a fn method&amp;quot;&amp;lt;br&amp;gt;  [(every? symbol? (map first args))&amp;lt;br&amp;gt;   (every? Type? (map second args))&amp;lt;br&amp;gt;   (nil? kws)&amp;lt;br&amp;gt;   ((some-fn nil? (hvector-c? symbol? Type?)) rest)&amp;lt;br&amp;gt;   (nil? drest)&amp;lt;br&amp;gt;   (TCResult? body)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">FnResult?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Function?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Function [dom rng rest drest kws]&amp;lt;br&amp;gt;  &amp;quot;A function arity, must be part of an intersection&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? dom)&amp;lt;br&amp;gt;       (sequential? dom))&amp;lt;br&amp;gt;   (every? Type? dom)&amp;lt;br&amp;gt;   (Result? rng)&amp;lt;br&amp;gt;   ;at most one of rest drest or kws can be provided&amp;lt;br&amp;gt;   (#{0 1} (count (filter identity [rest drest kws])))&amp;lt;br&amp;gt;   (or (nil? rest)&amp;lt;br&amp;gt;       (Type? rest))&amp;lt;br&amp;gt;   (or (nil? drest)&amp;lt;br&amp;gt;       (DottedPretype? drest))&amp;lt;br&amp;gt;   (or (nil? kws)&amp;lt;br&amp;gt;       (KwArgs? kws))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Function?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;FunctionCLJS?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FunctionCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive function in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">FunctionCLJS?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;GTRange?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord GTRange [n]&amp;lt;br&amp;gt;  &amp;quot;The type of all numbers greater than n&amp;quot;&amp;lt;br&amp;gt;  [(number? n)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">GTRange?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;HeterogeneousList?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord HeterogeneousList [types]&amp;lt;br&amp;gt;  &amp;quot;A constant list, clojure.lang.IPersistentList&amp;quot;&amp;lt;br&amp;gt;  [(sequential? types)&amp;lt;br&amp;gt;   (every? Type? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">HeterogeneousList?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;HeterogeneousMap?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord HeterogeneousMap [types other-keys?]&amp;lt;br&amp;gt;  &amp;quot;A constant map, clojure.lang.IPersistentMap&amp;quot;&amp;lt;br&amp;gt;  [((hash-c? Value? (some-fn Type? Result?))&amp;lt;br&amp;gt;     types)&amp;lt;br&amp;gt;   (boolean? other-keys?)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">HeterogeneousMap?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;HeterogeneousSeq?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord HeterogeneousSeq [types]&amp;lt;br&amp;gt;  &amp;quot;A constant seq, clojure.lang.ISeq&amp;quot;&amp;lt;br&amp;gt;  [(sequential? types)&amp;lt;br&amp;gt;   (every? Type? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">HeterogeneousSeq?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;HeterogeneousVector?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord HeterogeneousVector [types]&amp;lt;br&amp;gt;  &amp;quot;A constant vector, clojure.lang.IPersistentVector&amp;quot;&amp;lt;br&amp;gt;  [(vector? types)&amp;lt;br&amp;gt;   (every? (some-fn Type? Result?) types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">HeterogeneousVector?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ImpFilter?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ImpFilter [a c]&amp;lt;br&amp;gt;  &amp;quot;Antecedent (filter a) implies consequent (filter c)&amp;quot;&amp;lt;br&amp;gt;  [(Filter? a)&amp;lt;br&amp;gt;   (Filter? c)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ImpFilter?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;In&lt;/b&gt; ([&amp; types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn In [&amp;amp; types]&amp;lt;br&amp;gt;  {:pre [(every? Type? types)]&amp;lt;br&amp;gt;   :post [(Type? %)]}&amp;lt;br&amp;gt;           ;flatten intersections&amp;lt;br&amp;gt;  (let [ts (set (apply concat&amp;lt;br&amp;gt;                       (for [t (set types)]&amp;lt;br&amp;gt;                         (if (Intersection? t)&amp;lt;br&amp;gt;                           (:types t)&amp;lt;br&amp;gt;                           [t]))))]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (or (empty? ts)&amp;lt;br&amp;gt;          (ts (Un))) (Bottom)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (= 1 (count ts)) (first ts)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ; if there no overlap&amp;lt;br&amp;gt;      (and (&amp;lt;= (count ts) 2)&amp;lt;br&amp;gt;           (some (fn [[t1 t2]] (not (overlap t1 t2))) (comb/combinations ts 2))) (Bottom)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (some Union? ts) (let [flat (set (mapcat #(if (Union? %)&amp;lt;br&amp;gt;                                                  (:types %)&amp;lt;br&amp;gt;                                                  [%])&amp;lt;br&amp;gt;                                               ts))]&amp;lt;br&amp;gt;                         (apply Un&amp;lt;br&amp;gt;                                (set&amp;lt;br&amp;gt;                                  (for [[t1 t2] (comb/combinations flat 2)]&amp;lt;br&amp;gt;                                    (In t1 t2)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (ts -any) (apply In (disj ts -any))&amp;lt;br&amp;gt;      :else (-&amp;gt;Intersection ts))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">In</a>[& types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Intersection?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Intersection [types]&amp;lt;br&amp;gt;  &amp;quot;An unordered intersection of types.&amp;quot;&amp;lt;br&amp;gt;  [(seq types)&amp;lt;br&amp;gt;   (every? Type? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Intersection?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Java-symbol-&gt;Type&lt;/b&gt; ([sym nilable?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Java-symbol-&amp;gt;Type [sym nilable?]&amp;lt;br&amp;gt;  {:pre [(symbol? sym)&amp;lt;br&amp;gt;         (boolean? nilable?)]&amp;lt;br&amp;gt;   :post [(Type? %)]}&amp;lt;br&amp;gt;  (if-let [typ (or (primitives sym)&amp;lt;br&amp;gt;                   (symbol-&amp;gt;PArray sym nilable?)&amp;lt;br&amp;gt;                   (when-let [cls (resolve sym)]&amp;lt;br&amp;gt;                     (let [rcls-or-poly (@RESTRICTED-CLASS (Class-&amp;gt;symbol cls))&amp;lt;br&amp;gt;                           ; use correct number of arguments. Could be more general by recognising variance.&amp;lt;br&amp;gt;                           nargs (when rcls-or-poly&amp;lt;br&amp;gt;                                   (if (Poly? rcls-or-poly)&amp;lt;br&amp;gt;                                     (let [^RClass body (Poly-body* (repeatedly (:nbound rcls-or-poly) gensym)&amp;lt;br&amp;gt;                                                                    rcls-or-poly)&amp;lt;br&amp;gt;                                           _ (assert (RClass? body))]&amp;lt;br&amp;gt;                                       (count (.poly? body)))&amp;lt;br&amp;gt;                                     (let [_ (assert (RClass? rcls-or-poly))]&amp;lt;br&amp;gt;                                       (count (.poly? ^RClass rcls-or-poly)))))]&amp;lt;br&amp;gt;;                       (prn &amp;quot;class&amp;quot; cls)&amp;lt;br&amp;gt;;                       (prn &amp;quot;nargs&amp;quot; nargs)&amp;lt;br&amp;gt;                       (apply Un (apply RClass-of cls (when nargs&amp;lt;br&amp;gt;                                                        ; fill in arguments with Any&amp;lt;br&amp;gt;                                                        [(repeat nargs -any)]))&amp;lt;br&amp;gt;                              (when nilable?&amp;lt;br&amp;gt;                                [-nil])))))]&amp;lt;br&amp;gt;    typ&amp;lt;br&amp;gt;    (throw (Exception. (str &amp;quot;Method symbol &amp;quot; sym &amp;quot; does not resolve to a type&amp;quot;)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Java-symbol->Type</a>[sym nilable?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;KeyPE?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord KeyPE [val]&amp;lt;br&amp;gt;  &amp;quot;A key in a hash-map&amp;quot;&amp;lt;br&amp;gt;  [(keyword? val)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">KeyPE?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;KwArgs?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord KwArgs [mandatory optional]&amp;lt;br&amp;gt;  &amp;quot;A set of mandatory and optional keywords&amp;quot;&amp;lt;br&amp;gt;  [(every? (hash-c? Value? Type?) [mandatory optional])])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">KwArgs?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;LTRange?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord LTRange [n]&amp;lt;br&amp;gt;  &amp;quot;The type of all numbers less than n&amp;quot;&amp;lt;br&amp;gt;  [(number? n)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">LTRange?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ListDots?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ListDots [pre-type bound]&amp;lt;br&amp;gt;  &amp;quot;A dotted list&amp;quot;&amp;lt;br&amp;gt;  [(Type? pre-type)&amp;lt;br&amp;gt;   ((some-fn F? B?) bound)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ListDots?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Method-&gt;symbol&lt;/b&gt; ([{name-sym :name, :keys [declaring-class], :as method}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Method-&amp;gt;symbol [{name-sym :name :keys [declaring-class] :as method}]&amp;lt;br&amp;gt;  {:pre [(instance? clojure.reflect.Method method)]&amp;lt;br&amp;gt;   :post [((every-pred namespace symbol?) %)]}&amp;lt;br&amp;gt;  (symbol (name declaring-class) (name name-sym)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Method->symbol</a>[{name-sym :name, :keys [declaring-class], :as method}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;MethodExpr-&gt;qualsym&lt;/b&gt; ([{c :class, :keys [op method method-name], :as expr}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn MethodExpr-&amp;gt;qualsym [{c :class :keys [op method method-name] :as expr}]&amp;lt;br&amp;gt;  {:pre [(#{:static-method :instance-method} op)]&amp;lt;br&amp;gt;   :post [((some-fn nil? symbol?) %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    method (Method-&amp;gt;symbol method)&amp;lt;br&amp;gt;    (and c method-name) (symbol (str (Class-&amp;gt;symbol c))&amp;lt;br&amp;gt;                                (str method-name))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">MethodExpr->qualsym</a>[{c :class, :keys [op method method-name], :as expr}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Mu*&lt;/b&gt; ([name body])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Mu* [name body]&amp;lt;br&amp;gt;  (-&amp;gt;Mu (abstract name body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Mu*</a>[name body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Mu-body*&lt;/b&gt; ([name t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Mu-body* [name t]&amp;lt;br&amp;gt;  {:pre [(Mu? t)&amp;lt;br&amp;gt;         (symbol? name)]}&amp;lt;br&amp;gt;  (instantiate name (:scope t)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Mu-body*</a>[name t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Mu?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Mu [scope]&amp;lt;br&amp;gt;  &amp;quot;A recursive type containing one bound variable, itself&amp;quot;&amp;lt;br&amp;gt;  [(Scope? scope)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Mu?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Name?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Name [id]&amp;lt;br&amp;gt;  &amp;quot;A late bound name&amp;quot;&amp;lt;br&amp;gt;  [((every-pred (some-fn namespace (fn [a] (some (fn [c] (= \. c)) (str a))))&amp;lt;br&amp;gt;                symbol?) &amp;lt;br&amp;gt;     id)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Name?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;NextPE?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NextPE []&amp;lt;br&amp;gt;  &amp;quot;A path calling clojure.core/next&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">NextPE?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Nil?&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Nil? [a] (= -nil a))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Nil?</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;NoFilter?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NoFilter []&amp;lt;br&amp;gt;  &amp;quot;Represents no info about filters, used for parsing types&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">NoFilter?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;NoObject?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NoObject []&amp;lt;br&amp;gt;  &amp;quot;Represents no info about the object of this expression&amp;lt;br&amp;gt;  should only be used for parsing type annotations and expected types&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">NoObject?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;NotType?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NotType [type]&amp;lt;br&amp;gt;  &amp;quot;A type that does not include type&amp;quot;&amp;lt;br&amp;gt;  [(Type? type)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">NotType?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;NotTypeFilter?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NotTypeFilter [type path id]&amp;lt;br&amp;gt;  &amp;quot;A filter claiming looking up id, down the given path, is NOT of given type&amp;quot;&amp;lt;br&amp;gt;  [(Type? type)&amp;lt;br&amp;gt;   (every? PathElem? path)&amp;lt;br&amp;gt;   (name-ref? id)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">NotTypeFilter?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;NumberCLJS?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NumberCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive number in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">NumberCLJS?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ObjectCLJS?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ObjectCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive object in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ObjectCLJS?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;OrFilter?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord OrFilter [fs]&amp;lt;br&amp;gt;  &amp;quot;Logical disjunction of filters&amp;quot;&amp;lt;br&amp;gt;  [(seq fs)&amp;lt;br&amp;gt;   (set? fs)&amp;lt;br&amp;gt;   (every? Filter? fs)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">OrFilter?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Path?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Path [path id]&amp;lt;br&amp;gt;  &amp;quot;A path to a variable. Paths grow to the right, with leftmost&amp;lt;br&amp;gt;  pathelem being applied first (think of -&amp;gt; threading operator).&amp;quot;&amp;lt;br&amp;gt;  [(or (and (seq path)&amp;lt;br&amp;gt;            (sequential? path))&amp;lt;br&amp;gt;       (nil? path))&amp;lt;br&amp;gt;   (every? PathElem? path)&amp;lt;br&amp;gt;   (name-ref? id)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Path?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;PathElem?&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn PathElem? [a]&amp;lt;br&amp;gt;  (isa? (class a) PathElem))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">PathElem?</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Poly*&lt;/b&gt; ([names bbnds body free-names])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Poly* [names bbnds body free-names]&amp;lt;br&amp;gt;  {:pre [(every? symbol names)&amp;lt;br&amp;gt;         (every? Bounds? bbnds)&amp;lt;br&amp;gt;         (Type? body)&amp;lt;br&amp;gt;         (every? symbol? free-names)&amp;lt;br&amp;gt;         (apply = (map count [names bbnds free-names]))]}&amp;lt;br&amp;gt;  (if (empty? names)&amp;lt;br&amp;gt;    body&amp;lt;br&amp;gt;    (-&amp;gt;Poly (count names) &amp;lt;br&amp;gt;            (vec&amp;lt;br&amp;gt;              (for [bnd bbnds]&amp;lt;br&amp;gt;                (visit-bounds bnd #(abstract-many names %))))&amp;lt;br&amp;gt;            (abstract-many names body)&amp;lt;br&amp;gt;            free-names)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Poly*</a>[names bbnds body free-names]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Poly-bbnds*&lt;/b&gt; ([names poly])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Poly-bbnds* [names ^Poly poly]&amp;lt;br&amp;gt;  {:pre [(every? symbol? names)&amp;lt;br&amp;gt;         (Poly? poly)]}&amp;lt;br&amp;gt;  (assert (= (.nbound poly) (count names)) &amp;quot;Wrong number of names&amp;quot;)&amp;lt;br&amp;gt;  (mapv (fn [b]&amp;lt;br&amp;gt;          (visit-bounds b #(instantiate-many names %)))&amp;lt;br&amp;gt;        (.bbnds poly)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Poly-bbnds*</a>[names poly]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Poly-body*&lt;/b&gt; ([names poly])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Poly-body* [names ^Poly poly]&amp;lt;br&amp;gt;  {:pre [(every? symbol? names)&amp;lt;br&amp;gt;         (Poly? poly)]}&amp;lt;br&amp;gt;  (assert (= (.nbound poly) (count names)) &amp;quot;Wrong number of names&amp;quot;)&amp;lt;br&amp;gt;  (instantiate-many names (.scope poly)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Poly-body*</a>[names poly]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Poly-free-names*&lt;/b&gt; ([poly])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Poly-free-names* [^Poly poly]&amp;lt;br&amp;gt;  {:pre [(Poly? poly)]&amp;lt;br&amp;gt;   :post [((every-pred seq (every-c? symbol?)) %)]}&amp;lt;br&amp;gt;  (.actual-frees poly))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Poly-free-names*</a>[poly]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Poly?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Poly [nbound bbnds scope actual-frees]&amp;lt;br&amp;gt;  &amp;quot;A polymorphic type containing n bound variables, with display names actual-frees&amp;quot;&amp;lt;br&amp;gt;  [(nat? nbound)&amp;lt;br&amp;gt;   (every? Bounds? bbnds)&amp;lt;br&amp;gt;   (every? symbol? actual-frees)&amp;lt;br&amp;gt;   (apply = nbound (map count [bbnds actual-frees]))&amp;lt;br&amp;gt;   (scope-depth? scope nbound)&amp;lt;br&amp;gt;   (Scope? scope)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Poly?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;PolyDots*&lt;/b&gt; ([names bbnds body])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn PolyDots* [names bbnds body]&amp;lt;br&amp;gt;  {:pre [(every? symbol names)&amp;lt;br&amp;gt;         (every? Bounds? bbnds)&amp;lt;br&amp;gt;         (Type? body)]}&amp;lt;br&amp;gt;  (assert (= (count names) (count bbnds)) &amp;quot;Wrong number of names&amp;quot;)&amp;lt;br&amp;gt;  (if (empty? names)&amp;lt;br&amp;gt;    body&amp;lt;br&amp;gt;    (-&amp;gt;PolyDots (count names) &amp;lt;br&amp;gt;                (mapv (fn [bnd] &amp;lt;br&amp;gt;                        (visit-bounds bnd #(abstract-many names %)))&amp;lt;br&amp;gt;                      bbnds)&amp;lt;br&amp;gt;                (abstract-many names body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">PolyDots*</a>[names bbnds body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;PolyDots-bbnds*&lt;/b&gt; ([names poly])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn PolyDots-bbnds* [names ^PolyDots poly]&amp;lt;br&amp;gt;  {:pre [(every? symbol? names)&amp;lt;br&amp;gt;         (PolyDots? poly)]}&amp;lt;br&amp;gt;  (assert (= (.nbound poly) (count names)) &amp;quot;Wrong number of names&amp;quot;)&amp;lt;br&amp;gt;  (mapv (fn [b]&amp;lt;br&amp;gt;          (visit-bounds b #(instantiate-many names %)))&amp;lt;br&amp;gt;        (.bbnds poly)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">PolyDots-bbnds*</a>[names poly]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;PolyDots-body*&lt;/b&gt; ([names poly])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn PolyDots-body* [names ^PolyDots poly]&amp;lt;br&amp;gt;  {:pre [(every? symbol? names)&amp;lt;br&amp;gt;         (PolyDots? poly)]}&amp;lt;br&amp;gt;  (assert (= (.nbound poly) (count names)) &amp;quot;Wrong number of names&amp;quot;)&amp;lt;br&amp;gt;  (instantiate-many names (.scope poly)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">PolyDots-body*</a>[names poly]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;PolyDots?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord PolyDots [nbound bbnds ^Scope scope]&amp;lt;br&amp;gt;  &amp;quot;A polymorphic type containing n-1 bound variables and 1 ... variable&amp;quot;&amp;lt;br&amp;gt;  [(nat? nbound)&amp;lt;br&amp;gt;   (every? Bounds? bbnds)&amp;lt;br&amp;gt;   (= nbound (count bbnds))&amp;lt;br&amp;gt;   (scope-depth? scope nbound)&amp;lt;br&amp;gt;   (Scope? scope)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">PolyDots?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;PrimitiveArray?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord PrimitiveArray [jtype input-type output-type]&amp;lt;br&amp;gt;  &amp;quot;A Java Primitive array&amp;quot;&amp;lt;br&amp;gt;  [(class? jtype)&amp;lt;br&amp;gt;   (Type? input-type)&amp;lt;br&amp;gt;   (Type? output-type)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">PrimitiveArray?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Projection?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Projection [afn ts]&amp;lt;br&amp;gt;  &amp;quot;Projects type variables as arguments to afn&amp;quot;&amp;lt;br&amp;gt;  [(fn? afn)&amp;lt;br&amp;gt;   (every? AnyType? ts)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Projection?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;PropEnv?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord PropEnv [l props]&amp;lt;br&amp;gt;  &amp;quot;A lexical environment l, props is a list of known propositions&amp;quot;&amp;lt;br&amp;gt;  [(lex-env? l)&amp;lt;br&amp;gt;   (set? props)&amp;lt;br&amp;gt;   (every? Filter? props)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">PropEnv?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Protocol?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Protocol [the-var variances poly? on-class methods]&amp;lt;br&amp;gt;  &amp;quot;A Clojure Protocol&amp;quot;&amp;lt;br&amp;gt;  [(symbol? the-var)&amp;lt;br&amp;gt;   (or (nil? variances)&amp;lt;br&amp;gt;       (and (seq variances)&amp;lt;br&amp;gt;            (every? variance? variances)))&amp;lt;br&amp;gt;   (or (nil? poly?)&amp;lt;br&amp;gt;       (and (seq poly?)&amp;lt;br&amp;gt;            (every? Type? poly?)))&amp;lt;br&amp;gt;   (= (count poly?) (count variances))&amp;lt;br&amp;gt;   (symbol? on-class)&amp;lt;br&amp;gt;   ((hash-c? (every-pred symbol? (complement namespace)) Type?) methods)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Protocol?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;RClass*&lt;/b&gt; ([names variances poly? the-class replacements] [names variances poly? the-class replacements unchecked-ancestors])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn RClass* &amp;lt;br&amp;gt;  ([names variances poly? the-class replacements]&amp;lt;br&amp;gt;   (RClass* names variances poly? the-class replacements #{}))&amp;lt;br&amp;gt;  ([names variances poly? the-class replacements unchecked-ancestors]&amp;lt;br&amp;gt;  {:pre [(every? symbol? names)&amp;lt;br&amp;gt;         (every? variance? variances)&amp;lt;br&amp;gt;         (= (count variances) (count poly?))&amp;lt;br&amp;gt;         (every? Type? poly?)&amp;lt;br&amp;gt;         (symbol? the-class)]}&amp;lt;br&amp;gt;  (if (seq variances)&amp;lt;br&amp;gt;    (Poly* names (repeat (count names) no-bounds) (-&amp;gt;RClass variances poly? the-class replacements unchecked-ancestors) names)&amp;lt;br&amp;gt;    (-&amp;gt;RClass nil nil the-class replacements unchecked-ancestors))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">RClass*</a>[names variances poly? the-class replacements] [names variances poly? the-class replacements unchecked-ancestors]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;RClass-&gt;Class&lt;/b&gt; ([rcls])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^Class RClass-&amp;gt;Class [^RClass rcls]&amp;lt;br&amp;gt;  (symbol-&amp;gt;Class (.the-class rcls)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">RClass->Class</a>[rcls]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;RClass-of&lt;/b&gt; ([sym-or-cls] [sym-or-cls args])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn RClass-of &amp;lt;br&amp;gt;  ([sym-or-cls] (RClass-of sym-or-cls nil))&amp;lt;br&amp;gt;  ([sym-or-cls args]&amp;lt;br&amp;gt;   {:pre [((some-fn class? symbol?) sym-or-cls)&amp;lt;br&amp;gt;          (every? Type? args)]&amp;lt;br&amp;gt;    :post [(RClass? %)]}&amp;lt;br&amp;gt;   (let [sym (if (class? sym-or-cls)&amp;lt;br&amp;gt;               (Class-&amp;gt;symbol sym-or-cls)&amp;lt;br&amp;gt;               sym-or-cls)&amp;lt;br&amp;gt;         rc (@RESTRICTED-CLASS sym)]&amp;lt;br&amp;gt;     (assert ((some-fn Poly? RClass? nil?) rc))&amp;lt;br&amp;gt;     (assert (or (Poly? rc) (empty? args)) &amp;lt;br&amp;gt;             (str &amp;quot;Cannot instantiate non-polymorphic RClass &amp;quot; sym&amp;lt;br&amp;gt;                  (when *current-RClass-super*&amp;lt;br&amp;gt;                    (str &amp;quot; when checking supertypes of RClass &amp;quot; *current-RClass-super*))))&amp;lt;br&amp;gt;     (cond &amp;lt;br&amp;gt;       (Poly? rc) (instantiate-poly rc args)&amp;lt;br&amp;gt;       (RClass? rc) rc&amp;lt;br&amp;gt;       :else (-&amp;gt;RClass nil nil sym {} #{})))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">RClass-of</a>[sym-or-cls] [sym-or-cls args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;RClass-of-with-unknown-params&lt;/b&gt; ([sym-or-cls])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn RClass-of-with-unknown-params&amp;lt;br&amp;gt;  ([sym-or-cls]&amp;lt;br&amp;gt;   {:pre [((some-fn class? symbol?) sym-or-cls)]&amp;lt;br&amp;gt;    :post [(RClass? %)]}&amp;lt;br&amp;gt;   (let [sym (if (class? sym-or-cls)&amp;lt;br&amp;gt;               (Class-&amp;gt;symbol sym-or-cls)&amp;lt;br&amp;gt;               sym-or-cls)&amp;lt;br&amp;gt;         rc (@RESTRICTED-CLASS sym)&amp;lt;br&amp;gt;         args (when (Poly? rc)&amp;lt;br&amp;gt;                ;instantiate with Any, could be more general if respecting variance&amp;lt;br&amp;gt;                (repeat (.nbound ^Poly rc) -any))]&amp;lt;br&amp;gt;     (RClass-of sym args))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">RClass-of-with-unknown-params</a>[sym-or-cls]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;RClass-supers*&lt;/b&gt; ([{:keys [poly? replacements the-class unchecked-ancestors], :as rcls}])&lt;br&gt; Return a set of ancestors to the RClass&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn RClass-supers* &amp;lt;br&amp;gt;  &amp;quot;Return a set of ancestors to the RClass&amp;quot;&amp;lt;br&amp;gt;  [{:keys [poly? replacements the-class unchecked-ancestors] :as rcls}]&amp;lt;br&amp;gt;  {:pre [(RClass? rcls)]&amp;lt;br&amp;gt;   :post [(set? %)&amp;lt;br&amp;gt;          (every? Type? %)&amp;lt;br&amp;gt;          (&amp;lt;= (count (filter (some-fn FnIntersection? Poly? PolyDots?) %))&amp;lt;br&amp;gt;              1)]}&amp;lt;br&amp;gt;  (let [;set of symbols of Classes we haven't explicitly replaced&amp;lt;br&amp;gt;        not-replaced (set/difference (set (map Class-&amp;gt;symbol (-&amp;gt; the-class symbol-&amp;gt;Class supers)))&amp;lt;br&amp;gt;                                     (set (keys replacements)))]&amp;lt;br&amp;gt;    (set/union (binding [*current-RClass-super* the-class]&amp;lt;br&amp;gt;                 (set (doall &amp;lt;br&amp;gt;                        (for [csym not-replaced]&amp;lt;br&amp;gt;                          (RClass-of-with-unknown-params csym)))))&amp;lt;br&amp;gt;               (set (vals replacements))&amp;lt;br&amp;gt;               #{(RClass-of Object)}&amp;lt;br&amp;gt;               unchecked-ancestors)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">RClass-supers*</a>[{:keys [poly? replacements the-class unchecked-ancestors], :as rcls}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;RClass?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord RClass [variances poly? the-class replacements unchecked-ancestors]&amp;lt;br&amp;gt;  &amp;quot;A restricted class, where ancestors are&amp;lt;br&amp;gt;  (replace replacements (ancestors the-class))&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? variances)&amp;lt;br&amp;gt;       (and (seq variances)&amp;lt;br&amp;gt;            (sequential? variances)&amp;lt;br&amp;gt;            (every? variance? variances)))&amp;lt;br&amp;gt;   (or (nil? poly?)&amp;lt;br&amp;gt;       (and (seq poly?)&amp;lt;br&amp;gt;            (sequential? poly?)&amp;lt;br&amp;gt;            (every? Type? poly?)))&amp;lt;br&amp;gt;   (symbol? the-class)&amp;lt;br&amp;gt;   ((hash-c? symbol? (some-fn Type? Scope?)) replacements)&amp;lt;br&amp;gt;   ((set-c? (some-fn Type? Scope?)) unchecked-ancestors)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">RClass?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;RObject?&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn RObject? [a]&amp;lt;br&amp;gt;  (isa? (class a) RObject))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">RObject?</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Record-&gt;HMap&lt;/b&gt; ([r])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Record-&amp;gt;HMap [^Record r]&amp;lt;br&amp;gt;  {:pre [(Record? r)]&amp;lt;br&amp;gt;   :post [(Type? %)]}&amp;lt;br&amp;gt;  (let [kf (zipmap (map (comp -val keyword) (keys (.fields r)))&amp;lt;br&amp;gt;                   (vals (.fields r)))]&amp;lt;br&amp;gt;    (-hmap kf)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Record->HMap</a>[r]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Record?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Record [the-class variances poly? fields]&amp;lt;br&amp;gt;  &amp;quot;A Clojure record&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? variances)&amp;lt;br&amp;gt;       (and (seq variances)&amp;lt;br&amp;gt;            (every? variance? variances)))&amp;lt;br&amp;gt;   (or (nil? poly?)&amp;lt;br&amp;gt;       (and (seq poly?)&amp;lt;br&amp;gt;            (every? Type? poly?)))&amp;lt;br&amp;gt;   (symbol? the-class)&amp;lt;br&amp;gt;   ((array-map-c? symbol? (some-fn Scope? Type?)) fields)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Record?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;RecurTarget?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord RecurTarget [dom rest drest kws]&amp;lt;br&amp;gt;  &amp;quot;A target for recur&amp;quot;&amp;lt;br&amp;gt;  [(every? Type? dom)&amp;lt;br&amp;gt;   ((some-fn nil? Type?) rest)&amp;lt;br&amp;gt;   (nil? drest) ;TODO&amp;lt;br&amp;gt;   (nil? kws)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">RecurTarget?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Result-&gt;TCResult&lt;/b&gt; ([{:keys [t fl o], :as r}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Result-&amp;gt;TCResult [{:keys [t fl o] :as r}]&amp;lt;br&amp;gt;  {:pre [(Result? r)]&amp;lt;br&amp;gt;   :post [(TCResult? %)]}&amp;lt;br&amp;gt;  (ret t fl o))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Result->TCResult</a>[{:keys [t fl o], :as r}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Result-filter*&lt;/b&gt; ([r])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Result-filter* [r]&amp;lt;br&amp;gt;  {:pre [(Result? r)]&amp;lt;br&amp;gt;   :post [(Filter? %)]}&amp;lt;br&amp;gt;  (:fl r))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Result-filter*</a>[r]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Result-object*&lt;/b&gt; ([r])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Result-object* [r]&amp;lt;br&amp;gt;  {:pre [(Result? r)]&amp;lt;br&amp;gt;   :post [(RObject? %)]}&amp;lt;br&amp;gt;  (:o r))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Result-object*</a>[r]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Result-type*&lt;/b&gt; ([r])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Result-type* [r]&amp;lt;br&amp;gt;  {:pre [(Result? r)]&amp;lt;br&amp;gt;   :post [(Type? %)]}&amp;lt;br&amp;gt;  (:t r))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Result-type*</a>[r]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Result?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Result [t fl o]&amp;lt;br&amp;gt;  &amp;quot;A result type with filter f and object o. NOT a type.&amp;quot;&amp;lt;br&amp;gt;  [(Type? t)&amp;lt;br&amp;gt;   (Filter? fl)&amp;lt;br&amp;gt;   (RObject? o)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Result?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Scope?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Scope [body]&amp;lt;br&amp;gt;  &amp;quot;A scope that contains one bound variable, can be nested. Not used directly&amp;quot;&amp;lt;br&amp;gt;  [((some-fn Type? Scope?) body)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Scope?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;StringCLJS?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord StringCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive string in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">StringCLJS?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;SymbolCLJS?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord SymbolCLJS []&amp;lt;br&amp;gt;  &amp;quot;A type for Clojurescript symbols&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">SymbolCLJS?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;TApp?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TApp [rator rands]&amp;lt;br&amp;gt;  &amp;quot;An application of a type function to arguments.&amp;quot;&amp;lt;br&amp;gt;  [((some-fn Name? TypeFn? F? B?) rator)&amp;lt;br&amp;gt;   (every? (some-fn TypeFn? Type?) rands)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">TApp?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Top?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Top []&amp;lt;br&amp;gt;  &amp;quot;The top type&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Top?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;TopFilter?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TopFilter []&amp;lt;br&amp;gt;  &amp;quot;Trivially true proposition&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">TopFilter?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;TopFunction?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TopFunction []&amp;lt;br&amp;gt;  &amp;quot;Supertype to all functions&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">TopFunction?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;True?&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn True? [a] (= -true a))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">True?</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Type-&gt;array-member-Class&lt;/b&gt; ([ty] [ty nilok?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Type-&amp;gt;array-member-Class &amp;lt;br&amp;gt;  ([ty] (Type-&amp;gt;array-member-Class ty false))&amp;lt;br&amp;gt;  ([ty nilok?]&amp;lt;br&amp;gt;   {:pre [(Type? ty)]}&amp;lt;br&amp;gt;   (cond&amp;lt;br&amp;gt;     (requires-resolving? ty) (Type-&amp;gt;array-member-Class (-resolve ty) nilok?)&amp;lt;br&amp;gt;     (Nil? ty) (if nilok?&amp;lt;br&amp;gt;                 nil&amp;lt;br&amp;gt;                 Object)&amp;lt;br&amp;gt;     (Value? ty) (Value-&amp;gt;Class ty)&amp;lt;br&amp;gt;     ;; handles most common case of (U nil Type)&amp;lt;br&amp;gt;     (Union? ty) (let [clss (map #(Type-&amp;gt;array-member-Class % true) (:types ty))&amp;lt;br&amp;gt;                       prim-and-nil? (and (some nil? clss)&amp;lt;br&amp;gt;                                          (some #(when % (.isPrimitive ^Class %)) clss))&amp;lt;br&amp;gt;                       nonil-clss (remove nil? clss)]&amp;lt;br&amp;gt;                   (if (and (= 1 (count nonil-clss))&amp;lt;br&amp;gt;                            (not prim-and-nil?))&amp;lt;br&amp;gt;                     (first nonil-clss)&amp;lt;br&amp;gt;                     Object))&amp;lt;br&amp;gt;     (Intersection? ty) Object&amp;lt;br&amp;gt;     (RClass? ty) (RClass-&amp;gt;Class ty)&amp;lt;br&amp;gt;     (PrimitiveArray? ty) (class (make-array (Type-&amp;gt;array-member-Class (:jtype ty) false) 0))&amp;lt;br&amp;gt;     :else Object)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Type->array-member-Class</a>[ty] [ty nilok?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Type?&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Type? [a]&amp;lt;br&amp;gt;  (isa? (class a) Type))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Type?</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;TypeFilter?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TypeFilter [type path id]&amp;lt;br&amp;gt;  &amp;quot;A filter claiming looking up id, down the given path, is of given type&amp;quot;&amp;lt;br&amp;gt;  [(Type? type)&amp;lt;br&amp;gt;   (every? PathElem? path)&amp;lt;br&amp;gt;   (name-ref? id)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">TypeFilter?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;TypeFn*&lt;/b&gt; ([names variances bbnds body])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn TypeFn* [names variances bbnds body]&amp;lt;br&amp;gt;  {:pre [(every? symbol names)&amp;lt;br&amp;gt;         (every? variance? variances)&amp;lt;br&amp;gt;         (every? Bounds? bbnds)&amp;lt;br&amp;gt;         (apply = (map count [names variances bbnds]))&amp;lt;br&amp;gt;         ((some-fn TypeFn? Type?) body)]}&amp;lt;br&amp;gt;  (if (empty? names)&amp;lt;br&amp;gt;    body&amp;lt;br&amp;gt;    (-&amp;gt;TypeFn (count names) &amp;lt;br&amp;gt;              variances&amp;lt;br&amp;gt;              (vec&amp;lt;br&amp;gt;                (for [bnd bbnds]&amp;lt;br&amp;gt;                  (visit-bounds bnd #(abstract-many names %))))&amp;lt;br&amp;gt;              (abstract-many names body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">TypeFn*</a>[names variances bbnds body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;TypeFn-bbnds*&lt;/b&gt; ([names typefn])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn TypeFn-bbnds* [names ^TypeFn typefn]&amp;lt;br&amp;gt;  {:pre [(every? symbol? names)&amp;lt;br&amp;gt;         (TypeFn? typefn)]&amp;lt;br&amp;gt;   :post [(every? Bounds? %)]}&amp;lt;br&amp;gt;  (assert (= (.nbound typefn) (count names)) &amp;quot;Wrong number of names&amp;quot;)&amp;lt;br&amp;gt;  (mapv (fn [b]&amp;lt;br&amp;gt;          (visit-bounds b #(instantiate-many names %)))&amp;lt;br&amp;gt;        (.bbnds typefn)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">TypeFn-bbnds*</a>[names typefn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;TypeFn-body*&lt;/b&gt; ([names typefn])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn TypeFn-body* [names ^TypeFn typefn]&amp;lt;br&amp;gt;  {:pre [(every? symbol? names)&amp;lt;br&amp;gt;         (TypeFn? typefn)]}&amp;lt;br&amp;gt;  (assert (= (.nbound typefn) (count names)) &amp;quot;Wrong number of names&amp;quot;)&amp;lt;br&amp;gt;  (instantiate-many names (.scope typefn)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">TypeFn-body*</a>[names typefn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;TypeFn?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TypeFn [nbound variances bbnds scope]&amp;lt;br&amp;gt;  &amp;quot;A type function containing n bound variables with variances.&amp;lt;br&amp;gt;  It is of a higher kind&amp;quot;&amp;lt;br&amp;gt;  [(nat? nbound)&amp;lt;br&amp;gt;   (every? variance? variances)&amp;lt;br&amp;gt;   (every? Bounds? bbnds)&amp;lt;br&amp;gt;   (apply = nbound (map count [variances bbnds]))&amp;lt;br&amp;gt;   (scope-depth? scope nbound)&amp;lt;br&amp;gt;   (Scope? scope)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">TypeFn?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Un&lt;/b&gt; ([&amp; types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Un [&amp;amp; types]&amp;lt;br&amp;gt;  (let [types (disj (set types) empty-union)]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (empty? types) empty-union&amp;lt;br&amp;gt;      (= 1 (count types)) (first types)&amp;lt;br&amp;gt;      :else (-&amp;gt;Union (set (apply concat&amp;lt;br&amp;gt;                                 (for [t (set types)]&amp;lt;br&amp;gt;                                   (if (Union? t)&amp;lt;br&amp;gt;                                     (:types t)&amp;lt;br&amp;gt;                                     [t]))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Un</a>[& types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Union?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Union [types]&amp;lt;br&amp;gt;  &amp;quot;An flattened, unordered union of types&amp;quot;&amp;lt;br&amp;gt;  [(set? types)&amp;lt;br&amp;gt;   (every? Type? types)&amp;lt;br&amp;gt;   (not (some Union? types))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Union?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Value-&gt;Class&lt;/b&gt; ([tval])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^Class Value-&amp;gt;Class [^Value tval]&amp;lt;br&amp;gt;  (class (.val tval)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Value->Class</a>[tval]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;Value?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Value [val]&amp;lt;br&amp;gt;  &amp;quot;A Clojure value&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Value?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;abo&lt;/b&gt; ([xs idxs f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn abo [xs idxs f]&amp;lt;br&amp;gt;  {:pre [(every? symbol? xs)&amp;lt;br&amp;gt;         (every? integer? idxs)&amp;lt;br&amp;gt;         (Filter? f)]&amp;lt;br&amp;gt;   :post [(Filter? %)]}&amp;lt;br&amp;gt;;  (prn &amp;quot;abo&amp;quot;)&amp;lt;br&amp;gt;;  (prn xs idxs f)&amp;lt;br&amp;gt;  (letfn [(lookup [y]&amp;lt;br&amp;gt;            {:pre [(symbol? y)]&amp;lt;br&amp;gt;             :post [((some-fn nil? integer?) %)]}&amp;lt;br&amp;gt;            (some (fn [[x i]] (and (= x y) i))&amp;lt;br&amp;gt;                  (map vector xs idxs)))&amp;lt;br&amp;gt;          (rec [f] (abo xs idxs f))&amp;lt;br&amp;gt;          (sb-t [t] t)]&amp;lt;br&amp;gt;    (fold-rhs ::abo&amp;lt;br&amp;gt;      {:type-rec sb-t &amp;lt;br&amp;gt;       :filter-rec rec&amp;lt;br&amp;gt;       :locals {:lookup lookup}}&amp;lt;br&amp;gt;      f)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">abo</a>[xs idxs f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;abstract&lt;/b&gt; ([name ty])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn abstract [name ty]&amp;lt;br&amp;gt;  &amp;quot;Make free name bound&amp;quot;&amp;lt;br&amp;gt;  {:pre [(symbol? name)&amp;lt;br&amp;gt;         (Type? ty)]}&amp;lt;br&amp;gt;  (abstract-many [name] ty))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">abstract</a>[name ty]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;abstract-filter&lt;/b&gt; ([ids keys fs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn abstract-filter [ids keys fs]&amp;lt;br&amp;gt;  {:pre [(every? symbol? ids)&amp;lt;br&amp;gt;         (every? integer? keys)&amp;lt;br&amp;gt;         ((some-fn NoFilter? FilterSet?) fs)]&amp;lt;br&amp;gt;   :post [((some-fn NoFilter? FilterSet?) %)]}&amp;lt;br&amp;gt;;  (prn &amp;quot;abstract filter&amp;quot;)&amp;lt;br&amp;gt;;  (prn ids keys fs)&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (FilterSet? fs)&amp;lt;br&amp;gt;    (let [{fs+ :then fs- :else} fs]&amp;lt;br&amp;gt;      (-FS (abo ids keys fs+)&amp;lt;br&amp;gt;           (abo ids keys fs-)))&amp;lt;br&amp;gt;    (NoFilter? fs) (-FS -top -top)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">abstract-filter</a>[ids keys fs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;abstract-many&lt;/b&gt; ([names ty])&lt;br&gt; Names Type -&gt; Scope^n  where n is (count names)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn abstract-many &amp;lt;br&amp;gt;  &amp;quot;Names Type -&amp;gt; Scope^n  where n is (count names)&amp;quot;&amp;lt;br&amp;gt;  [names ty]&amp;lt;br&amp;gt;  {:pre [(every? symbol? names)&amp;lt;br&amp;gt;         ((some-fn Type? TypeFn?) ty)]}&amp;lt;br&amp;gt;  (letfn [(name-to &amp;lt;br&amp;gt;            ([name count type] (name-to name count type 0 type))&amp;lt;br&amp;gt;            ([name count type outer ty]&amp;lt;br&amp;gt;             (letfn [(sb [t] (name-to name count type outer t))]&amp;lt;br&amp;gt;               (fold-rhs ::abstract-many&amp;lt;br&amp;gt;                 {:type-rec sb&amp;lt;br&amp;gt;                  :filter-rec (sub-f sb ::abstract-many)&amp;lt;br&amp;gt;                  :object-rec (sub-o sb ::abstract-many)&amp;lt;br&amp;gt;                  :locals {:name name&amp;lt;br&amp;gt;                           :count count&amp;lt;br&amp;gt;                           :outer outer&amp;lt;br&amp;gt;                           :sb sb&amp;lt;br&amp;gt;                           :name-to name-to}}&amp;lt;br&amp;gt;                 ty))))]&amp;lt;br&amp;gt;    (if (empty? names)&amp;lt;br&amp;gt;      ty&amp;lt;br&amp;gt;      (let [n (count names)]&amp;lt;br&amp;gt;        (loop [ty ty&amp;lt;br&amp;gt;               names names&amp;lt;br&amp;gt;               count (dec n)]&amp;lt;br&amp;gt;          (if (zero? count)&amp;lt;br&amp;gt;            (add-scopes n (name-to (first names) 0 ty))&amp;lt;br&amp;gt;            (recur (name-to (first names) count ty)&amp;lt;br&amp;gt;                   (next names)&amp;lt;br&amp;gt;                   (dec count))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">abstract-many</a>[names ty]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;abstract-object&lt;/b&gt; ([ids keys o])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn abstract-object [ids keys o]&amp;lt;br&amp;gt;  {:pre [(every? symbol? ids)&amp;lt;br&amp;gt;         (every? integer? keys)&amp;lt;br&amp;gt;         (RObject? o)]&amp;lt;br&amp;gt;   :post [(RObject? %)]}&amp;lt;br&amp;gt;  (letfn [(lookup [y]&amp;lt;br&amp;gt;            {:pre [(symbol? y)]&amp;lt;br&amp;gt;             :post [((some-fn nil? integer?) %)]}&amp;lt;br&amp;gt;            (some (fn [[x i]] (and (= x y) i))&amp;lt;br&amp;gt;                  (map vector ids keys)))]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (and (Path? o)&amp;lt;br&amp;gt;           (lookup (:id o))) (update-in o [:id] lookup)&amp;lt;br&amp;gt;      :else -empty)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">abstract-object</a>[ids keys o]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;abstract-result&lt;/b&gt; ([result arg-names])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn abstract-result [result arg-names]&amp;lt;br&amp;gt;  {:pre [(TCResult? result)&amp;lt;br&amp;gt;         (every? symbol? arg-names)]&amp;lt;br&amp;gt;   :post [(Result? %)]}&amp;lt;br&amp;gt;  (let [keys (range (count arg-names))]&amp;lt;br&amp;gt;    (make-Result&amp;lt;br&amp;gt;      (ret-t result)&amp;lt;br&amp;gt;      (abstract-filter arg-names keys (ret-f result))&amp;lt;br&amp;gt;      (abstract-object arg-names keys (ret-o result)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">abstract-result</a>[result arg-names]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-constructor-override&lt;/b&gt; ([sym t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-constructor-override [sym t]&amp;lt;br&amp;gt;  (swap! CONSTRUCTOR-OVERRIDE-ENV assoc sym t)&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-constructor-override</a>[sym t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-datatype&lt;/b&gt; ([sym t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-datatype [sym t]&amp;lt;br&amp;gt;  (swap! DATATYPE-ENV assoc sym t)&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-datatype</a>[sym t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-datatype-ancestors&lt;/b&gt; ([sym tset])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-datatype-ancestors [sym tset]&amp;lt;br&amp;gt;  (swap! DATATYPE-ANCESTOR-ENV update-in [sym] #(set/union (or % #{}) tset))&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-datatype-ancestors</a>[sym tset]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-declared-kind&lt;/b&gt; ([sym tfn])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-declared-kind [sym tfn]&amp;lt;br&amp;gt;  (swap! DECLARED-KIND-ENV assoc sym tfn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-declared-kind</a>[sym tfn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-default-fold-case&lt;/b&gt; ([ty fld-fn])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro add-default-fold-case [ty fld-fn]&amp;lt;br&amp;gt;  `(add-fold-case fold-rhs-default ~ty ~fld-fn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-default-fold-case</a>[ty fld-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-fold-case&lt;/b&gt; ([mode ty fld-fn])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro add-fold-case [mode ty fld-fn]&amp;lt;br&amp;gt;  `(defmethod fold-rhs [~mode ~ty]&amp;lt;br&amp;gt;     [mode# options# ty#]&amp;lt;br&amp;gt;     (let [~'[type-rec filter-rec object-rec pathelem-rec]&amp;lt;br&amp;gt;           (map #(or (% options#)&amp;lt;br&amp;gt;                     (partial fold-rhs mode# options#))&amp;lt;br&amp;gt;                [:type-rec :filter-rec :object-rec :pathelem-rec])]&amp;lt;br&amp;gt;       (~fld-fn ty# options#))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-fold-case</a>[mode ty fld-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-method-nilable-param&lt;/b&gt; ([sym a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-method-nilable-param [sym a]&amp;lt;br&amp;gt;  (swap! METHOD-PARAM-NILABLE-ENV assoc sym a)&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-method-nilable-param</a>[sym a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-method-override&lt;/b&gt; ([sym t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-method-override [sym t]&amp;lt;br&amp;gt;  (swap! METHOD-OVERRIDE-ENV assoc sym t)&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-method-override</a>[sym t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-multimethod-dispatch-type&lt;/b&gt; ([mmsym dtype])&lt;br&gt; Add the type of the dispatch function of the multimethod named by mmsym&lt;br&gt;  to the environment. If already exists, must be identical.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-multimethod-dispatch-type&amp;lt;br&amp;gt;  &amp;quot;Add the type of the dispatch function of the multimethod named by mmsym&amp;lt;br&amp;gt;  to the environment. If already exists, must be identical.&amp;quot;&amp;lt;br&amp;gt;  [mmsym dtype]&amp;lt;br&amp;gt;  {:pre [(symbol? mmsym)&amp;lt;br&amp;gt;         (Type? dtype)]}&amp;lt;br&amp;gt;  (when-let [old (@MULTIMETHOD-DISPATCH-ENV mmsym)]&amp;lt;br&amp;gt;    (assert (= old dtype)&amp;lt;br&amp;gt;            (str &amp;quot;Cannot assign multimethod a different dispatch result: &amp;quot;&amp;lt;br&amp;gt;                 &amp;quot; Old: &amp;quot; (unparse-type old)&amp;lt;br&amp;gt;                 &amp;quot; New: &amp;quot; (unparse-type dtype))))&amp;lt;br&amp;gt;  (swap! MULTIMETHOD-DISPATCH-ENV assoc mmsym dtype)&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-multimethod-dispatch-type</a>[mmsym dtype]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-nonnilable-method-return&lt;/b&gt; ([sym m])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-nonnilable-method-return [sym m]&amp;lt;br&amp;gt;  (swap! METHOD-RETURN-NONNILABLE-ENV assoc sym m)&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-nonnilable-method-return</a>[sym m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-protocol&lt;/b&gt; ([sym t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-protocol [sym t]&amp;lt;br&amp;gt;  (swap! PROTOCOL-ENV assoc sym t)&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-protocol</a>[sym t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-scopes&lt;/b&gt; ([n t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-scopes [n t]&amp;lt;br&amp;gt;  &amp;quot;Wrap type in n Scopes&amp;quot;&amp;lt;br&amp;gt;  {:pre [(nat? n)&amp;lt;br&amp;gt;         (Type? t)]}&amp;lt;br&amp;gt;  (doall&amp;lt;br&amp;gt;    (last &amp;lt;br&amp;gt;      (take (inc n) (iterate -&amp;gt;Scope t)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-scopes</a>[n t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-type-name&lt;/b&gt; ([sym ty])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-type-name [sym ty]&amp;lt;br&amp;gt;  (swap! TYPE-NAME-ENV assoc sym (if (Type? ty)&amp;lt;br&amp;gt;                                   (vary-meta ty assoc :from-name sym)&amp;lt;br&amp;gt;                                   ty))&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-type-name</a>[sym ty]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;add-var-type&lt;/b&gt; ([sym type])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-var-type [sym type]&amp;lt;br&amp;gt;  (swap! VAR-ANNOTATIONS #(assoc % sym type))&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-var-type</a>[sym type]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;alter-class&lt;/b&gt; ([the-class frees-syn &amp; opts])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro alter-class [the-class frees-syn &amp;amp; opts]&amp;lt;br&amp;gt;  (let [{replacements-syn :replace&amp;lt;br&amp;gt;         unchecked-ancestors-syn :unchecked-ancestors} (apply hash-map opts)]&amp;lt;br&amp;gt;     `(let [[variances# frees#] (when-let [fs# (seq '~frees-syn)]&amp;lt;br&amp;gt;                                  (let [b# (parse-RClass-binder fs#)]&amp;lt;br&amp;gt;                                    [(map first b#) (map second b#)]))&amp;lt;br&amp;gt;            csym# (let [cls# (when-let [c# (resolve '~the-class)]&amp;lt;br&amp;gt;                               (when (class? c#)&amp;lt;br&amp;gt;                                 c#))]&amp;lt;br&amp;gt;                    (or (and cls# (Class-&amp;gt;symbol cls#))&amp;lt;br&amp;gt;                        '~the-class))]&amp;lt;br&amp;gt;        (alter-class* csym# &amp;lt;br&amp;gt;                      (RClass* (map :name frees#) variances# frees# csym#&amp;lt;br&amp;gt;                               (with-frees frees#&amp;lt;br&amp;gt;                                 ~(build-replacement-syntax replacements-syn))&amp;lt;br&amp;gt;                               (with-frees frees#&amp;lt;br&amp;gt;                                 (set (map parse-type '~unchecked-ancestors-syn)))))&amp;lt;br&amp;gt;        ~the-class)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">alter-class</a>[the-class frees-syn & opts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;alter-class*&lt;/b&gt; ([csym type])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn alter-class* [csym type]&amp;lt;br&amp;gt;  (swap! RESTRICTED-CLASS assoc csym type))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">alter-class*</a>[csym type]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ana-cljs&lt;/b&gt; ([env form])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ana-cljs [env form]&amp;lt;br&amp;gt;  (with-altered-specials&amp;lt;br&amp;gt;    (binding [cljs/*cljs-ns* cljs/*cljs-ns*]&amp;lt;br&amp;gt;      (cljs/analyze env form))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ana-cljs</a>[env form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;analyze-file-asts&lt;/b&gt; ([f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-file-asts&amp;lt;br&amp;gt;  [^String f]&amp;lt;br&amp;gt;  (let [res (if (re-find #&amp;quot;^file://&amp;quot; f) (java.net.URL. f) (io/resource f))]&amp;lt;br&amp;gt;    (assert res (str &amp;quot;Can't find &amp;quot; f &amp;quot; in classpath&amp;quot;))&amp;lt;br&amp;gt;    (with-altered-specials&amp;lt;br&amp;gt;      (binding [cljs/*cljs-ns* 'cljs.user&amp;lt;br&amp;gt;                cljs/*cljs-file* (.getPath ^java.net.URL res)&amp;lt;br&amp;gt;                *ns* cljs/*reader-ns*]&amp;lt;br&amp;gt;        (with-open [r (io/reader res)]&amp;lt;br&amp;gt;          (let [env (cljs/empty-env)&amp;lt;br&amp;gt;                pbr (clojure.lang.LineNumberingPushbackReader. r)&amp;lt;br&amp;gt;                eof (Object.)]&amp;lt;br&amp;gt;            (loop [r (read pbr false eof false)&amp;lt;br&amp;gt;                   asts []]&amp;lt;br&amp;gt;              (let [env (assoc env :ns (cljs/get-namespace cljs/*cljs-ns*))]&amp;lt;br&amp;gt;                (if-not (identical? eof r)&amp;lt;br&amp;gt;                  (let [ast1 (cljs/analyze env r)]&amp;lt;br&amp;gt;                    (recur (read pbr false eof false) (conj asts ast1)))&amp;lt;br&amp;gt;                  asts)))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-file-asts</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ann&lt;/b&gt; ([varsym typesyn])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ann [varsym typesyn]&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt; (do (ensure-clojure)&amp;lt;br&amp;gt;   (let [t# (parse-type '~typesyn)&amp;lt;br&amp;gt;         s# (if (namespace '~varsym)&amp;lt;br&amp;gt;              '~varsym&amp;lt;br&amp;gt;              (symbol (-&amp;gt; *ns* ns-name str) (str '~varsym)))]&amp;lt;br&amp;gt;     (do (add-var-type s# t#)&amp;lt;br&amp;gt;       [s# (unparse-type t#)])))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ann</a>[varsym typesyn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ann-datatype&lt;/b&gt; ([dname fields &amp; {ancests :unchecked-ancestors, rplc :replace}])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ann-datatype [dname fields &amp;amp; {ancests :unchecked-ancestors rplc :replace}]&amp;lt;br&amp;gt;  (assert (not rplc) &amp;quot;Replace NYI&amp;quot;)&amp;lt;br&amp;gt;  (assert (symbol? dname)&amp;lt;br&amp;gt;          (str &amp;quot;Must provide name symbol: &amp;quot; dname))&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;     ~(gen-datatype* dname fields nil nil ancests false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ann-datatype</a>[dname fields & {ancests :unchecked-ancestors, rplc :replace}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ann-form&lt;/b&gt; ([form ty])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ann-form [form ty]&amp;lt;br&amp;gt;  `(ann-form* ~form '~ty))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ann-form</a>[form ty]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ann-form*&lt;/b&gt; ([form ty])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ann-form* [form ty]&amp;lt;br&amp;gt;  form)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ann-form*</a>[form ty]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ann-form-cljs&lt;/b&gt; ([form tsyn])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ann-form-cljs [form tsyn]&amp;lt;br&amp;gt;  `(typed.internal/ann-form-cljs* ~form '~tsyn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ann-form-cljs</a>[form tsyn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ann-pdatatype&lt;/b&gt; ([dname vbnd fields &amp; {ancests :unchecked-ancestors, rplc :replace}])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ann-pdatatype [dname vbnd fields &amp;amp; {ancests :unchecked-ancestors rplc :replace}]&amp;lt;br&amp;gt;  (assert (not rplc) &amp;quot;Replace NYI&amp;quot;)&amp;lt;br&amp;gt;  (assert (symbol? dname)&amp;lt;br&amp;gt;          (str &amp;quot;Must provide local symbol: &amp;quot; dname))&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;     ~(gen-datatype* dname fields (map second vbnd) (map first vbnd) ancests false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ann-pdatatype</a>[dname vbnd fields & {ancests :unchecked-ancestors, rplc :replace}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ann-pprotocol&lt;/b&gt; ([local-varsym vbnd &amp; {:as mth}])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ann-pprotocol [local-varsym vbnd &amp;amp; {:as mth}]&amp;lt;br&amp;gt;  (assert (not (or (namespace local-varsym)&amp;lt;br&amp;gt;                   (some #{\.} (str local-varsym))))&amp;lt;br&amp;gt;          (str &amp;quot;Must provide local var name for protocol: &amp;quot; local-varsym))&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;     ~(gen-protocol* local-varsym (mapv second vbnd) (mapv first vbnd) mth)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ann-pprotocol</a>[local-varsym vbnd & {:as mth}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ann-precord&lt;/b&gt; ([dname vbnd fields &amp; {ancests :unchecked-ancestors, rplc :replace}])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ann-precord [dname vbnd fields &amp;amp; {ancests :unchecked-ancestors rplc :replace}]&amp;lt;br&amp;gt;  (assert (not rplc) &amp;quot;Replace NYI&amp;quot;)&amp;lt;br&amp;gt;  (assert (symbol? dname)&amp;lt;br&amp;gt;          (str &amp;quot;Must provide local symbol: &amp;quot; dname))&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;     ~(gen-datatype* dname fields (map second vbnd) (map first vbnd) ancests true)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ann-precord</a>[dname vbnd fields & {ancests :unchecked-ancestors, rplc :replace}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ann-protocol&lt;/b&gt; ([local-varsym &amp; {:as mth}])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ann-protocol [local-varsym &amp;amp; {:as mth}]&amp;lt;br&amp;gt;  (assert (not (or (namespace local-varsym)&amp;lt;br&amp;gt;                   (some #{\.} (str local-varsym))))&amp;lt;br&amp;gt;          (str &amp;quot;Must provide local var name for protocol: &amp;quot; local-varsym))&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;     ~(gen-protocol* local-varsym nil nil mth)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ann-protocol</a>[local-varsym & {:as mth}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ann-record&lt;/b&gt; ([dname fields &amp; {ancests :unchecked-ancestors, rplc :replace}])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ann-record [dname fields &amp;amp; {ancests :unchecked-ancestors rplc :replace}]&amp;lt;br&amp;gt;  (assert (not rplc) &amp;quot;Replace NYI&amp;quot;)&amp;lt;br&amp;gt;  (assert (symbol? dname)&amp;lt;br&amp;gt;          (str &amp;quot;Must provide name symbol: &amp;quot; dname))&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;     ~(gen-datatype* dname fields nil nil ancests true)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ann-record</a>[dname fields & {ancests :unchecked-ancestors, rplc :replace}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;app-type-error&lt;/b&gt; ([fexpr args fin arg-ret-types expected poly?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String app-type-error [fexpr args ^FnIntersection fin arg-ret-types expected poly?]&amp;lt;br&amp;gt;  {:pre [(FnIntersection? fin)]}&amp;lt;br&amp;gt;  (let [static-method? (= :static-method (:op fexpr))&amp;lt;br&amp;gt;        instance-method? (= :instance-method (:op fexpr))&amp;lt;br&amp;gt;        method-sym (when (or static-method? instance-method?)&amp;lt;br&amp;gt;                     (MethodExpr-&amp;gt;qualsym fexpr))]&amp;lt;br&amp;gt;    (error-msg &amp;lt;br&amp;gt;      (if poly? &amp;lt;br&amp;gt;        (str &amp;quot;Polymorphic &amp;quot; &amp;lt;br&amp;gt;             (cond static-method? &amp;quot;static method &amp;quot;&amp;lt;br&amp;gt;                   instance-method? &amp;quot;instance method &amp;quot;&amp;lt;br&amp;gt;                   :else &amp;quot;function &amp;quot;))&amp;lt;br&amp;gt;        (cond static-method? &amp;quot;Static method &amp;quot;&amp;lt;br&amp;gt;              instance-method? &amp;quot;Instance method &amp;quot;&amp;lt;br&amp;gt;              :else &amp;quot;Function &amp;quot;))&amp;lt;br&amp;gt;      (if (or static-method?&amp;lt;br&amp;gt;              instance-method?)  &amp;lt;br&amp;gt;        (or method-sym&amp;lt;br&amp;gt;            (:method-name fexpr))&amp;lt;br&amp;gt;        (emit-form-fn fexpr)) &amp;lt;br&amp;gt;      &amp;quot; could not be applied to arguments:\n&amp;quot;&amp;lt;br&amp;gt;      &amp;quot;Domains: \n\t&amp;quot; &amp;lt;br&amp;gt;      (clojure.string/join &amp;quot;\n\t&amp;quot; (map (partial apply pr-str) (map (comp #(map unparse-type %) :dom) (.types fin)))) &amp;lt;br&amp;gt;      &amp;quot;\n\n&amp;quot;&amp;lt;br&amp;gt;      &amp;quot;Arguments:\n\t&amp;quot; (apply prn-str (mapv (comp unparse-type ret-t) arg-ret-types)) &amp;quot;\n&amp;quot;&amp;lt;br&amp;gt;      (when expected (str &amp;quot;with expected type:\n\t&amp;quot; (unparse-type (ret-t expected)) &amp;quot;\n\n&amp;quot;))&amp;lt;br&amp;gt;      &amp;quot;in: &amp;quot; (if (or static-method? instance-method?)&amp;lt;br&amp;gt;               (emit-form-fn fexpr)&amp;lt;br&amp;gt;               (list* (emit-form-fn fexpr)&amp;lt;br&amp;gt;                      (map emit-form-fn args))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">app-type-error</a>[fexpr args fin arg-ret-types expected poly?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;arr-subtype&lt;/b&gt; ([A0 s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn arr-subtype [A0 ^Function s ^Function t]&amp;lt;br&amp;gt;  {:pre [(Function? s)&amp;lt;br&amp;gt;         (Function? t)]}&amp;lt;br&amp;gt;  (assert (not (some :kws [s t])))&amp;lt;br&amp;gt;  ;; top for functions is above everything&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    ;; top for functions is above everything&amp;lt;br&amp;gt;    (TopFunction? t) A0&amp;lt;br&amp;gt;    ;; the really simple case&amp;lt;br&amp;gt;    (and (not ((some-fn :rest :drest :kws) s))&amp;lt;br&amp;gt;         (not ((some-fn :rest :drest :kws) t)))&amp;lt;br&amp;gt;    (do&amp;lt;br&amp;gt;      (when-not (= (count (.dom s))&amp;lt;br&amp;gt;                   (count (.dom t)))&amp;lt;br&amp;gt;        (type-error s t))&amp;lt;br&amp;gt;      (-&amp;gt; *sub-current-seen*&amp;lt;br&amp;gt;        ((fn [A0]&amp;lt;br&amp;gt;           (reduce (fn [A* [s t]]&amp;lt;br&amp;gt;                     (subtypeA* A* s t))&amp;lt;br&amp;gt;                   A0&amp;lt;br&amp;gt;                   (map vector (.dom t) (.dom s)))))&amp;lt;br&amp;gt;        (subtypeA* (.rng s) (.rng t))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (:rest s)&amp;lt;br&amp;gt;         (not ((some-fn :rest :drest) t)))&amp;lt;br&amp;gt;    (-&amp;gt; *sub-current-seen*&amp;lt;br&amp;gt;      (subtypes*-varargs (.dom t) (.dom s) (.rest s))&amp;lt;br&amp;gt;      (subtypeA* (.rng s) (.rng t)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (not ((some-fn :rest :drest) s))&amp;lt;br&amp;gt;         (:rest t))&amp;lt;br&amp;gt;    (type-error s t)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (.rest s)&amp;lt;br&amp;gt;         (.rest t))&amp;lt;br&amp;gt;    (-&amp;gt; *sub-current-seen*&amp;lt;br&amp;gt;      (subtypes*-varargs (:dom t) (:dom s) (:rest s))&amp;lt;br&amp;gt;      (subtypeA* (:rest t) (:rest s))&amp;lt;br&amp;gt;      (subtypeA* (:rng s) (:rng t)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    ;; handle ... varargs when the bounds are the same&amp;lt;br&amp;gt;    (and (:drest s)&amp;lt;br&amp;gt;         (:drest t)&amp;lt;br&amp;gt;         (= (-&amp;gt; s :drest :name)&amp;lt;br&amp;gt;            (-&amp;gt; t :drest :name)))&amp;lt;br&amp;gt;    (-&amp;gt; *sub-current-seen*&amp;lt;br&amp;gt;      (subtypeA* (-&amp;gt; t :drest :pre-type) (-&amp;gt; s :drest :pre-type))&amp;lt;br&amp;gt;      ((fn [A0] &amp;lt;br&amp;gt;         (reduce (fn [A* [s t]]&amp;lt;br&amp;gt;                   (subtypeA* A* s t))&amp;lt;br&amp;gt;                 A0 (map vector (:dom t) (:dom s)))))&amp;lt;br&amp;gt;      (subtypeA* (:rng s) (:rng t)))&amp;lt;br&amp;gt;    :else (type-error s t)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">arr-subtype</a>[A0 s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;binding-init-sym&lt;/b&gt; ([binding-init])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn binding-init-sym [binding-init]&amp;lt;br&amp;gt;  {:pre [(= :binding-init (:op binding-init))]&amp;lt;br&amp;gt;   :post [(symbol? %)]}&amp;lt;br&amp;gt;  (-&amp;gt; binding-init&amp;lt;br&amp;gt;    :local-binding&amp;lt;br&amp;gt;    hygienic/hsym-key))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">binding-init-sym</a>[binding-init]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;bound-index?&lt;/b&gt; ([n])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bound-index? [n]&amp;lt;br&amp;gt;  (contains? *dotted-scope* n))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bound-index?</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;c-meet&lt;/b&gt; ([{S :S, X :X, T :T, bnds :bnds, :as c1} {S* :S, X* :X, T* :T, bnds* :bnds, :as c2} &amp; [var]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn c-meet [{S  :S X  :X T  :T bnds  :bnds :as c1}&amp;lt;br&amp;gt;              {S* :S X* :X T* :T bnds* :bnds :as c2}&amp;lt;br&amp;gt;              &amp;amp; [var]]&amp;lt;br&amp;gt;  #_(prn &amp;quot;c-meet&amp;quot; c1 c2)&amp;lt;br&amp;gt;  (when-not (or var (= X X*))&amp;lt;br&amp;gt;    (throw (Exception. (str &amp;quot;Non-matching vars in c-meet:&amp;quot; X X*))))&amp;lt;br&amp;gt;  (when-not (= bnds bnds*)&amp;lt;br&amp;gt;    (throw (Exception. (str &amp;quot;Non-matching bounds in c-meet:&amp;quot; bnds bnds*))))&amp;lt;br&amp;gt;  (let [S (join S S*)&amp;lt;br&amp;gt;        T (meet T T*)]&amp;lt;br&amp;gt;    (when-not (subtype? S T)&amp;lt;br&amp;gt;      (type-error S T))&amp;lt;br&amp;gt;    (-&amp;gt;c S (or var X) T bnds)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">c-meet</a>[{S :S, X :X, T :T, bnds :bnds, :as c1} {S* :S, X* :X, T* :T, bnds* :bnds, :as c2} & [var]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;c?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord c [S X T bnds]&amp;lt;br&amp;gt;  &amp;quot;A type constraint on a variable within an upper and lower bound&amp;quot;&amp;lt;br&amp;gt;  [(Type? S)&amp;lt;br&amp;gt;   (symbol? X)&amp;lt;br&amp;gt;   (Type? T)&amp;lt;br&amp;gt;   (Bounds? bnds)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">c?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cf&lt;/b&gt; ([form] [form expected])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Type check a Clojure form and return its type&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro cf &amp;lt;br&amp;gt;  &amp;quot;Type check a Clojure form and return its type&amp;quot;&amp;lt;br&amp;gt;  ([form]&amp;lt;br&amp;gt;  `(do (ensure-clojure)&amp;lt;br&amp;gt;     (tc-ignore&amp;lt;br&amp;gt;       (-&amp;gt; (analyze/ast ~form) hygienic/ast-hy check expr-type unparse-TCResult))))&amp;lt;br&amp;gt;  ([form expected]&amp;lt;br&amp;gt;  `(do (ensure-clojure)&amp;lt;br&amp;gt;     (tc-ignore&amp;lt;br&amp;gt;       (-&amp;gt; (analyze/ast (ann-form ~form ~expected)) hygienic/ast-hy (#(check % (ret (parse-type '~expected)))) expr-type unparse-TCResult)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cf</a>[form] [form expected]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cf-cljs&lt;/b&gt; ([form] [form expected])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Type check a Clojurescript form and return its type&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro cf-cljs&amp;lt;br&amp;gt;  &amp;quot;Type check a Clojurescript form and return its type&amp;quot;&amp;lt;br&amp;gt;  ([form]&amp;lt;br&amp;gt;   (let [t&amp;lt;br&amp;gt;         (do (ensure-clojurescript)&amp;lt;br&amp;gt;           (-&amp;gt; (ana-cljs {:locals {} :context :expr :ns {:name cljs/*cljs-ns*}} form) check-cljs expr-type unparse-TCResult))]&amp;lt;br&amp;gt;     `'~t))&amp;lt;br&amp;gt;  ([form expected]&amp;lt;br&amp;gt;   (let [t&amp;lt;br&amp;gt;         (do (ensure-clojurescript)&amp;lt;br&amp;gt;           (-&amp;gt; (ana-cljs {:locals {} :context :expr :ns {:name cljs/*cljs-ns*}}&amp;lt;br&amp;gt;                         (list `ann-form-cljs form expected))&amp;lt;br&amp;gt;             (#(check-cljs % (ret (parse-type expected)))) expr-type unparse-TCResult))]&amp;lt;br&amp;gt;     `'~t)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cf-cljs</a>[form] [form expected]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-anon-fn&lt;/b&gt; ([{:keys [methods], :as expr} methods-types &amp; {:keys [poly]}])&lt;br&gt; Check anonymous function, with annotated methods. methods-types&lt;br&gt;  is a (Seqable (HMap {:dom (Seqable Type) :rng (U nil Type)}))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-anon-fn&amp;lt;br&amp;gt;  &amp;quot;Check anonymous function, with annotated methods. methods-types&amp;lt;br&amp;gt;  is a (Seqable (HMap {:dom (Seqable Type) :rng (U nil Type)}))&amp;quot;&amp;lt;br&amp;gt;  [{:keys [methods] :as expr} methods-types &amp;amp; {:keys [poly]}]&amp;lt;br&amp;gt;  {:pre [(every? (hmap-c? :dom (every-c? Type?)&amp;lt;br&amp;gt;                          :rng (some-fn nil? Type?)&amp;lt;br&amp;gt;                          :rest nil? ;TODO&amp;lt;br&amp;gt;                          :drest nil?) ;TODO&amp;lt;br&amp;gt;                 methods-types)&amp;lt;br&amp;gt;         ((some-fn nil? &amp;lt;br&amp;gt;                   (every-c? (hvector-c? symbol? Bounds?)))&amp;lt;br&amp;gt;            poly)]&amp;lt;br&amp;gt;   :post [(TCResult? (expr-type %))]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    ; named fns must be fully annotated, and are checked with normal check&amp;lt;br&amp;gt;    (:name expr) (let [ftype (apply make-FnIntersection &amp;lt;br&amp;gt;                                    (doall (for [{:keys [dom rng]} methods-types]&amp;lt;br&amp;gt;                                             (if rng&amp;lt;br&amp;gt;                                               (make-Function dom rng)&amp;lt;br&amp;gt;                                               (throw (Exception. &amp;quot;Named anonymous functions require return type annotation&amp;quot;))))))&amp;lt;br&amp;gt;                       ftype (if poly&amp;lt;br&amp;gt;                               (Poly* (map first poly)&amp;lt;br&amp;gt;                                      (map second poly)&amp;lt;br&amp;gt;                                      ftype&amp;lt;br&amp;gt;                                      (map first poly))&amp;lt;br&amp;gt;                               ftype)]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;                   (check expr (ret ftype)))&amp;lt;br&amp;gt;    :else&amp;lt;br&amp;gt;    (let [;_ (prn methods methods-types expr)&amp;lt;br&amp;gt;          ftype (apply make-FnIntersection (mapv FnResult-&amp;gt;Function &amp;lt;br&amp;gt;                                                 (mapv (fn [m {:keys [dom rng]}]&amp;lt;br&amp;gt;                                                         (check-anon-fn-method m dom rng))&amp;lt;br&amp;gt;                                                       methods methods-types)))]&amp;lt;br&amp;gt;      (assoc expr&amp;lt;br&amp;gt;             expr-type (ret ftype (-FS -top -bot) -empty)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-anon-fn</a>[{:keys [methods], :as expr} methods-types & {:keys [poly]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-apply&lt;/b&gt; ([{[fexpr &amp; args] :args, :as expr} expected])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-apply&amp;lt;br&amp;gt;  [{[fexpr &amp;amp; args] :args :as expr} expected]&amp;lt;br&amp;gt;  {:post [((some-fn TCResult? #{::not-special}) %)]}&amp;lt;br&amp;gt;  (let [ftype (ret-t (expr-type (check fexpr)))&amp;lt;br&amp;gt;        [fixed-args tail] [(butlast args) (last args)]]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      ;apply of a simple function&amp;lt;br&amp;gt;      (FnIntersection? ftype)&amp;lt;br&amp;gt;      (do &amp;lt;br&amp;gt;        (when (empty? (:types ftype))&amp;lt;br&amp;gt;          (throw (Exception. &amp;quot;Empty function intersection given as argument to apply&amp;quot;)))&amp;lt;br&amp;gt;        (let [arg-tres (mapv check fixed-args)&amp;lt;br&amp;gt;              arg-tys (mapv (comp ret-t expr-type) arg-tres)&amp;lt;br&amp;gt;              tail-ty (ret-t (expr-type (check tail)))]&amp;lt;br&amp;gt;          (loop [[{:keys [dom rng rest drest]} :as fs] (:types ftype)]&amp;lt;br&amp;gt;            (cond&amp;lt;br&amp;gt;              ;we've run out of cases to try, so error out&amp;lt;br&amp;gt;              (empty? fs)&amp;lt;br&amp;gt;              (throw (Exception. (str (when *current-env*&amp;lt;br&amp;gt;                                        (str (:line *current-env*) &amp;quot;: &amp;quot;))&amp;lt;br&amp;gt;                                      &amp;quot;Bad arguments to function in apply: &amp;quot; &amp;lt;br&amp;gt;                                      (unparse-type ftype) (mapv unparse-type (concat arg-tys [tail-ty])))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;              ;this case of the function type has a rest argument&amp;lt;br&amp;gt;              (and rest&amp;lt;br&amp;gt;                   ;; check that the tail expression is a subtype of the rest argument&amp;lt;br&amp;gt;                   (subtype? tail-ty (Un -nil (RClass-of Seqable [rest])))&amp;lt;br&amp;gt;                   (subtypes-varargs? arg-tys dom rest))&amp;lt;br&amp;gt;              (ret (Result-type* rng)&amp;lt;br&amp;gt;                   (Result-filter* rng)&amp;lt;br&amp;gt;                   (Result-object* rng))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;              ;other cases go here&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;              ;next case&amp;lt;br&amp;gt;              :else (recur (next fs))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;; apply of a simple polymorphic function&amp;lt;br&amp;gt;      (Poly? ftype)&amp;lt;br&amp;gt;      (let [vars (repeatedly (:nbound ftype) gensym)&amp;lt;br&amp;gt;            bbnds (Poly-bbnds* vars ftype)&amp;lt;br&amp;gt;            body (Poly-body* vars ftype)&amp;lt;br&amp;gt;            _ (assert (FnIntersection? body))&amp;lt;br&amp;gt;            arg-tres (mapv check fixed-args)&amp;lt;br&amp;gt;            arg-tys (mapv (comp ret-t expr-type) arg-tres)&amp;lt;br&amp;gt;            tail-bound nil&amp;lt;br&amp;gt;            tail-ty (ret-t (expr-type (check tail)))]&amp;lt;br&amp;gt;        (loop [[{:keys [dom rng rest drest] :as ftype0} :as fs] (:types body)]&amp;lt;br&amp;gt;;          (when (seq fs)&amp;lt;br&amp;gt;;            (prn &amp;quot;checking fn&amp;quot; (unparse-type (first fs))&amp;lt;br&amp;gt;;                 (mapv unparse-type arg-tys)))&amp;lt;br&amp;gt;          (cond&amp;lt;br&amp;gt;            (empty? fs) (throw (Exception. &amp;quot;Bad arguments to polymorphic function in apply&amp;quot;))&amp;lt;br&amp;gt;            ;the actual work, when we have a * function and a list final argument&amp;lt;br&amp;gt;            :else &amp;lt;br&amp;gt;            (if-let [substitution (try&amp;lt;br&amp;gt;                                    (and rest (not tail-bound) &amp;lt;br&amp;gt;                                         (&amp;lt;= (count dom)&amp;lt;br&amp;gt;                                             (count arg-tys))&amp;lt;br&amp;gt;                                         (infer-vararg (zipmap vars bbnds) {}&amp;lt;br&amp;gt;                                                       (cons tail-ty arg-tys)&amp;lt;br&amp;gt;                                                       (cons (Un -nil (RClass-of Seqable [rest])) dom)&amp;lt;br&amp;gt;                                                       rest&amp;lt;br&amp;gt;                                                       (Result-type* rng)))&amp;lt;br&amp;gt;                                    (catch IllegalArgumentException e&amp;lt;br&amp;gt;                                      (throw e))&amp;lt;br&amp;gt;                                    (catch Exception e&amp;lt;br&amp;gt;                                      ;(prn &amp;quot;caught failed polymorphic case&amp;quot;)&amp;lt;br&amp;gt;                                      ))]&amp;lt;br&amp;gt;              (ret (subst-all substitution (Result-type* rng)))&amp;lt;br&amp;gt;              (recur (next fs))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      :else ::not-special)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-apply</a>[{[fexpr & args] :args, :as expr} expected]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-below&lt;/b&gt; ([tr1 expected])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-below [tr1 expected]&amp;lt;br&amp;gt;  {:pre [((some-fn TCResult? Type?) tr1)&amp;lt;br&amp;gt;         ((some-fn TCResult? Type?) expected)]&amp;lt;br&amp;gt;   :post [((some-fn TCResult? Type?) %)]}&amp;lt;br&amp;gt;  (letfn [(filter-better? [{f1+ :then f1- :else :as f1}&amp;lt;br&amp;gt;                           {f2+ :then f2- :else :as f2}]&amp;lt;br&amp;gt;            {:pre [(Filter? f1)&amp;lt;br&amp;gt;                   (Filter? f2)]&amp;lt;br&amp;gt;             :post [(boolean? %)]}&amp;lt;br&amp;gt;            (cond&amp;lt;br&amp;gt;              (= f1 f2) true&amp;lt;br&amp;gt;              (and (implied-atomic? f2+ f1+)&amp;lt;br&amp;gt;                   (implied-atomic? f2- f1-)) true&amp;lt;br&amp;gt;              :else false))&amp;lt;br&amp;gt;          (object-better? [o1 o2]&amp;lt;br&amp;gt;            {:pre [(RObject? o1)&amp;lt;br&amp;gt;                   (RObject? o2)]&amp;lt;br&amp;gt;             :post [(boolean? %)]}&amp;lt;br&amp;gt;            (cond&amp;lt;br&amp;gt;              (= o1 o2) true&amp;lt;br&amp;gt;              ((some-fn NoObject? EmptyObject?) o2) true&amp;lt;br&amp;gt;              :else false))]&amp;lt;br&amp;gt;    ;tr1 = arg&amp;lt;br&amp;gt;    ;expected = dom&amp;lt;br&amp;gt;    ; Omitted some cases dealing with multiple return values&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (and (TCResult? tr1)&amp;lt;br&amp;gt;           (TCResult? expected)&amp;lt;br&amp;gt;           (= (Un) (ret-t tr1))&amp;lt;br&amp;gt;           (NoFilter? (ret-f expected))&amp;lt;br&amp;gt;           (NoObject? (ret-o expected)))&amp;lt;br&amp;gt;      (let [ts2 (:t tr1)]&amp;lt;br&amp;gt;        (ret ts2))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (TCResult? tr1)&amp;lt;br&amp;gt;           (= (Un) (ret-t tr1)))&amp;lt;br&amp;gt;      expected&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (TCResult? tr1)&amp;lt;br&amp;gt;           (TCResult? expected)&amp;lt;br&amp;gt;           (= (-FS -top -top)&amp;lt;br&amp;gt;              (ret-f expected))&amp;lt;br&amp;gt;           (EmptyObject? (ret-o expected)))&amp;lt;br&amp;gt;      (let [{t1 :t f1 :fl o1 :o} tr1&amp;lt;br&amp;gt;            {t2 :t} expected]&amp;lt;br&amp;gt;        (when-not (subtype? t1 t2)&amp;lt;br&amp;gt;          (type-error t1 t2))&amp;lt;br&amp;gt;        expected)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (TCResult? tr1)&amp;lt;br&amp;gt;           (TCResult? expected))&amp;lt;br&amp;gt;      (let [{t1 :t f1 :fl o1 :o} tr1&amp;lt;br&amp;gt;            {t2 :t f2 :fl o2 :o} expected]&amp;lt;br&amp;gt;        (cond&amp;lt;br&amp;gt;          (not (subtype? t1 t2)) (type-error t1 t2)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;          (and (not (filter-better? f1 f2))&amp;lt;br&amp;gt;               (object-better? o1 o2))&amp;lt;br&amp;gt;          (throw (Exception. (str &amp;quot;Expected result with filter &amp;quot; f2 &amp;quot;, got filter&amp;quot;  f1)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;          (and (filter-better? f1 f2)&amp;lt;br&amp;gt;               (not (object-better? o1 o2)))&amp;lt;br&amp;gt;          (throw (Exception. (str &amp;quot;Expected result with object &amp;quot; o2 &amp;quot;, got object&amp;quot;  o1)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;          (and (not (filter-better? f1 f2))&amp;lt;br&amp;gt;               (not (object-better? o1 o2)))&amp;lt;br&amp;gt;          (throw (Exception. (str &amp;quot;Expected result with object &amp;quot; o2 &amp;quot;, got object&amp;quot;  o1 &amp;quot; and filter &amp;quot;&amp;lt;br&amp;gt;                                  f2 &amp;quot; got filter &amp;quot; f1))))&amp;lt;br&amp;gt;        expected)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (TCResult? tr1)&amp;lt;br&amp;gt;           (Type? expected))&amp;lt;br&amp;gt;      (let [{t1 :t f :fl o :o} tr1&amp;lt;br&amp;gt;            t2 expected]&amp;lt;br&amp;gt;        (when-not (subtype? t1 t2)&amp;lt;br&amp;gt;          (type-error t1 t2))&amp;lt;br&amp;gt;        (ret t2 f o))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;FIXME&amp;lt;br&amp;gt;      ;; erm.. ? What is (FilterSet: (list) (list))&amp;lt;br&amp;gt;      ;; TODO this case goes here, but not sure what it means &amp;lt;br&amp;gt;      ;&amp;lt;br&amp;gt;      ;[((? Type? t1) (tc-result1: t2 (FilterSet: (list) (list)) (Empty:)))&amp;lt;br&amp;gt;      ; (unless (subtype t1 t2)&amp;lt;br&amp;gt;      ;   (tc-error/expr &amp;quot;Expected ~a, but got ~a&amp;quot; t2 t1))&amp;lt;br&amp;gt;      ; t1]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (Type? tr1)&amp;lt;br&amp;gt;           (TCResult? expected))&amp;lt;br&amp;gt;      (let [t1 tr1&amp;lt;br&amp;gt;            {t2 :t f :fl o :o} expected]&amp;lt;br&amp;gt;        (if (subtype? t1 t2)&amp;lt;br&amp;gt;          (throw (Exception. (str &amp;quot;Expected result with filter &amp;quot; f &amp;quot; and &amp;quot; o &amp;quot;, got &amp;quot; t1)))&amp;lt;br&amp;gt;          (type-error t1 t2))&amp;lt;br&amp;gt;        t1)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (Type? tr1)&amp;lt;br&amp;gt;           (Type? expected))&amp;lt;br&amp;gt;      (let [t1 tr1&amp;lt;br&amp;gt;            t2 expected]&amp;lt;br&amp;gt;        (when-not (subtype? t1 t2)&amp;lt;br&amp;gt;          (type-error t1 t2))&amp;lt;br&amp;gt;        expected)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      :else (let [a tr1&amp;lt;br&amp;gt;                  b expected]&amp;lt;br&amp;gt;              (throw (Exception. (str &amp;quot;Unexpected input for check-below &amp;quot; a b)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-below</a>[tr1 expected]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-cljs-ns&lt;/b&gt; ([] [nsym])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro check-cljs-ns&amp;lt;br&amp;gt;  ([] (check-cljs-ns*) `'~'success)&amp;lt;br&amp;gt;  ([nsym] (check-cljs-ns* nsym) `'~'success))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-cljs-ns</a>[] [nsym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-cljs-ns*&lt;/b&gt; ([] [nsym])&lt;br&gt; Type check a CLJS namespace. If not provided default to current namespace&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-cljs-ns*&amp;lt;br&amp;gt;  &amp;quot;Type check a CLJS namespace. If not provided default to current namespace&amp;quot;&amp;lt;br&amp;gt;  ([] (check-cljs-ns* cljs/*cljs-ns*))&amp;lt;br&amp;gt;  ([nsym]&amp;lt;br&amp;gt;   (ensure-clojurescript)&amp;lt;br&amp;gt;   (let [asts (analyze-file-asts (cljs/ns-&amp;gt;relpath nsym))]&amp;lt;br&amp;gt;     (doseq [ast asts]&amp;lt;br&amp;gt;       (check-cljs ast)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-cljs-ns*</a>[] [nsym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-expr&lt;/b&gt; ([expr &amp; [expected]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-expr [expr &amp;amp; [expected]]&amp;lt;br&amp;gt;  (prn &amp;quot;Checking line:&amp;quot; (-&amp;gt; expr :env :line))&amp;lt;br&amp;gt;  (check expr expected))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-expr</a>[expr & [expected]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-field&lt;/b&gt; ([{:keys [target field val], :as expr} &amp; [expected]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-field &amp;lt;br&amp;gt;  [{:keys [target field val] :as expr} &amp;amp; [expected]]&amp;lt;br&amp;gt;  (assert false))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-field</a>[{:keys [target field val], :as expr} & [expected]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-fn&lt;/b&gt; ([{:keys [methods], :as fexpr} expected])&lt;br&gt; Check a fn to be under expected and annotate the inferred type&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-fn &amp;lt;br&amp;gt;  &amp;quot;Check a fn to be under expected and annotate the inferred type&amp;quot;&amp;lt;br&amp;gt;  [{:keys [methods] :as fexpr} expected]&amp;lt;br&amp;gt;  {:pre [(TCResult? expected)]&amp;lt;br&amp;gt;   :post [(TCResult? %)]}&amp;lt;br&amp;gt;  (let [; try and unwrap type enough to find function types&amp;lt;br&amp;gt;        exp (resolve-to-ftype (ret-t expected))&amp;lt;br&amp;gt;        ; unwrap polymorphic expected types&amp;lt;br&amp;gt;        [fin orig-names inst-frees bnds poly?] (unwrap-poly exp)&amp;lt;br&amp;gt;        ; once more to make sure (FIXME is this needed?)&amp;lt;br&amp;gt;        fin (resolve-to-ftype fin)&amp;lt;br&amp;gt;        ;ensure a function type&amp;lt;br&amp;gt;        _ (assert (FnIntersection? fin)&amp;lt;br&amp;gt;                  (str (when *current-env*&amp;lt;br&amp;gt;                         (str (:line *current-env*) &amp;quot;: &amp;quot;))&amp;lt;br&amp;gt;                       (unparse-type fin) &amp;quot; is not a function type&amp;quot;))&amp;lt;br&amp;gt;        ;collect all inferred Functions&amp;lt;br&amp;gt;        inferred-fni (with-locals (when-let [name (hygienic/hname-key fexpr)] ;self calls&amp;lt;br&amp;gt;                                    (assert expected &amp;quot;Recursive methods require full annotation&amp;quot;)&amp;lt;br&amp;gt;                                    {name (ret-t expected)})&amp;lt;br&amp;gt;                       ;scope type variables from polymorphic type in body&amp;lt;br&amp;gt;                       (with-free-mappings (case poly?&amp;lt;br&amp;gt;                                             :Poly (zipmap orig-names (map #(hash-map :F %1 :bnds %2) inst-frees bnds))&amp;lt;br&amp;gt;                                             :PolyDots (zipmap (next orig-names) &amp;lt;br&amp;gt;                                                               (map #(hash-map :F %1 :bnds %2) (next inst-frees) (next bnds)))&amp;lt;br&amp;gt;                                             nil)&amp;lt;br&amp;gt;                         (with-dotted-mappings (case poly?&amp;lt;br&amp;gt;                                                 :PolyDots {(last orig-names) (last inst-frees)}&amp;lt;br&amp;gt;                                                 nil)&amp;lt;br&amp;gt;                           (apply make-FnIntersection&amp;lt;br&amp;gt;                                  (mapcat (fn [method]&amp;lt;br&amp;gt;                                            (let [fnt (check-fn-method method fin)]&amp;lt;br&amp;gt;                                              fnt))&amp;lt;br&amp;gt;                                          methods)))))&amp;lt;br&amp;gt;        ;rewrap in Poly or PolyDots if needed&amp;lt;br&amp;gt;        pfni (rewrap-poly inferred-fni orig-names inst-frees bnds poly?)]&amp;lt;br&amp;gt;    (ret pfni (-FS -top -bot) -empty)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-fn</a>[{:keys [methods], :as fexpr} expected]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-fn-method&lt;/b&gt; ([{:keys [required-params rest-param], :as method} fin])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-fn-method [{:keys [required-params rest-param] :as method} fin]&amp;lt;br&amp;gt;  {:pre [(FnIntersection? fin)]&amp;lt;br&amp;gt;   :post [(seq %)&amp;lt;br&amp;gt;          (every? Function? %)]}&amp;lt;br&amp;gt;  (let [mfns (relevant-Fns required-params rest-param fin)]&amp;lt;br&amp;gt;    #_(prn &amp;quot;relevant-Fns&amp;quot; (map unparse-type mfns))&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      ;If no matching cases, assign parameters to Any&amp;lt;br&amp;gt;      (empty? mfns) [(check-fn-method1 method (make-Function (repeat (count required-params) -any)&amp;lt;br&amp;gt;                                                             -any (when rest-param&amp;lt;br&amp;gt;                                                                    -any) nil))]&amp;lt;br&amp;gt;      :else (doall&amp;lt;br&amp;gt;              (for [f mfns]&amp;lt;br&amp;gt;                (check-fn-method1 method f))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-fn-method</a>[{:keys [required-params rest-param], :as method} fin]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-fn-method1&lt;/b&gt; ([{:keys [body required-params rest-param], :as method} {:keys [dom rest drest], :as expected}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-fn-method1 [{:keys [body required-params rest-param] :as method} {:keys [dom rest drest] :as expected}]&amp;lt;br&amp;gt;  {:pre [(Function? expected)]&amp;lt;br&amp;gt;   :post [(Function? %)]}&amp;lt;br&amp;gt;  (let [expected-rng (Result-&amp;gt;TCResult (:rng expected))&amp;lt;br&amp;gt;        ;ensure Function fits method&amp;lt;br&amp;gt;        _ (assert ((if rest &amp;lt;= =) (count required-params) (count dom))&amp;lt;br&amp;gt;                  (error-msg &amp;quot;Checking method with incorrect number of expected parameters&amp;quot;&amp;lt;br&amp;gt;                             &amp;quot;, expected &amp;quot; (count dom) &amp;quot; required parameter(s) with&amp;quot;&amp;lt;br&amp;gt;                             (if rest &amp;quot; a &amp;quot; &amp;quot; no &amp;quot;) &amp;quot;rest parameter, found &amp;quot; (count required-params)&amp;lt;br&amp;gt;                             &amp;quot; required parameter(s) and&amp;quot; (if rest-param &amp;quot; a &amp;quot; &amp;quot; no &amp;quot;)&amp;lt;br&amp;gt;                             &amp;quot;rest parameter.&amp;quot;))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        _ (assert (or (not rest-param)&amp;lt;br&amp;gt;                      (some identity [drest rest]))&amp;lt;br&amp;gt;                  (error-msg &amp;quot;No type for rest parameter&amp;quot;))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;;;unhygienic version&amp;lt;br&amp;gt;;        ; Update filters that reference bindings that the params shadow.&amp;lt;br&amp;gt;;        ; Abstracting references to parameters is handled later in abstract-result, but&amp;lt;br&amp;gt;;        ; suffers from bugs due to un-hygienic macroexpansion (see `abstract-result`).&amp;lt;br&amp;gt;;        ; In short, don't shadow parameters if you want meaningful filters.&amp;lt;br&amp;gt;;        props (mapv (fn [oldp]&amp;lt;br&amp;gt;;                      (reduce (fn [p sym]&amp;lt;br&amp;gt;;                                {:pre [(Filter? p)&amp;lt;br&amp;gt;;                                       (symbol? sym)]}&amp;lt;br&amp;gt;;                                (subst-filter p sym -empty true))&amp;lt;br&amp;gt;;                              oldp (map :sym required-params)))&amp;lt;br&amp;gt;;                    (:props *lexical-env*))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        _ (assert (every? symbol? (map hygienic/hsym-key required-params))&amp;lt;br&amp;gt;                  &amp;quot;Unhygienic AST detected&amp;quot;)&amp;lt;br&amp;gt;        props (:props *lexical-env*)&amp;lt;br&amp;gt;        fixed-entry (map vector (map hygienic/hsym-key required-params) &amp;lt;br&amp;gt;                         (concat dom (repeat (or rest &amp;lt;br&amp;gt;                                                 (:pre-type drest)))))&amp;lt;br&amp;gt;        rest-entry (when rest-param&amp;lt;br&amp;gt;                     [[(hygienic/hsym-key rest-param) &amp;lt;br&amp;gt;                       (*check-fn-method1-rest-type* rest drest)]])&amp;lt;br&amp;gt;        _ (assert ((hash-c? symbol? Type?) (into {} fixed-entry))&amp;lt;br&amp;gt;                  (into {} fixed-entry))&amp;lt;br&amp;gt;        _ (assert ((some-fn nil? (hash-c? symbol? Type?)) (when rest-entry&amp;lt;br&amp;gt;                                                            (into {} rest-entry))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ; if this fn method is a multimethod dispatch method, then infer&amp;lt;br&amp;gt;        ; a new filter that results from being dispatched &amp;quot;here&amp;quot;&amp;lt;br&amp;gt;        mm-filter (when-let [{:keys [dispatch-fn-type dispatch-val-ret]} *current-mm*]&amp;lt;br&amp;gt;                    (assert (and dispatch-fn-type dispatch-val-ret))&amp;lt;br&amp;gt;                    (assert (not (or drest rest rest-param)))&amp;lt;br&amp;gt;                    (let [disp-app-ret (check-funapp nil nil &amp;lt;br&amp;gt;                                                     (ret dispatch-fn-type)&amp;lt;br&amp;gt;                                                     (map ret dom (repeat (-FS -top -top)) &amp;lt;br&amp;gt;                                                          (map (comp #(-&amp;gt;Path nil %) hygienic/hsym-key) required-params))&amp;lt;br&amp;gt;                                                     nil)&amp;lt;br&amp;gt;                          ;_ (prn &amp;quot;disp-app-ret&amp;quot; disp-app-ret)&amp;lt;br&amp;gt;                          ;_ (prn &amp;quot;disp-fn-type&amp;quot; (unparse-type dispatch-fn-type))&amp;lt;br&amp;gt;                          ;_ (prn &amp;quot;dom&amp;quot; dom)&amp;lt;br&amp;gt;                          isa-ret (tc-isa? disp-app-ret dispatch-val-ret)&amp;lt;br&amp;gt;                          then-filter (-&amp;gt; isa-ret ret-f :then)&amp;lt;br&amp;gt;                          _ (assert then-filter)]&amp;lt;br&amp;gt;                      then-filter))&amp;lt;br&amp;gt;        ;_ (prn &amp;quot;^^^ mm-filter&amp;quot;)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ;_ (prn &amp;quot;funapp1: inferred mm-filter&amp;quot; mm-filter)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        env (let [env (-&amp;gt; *lexical-env*&amp;lt;br&amp;gt;                        ;add mm-filter&amp;lt;br&amp;gt;                        (assoc-in [:props] (set (concat props (when mm-filter [mm-filter]))))&amp;lt;br&amp;gt;                        ;add parameters to scope&amp;lt;br&amp;gt;                        ;IF UNHYGIENIC order important, (fn [a a &amp;amp; a]) prefers rightmost name&amp;lt;br&amp;gt;                        (update-in [:l] merge (into {} fixed-entry) (into {} rest-entry)))&amp;lt;br&amp;gt;                  flag (atom false :validator boolean?)&amp;lt;br&amp;gt;                  env (if mm-filter&amp;lt;br&amp;gt;                        (let [t (env+ env [mm-filter] flag)]&amp;lt;br&amp;gt;                          t)&amp;lt;br&amp;gt;                        env)]&amp;lt;br&amp;gt;              (assert (not @flag) &amp;quot;Unreachable method: Local inferred to be bottom when applying multimethod filter&amp;quot;)&amp;lt;br&amp;gt;              env)&amp;lt;br&amp;gt;                &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ; rng before adding new filters&amp;lt;br&amp;gt;        crng-nopass&amp;lt;br&amp;gt;        (binding [*current-mm* nil]&amp;lt;br&amp;gt;          (with-lexical-env env&amp;lt;br&amp;gt;            (with-recur-target (-&amp;gt;RecurTarget dom rest drest nil)&amp;lt;br&amp;gt;              (*check-fn-method1-checkfn* body expected-rng))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ; Apply the filters of computed rng to the environment and express&amp;lt;br&amp;gt;        ; changes to the lexical env as new filters, and conjoin with existing filters.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ;_ (prn &amp;quot;crng-nopass&amp;quot; crng-nopass)&amp;lt;br&amp;gt;        {:keys [then else]} (-&amp;gt; crng-nopass expr-type ret-f)&amp;lt;br&amp;gt;        then-env (env+ env [then] (atom true))&amp;lt;br&amp;gt;        new-then-props (reduce (fn [fs [sym t]]&amp;lt;br&amp;gt;                                 {:pre [((set-c? Filter?) fs)]}&amp;lt;br&amp;gt;                                 (if (= t (get-in env [:l sym]))&amp;lt;br&amp;gt;                                   ;type hasn't changed, no new propositions&amp;lt;br&amp;gt;                                   fs&amp;lt;br&amp;gt;                                   ;new type, add positive proposition&amp;lt;br&amp;gt;                                   (conj fs (-filter t sym))))&amp;lt;br&amp;gt;                               #{}&amp;lt;br&amp;gt;                               (:l then-env))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        crng (update-in crng-nopass [expr-type :fl :then] &amp;lt;br&amp;gt;                        (fn [f]&amp;lt;br&amp;gt;                          (apply -and f new-then-props)))&amp;lt;br&amp;gt;        _ (binding [*current-expr* body&amp;lt;br&amp;gt;                    *current-env* (:env body)]&amp;lt;br&amp;gt;            (subtype (-&amp;gt; crng expr-type ret-t) (ret-t expected-rng)))]&amp;lt;br&amp;gt;    (FnResult-&amp;gt;Function &amp;lt;br&amp;gt;      (-&amp;gt;FnResult fixed-entry nil &amp;lt;br&amp;gt;                  (when (and rest rest-param)&amp;lt;br&amp;gt;                    [(hygienic/hsym-key rest-param) rest])&amp;lt;br&amp;gt;                  (when (and drest rest-param) &amp;lt;br&amp;gt;                    [(hygienic/hsym-key rest-param) drest])&amp;lt;br&amp;gt;                  (expr-type crng)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-fn-method1</a>[{:keys [body required-params rest-param], :as method} {:keys [dom rest drest], :as expected}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-forbidden-rec&lt;/b&gt; ([rec tbody])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-forbidden-rec [rec tbody]&amp;lt;br&amp;gt;  (when (or (= rec tbody) &amp;lt;br&amp;gt;            (and (Intersection? tbody)&amp;lt;br&amp;gt;                 (contains? (set (:types tbody)) rec))&amp;lt;br&amp;gt;            (and (Union? tbody)&amp;lt;br&amp;gt;                 (contains? (set (:types tbody)) rec)))&amp;lt;br&amp;gt;    (throw (Exception. &amp;quot;Recursive type not allowed here&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-forbidden-rec</a>[rec tbody]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-funapp&lt;/b&gt; ([fexpr args fexpr-ret-type arg-ret-types expected])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-funapp [fexpr args fexpr-ret-type arg-ret-types expected]&amp;lt;br&amp;gt;  {:pre [(TCResult? fexpr-ret-type)&amp;lt;br&amp;gt;         (every? TCResult? arg-ret-types)&amp;lt;br&amp;gt;         ((some-fn nil? TCResult?) expected)]&amp;lt;br&amp;gt;   :post [(TCResult? %)]}&amp;lt;br&amp;gt;  (let [fexpr-type (resolve-to-ftype (ret-t fexpr-ret-type))&amp;lt;br&amp;gt;        arg-types (mapv ret-t arg-ret-types)]&amp;lt;br&amp;gt;    ;(prn &amp;quot;check-funapp&amp;quot; (unparse-type fexpr-type) (map unparse-type arg-types) fexpr-type)&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      ;keyword function&amp;lt;br&amp;gt;      (and (Value? fexpr-type)&amp;lt;br&amp;gt;           (keyword? (:val fexpr-type)))&amp;lt;br&amp;gt;      (let [[target-ret default-ret &amp;amp; more-args] arg-ret-types]&amp;lt;br&amp;gt;        (assert (empty? more-args))&amp;lt;br&amp;gt;        (invoke-keyword fexpr-ret-type target-ret default-ret expected))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;set function&amp;lt;br&amp;gt;      ;FIXME yuck&amp;lt;br&amp;gt;      (and (RClass? fexpr-type)&amp;lt;br&amp;gt;           (isa? (symbol-&amp;gt;Class (.the-class ^RClass fexpr-type)) IPersistentSet))&amp;lt;br&amp;gt;      (do&amp;lt;br&amp;gt;        (assert (#{1} (count args)))&amp;lt;br&amp;gt;        (ret -any))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (RClass? fexpr-type)&amp;lt;br&amp;gt;           (isa? (symbol-&amp;gt;Class (.the-class ^RClass fexpr-type)) IPersistentMap))&amp;lt;br&amp;gt;      ;rewrite ({..} x) as (f {..} x), where f is some dummy fn&amp;lt;br&amp;gt;      (let [mapfn (parse-type '(All [x] [(IPersistentMap Any x) Any -&amp;gt; (U nil x)]))]&amp;lt;br&amp;gt;        (check-funapp fexpr args (ret mapfn) (concat [fexpr-ret-type] arg-ret-types) expected))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;Symbol function&amp;lt;br&amp;gt;      (and (RClass? fexpr-type)&amp;lt;br&amp;gt;           ('#{clojure.lang.Symbol} (.the-class ^RClass fexpr-type)))&amp;lt;br&amp;gt;      (let [symfn (parse-type '(All [x] [(U (IPersistentMap Any x) Any) -&amp;gt; (U x nil)]))]&amp;lt;br&amp;gt;        (check-funapp fexpr args (ret symfn) arg-ret-types expected))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;ordinary Function, single case, special cased for improved error msgs&amp;lt;br&amp;gt;      (and (FnIntersection? fexpr-type)&amp;lt;br&amp;gt;           (let [[{:keys [drest] :as ft} :as ts] (:types fexpr-type)]&amp;lt;br&amp;gt;             (and (= 1 (count ts))&amp;lt;br&amp;gt;                  (not drest))))&amp;lt;br&amp;gt;      (let [argtys arg-ret-types&amp;lt;br&amp;gt;            {[t] :types} fexpr-type]&amp;lt;br&amp;gt;        (check-funapp1 fexpr args t argtys expected))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;ordinary Function, multiple cases&amp;lt;br&amp;gt;      (FnIntersection? fexpr-type)&amp;lt;br&amp;gt;      (let [ftypes (:types fexpr-type)&amp;lt;br&amp;gt;            success-ret-type (some #(check-funapp1 fexpr args % arg-ret-types expected :check? false)&amp;lt;br&amp;gt;                                   (filter (fn [{:keys [dom rest] :as f}]&amp;lt;br&amp;gt;                                             {:pre [(Function? f)]}&amp;lt;br&amp;gt;                                             (subtypes-varargs? arg-types dom rest))&amp;lt;br&amp;gt;                                           ftypes))]&amp;lt;br&amp;gt;        (if success-ret-type&amp;lt;br&amp;gt;          success-ret-type&amp;lt;br&amp;gt;          (throw (Exception. (plainapp-type-error fexpr args fexpr-type arg-ret-types expected)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;ordinary polymorphic function without dotted rest&amp;lt;br&amp;gt;      (and (Poly? fexpr-type)&amp;lt;br&amp;gt;           (let [body (Poly-body* (repeatedly (.nbound ^Poly fexpr-type) gensym) fexpr-type)]&amp;lt;br&amp;gt;             (and (FnIntersection? body)&amp;lt;br&amp;gt;                  (every? (complement :drest) (.types ^FnIntersection body)))))&amp;lt;br&amp;gt;      (let [fs-names (repeatedly (.nbound ^Poly fexpr-type) gensym)&amp;lt;br&amp;gt;            _ (assert (every? symbol? fs-names))&amp;lt;br&amp;gt;            ^FnIntersection fin (Poly-body* fs-names fexpr-type)&amp;lt;br&amp;gt;            bbnds (Poly-bbnds* fs-names fexpr-type)&amp;lt;br&amp;gt;            _ (assert (FnIntersection? fin))&amp;lt;br&amp;gt;            ret-type (loop [[{:keys [dom rng rest drest kws] :as ftype} &amp;amp; ftypes] (.types fin)]&amp;lt;br&amp;gt;                       (when ftype&amp;lt;br&amp;gt;                         #_(prn &amp;quot;infer poly fn&amp;quot; (unparse-type ftype) (map unparse-type arg-types)&amp;lt;br&amp;gt;                              (count dom) (count arg-types))&amp;lt;br&amp;gt;                         #_(when rest (prn &amp;quot;rest&amp;quot; (unparse-type rest)))&amp;lt;br&amp;gt;                         ;; only try inference if argument types are appropriate and no kws&amp;lt;br&amp;gt;                         (if-let [substitution (try&amp;lt;br&amp;gt;                                                 (and (not (or drest kws))&amp;lt;br&amp;gt;                                                      ((if rest &amp;lt;= =) (count dom) (count arg-types))&amp;lt;br&amp;gt;                                                      (infer-vararg (zipmap fs-names bbnds) {} arg-types dom rest (Result-type* rng)&amp;lt;br&amp;gt;                                                                    (and expected (ret-t expected))))&amp;lt;br&amp;gt;                                                 (catch IllegalArgumentException e&amp;lt;br&amp;gt;                                                   (throw e))&amp;lt;br&amp;gt;                                                 (catch Exception e&amp;lt;br&amp;gt;                                                   #_(prn e)))]&amp;lt;br&amp;gt;                           (do #_(prn &amp;quot;subst:&amp;quot; substitution)&amp;lt;br&amp;gt;                             (check-funapp1 fexpr args (subst-all substitution ftype)&amp;lt;br&amp;gt;                                            arg-ret-types expected :check? false))&amp;lt;br&amp;gt;                           (if (or drest kws)&amp;lt;br&amp;gt;                             (throw (Exception. &amp;quot;Cannot infer arguments to polymorphic functions with dotted rest or kw types&amp;quot;))&amp;lt;br&amp;gt;                             (recur ftypes)))))]&amp;lt;br&amp;gt;        (if ret-type&amp;lt;br&amp;gt;          ret-type&amp;lt;br&amp;gt;          (throw (Exception. (polyapp-type-error fexpr args fexpr-type arg-ret-types expected)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      :else ;; any kind of dotted polymorphic function without mandatory keyword args&amp;lt;br&amp;gt;      (if-let [[pbody fixed-vars fixed-bnds dotted-var dotted-bnd]&amp;lt;br&amp;gt;               (and (PolyDots? fexpr-type)&amp;lt;br&amp;gt;                    (let [vars (vec (repeatedly (:nbound fexpr-type) gensym))&amp;lt;br&amp;gt;                          bbnds (PolyDots-bbnds* vars fexpr-type)&amp;lt;br&amp;gt;                          [fixed-bnds dotted-bnd] [(butlast bbnds) (last bbnds)]&amp;lt;br&amp;gt;                          [fixed-vars dotted-var] [(butlast vars) (last vars)]&amp;lt;br&amp;gt;                          pbody (PolyDots-body* vars fexpr-type)]&amp;lt;br&amp;gt;                      (and (FnIntersection? pbody)&amp;lt;br&amp;gt;                           (seq (:types pbody))&amp;lt;br&amp;gt;                           (not (some :kws (:types pbody)))&amp;lt;br&amp;gt;                           [pbody fixed-vars fixed-bnds dotted-var dotted-bnd])))]&amp;lt;br&amp;gt;        (let [inferred-rng (some identity&amp;lt;br&amp;gt;                                 (for [{:keys [dom rest ^DottedPretype drest rng] :as ftype} (:types pbody)&amp;lt;br&amp;gt;                                       ;only try inference if argument types match&amp;lt;br&amp;gt;                                       :when (cond&amp;lt;br&amp;gt;                                               rest (&amp;lt;= (count dom) (count arg-types))&amp;lt;br&amp;gt;                                               drest (and (&amp;lt;= (count dom) (count arg-types))&amp;lt;br&amp;gt;                                                          (= dotted-var (-&amp;gt; drest :name)))&amp;lt;br&amp;gt;                                               :else (= (count dom) (count arg-types)))]&amp;lt;br&amp;gt;                                   (do&amp;lt;br&amp;gt;                                     ;(prn &amp;quot;Inferring dotted fn&amp;quot; (unparse-type ftype))&amp;lt;br&amp;gt;                                     ;; Only try to infer the free vars of the rng (which includes the vars&amp;lt;br&amp;gt;                                     ;; in filters/objects).&amp;lt;br&amp;gt;                                     (let [substitution (cond&amp;lt;br&amp;gt;                                                          drest (infer-dots (zipmap fixed-vars fixed-bnds) dotted-var dotted-bnd&amp;lt;br&amp;gt;                                                                            arg-types dom (.pre-type drest) (Result-type* rng) (fv rng)&amp;lt;br&amp;gt;                                                                            :expected (and expected (ret-t expected)))&amp;lt;br&amp;gt;                                                          rest (infer-vararg (zipmap fixed-vars fixed-bnds) {dotted-var dotted-bnd}&amp;lt;br&amp;gt;                                                                             arg-types dom rest (Result-type* rng)&amp;lt;br&amp;gt;                                                                             (and expected (ret-t expected)))&amp;lt;br&amp;gt;                                                          :else (infer (zipmap fixed-vars fixed-bnds) {dotted-var dotted-bnd} &amp;lt;br&amp;gt;                                                                       arg-types dom (Result-type* rng)&amp;lt;br&amp;gt;                                                                       (and expected (ret-t expected))))&amp;lt;br&amp;gt;                                           ;_ (prn &amp;quot;substitution:&amp;quot; substitution)&amp;lt;br&amp;gt;                                           substituted-type (subst-all substitution ftype)&amp;lt;br&amp;gt;                                           ;_ (prn &amp;quot;substituted-type&amp;quot; (unparse-type substituted-type))&amp;lt;br&amp;gt;                                           ;_ (prn &amp;quot;args&amp;quot; (map unparse-type arg-types))&amp;lt;br&amp;gt;                                           ]&amp;lt;br&amp;gt;                                       (or (and substitution&amp;lt;br&amp;gt;                                                (check-funapp1 fexpr args &amp;lt;br&amp;gt;                                                               substituted-type arg-ret-types expected :check? false))&amp;lt;br&amp;gt;                                           (throw (Exception. &amp;quot;Error applying dotted type&amp;quot;)))))))]&amp;lt;br&amp;gt;          ;(prn &amp;quot;inferred-rng&amp;quot;inferred-rng)&amp;lt;br&amp;gt;          (if inferred-rng&amp;lt;br&amp;gt;            inferred-rng&amp;lt;br&amp;gt;            (throw (Exception. (pr-str &amp;quot;Could not apply dotted function &amp;quot; (unparse-type fexpr-type)&amp;lt;br&amp;gt;                                       &amp;quot; to arguments &amp;quot; (map unparse-type arg-types))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (throw (Exception. (error-msg&amp;lt;br&amp;gt;                             &amp;quot;Cannot invoke type: &amp;quot; (unparse-type fexpr-type))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-funapp</a>[fexpr args fexpr-ret-type arg-ret-types expected]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-funapp1&lt;/b&gt; ([fexpr arg-exprs {{optional-kw :optional, mandatory-kw :mandatory, :as kws} :kws, :keys [dom rng rest drest], :as ftype0} argtys expected &amp; {:keys [check?], :or {check? true}}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-funapp1 [fexpr arg-exprs {{optional-kw :optional mandatory-kw :mandatory :as kws} :kws&amp;lt;br&amp;gt;                                      :keys [dom rng rest drest] :as ftype0}&amp;lt;br&amp;gt;                     argtys expected &amp;amp; {:keys [check?] :or {check? true}}]&amp;lt;br&amp;gt;  {:pre [(Function? ftype0)&amp;lt;br&amp;gt;         (every? TCResult? argtys)&amp;lt;br&amp;gt;         ((some-fn nil? TCResult?) expected)&amp;lt;br&amp;gt;         (boolean? check?)]&amp;lt;br&amp;gt;   :post [(TCResult? %)]}&amp;lt;br&amp;gt;  (assert (not drest) &amp;quot;funapp with drest args NYI&amp;quot;)&amp;lt;br&amp;gt;  (assert (empty? mandatory-kw) &amp;quot;funapp with mandatory keyword args NYI&amp;quot;)&amp;lt;br&amp;gt;  (assert (empty? optional-kw) &amp;quot;funapp with optional keyword args NYI&amp;quot;)&amp;lt;br&amp;gt;;  (prn &amp;quot;check-funapp1&amp;quot;)&amp;lt;br&amp;gt;;  (prn &amp;quot;argtys objects&amp;quot; (map ret-o argtys))&amp;lt;br&amp;gt;  ;checking&amp;lt;br&amp;gt;  (when check?&amp;lt;br&amp;gt;    (let [nactual (count argtys)]&amp;lt;br&amp;gt;      (when-not (or (when (and (not rest)&amp;lt;br&amp;gt;                               (empty? optional-kw)&amp;lt;br&amp;gt;                               (empty? mandatory-kw))&amp;lt;br&amp;gt;                      (= (count dom) (count argtys)))&amp;lt;br&amp;gt;                    (when rest&amp;lt;br&amp;gt;                      (&amp;lt;= (count dom) nactual))&amp;lt;br&amp;gt;                    (when kws&amp;lt;br&amp;gt;                      (let [nexpected (+ (count dom)&amp;lt;br&amp;gt;                                         (* 2 (count mandatory-kw)))]&amp;lt;br&amp;gt;                        (and (even? (- nactual (count dom)))&amp;lt;br&amp;gt;                             ((if (seq optional-kw) &amp;lt;= =)&amp;lt;br&amp;gt;                                nexpected&amp;lt;br&amp;gt;                                nactual)))))&amp;lt;br&amp;gt;        (throw (Exception. (error-msg &amp;quot;Wrong number of arguments, expected &amp;quot; (count dom) &amp;quot; fixed parameters&amp;quot;&amp;lt;br&amp;gt;                                      (cond&amp;lt;br&amp;gt;                                        rest &amp;quot; and a rest parameter &amp;quot;&amp;lt;br&amp;gt;                                        drest &amp;quot; and a dotted rest parameter &amp;quot;&amp;lt;br&amp;gt;                                        kws (cond&amp;lt;br&amp;gt;                                              (and (seq mandatory-kw) (seq optional-kw))&amp;lt;br&amp;gt;                                              (str &amp;quot;, some optional keyword arguments and &amp;quot; (count mandatory-kw) &amp;lt;br&amp;gt;                                                   &amp;quot; mandatory keyword arguments&amp;quot;)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;                                              (seq mandatory-kw) (str &amp;quot;and &amp;quot; (count mandatory-kw) &amp;quot;  mandatory keyword arguments&amp;quot;)&amp;lt;br&amp;gt;                                              (seq optional-kw) &amp;quot; and some optional keyword arguments&amp;quot;))&amp;lt;br&amp;gt;                                      &amp;quot;, and got &amp;quot; nactual&amp;lt;br&amp;gt;                                      &amp;quot; for function &amp;quot; (unparse-type ftype0) &amp;quot; and arguments &amp;quot; (mapv (comp unparse-type ret-t) argtys)))))&amp;lt;br&amp;gt;        (doseq [[arg-t dom-t] (map vector &amp;lt;br&amp;gt;                                   (map ret-t argtys) &amp;lt;br&amp;gt;                                   (concat dom (when rest (repeat rest))))]&amp;lt;br&amp;gt;          (check-below arg-t dom-t))))&amp;lt;br&amp;gt;  (let [dom-count (count dom)&amp;lt;br&amp;gt;        arg-count (+ dom-count (if rest 1 0) (count optional-kw))&amp;lt;br&amp;gt;        o-a (map ret-o argtys)&amp;lt;br&amp;gt;        _ (assert (every? RObject? o-a))&amp;lt;br&amp;gt;        t-a (map ret-t argtys)&amp;lt;br&amp;gt;        _ (assert (every? Type? t-a))&amp;lt;br&amp;gt;        [o-a t-a] (let [rs (for [[nm oa ta] (map vector &amp;lt;br&amp;gt;                                                 (range arg-count) &amp;lt;br&amp;gt;                                                 (concat o-a (repeatedly -&amp;gt;EmptyObject))&amp;lt;br&amp;gt;                                                 (concat t-a (repeatedly Un)))]&amp;lt;br&amp;gt;                             [(if (&amp;gt;= nm dom-count) (-&amp;gt;EmptyObject) oa)&amp;lt;br&amp;gt;                              ta])]&amp;lt;br&amp;gt;                    [(map first rs) (map second rs)])&amp;lt;br&amp;gt;        [t-r f-r o-r] (open-Result rng o-a t-a)]&amp;lt;br&amp;gt;    (ret t-r f-r o-r)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-funapp1</a>[fexpr arg-exprs {{optional-kw :optional, mandatory-kw :mandatory, :as kws} :kws, :keys [dom rng rest drest], :as ftype0} argtys expected & {:keys [check?], :or {check? true}}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-if&lt;/b&gt; ([tst thn els &amp; [expected]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-if [tst thn els &amp;amp; [expected]]&amp;lt;br&amp;gt;  {:pre [(TCResult? tst)&amp;lt;br&amp;gt;         ((some-fn TCResult? nil?) expected)]&amp;lt;br&amp;gt;   :post [(TCResult? %)]}&amp;lt;br&amp;gt;  (letfn [(tc [expr reachable?]&amp;lt;br&amp;gt;            {:post [(TCResult? %)]}&amp;lt;br&amp;gt;            (when-not reachable?&amp;lt;br&amp;gt;              #_(prn &amp;quot;Unreachable code found.. &amp;quot; expr))&amp;lt;br&amp;gt;            (cond&amp;lt;br&amp;gt;              ;; if reachable? is #f, then we don't want to verify that this branch has the appropriate type&amp;lt;br&amp;gt;              ;; in particular, it might be (void)&amp;lt;br&amp;gt;              (and expected reachable?)&amp;lt;br&amp;gt;              (-&amp;gt; (*check-if-checkfn* expr (-&amp;gt; expected&amp;lt;br&amp;gt;                                             (assoc :fl (-FS -top -top))&amp;lt;br&amp;gt;                                             (assoc :o -empty)&amp;lt;br&amp;gt;                                             (assoc :flow (-flow -top))))&amp;lt;br&amp;gt;                expr-type)&amp;lt;br&amp;gt;              ;; this code is reachable, but we have no expected type&amp;lt;br&amp;gt;              reachable? (-&amp;gt; (*check-if-checkfn* expr) expr-type)&amp;lt;br&amp;gt;              ;; otherwise, this code is unreachable&amp;lt;br&amp;gt;              ;; and the resulting type should be the empty type&amp;lt;br&amp;gt;              :else (do #_(prn (error-msg &amp;quot;Not checking unreachable code&amp;quot;))&amp;lt;br&amp;gt;                      (ret (Un)))))]&amp;lt;br&amp;gt;    (let [{fs+ :then fs- :else :as f1} (ret-f tst)&amp;lt;br&amp;gt;;          _ (prn &amp;quot;check-if: fs+&amp;quot; (unparse-filter fs+))&amp;lt;br&amp;gt;;          _ (prn &amp;quot;check-if: fs-&amp;quot; (unparse-filter fs-))&amp;lt;br&amp;gt;          flag+ (atom true :validator boolean?)&amp;lt;br&amp;gt;          flag- (atom true :validator boolean?)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;          ;_ (print-env)&amp;lt;br&amp;gt;          idsym (gensym)&amp;lt;br&amp;gt;          env-thn (env+ *lexical-env* [fs+] flag+)&amp;lt;br&amp;gt;;          _ (do (pr &amp;quot;check-if: env-thn&amp;quot;)&amp;lt;br&amp;gt;;              (print-env env-thn))&amp;lt;br&amp;gt;          env-els (env+ *lexical-env* [fs-] flag-)&amp;lt;br&amp;gt;;          _ (do (pr &amp;quot;check-if: env-els&amp;quot;)&amp;lt;br&amp;gt;;              (print-env env-els))&amp;lt;br&amp;gt;;          new-thn-props (set&amp;lt;br&amp;gt;;                          (filter atomic-filter?&amp;lt;br&amp;gt;;                                  (set/difference&amp;lt;br&amp;gt;;                                    (set (:props *lexical-env*))&amp;lt;br&amp;gt;;                                    (set (:props env-thn)))))&amp;lt;br&amp;gt;          ;_ (prn idsym&amp;quot;env+: new-thn-props&amp;quot; (map unparse-filter new-thn-props))&amp;lt;br&amp;gt;;          new-els-props (set&amp;lt;br&amp;gt;;                          (filter atomic-filter?&amp;lt;br&amp;gt;;                                  (set/difference&amp;lt;br&amp;gt;;                                    (set (:props *lexical-env*))&amp;lt;br&amp;gt;;                                    (set (:props env-els)))))&amp;lt;br&amp;gt;          ;_ (prn idsym&amp;quot;env+: new-els-props&amp;quot; (map unparse-filter new-els-props))&amp;lt;br&amp;gt;          {ts :t fs2 :fl os2 :o flow2 :flow :as then-ret} &amp;lt;br&amp;gt;          (binding [*current-expr* thn]&amp;lt;br&amp;gt;            (with-lexical-env env-thn&amp;lt;br&amp;gt;              (tc thn @flag+)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;          {us :t fs3 :fl os3 :o flow3 :flow :as else-ret} &amp;lt;br&amp;gt;          (binding [*current-expr* els]&amp;lt;br&amp;gt;            (with-lexical-env env-els&amp;lt;br&amp;gt;              (tc els @flag-)))]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;some optimization code here, contraditions etc? omitted&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;;      (prn &amp;quot;check-if: then branch:&amp;quot; (unparse-TCResult then-ret))&amp;lt;br&amp;gt;;      (prn &amp;quot;check-if: else branch:&amp;quot; (unparse-TCResult else-ret))&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;        ;both branches reachable&amp;lt;br&amp;gt;        (and (not (type-equal? (Un) ts))&amp;lt;br&amp;gt;             (not (type-equal? (Un) us)))&amp;lt;br&amp;gt;        (let [r (let [filter (cond&amp;lt;br&amp;gt;                               (or (NoFilter? fs2)&amp;lt;br&amp;gt;                                   (NoFilter? fs3)) (-FS -top -top)&amp;lt;br&amp;gt;                               (and (FilterSet? fs2)&amp;lt;br&amp;gt;                                    (FilterSet? fs3))&amp;lt;br&amp;gt;                               (let [{f2+ :then f2- :else} fs2&amp;lt;br&amp;gt;                                     {f3+ :then f3- :else} fs3&amp;lt;br&amp;gt;                                     ; +ve test, +ve then&amp;lt;br&amp;gt;                                     new-thn-props (:props env-thn)&amp;lt;br&amp;gt;                                     new-els-props (:props env-els)&amp;lt;br&amp;gt;                                     +t+t (apply -and fs+ f2+ new-thn-props)&amp;lt;br&amp;gt;                                     ; -ve test, +ve else&amp;lt;br&amp;gt;                                     -t+e (apply -and fs- f3+ new-els-props)&amp;lt;br&amp;gt;                                     ; +ve test, -ve then&amp;lt;br&amp;gt;                                     +t-t (apply -and fs+ f2- new-thn-props)&amp;lt;br&amp;gt;                                     ; -ve test, -ve else&amp;lt;br&amp;gt;                                     -t-e (apply -and fs- f3- new-els-props)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;                                     final-thn-prop (-or +t+t -t+e)&amp;lt;br&amp;gt;                                     final-els-prop (-or +t-t -t-e)&amp;lt;br&amp;gt;                                     fs (-FS final-thn-prop final-els-prop)]&amp;lt;br&amp;gt;                                 fs)&amp;lt;br&amp;gt;                               :else (throw (Exception. (str &amp;quot;What are these?&amp;quot; fs2 fs3))))&amp;lt;br&amp;gt;                      type (Un ts us)&amp;lt;br&amp;gt;                      object (if (object-equal? os2 os3) os2 (-&amp;gt;EmptyObject))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;                      ;only bother with something interesting if a branch is unreachable (the next two cond cases)&amp;lt;br&amp;gt;                      ;Should be enough for `assert`&amp;lt;br&amp;gt;                      ;flow (-flow (-or flow2 flow3))&amp;lt;br&amp;gt;                      flow (-flow -top)&amp;lt;br&amp;gt;                      ]&amp;lt;br&amp;gt;                  (ret type filter object flow))]&amp;lt;br&amp;gt;          ;(prn &amp;quot;check if:&amp;quot; &amp;quot;both branches reachable, with combined result&amp;quot; (unparse-TCResult r))&amp;lt;br&amp;gt;          (if expected (check-below r expected) r))&amp;lt;br&amp;gt;        ;; special case if one of the branches is unreachable&amp;lt;br&amp;gt;        (type-equal? us (Un))&amp;lt;br&amp;gt;        (if expected (check-below (ret ts fs2 os2 flow2) expected) (ret ts fs2 os2 flow2))&amp;lt;br&amp;gt;        (type-equal? ts (Un))&amp;lt;br&amp;gt;        (if expected (check-below (ret us fs3 os3 flow3) expected) (ret us fs3 os3 flow3))&amp;lt;br&amp;gt;        :else (throw (Exception. &amp;quot;Something happened&amp;quot;))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-if</a>[tst thn els & [expected]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-invoke-method&lt;/b&gt; ([{c :class, :keys [args tag method env method-name], :as expr} expected inst?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-invoke-method [{c :class :keys [args tag method env method-name] :as expr} expected inst?]&amp;lt;br&amp;gt;  {:pre [((some-fn nil? TCResult?) expected)]&amp;lt;br&amp;gt;   :post [(-&amp;gt; % expr-type TCResult?)]}&amp;lt;br&amp;gt;  #_(prn &amp;quot;invoke method: &amp;quot; (when method (Method-&amp;gt;symbol method)) inst?)&amp;lt;br&amp;gt;  (binding [*current-env* env]&amp;lt;br&amp;gt;    (let [msym (MethodExpr-&amp;gt;qualsym expr)&amp;lt;br&amp;gt;          rfin-type (or (when msym&amp;lt;br&amp;gt;                          (@METHOD-OVERRIDE-ENV msym))&amp;lt;br&amp;gt;                        (when method&amp;lt;br&amp;gt;                          (Method-&amp;gt;Type method)))&amp;lt;br&amp;gt;          _ (assert rfin-type (error-msg &amp;quot;Unresolved &amp;quot; (if inst? &amp;quot;instance&amp;quot; &amp;quot;static&amp;quot;) &amp;lt;br&amp;gt;                                         &amp;quot; method invocation &amp;quot; &amp;lt;br&amp;gt;                                         (when c&amp;lt;br&amp;gt;                                           (str (Class-&amp;gt;symbol c) &amp;quot;/&amp;quot;))&amp;lt;br&amp;gt;                                         method-name &amp;lt;br&amp;gt;                                         ;&amp;quot;, insufficient type hints.&amp;quot;&amp;lt;br&amp;gt;                                         ;&amp;quot;\n\nForm:\n\t&amp;quot; (emit-form-fn expr))&amp;lt;br&amp;gt;                                         ))&amp;lt;br&amp;gt;          _ (when inst?&amp;lt;br&amp;gt;              (let [ctarget (check (:target expr))&amp;lt;br&amp;gt;                    target-class (resolve (:declaring-class method))&amp;lt;br&amp;gt;                    _ (assert target-class)]&amp;lt;br&amp;gt;;                (prn &amp;quot;check target&amp;quot; (unparse-type (ret-t (expr-type ctarget)))&amp;lt;br&amp;gt;;                     (unparse-type (RClass-of (Class-&amp;gt;symbol (resolve (:declaring-class method))) nil)))&amp;lt;br&amp;gt;                (when-not (subtype? (ret-t (expr-type ctarget)) (RClass-of-with-unknown-params target-class))&amp;lt;br&amp;gt;                  (throw (Exception. (error-msg &amp;quot;Cannot call instance method &amp;quot; (Method-&amp;gt;symbol method)&amp;lt;br&amp;gt;                                                &amp;quot; on type &amp;quot; (pr-str (unparse-type (ret-t (expr-type ctarget))))&amp;lt;br&amp;gt;                                                &amp;quot;\n\n&amp;quot;&amp;lt;br&amp;gt;                                                &amp;quot;Form:&amp;quot;&amp;lt;br&amp;gt;                                                &amp;quot;\n\t&amp;quot; (emit-form-fn expr)))))))&amp;lt;br&amp;gt;          cargs (doall (map check args))&amp;lt;br&amp;gt;          result-type (check-funapp expr args (ret rfin-type) (map expr-type cargs) expected)]&amp;lt;br&amp;gt;      (assoc expr&amp;lt;br&amp;gt;             expr-type result-type))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-invoke-method</a>[{c :class, :keys [args tag method env method-name], :as expr} expected inst?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-let&lt;/b&gt; ([binding-inits body expr is-loop expected &amp; {:keys [expected-bnds]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-let [binding-inits body expr is-loop expected &amp;amp; {:keys [expected-bnds]}]&amp;lt;br&amp;gt;  (assert (or (not is-loop) expected-bnds) (error-msg &amp;quot;Loop requires more annotations&amp;quot;))&amp;lt;br&amp;gt;  (let [check-let-checkfn *check-let-checkfn*&amp;lt;br&amp;gt;        env (reduce (fn [env [{{:keys [init]} :local-binding :as expr} expected-bnd]]&amp;lt;br&amp;gt;                      {:pre [(PropEnv? env)]&amp;lt;br&amp;gt;                       :post [(PropEnv? env)]}&amp;lt;br&amp;gt;                      (let [sym (binding-init-sym expr)&amp;lt;br&amp;gt;                            ; check rhs&amp;lt;br&amp;gt;                            {:keys [t fl flow]} (expr-type&amp;lt;br&amp;gt;                                                  (binding [*current-expr* init]&amp;lt;br&amp;gt;                                                    (with-lexical-env env&amp;lt;br&amp;gt;                                                      (check-let-checkfn init (when is-loop&amp;lt;br&amp;gt;                                                                                (ret expected-bnd))))))&amp;lt;br&amp;gt;                            _ (assert (or (not expected-bnd)&amp;lt;br&amp;gt;                                          (subtype? t expected-bnd))&amp;lt;br&amp;gt;                                      (error-msg &amp;quot;Loop variable &amp;quot; sym &amp;quot; initialised to &amp;quot;&amp;lt;br&amp;gt;                                                 (pr-str (unparse-type t))&amp;lt;br&amp;gt;                                                 &amp;quot;, expected &amp;quot; (pr-str (unparse-type expected-bnd))&amp;lt;br&amp;gt;                                                 &amp;quot;\n\nForm:\n\t&amp;quot; (emit-form-fn init)))&amp;lt;br&amp;gt;                            t (or expected-bnd t)]&amp;lt;br&amp;gt;                        (cond&amp;lt;br&amp;gt;                          (FilterSet? fl)&amp;lt;br&amp;gt;                          (let [{:keys [then else]} fl&amp;lt;br&amp;gt;                                p* [(-imp (-not-filter (Un -nil -false) sym) then)&amp;lt;br&amp;gt;                                    (-imp (-filter (Un -nil -false) sym) else)]&amp;lt;br&amp;gt;                                flow-f (flow-normal flow)&amp;lt;br&amp;gt;                                flow-atom (atom true)&amp;lt;br&amp;gt;                                new-env (-&amp;gt; env&amp;lt;br&amp;gt;                                          ;update binding type&amp;lt;br&amp;gt;                                          (assoc-in [:l sym] t)&amp;lt;br&amp;gt;                                          ;update props&amp;lt;br&amp;gt;                                          (update-in [:props] #(set &amp;lt;br&amp;gt;                                                                 (apply concat &amp;lt;br&amp;gt;                                                                        (combine-props p* % (atom true)))))&amp;lt;br&amp;gt;                                          (env+ [(if (= -bot flow-f) -top flow-f)] flow-atom))&amp;lt;br&amp;gt;                                _ (assert @flow-atom &amp;quot;Applying flow filter resulted in local being bottom&amp;quot;)]&amp;lt;br&amp;gt;                            new-env)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;                          (NoFilter? fl) (do&amp;lt;br&amp;gt;                                           (assert (= (-flow -top) flow))&amp;lt;br&amp;gt;                                           (-&amp;gt; env&amp;lt;br&amp;gt;                                             ;no propositions to add, just update binding type&amp;lt;br&amp;gt;                                             (assoc-in [:l sym] t))))))&amp;lt;br&amp;gt;                    *lexical-env* (map vector binding-inits (or expected-bnds&amp;lt;br&amp;gt;                                                                (repeat nil))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        cbody (with-lexical-env env&amp;lt;br&amp;gt;                (if is-loop&amp;lt;br&amp;gt;                  (binding [*recur-target* (-&amp;gt;RecurTarget expected-bnds nil nil nil)]&amp;lt;br&amp;gt;                    (check-let-checkfn body expected))&amp;lt;br&amp;gt;                  (binding [*current-expr* body]&amp;lt;br&amp;gt;                    (check-let-checkfn body expected))))&amp;lt;br&amp;gt;        ;now we return a result to the enclosing scope, so we&amp;lt;br&amp;gt;        ;erase references to any bindings this scope introduces&amp;lt;br&amp;gt;        unshadowed-ret&amp;lt;br&amp;gt;        (reduce (fn [ty sym]&amp;lt;br&amp;gt;                  {:pre [(TCResult? ty)&amp;lt;br&amp;gt;                         (symbol? sym)]}&amp;lt;br&amp;gt;                  (-&amp;gt; ty&amp;lt;br&amp;gt;                    (update-in [:t] subst-type sym -empty true)&amp;lt;br&amp;gt;                    (update-in [:fl] subst-filter-set sym -empty true)&amp;lt;br&amp;gt;                    (update-in [:o] subst-object sym -empty true)&amp;lt;br&amp;gt;                    (update-in [:flow :normal] subst-filter sym -empty true)))&amp;lt;br&amp;gt;                (expr-type cbody)&amp;lt;br&amp;gt;                (map (comp hygienic/hsym-key :local-binding) binding-inits))]&amp;lt;br&amp;gt;    (assoc expr&amp;lt;br&amp;gt;           expr-type unshadowed-ret)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-let</a>[binding-inits body expr is-loop expected & {:keys [expected-bnds]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-new-instance-method&lt;/b&gt; ([{:keys [body required-params], :as expr} expected-fin])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-new-instance-method&amp;lt;br&amp;gt;  [{:keys [body required-params] :as expr} expected-fin]&amp;lt;br&amp;gt;  {:pre [(FnIntersection? expected-fin)]}&amp;lt;br&amp;gt;  (let [_ (assert (= 1 (count (:types expected-fin))))&amp;lt;br&amp;gt;        {:keys [dom rng] :as expected-fn} (-&amp;gt; expected-fin :types first)&amp;lt;br&amp;gt;        _ (assert (not (:rest expected-fn)))&amp;lt;br&amp;gt;        cbody (with-locals (zipmap (map hygienic/hsym-key required-params) dom)&amp;lt;br&amp;gt;                (check body (ret (Result-type* rng)&amp;lt;br&amp;gt;                                 (Result-filter* rng)&amp;lt;br&amp;gt;                                 (Result-object* rng))))&amp;lt;br&amp;gt;        _ (subtype (-&amp;gt; cbody expr-type ret-t)&amp;lt;br&amp;gt;                   (Result-type* rng))]&amp;lt;br&amp;gt;    (assoc expr&amp;lt;br&amp;gt;           expr-type (expr-type cbody))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-new-instance-method</a>[{:keys [body required-params], :as expr} expected-fin]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-normal-def&lt;/b&gt; ([{:keys [var init init-provided env], :as expr} &amp; [expected]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-normal-def [{:keys [var init init-provided env] :as expr} &amp;amp; [expected]]&amp;lt;br&amp;gt;  (assert (not expected))&amp;lt;br&amp;gt;  (assert init-provided)&amp;lt;br&amp;gt;  (let [t (binding [*var-annotations* VAR-ANNOTATIONS]&amp;lt;br&amp;gt;            (type-of (var-&amp;gt;symbol var)))&amp;lt;br&amp;gt;        cinit (cond &amp;lt;br&amp;gt;                (not init-provided) expr ;handle `declare`&amp;lt;br&amp;gt;                :else (check init (ret t)))&amp;lt;br&amp;gt;        _ (when init-provided&amp;lt;br&amp;gt;            (subtype (ret-t (expr-type cinit)) t))]&amp;lt;br&amp;gt;    ;def returns a Var&amp;lt;br&amp;gt;    (assoc expr&amp;lt;br&amp;gt;           expr-type (ret (RClass-of Var)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-normal-def</a>[{:keys [var init init-provided env], :as expr} & [expected]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-ns&lt;/b&gt; ([] [nsym])&lt;br&gt; Type check a namespace. If not provided default to current namespace&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-ns &amp;lt;br&amp;gt;  &amp;quot;Type check a namespace. If not provided default to current namespace&amp;quot;&amp;lt;br&amp;gt;  ([] (check-ns (ns-name *ns*)))&amp;lt;br&amp;gt;  ([nsym]&amp;lt;br&amp;gt;   (when-not (*currently-checking-clj* nsym)&amp;lt;br&amp;gt;     (binding [*currently-checking-clj* (conj *currently-checking-clj* nsym)]&amp;lt;br&amp;gt;       (ensure-clojure)&amp;lt;br&amp;gt;       (with-open [^clojure.lang.LineNumberingPushbackReader pbr (analyze/pb-reader-for-ns nsym)]&amp;lt;br&amp;gt;         ;FIXME Ignore the first form, assumed to be a call to ns. Functions need to be proper RClasses before this&amp;lt;br&amp;gt;         ;checks properly. http://dev.clojure.org/jira/browse/CTYP-16&amp;lt;br&amp;gt;         (let [[_ns-decl_ &amp;amp; asts] (-&amp;gt;&amp;gt; (analyze/analyze-ns pbr (analyze/uri-for-ns nsym) nsym)&amp;lt;br&amp;gt;                                      (map hygienic/ast-hy))]&amp;lt;br&amp;gt;           (doseq [ast asts]&amp;lt;br&amp;gt;             (check-expr ast))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-ns</a>[] [nsym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-top-level&lt;/b&gt; ([nsym form])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-top-level [nsym form]&amp;lt;br&amp;gt;  (ensure-clojure)&amp;lt;br&amp;gt;  (let [ast (-&amp;gt; (analyze/analyze-form-in-ns nsym form)&amp;lt;br&amp;gt;              hygienic/ast-hy)]&amp;lt;br&amp;gt;    (check ast)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-top-level</a>[nsym form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;check-value&lt;/b&gt; ([{:keys [val], :as expr} &amp; [expected]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-value&amp;lt;br&amp;gt;  [{:keys [val] :as expr} &amp;amp; [expected]]&amp;lt;br&amp;gt;  (let [actual-type (constant-type val)&amp;lt;br&amp;gt;        _ (when expected&amp;lt;br&amp;gt;            (binding [*current-expr* expr]&amp;lt;br&amp;gt;              (subtype actual-type (ret-t expected))))&amp;lt;br&amp;gt;        flow (flow-for-value)]&amp;lt;br&amp;gt;    (assoc expr&amp;lt;br&amp;gt;           expr-type (if val&amp;lt;br&amp;gt;                       (ret actual-type&amp;lt;br&amp;gt;                            (-FS -top -bot)&amp;lt;br&amp;gt;                            -empty&amp;lt;br&amp;gt;                            flow)&amp;lt;br&amp;gt;                       (ret actual-type&amp;lt;br&amp;gt;                            (-FS -bot -top)&amp;lt;br&amp;gt;                            -empty&amp;lt;br&amp;gt;                            flow)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-value</a>[{:keys [val], :as expr} & [expected]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;checking-clojure?&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn checking-clojure? []&amp;lt;br&amp;gt;  (= ::clojure @TYPED-IMPL))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">checking-clojure?</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;checking-clojurescript?&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn checking-clojurescript? []&amp;lt;br&amp;gt;  (= ::clojurescript @TYPED-IMPL))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">checking-clojurescript?</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cljs-ann&lt;/b&gt; ([vname tsyn])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro cljs-ann [vname tsyn]&amp;lt;br&amp;gt;  (let [r (cljs-ann* vname tsyn)]&amp;lt;br&amp;gt;  `'~r))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cljs-ann</a>[vname tsyn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cljs-ann*&lt;/b&gt; ([vname tsyn])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cljs-ann* [vname tsyn]&amp;lt;br&amp;gt;  (let [vtype (parse-type tsyn)&amp;lt;br&amp;gt;        var (if (namespace vname)&amp;lt;br&amp;gt;              (symbol vname)&amp;lt;br&amp;gt;              (symbol (str cljs/*cljs-ns*) (str vname)))]&amp;lt;br&amp;gt;    (swap! CLJS-VAR-ENV assoc var vtype)&amp;lt;br&amp;gt;    [var (unparse-type vtype)]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cljs-ann*</a>[vname tsyn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;coerse-RClass-primitive&lt;/b&gt; ([s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn coerse-RClass-primitive&amp;lt;br&amp;gt;  [s t]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    ; (U Integer Long) &amp;lt;: (U int long)&amp;lt;br&amp;gt;    (and &amp;lt;br&amp;gt;      (#{(RClass-of Integer) (RClass-of Long)} s)&amp;lt;br&amp;gt;      (#{(RClass-of 'int) (RClass-of 'long)} t))&amp;lt;br&amp;gt;    true&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    :else&amp;lt;br&amp;gt;    (let [spcls (symbol-&amp;gt;Class (:the-class s))&amp;lt;br&amp;gt;          tpcls (symbol-&amp;gt;Class (:the-class t))&amp;lt;br&amp;gt;          scls (or (boxed-primitives spcls)&amp;lt;br&amp;gt;                   spcls)&amp;lt;br&amp;gt;          tcls (or (boxed-primitives tpcls)&amp;lt;br&amp;gt;                   tpcls)]&amp;lt;br&amp;gt;      (isa? scls tcls))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">coerse-RClass-primitive</a>[s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;combine-frees&lt;/b&gt; ([&amp; frees])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn combine-frees [&amp;amp; frees]&amp;lt;br&amp;gt;  {:pre [(every? variance-map? frees)]&amp;lt;br&amp;gt;   :post [(variance-map? %)]}&amp;lt;br&amp;gt;  (into {}&amp;lt;br&amp;gt;        (apply merge-with (fn [old-vari new-vari]&amp;lt;br&amp;gt;                            (cond &amp;lt;br&amp;gt;                              (= old-vari new-vari) old-vari&amp;lt;br&amp;gt;                              (= old-vari :dotted) new-vari&amp;lt;br&amp;gt;                              (= new-vari :dotted) old-vari&amp;lt;br&amp;gt;                              (= old-vari :constant) new-vari&amp;lt;br&amp;gt;                              (= new-vari :constant) old-vari&amp;lt;br&amp;gt;                              :else :invariant))&amp;lt;br&amp;gt;               frees)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">combine-frees</a>[& frees]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;combine-props&lt;/b&gt; ([new-props old-props flag])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn combine-props [new-props old-props flag]&amp;lt;br&amp;gt;  {:pre [(every? Filter? (concat new-props old-props))&amp;lt;br&amp;gt;         (instance? clojure.lang.Atom flag)&amp;lt;br&amp;gt;         (boolean? @flag)]&amp;lt;br&amp;gt;   :post [(let [[derived-props derived-atoms] %]&amp;lt;br&amp;gt;            (and (every? (some-fn ImpFilter? OrFilter? AndFilter?) derived-props)&amp;lt;br&amp;gt;                 (every? (some-fn TypeFilter? NotTypeFilter?) derived-atoms)))]}&amp;lt;br&amp;gt;  (let [atomic-prop? (some-fn TypeFilter? NotTypeFilter?)&amp;lt;br&amp;gt;        {new-atoms true new-formulas false} (group-by atomic-prop? (flatten-props new-props))]&amp;lt;br&amp;gt;    (loop [derived-props []&amp;lt;br&amp;gt;           derived-atoms new-atoms&amp;lt;br&amp;gt;           worklist (concat old-props new-formulas)]&amp;lt;br&amp;gt;      (if (empty? worklist)&amp;lt;br&amp;gt;        [derived-props derived-atoms]&amp;lt;br&amp;gt;        (let [p (first worklist)&amp;lt;br&amp;gt;              p (resolve* derived-atoms p)]&amp;lt;br&amp;gt;          (cond&amp;lt;br&amp;gt;            (AndFilter? p) (recur derived-props derived-atoms (concat (:fs p) (next worklist)))&amp;lt;br&amp;gt;            (ImpFilter? p) &amp;lt;br&amp;gt;            (let [{:keys [a c]} p&amp;lt;br&amp;gt;                  implied? (some (fn [p] (implied-atomic? a p)) (concat derived-props derived-atoms))]&amp;lt;br&amp;gt;              #_(prn &amp;quot;combining &amp;quot; (unparse-filter p) &amp;quot; with &amp;quot; (map unparse-filter (concat derived-props&amp;lt;br&amp;gt;                                                                                        derived-atoms))&amp;lt;br&amp;gt;                   &amp;quot; and implied:&amp;quot; implied?)&amp;lt;br&amp;gt;              (if implied?&amp;lt;br&amp;gt;                (recur derived-props derived-atoms (cons c (rest worklist)))&amp;lt;br&amp;gt;                (recur (cons p derived-props) derived-atoms (next worklist))))&amp;lt;br&amp;gt;            (OrFilter? p)&amp;lt;br&amp;gt;            (let [ps (:fs p)&amp;lt;br&amp;gt;                  new-or (loop [ps ps&amp;lt;br&amp;gt;                                result []]&amp;lt;br&amp;gt;                           (cond&amp;lt;br&amp;gt;                             (empty? ps) (apply -or result)&amp;lt;br&amp;gt;                             (some (fn [other-p] (opposite? (first ps) other-p))&amp;lt;br&amp;gt;                                   (concat derived-props derived-atoms))&amp;lt;br&amp;gt;                             (recur (next ps) result)&amp;lt;br&amp;gt;                             (some (fn [other-p] (implied-atomic? (first ps) other-p))&amp;lt;br&amp;gt;                                   derived-atoms)&amp;lt;br&amp;gt;                             -top&amp;lt;br&amp;gt;                             :else (recur (next ps) (cons (first ps) result))))]&amp;lt;br&amp;gt;              (if (OrFilter? new-or)&amp;lt;br&amp;gt;                (recur (cons new-or derived-props) derived-atoms (next worklist))&amp;lt;br&amp;gt;                (recur derived-props derived-atoms (cons new-or (next worklist)))))&amp;lt;br&amp;gt;            (and (TypeFilter? p)&amp;lt;br&amp;gt;                 (type-equal? (Un) (:type p)))&amp;lt;br&amp;gt;            (do &amp;lt;br&amp;gt;              ;(prn &amp;quot;Variable set to bottom:&amp;quot; (unparse-filter p))&amp;lt;br&amp;gt;              (reset! flag false)&amp;lt;br&amp;gt;              [derived-props derived-atoms])&amp;lt;br&amp;gt;            (TypeFilter? p) (recur derived-props (cons p derived-atoms) (next worklist))&amp;lt;br&amp;gt;            (and (NotTypeFilter? p)&amp;lt;br&amp;gt;                 (type-equal? (-&amp;gt;Top) (:type p)))&amp;lt;br&amp;gt;            (do &amp;lt;br&amp;gt;              ;(prn &amp;quot;Variable set to bottom:&amp;quot; (unparse-filter p))&amp;lt;br&amp;gt;              (reset! flag false)&amp;lt;br&amp;gt;              [derived-props derived-atoms])&amp;lt;br&amp;gt;            (NotTypeFilter? p) (recur derived-props (cons p derived-atoms) (next worklist))&amp;lt;br&amp;gt;            (TopFilter? p) (recur derived-props derived-atoms (next worklist))&amp;lt;br&amp;gt;            (BotFilter? p) (do &amp;lt;br&amp;gt;                             ;(prn &amp;quot;Bot filter found&amp;quot;)&amp;lt;br&amp;gt;                             (reset! flag false)&amp;lt;br&amp;gt;                             [derived-props derived-atoms])&amp;lt;br&amp;gt;            :else (recur (cons p derived-props) derived-atoms (next worklist))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">combine-props</a>[new-props old-props flag]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;compact&lt;/b&gt; ([props or?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn compact [props or?]&amp;lt;br&amp;gt;  {:pre [(every? Filter? props)&amp;lt;br&amp;gt;         (boolean? or?)]&amp;lt;br&amp;gt;   :post [(every? Filter? %)]}&amp;lt;br&amp;gt;  (let [tf-map (atom {})&amp;lt;br&amp;gt;        ntf-map (atom {})]&amp;lt;br&amp;gt;    ;; props: the propositions we're processing&amp;lt;br&amp;gt;    ;; others: props that are neither TF or NTF&amp;lt;br&amp;gt;    (loop [props props&amp;lt;br&amp;gt;           others nil]&amp;lt;br&amp;gt;      (if (empty? props)&amp;lt;br&amp;gt;        (concat others&amp;lt;br&amp;gt;                (vals @tf-map)&amp;lt;br&amp;gt;                (vals @ntf-map))&amp;lt;br&amp;gt;        (cond&amp;lt;br&amp;gt;          (and or? (TypeFilter? (first props)))&amp;lt;br&amp;gt;          (let [{t1 :type f1 :path x :id :as p} (first props)]&amp;lt;br&amp;gt;            (swap! tf-map (fn [m] (update-in m [[f1 x]] #(if %&amp;lt;br&amp;gt;                                                           (if (TypeFilter? %)&amp;lt;br&amp;gt;                                                             (let [t2 (:type %)]&amp;lt;br&amp;gt;                                                               (-filter (Un t1 t2) x f1))&amp;lt;br&amp;gt;                                                             (throw (Exception. (str &amp;quot;got something that isn't a type filter&amp;quot; p))))&amp;lt;br&amp;gt;                                                           p))))&amp;lt;br&amp;gt;            (recur (rest props) others))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;          (and (not or?) (TypeFilter? (first props)))&amp;lt;br&amp;gt;          (let [{t1 :type f1 :path x :id} (first props)&amp;lt;br&amp;gt;                fl (@tf-map [f1 x])]&amp;lt;br&amp;gt;            (cond&amp;lt;br&amp;gt;              (and (TypeFilter? fl)&amp;lt;br&amp;gt;                   (let [t2 (:type fl)]&amp;lt;br&amp;gt;                     (not (overlap t1 (:type fl)))))&amp;lt;br&amp;gt;              ;; we're in an And, and we got two types for the same path that do not overlap&amp;lt;br&amp;gt;              [-bot]&amp;lt;br&amp;gt;              (TypeFilter? fl)&amp;lt;br&amp;gt;              (let [t2 (:type fl)]&amp;lt;br&amp;gt;                (swap! tf-map (fn [m] (assoc m [f1 x] (-filter (restrict t1 t2) x f1))))&amp;lt;br&amp;gt;                (recur (next props) others))&amp;lt;br&amp;gt;              :else&amp;lt;br&amp;gt;              (do &amp;lt;br&amp;gt;                (swap! tf-map (fn [m] (assoc m [f1 x] (-filter t1 x f1))))&amp;lt;br&amp;gt;                (recur (next props) others))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;          (and (not or?) &amp;lt;br&amp;gt;               (NotTypeFilter? (first props)))&amp;lt;br&amp;gt;          (let [{t1 :type f1 :path x :id :as p} (first props)]&amp;lt;br&amp;gt;            (swap! ntf-map (fn [m] (update-in m [[f1 x]]&amp;lt;br&amp;gt;                                              (fn [n]&amp;lt;br&amp;gt;                                                (if n&amp;lt;br&amp;gt;                                                  (if (NotTypeFilter? n)&amp;lt;br&amp;gt;                                                    (let [t2 (:type n)]&amp;lt;br&amp;gt;                                                      (-not-filter (Un t1 t2) x f1))&amp;lt;br&amp;gt;                                                    (throw (Exception. (str &amp;quot;got something that isn't a nottypefilter&amp;quot; p))))&amp;lt;br&amp;gt;                                                  p)))))&amp;lt;br&amp;gt;            (recur (next props) others))&amp;lt;br&amp;gt;          :else&amp;lt;br&amp;gt;          (let [p (first props)]&amp;lt;br&amp;gt;            (recur (next props) (cons p others))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">compact</a>[props or?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;complete-hmap?&lt;/b&gt; ([hmap])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn complete-hmap? [^HeterogeneousMap hmap]&amp;lt;br&amp;gt;  {:pre [(HeterogeneousMap? hmap)]}&amp;lt;br&amp;gt;  (not (.other-keys? hmap)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">complete-hmap?</a>[hmap]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;countrange-overlap?&lt;/b&gt; ([{lowerl :lower, upperl :upper, :as l} {lowerr :lower, upperr :upper, :as r}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn countrange-overlap? &amp;lt;br&amp;gt;  [{lowerl :lower upperl :upper :as l}&amp;lt;br&amp;gt;   {lowerr :lower upperr :upper :as r}]&amp;lt;br&amp;gt;  {:pre [(CountRange? l)&amp;lt;br&amp;gt;         (CountRange? r)]}&amp;lt;br&amp;gt;  (cond &amp;lt;br&amp;gt;    (and upperl upperr)&amp;lt;br&amp;gt;        (or &amp;lt;br&amp;gt;          ;; -----&amp;lt;br&amp;gt;          ;;   -------&amp;lt;br&amp;gt;          ;; and&amp;lt;br&amp;gt;          ;;   ---&amp;lt;br&amp;gt;          ;;   -------&amp;lt;br&amp;gt;          (&amp;lt;= lowerl lowerr upperl upperr)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;          ;;    --&amp;lt;br&amp;gt;          ;;   -------&amp;lt;br&amp;gt;          (&amp;lt;= lowerr lowerl upperl upperr)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;          ;;     ------&amp;lt;br&amp;gt;          ;; -------&amp;lt;br&amp;gt;          ;; and&amp;lt;br&amp;gt;          ;;     ---&amp;lt;br&amp;gt;          ;; -------&amp;lt;br&amp;gt;          (&amp;lt;= lowerr lowerl upperr upperl)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;          ;; otherwise no overlap&amp;lt;br&amp;gt;          false)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    upperl ;; and (not upperr)&amp;lt;br&amp;gt;      (or &amp;lt;br&amp;gt;        ;; ----&amp;lt;br&amp;gt;        ;;  -----&amp;gt;&amp;gt;&amp;lt;br&amp;gt;        ;; and&amp;lt;br&amp;gt;        ;;  ---&amp;lt;br&amp;gt;        ;;  -----&amp;gt;&amp;gt;&amp;lt;br&amp;gt;        (&amp;lt;= lowerl lowerr upperl)&amp;lt;br&amp;gt;        ;;   ---&amp;lt;br&amp;gt;        ;;  -----&amp;gt;&amp;gt;&amp;lt;br&amp;gt;        (&amp;lt;= lowerr lowerl)&amp;lt;br&amp;gt;        ;; otherwise no overlap&amp;lt;br&amp;gt;        false)&amp;lt;br&amp;gt;    upperr&amp;lt;br&amp;gt;      (or&amp;lt;br&amp;gt;        ;; ------&amp;gt;&amp;gt;&amp;lt;br&amp;gt;        ;;  ----&amp;lt;br&amp;gt;        ;; and&amp;lt;br&amp;gt;        ;;  -----&amp;gt;&amp;gt;&amp;lt;br&amp;gt;        ;;  ---&amp;lt;br&amp;gt;        (&amp;lt;= lowerl lowerr)&amp;lt;br&amp;gt;        &amp;lt;br&amp;gt;        ;;   ---&amp;gt;&amp;gt;&amp;lt;br&amp;gt;        ;; ----&amp;lt;br&amp;gt;        (&amp;lt;= lowerr lowerl upperr)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ;; else no overlap&amp;lt;br&amp;gt;        false)&amp;lt;br&amp;gt;    :else ;; (and (not upperl) (not upperr))&amp;lt;br&amp;gt;    ;; ----&amp;gt;&amp;gt;&amp;lt;br&amp;gt;    ;;   --&amp;gt;&amp;gt;&amp;lt;br&amp;gt;    ;; and&amp;lt;br&amp;gt;    ;;   --&amp;gt;&amp;gt;&amp;lt;br&amp;gt;    ;; ----&amp;gt;&amp;gt;&amp;lt;br&amp;gt;    true))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">countrange-overlap?</a>[{lowerl :lower, upperl :upper, :as l} {lowerr :lower, upperr :upper, :as r}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cs-gen&lt;/b&gt; ([V X Y S T])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cs-gen [V X Y S T]&amp;lt;br&amp;gt;  {:pre [((set-c? symbol?) V)&amp;lt;br&amp;gt;         (every? (hash-c? symbol? Bounds?) [X Y])&amp;lt;br&amp;gt;         (AnyType? S)&amp;lt;br&amp;gt;         (AnyType? T)]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  #_(prn &amp;quot;cs-gen&amp;quot; (unparse-type S) (unparse-type T))&amp;lt;br&amp;gt;  (if (or (*cs-current-seen* [S T]) &amp;lt;br&amp;gt;          (subtype? S T))&amp;lt;br&amp;gt;    ;already been around this loop, is a subtype&amp;lt;br&amp;gt;    (empty-cset X Y)&amp;lt;br&amp;gt;    (binding [*cs-current-seen* (conj *cs-current-seen* [S T])]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;        (Top? T)&amp;lt;br&amp;gt;        (empty-cset X Y)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ;IMPORTANT: handle frees first&amp;lt;br&amp;gt;        (and (F? S)&amp;lt;br&amp;gt;             (contains? X (.name ^F S)))&amp;lt;br&amp;gt;        (cs-gen-left-F V X Y S T)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (F? T)&amp;lt;br&amp;gt;             (contains? X (.name ^F T)))&amp;lt;br&amp;gt;        (cs-gen-right-F V X Y S T)&amp;lt;br&amp;gt;        &amp;lt;br&amp;gt;        ;values are subtypes of their classes&amp;lt;br&amp;gt;        (and (Value? S)&amp;lt;br&amp;gt;             (checking-clojure?))&amp;lt;br&amp;gt;        (let [^Value S S]&amp;lt;br&amp;gt;          (if (nil? (.val S))&amp;lt;br&amp;gt;            (type-error S T)&amp;lt;br&amp;gt;            (cs-gen V X Y&amp;lt;br&amp;gt;                    (apply In (RClass-of (class (.val S)))&amp;lt;br&amp;gt;                           (cond &amp;lt;br&amp;gt;                             ;keyword values are functions&amp;lt;br&amp;gt;                             (keyword? (.val S)) [(keyword-&amp;gt;Fn (.val S))]&amp;lt;br&amp;gt;                             ;strings have a known length as a seqable&amp;lt;br&amp;gt;                             (string? (.val S)) [(make-ExactCountRange (count (.val S)))]))&amp;lt;br&amp;gt;                    T)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ;; constrain body to be below T, but don't mention the new vars&amp;lt;br&amp;gt;        (Poly? S)&amp;lt;br&amp;gt;        (let [nms (repeatedly (.nbound ^Poly S) gensym)&amp;lt;br&amp;gt;              body (Poly-body* nms S)]&amp;lt;br&amp;gt;          (cs-gen (set/union (set nms) V) X Y body T))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (Name? S)&amp;lt;br&amp;gt;        (cs-gen V X Y (resolve-Name S) T)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (Name? T)&amp;lt;br&amp;gt;        (cs-gen V X Y S (resolve-Name T))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (TApp? S)&amp;lt;br&amp;gt;             (not (F? (.rator ^TApp S))))&amp;lt;br&amp;gt;        (cs-gen V X Y (resolve-TApp S) T)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (TApp? T)&amp;lt;br&amp;gt;             (not (F? (.rator ^TApp T))))&amp;lt;br&amp;gt;        (cs-gen V X Y S (resolve-TApp T))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ;constrain *each* element of S to be below T, and then combine the constraints&amp;lt;br&amp;gt;        (Union? S)&amp;lt;br&amp;gt;        (cset-meet*&amp;lt;br&amp;gt;          (cons (empty-cset X Y)&amp;lt;br&amp;gt;                (mapv #(cs-gen V X Y % T) (.types ^Union S))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ;; find *an* element of T which can be made a supertype of S&amp;lt;br&amp;gt;        (Union? T)&amp;lt;br&amp;gt;        (if-let [cs (seq (filter identity (mapv #(try (cs-gen V X Y S %)&amp;lt;br&amp;gt;                                                   (catch IllegalArgumentException e&amp;lt;br&amp;gt;                                                     (throw e))&amp;lt;br&amp;gt;                                                   (catch Exception e)) &amp;lt;br&amp;gt;                                                (.types ^Union T))))]&amp;lt;br&amp;gt;          (cset-combine cs)&amp;lt;br&amp;gt;          (type-error S T))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (Intersection? S)&amp;lt;br&amp;gt;             (Intersection? T))&amp;lt;br&amp;gt;        (cset-meet*&amp;lt;br&amp;gt;          (doall&amp;lt;br&amp;gt;            ; for each element of T, we need at least one element of S that works&amp;lt;br&amp;gt;            (for [t* (:types T)]&amp;lt;br&amp;gt;              (if-let [results (seq (filter identity&amp;lt;br&amp;gt;                                            (map #(try &amp;lt;br&amp;gt;                                                    (cs-gen V X Y % t*)&amp;lt;br&amp;gt;                                                    (catch IllegalArgumentException e&amp;lt;br&amp;gt;                                                      (throw e))&amp;lt;br&amp;gt;                                                    (catch Exception e))&amp;lt;br&amp;gt;                                                 (:types S))))]&amp;lt;br&amp;gt;                (cset-combine results)&amp;lt;br&amp;gt;                (type-error S T)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ;; find *an* element of S which can be made a subtype of T&amp;lt;br&amp;gt;        (Intersection? S)&amp;lt;br&amp;gt;        (if-let [cs (some #(try (cs-gen V X Y % T)&amp;lt;br&amp;gt;                             (catch IllegalArgumentException e&amp;lt;br&amp;gt;                               (throw e))&amp;lt;br&amp;gt;                             (catch Exception e)) ;TODO specialised data Exceptions&amp;lt;br&amp;gt;                          (:types S))]&amp;lt;br&amp;gt;          cs&amp;lt;br&amp;gt;          (throw (Exception. (str &amp;quot;Could not constrain &amp;quot;&amp;lt;br&amp;gt;                                  (unparse-type S) &amp;quot; to be under &amp;quot;&amp;lt;br&amp;gt;                                  (unparse-type T)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ;constrain *every* element of T to be above S, and then meet the constraints&amp;lt;br&amp;gt;        ;FIXME Should this combine csets instead?&amp;lt;br&amp;gt;        (Intersection? T)&amp;lt;br&amp;gt;        (cset-meet*&amp;lt;br&amp;gt;          (cons (empty-cset X Y)&amp;lt;br&amp;gt;                (mapv #(cs-gen V X Y S %) (:types T))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (App? S)&amp;lt;br&amp;gt;        (cs-gen V X Y (resolve-App S) T)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (App? T)&amp;lt;br&amp;gt;        (cs-gen V X Y S (resolve-App T))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (or (Projection? S)&amp;lt;br&amp;gt;            (Projection? T))&amp;lt;br&amp;gt;        (empty-cset-projection X Y [S T])&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        :else&amp;lt;br&amp;gt;        (cs-gen* V X Y S T)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cs-gen</a>[V X Y S T]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cs-gen-Function&lt;/b&gt; ([V X Y S T])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cs-gen-Function&amp;lt;br&amp;gt;  [V X Y S T]&amp;lt;br&amp;gt;  {:pre [((set-c? symbol?) V)&amp;lt;br&amp;gt;         (every? (hash-c? symbol? Bounds?) [X Y])&amp;lt;br&amp;gt;         (Function? S)&amp;lt;br&amp;gt;         (Function? T)]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  ;(prn &amp;quot;cs-gen-Function&amp;quot;)&amp;lt;br&amp;gt;  (letfn [(cg [S T] (cs-gen V X Y S T))]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      ;easy case - no rests, drests, kws&amp;lt;br&amp;gt;      (and (not (:rest S))&amp;lt;br&amp;gt;           (not (:rest T))&amp;lt;br&amp;gt;           (not (:drest S))&amp;lt;br&amp;gt;           (not (:drest T))&amp;lt;br&amp;gt;           (not (:kws S))&amp;lt;br&amp;gt;           (not (:kws T)))&amp;lt;br&amp;gt;      ; contravariant&amp;lt;br&amp;gt;      (let [;_ (prn &amp;quot;easy case&amp;quot;)&amp;lt;br&amp;gt;            ]&amp;lt;br&amp;gt;        (cset-meet* [(cs-gen-list V X Y (:dom T) (:dom S))&amp;lt;br&amp;gt;                     ; covariant&amp;lt;br&amp;gt;                     (cg (:rng S) (:rng T))]))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;just a rest arg, no drest, no keywords&amp;lt;br&amp;gt;      (and (or (:rest S)&amp;lt;br&amp;gt;               (:rest T))&amp;lt;br&amp;gt;           (not (:drest S))&amp;lt;br&amp;gt;           (not (:drest T))&amp;lt;br&amp;gt;           (not (:kws S))&amp;lt;br&amp;gt;           (not (:kws T)))&amp;lt;br&amp;gt;      (let [arg-mapping (cond&amp;lt;br&amp;gt;                          ;both rest args are present, so make them the same length&amp;lt;br&amp;gt;                          (and (:rest S) (:rest T))&amp;lt;br&amp;gt;                          (cs-gen-list V X Y &amp;lt;br&amp;gt;                                       (cons (:rest T) (concat (:dom T) (repeat (- (count (:dom S))&amp;lt;br&amp;gt;                                                                                   (count (:dom T)))&amp;lt;br&amp;gt;                                                                                (:rest T))))&amp;lt;br&amp;gt;                                       (cons (:rest S) (concat (:dom S) (repeat (- (count (:dom T))&amp;lt;br&amp;gt;                                                                                   (count (:dom S)))&amp;lt;br&amp;gt;                                                                                (:rest S)))))&amp;lt;br&amp;gt;                          ;no rest arg on the right, so just pad left and forget the rest arg&amp;lt;br&amp;gt;                          (and (:rest S) (not (:rest T)))&amp;lt;br&amp;gt;                          (let [new-S (concat (:dom S) (repeat (- (count (:dom T))&amp;lt;br&amp;gt;                                                                  (count (:dom S)))&amp;lt;br&amp;gt;                                                               (:rest S)))]&amp;lt;br&amp;gt;;                            (prn &amp;quot;infer rest arg on left&amp;quot;)&amp;lt;br&amp;gt;;                            (prn &amp;quot;left dom&amp;quot; (map unparse-type (:dom S)))&amp;lt;br&amp;gt;;                            (prn &amp;quot;right dom&amp;quot; (map unparse-type (:dom T)))&amp;lt;br&amp;gt;;                            (prn &amp;quot;new left dom&amp;quot; (map unparse-type new-S))&amp;lt;br&amp;gt;                            (cs-gen-list V X Y (:dom T) new-S))&amp;lt;br&amp;gt;                          ;no rest arg on left, or wrong number = fail&amp;lt;br&amp;gt;                          :else (type-error S T))&amp;lt;br&amp;gt;            ret-mapping (cs-gen V X Y (:rng S) (:rng T))]&amp;lt;br&amp;gt;        (cset-meet* [arg-mapping ret-mapping]))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;; dotted on the left, nothing on the right&amp;lt;br&amp;gt;      (and (not (:rest S))&amp;lt;br&amp;gt;           (not (:rest T))&amp;lt;br&amp;gt;           (:drest S)&amp;lt;br&amp;gt;           (not (:drest T))&amp;lt;br&amp;gt;           (not (:kws S))&amp;lt;br&amp;gt;           (not (:kws T)))&amp;lt;br&amp;gt;      (let [{dty :pre-type dbound :name} (:drest S)]&amp;lt;br&amp;gt;        (when-not (Y dbound)&amp;lt;br&amp;gt;          (type-error S T))&amp;lt;br&amp;gt;        (when-not (&amp;lt;= (count (:dom S)) (count (:dom T)))&amp;lt;br&amp;gt;          (type-error S T))&amp;lt;br&amp;gt;        (let [vars (var-store-take dbound dty (- (count (:dom T))&amp;lt;br&amp;gt;                                                 (count (:dom S))))&amp;lt;br&amp;gt;              new-tys (doall (for [var vars]&amp;lt;br&amp;gt;                               (substitute (make-F var) dbound dty)))&amp;lt;br&amp;gt;              new-s-arr (-&amp;gt;Function (concat (:dom S) new-tys) (:rng S) nil nil nil)&amp;lt;br&amp;gt;              new-cset (cs-gen-Function V &amp;lt;br&amp;gt;                                        ;move dotted lower/upper bounds to vars&amp;lt;br&amp;gt;                                        (merge X (zipmap vars (repeat (Y dbound)))) Y new-s-arr T)]&amp;lt;br&amp;gt;          (move-vars-to-dmap new-cset dbound vars)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;; dotted on the right, nothing on the left&amp;lt;br&amp;gt;      (and (not ((some-fn :rest :drest) S))&amp;lt;br&amp;gt;           (:drest T))&amp;lt;br&amp;gt;      (let [{dty :pre-type dbound :name} (:drest T)]&amp;lt;br&amp;gt;        (when-not (Y dbound)&amp;lt;br&amp;gt;          (type-error S T))&amp;lt;br&amp;gt;        (when-not (&amp;lt;= (count (:dom T)) (count (:dom S)))&amp;lt;br&amp;gt;          (type-error S T))&amp;lt;br&amp;gt;        (let [vars (var-store-take dbound dty (- (count (:dom S)) (count (:dom T))))&amp;lt;br&amp;gt;              new-tys (doall&amp;lt;br&amp;gt;                        (for [var vars]&amp;lt;br&amp;gt;                          (substitute (make-F var) dbound dty)))&amp;lt;br&amp;gt;              ;_ (prn &amp;quot;dotted on the right, nothing on the left&amp;quot;)&amp;lt;br&amp;gt;              ;_ (prn &amp;quot;vars&amp;quot; vars)&amp;lt;br&amp;gt;              new-t-arr (-&amp;gt;Function (concat (:dom T) new-tys) (:rng T) nil nil nil)&amp;lt;br&amp;gt;              ;_ (prn &amp;quot;S&amp;quot; (unparse-type S))&amp;lt;br&amp;gt;              ;_ (prn &amp;quot;new-t-arr&amp;quot; (unparse-type new-t-arr))&amp;lt;br&amp;gt;              new-cset (cs-gen-Function V &amp;lt;br&amp;gt;                                        ;move dotted lower/upper bounds to vars&amp;lt;br&amp;gt;                                        (merge X (zipmap vars (repeat (Y dbound)))) Y S new-t-arr)]&amp;lt;br&amp;gt;          (move-vars-to-dmap new-cset dbound vars)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;; * &amp;lt;: ...&amp;lt;br&amp;gt;      (and (:rest S)&amp;lt;br&amp;gt;           (:drest T))&amp;lt;br&amp;gt;      (let [{t-dty :pre-type dbound :name} (-&amp;gt; T :drest)]&amp;lt;br&amp;gt;        (when-not (Y dbound)&amp;lt;br&amp;gt;          (type-error S T))&amp;lt;br&amp;gt;        (if (&amp;lt;= (count (:dom S)) (count (:dom T)))&amp;lt;br&amp;gt;          ;; the simple case&amp;lt;br&amp;gt;          (let [arg-mapping (cs-gen-list V X Y (:dom T) (concat (:dom S) (repeat (- (count (:dom T)) (count (:dom S))) (:rest S))))&amp;lt;br&amp;gt;                darg-mapping (move-rest-to-dmap (cs-gen V (merge X {dbound (Y dbound)}) Y t-dty (:rest S)) dbound)&amp;lt;br&amp;gt;                ret-mapping (cg (:rng S) (:rng T))]&amp;lt;br&amp;gt;            (cset-meet* [arg-mapping darg-mapping ret-mapping]))&amp;lt;br&amp;gt;          ;; the hard case&amp;lt;br&amp;gt;          (let [vars (var-store-take dbound t-dty (- (count (:dom S)) (count (:dom T))))&amp;lt;br&amp;gt;                new-tys (doall (for [var vars]&amp;lt;br&amp;gt;                                 (substitute (make-F var) dbound t-dty)))&amp;lt;br&amp;gt;                new-t-arr (-&amp;gt;Function (concat (:dom T) new-tys) (:rng T) nil (-&amp;gt;DottedPretype t-dty dbound) nil)&amp;lt;br&amp;gt;                new-cset (cs-gen-Function V (merge X (zipmap vars (repeat (Y dbound))) X) Y S new-t-arr)]&amp;lt;br&amp;gt;            (move-vars+rest-to-dmap new-cset dbound vars))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;:else &amp;lt;br&amp;gt;(throw (IllegalArgumentException. (pr-str &amp;quot;NYI Function inference &amp;quot; (unparse-type S) (unparse-type T)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cs-gen-Function</a>[V X Y S T]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cs-gen-datatypes-or-records&lt;/b&gt; ([V X Y S T])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cs-gen-datatypes-or-records &amp;lt;br&amp;gt;  [V X Y S T]&amp;lt;br&amp;gt;  {:pre [(or (every? Record? [S T])&amp;lt;br&amp;gt;             (every? DataType? [S T]))]}&amp;lt;br&amp;gt;  (assert (= (:the-class S) (:the-class T)) (type-error S T))&amp;lt;br&amp;gt;  (if (seq (:poly? S))&amp;lt;br&amp;gt;    (cs-gen-list V X Y (:poly? S) (:poly? T))&amp;lt;br&amp;gt;    (empty-cset X Y)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cs-gen-datatypes-or-records</a>[V X Y S T]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cs-gen-filter&lt;/b&gt; ([V X Y s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cs-gen-filter [V X Y s t]&amp;lt;br&amp;gt;  {:pre [((set-c? symbol?) V)&amp;lt;br&amp;gt;         (every? (hash-c? symbol? Bounds?) [X Y])&amp;lt;br&amp;gt;         (Filter? s)&amp;lt;br&amp;gt;         (Filter? t)]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (= s t) (empty-cset X Y)&amp;lt;br&amp;gt;    (TopFilter? t) (empty-cset X Y)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (TypeFilter? s)&amp;lt;br&amp;gt;         (TypeFilter? t))&amp;lt;br&amp;gt;    (cset-meet (cs-gen V X Y (:type s) (:type t))&amp;lt;br&amp;gt;               (cs-gen V X Y (:type t) (:type s)))&amp;lt;br&amp;gt;    (and (NotTypeFilter? s)&amp;lt;br&amp;gt;         (NotTypeFilter? t))&amp;lt;br&amp;gt;    (cset-meet (cs-gen V X Y (:type s) (:type t))&amp;lt;br&amp;gt;               (cs-gen V X Y (:type t) (:type s)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    ; simple case for unifying x and y in (&amp;amp; (is x sym) ...) (is y sym)&amp;lt;br&amp;gt;    (and (AndFilter? s)&amp;lt;br&amp;gt;         (TypeFilter? t)&amp;lt;br&amp;gt;         (every? atomic-filter? (:fs s))&amp;lt;br&amp;gt;         (= 1 (count TypeFilter?) (:fs s)))&amp;lt;br&amp;gt;    (let [tf (first (filter TypeFilter? (:fs s)))]&amp;lt;br&amp;gt;      (cs-gen-filter V X Y tf t))&amp;lt;br&amp;gt;    :else (throw (Exception. (error-msg &amp;quot;Need two filters of same type &amp;quot;&amp;lt;br&amp;gt;                                        (pr-str (unparse-filter s)) &amp;quot; &amp;quot; (pr-str (unparse-filter t)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cs-gen-filter</a>[V X Y s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cs-gen-filter-set&lt;/b&gt; ([V X Y s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cs-gen-filter-set [V X Y s t]&amp;lt;br&amp;gt;  {:pre [((set-c? symbol?) V)&amp;lt;br&amp;gt;         (every? (hash-c? symbol? Bounds?) [X Y])&amp;lt;br&amp;gt;         (FilterSet? s)&amp;lt;br&amp;gt;         (FilterSet? t)]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (= s t) (empty-cset X Y)&amp;lt;br&amp;gt;    (and (FilterSet? s)&amp;lt;br&amp;gt;         (FilterSet? t))&amp;lt;br&amp;gt;    (let [{s+ :then s- :else} s&amp;lt;br&amp;gt;          {t+ :then t- :else} t]&amp;lt;br&amp;gt;      (cset-meet (cs-gen-filter V X Y s+ t+)&amp;lt;br&amp;gt;                 (cs-gen-filter V X Y s- t-)))&amp;lt;br&amp;gt;    :else (throw (IllegalArgumentException. &amp;quot;Need two filtersets&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cs-gen-filter-set</a>[V X Y s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cs-gen-left-F&lt;/b&gt; ([V X Y S T])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cs-gen-left-F [V X Y ^F S T]&amp;lt;br&amp;gt;  #_(prn &amp;quot;cs-gen* [F Type]&amp;quot; S T)&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (contains? X (.name S))&amp;lt;br&amp;gt;    (demote-F V X Y S T)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (F? T)&amp;lt;br&amp;gt;         (contains? X (.name ^F T)))&amp;lt;br&amp;gt;    (promote-F V X Y S T)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    :else (type-error S T)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cs-gen-left-F</a>[V X Y S T]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cs-gen-list&lt;/b&gt; ([V X Y S T &amp; {:keys [expected-cset], :or {expected-cset (empty-cset {} {})}}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cs-gen-list [V X Y S T &amp;amp; {:keys [expected-cset] :or {expected-cset (empty-cset {} {})}}]&amp;lt;br&amp;gt;  {:pre [((set-c? symbol?) V)&amp;lt;br&amp;gt;         (every? (hash-c? symbol? Bounds?) [X Y])&amp;lt;br&amp;gt;         (every? Type? (concat S T))&amp;lt;br&amp;gt;         (cset? expected-cset)]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;;  (prn &amp;quot;cs-gen-list&amp;quot; &amp;lt;br&amp;gt;;       V X Y&amp;lt;br&amp;gt;;       (map unparse-type S)&amp;lt;br&amp;gt;;       (map unparse-type T))&amp;lt;br&amp;gt;  (assert (= (count S) (count T))&amp;lt;br&amp;gt;          (pr-str &amp;quot;S:&amp;quot; (map unparse-type S)&amp;lt;br&amp;gt;                  &amp;quot;T:&amp;quot; (map unparse-type T)))&amp;lt;br&amp;gt;  (cset-meet*&amp;lt;br&amp;gt;    ;; We meet early to prune the csets to a reasonable size.&amp;lt;br&amp;gt;    ;; This weakens the inference a bit, but sometimes avoids&amp;lt;br&amp;gt;    ;; constraint explosion.&amp;lt;br&amp;gt;    (cons&amp;lt;br&amp;gt;      (empty-cset X Y)&amp;lt;br&amp;gt;      (doall &amp;lt;br&amp;gt;        (for [[s t] (map vector S T)]&amp;lt;br&amp;gt;          (let [c (cs-gen V X Y s t)]&amp;lt;br&amp;gt;;            (prn &amp;quot;s&amp;quot; s)&amp;lt;br&amp;gt;;            (prn &amp;quot;t&amp;quot; t)&amp;lt;br&amp;gt;;            (prn &amp;quot;c&amp;quot; c)&amp;lt;br&amp;gt;;            (prn &amp;quot;expected cset&amp;quot; expected-cset)&amp;lt;br&amp;gt;            (cset-meet c expected-cset)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cs-gen-list</a>[V X Y S T & {:keys [expected-cset], :or {expected-cset (empty-cset {} {})}}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cs-gen-object&lt;/b&gt; ([V X Y s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cs-gen-object [V X Y s t]&amp;lt;br&amp;gt;  {:pre [((set-c? symbol?) V)&amp;lt;br&amp;gt;         (every? (hash-c? symbol? Bounds?) [X Y])&amp;lt;br&amp;gt;         (RObject? s)&amp;lt;br&amp;gt;         (RObject? t)]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (= s t) (empty-cset X Y)&amp;lt;br&amp;gt;    (EmptyObject? t) (empty-cset X Y)&amp;lt;br&amp;gt;    ;;FIXME do something here&amp;lt;br&amp;gt;    :else (throw (IllegalArgumentException. (when *current-env*&amp;lt;br&amp;gt;                                              (str (:line *current-env*) &amp;quot;:&amp;quot;))&amp;lt;br&amp;gt;                                            &amp;quot;Objects don't match&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cs-gen-object</a>[V X Y s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cs-gen-right-F&lt;/b&gt; ([V X Y S T])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cs-gen-right-F [V X Y S T]&amp;lt;br&amp;gt;  ;(prn &amp;quot;cs-gen* [Type F]&amp;quot; S T X)&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (contains? X (:name T))&amp;lt;br&amp;gt;    (promote-F V X Y S T)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (F? S)&amp;lt;br&amp;gt;         (contains? X (:name S)))&amp;lt;br&amp;gt;    (demote-F V X Y S T)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    :else (type-error S T)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cs-gen-right-F</a>[V X Y S T]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cset-combine&lt;/b&gt; ([l])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cset-combine [l]&amp;lt;br&amp;gt;  {:pre [(every? cset? l)]}&amp;lt;br&amp;gt;  (let [mapss (map :maps l)]&amp;lt;br&amp;gt;    (-&amp;gt;cset (apply concat mapss))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cset-combine</a>[l]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cset-entry?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord cset-entry [fixed dmap projections]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [((hash-c? symbol? c?) fixed)&amp;lt;br&amp;gt;   (dmap? dmap)&amp;lt;br&amp;gt;   ((set-c? (hvector-c? (some-fn Type? Projection?)&amp;lt;br&amp;gt;                        (some-fn Type? Projection?)))&amp;lt;br&amp;gt;     projections)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cset-entry?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cset-meet&lt;/b&gt; ([{maps1 :maps, :as x} {maps2 :maps, :as y}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cset-meet [{maps1 :maps :as x} {maps2 :maps :as y}]&amp;lt;br&amp;gt;  {:pre [(cset? x)&amp;lt;br&amp;gt;         (cset? y)]}&amp;lt;br&amp;gt;  (let [maps (doall (for [[{map1 :fixed dmap1 :dmap prj1 :projections} &amp;lt;br&amp;gt;                           {map2 :fixed dmap2 :dmap prj2 :projections}] (map vector maps1 maps2)]&amp;lt;br&amp;gt;                      (-&amp;gt;cset-entry (merge-with c-meet map1 map2)&amp;lt;br&amp;gt;                                    (dmap-meet dmap1 dmap2)&amp;lt;br&amp;gt;                                    (set/union prj1 prj2))))]&amp;lt;br&amp;gt;    (when (empty? maps)&amp;lt;br&amp;gt;      (throw (Exception. (str &amp;quot;No meet found for csets&amp;quot;))))&amp;lt;br&amp;gt;    (-&amp;gt;cset maps)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cset-meet</a>[{maps1 :maps, :as x} {maps2 :maps, :as y}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cset-meet*&lt;/b&gt; ([args])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cset-meet* [args]&amp;lt;br&amp;gt;  {:pre [(every? cset? args)]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  (reduce (fn [a c] (cset-meet a c))&amp;lt;br&amp;gt;          (-&amp;gt;cset [(-&amp;gt;cset-entry {} (-&amp;gt;dmap {}) #{})])&amp;lt;br&amp;gt;          args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cset-meet*</a>[args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;cset?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord cset [maps]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? cset-entry? maps)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cset?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ctor-Class-&gt;symbol&lt;/b&gt; ([cls])&lt;br&gt; Returns a symbol representing this constructor's Class, removing any compiler stubs.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ctor-Class-&amp;gt;symbol &amp;lt;br&amp;gt;  &amp;quot;Returns a symbol representing this constructor's Class, removing any compiler stubs.&amp;quot;&amp;lt;br&amp;gt;  [cls]&amp;lt;br&amp;gt;  (let [cls-stub (Class-&amp;gt;symbol cls)]&amp;lt;br&amp;gt;    (symbol (str/replace-first (str cls-stub) (str COMPILE-STUB-PREFIX &amp;quot;.&amp;quot;) &amp;quot;&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ctor-Class->symbol</a>[cls]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;dcon-dotted?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord dcon-dotted [fixed dc dbound]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? c? fixed)&amp;lt;br&amp;gt;   (c? dc)&amp;lt;br&amp;gt;   (F? dbound)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dcon-dotted?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;dcon-exact?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord dcon-exact [fixed rest]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? c? fixed)&amp;lt;br&amp;gt;   (c? rest)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dcon-exact?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;dcon-meet&lt;/b&gt; ([dc1 dc2])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dcon-meet [dc1 dc2]&amp;lt;br&amp;gt;  {:pre [(dcon-c? dc1)&amp;lt;br&amp;gt;         (dcon-c? dc2)]&amp;lt;br&amp;gt;   :post [(dcon-c? %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (and (dcon-exact? dc1)&amp;lt;br&amp;gt;         ((some-fn dcon? dcon-exact?) dc2))&amp;lt;br&amp;gt;    (let [{fixed1 :fixed rest1 :rest} dc1&amp;lt;br&amp;gt;          {fixed2 :fixed rest2 :rest} dc2]&amp;lt;br&amp;gt;      (when-not (and rest2 (= (count fixed1) (count fixed2)))&amp;lt;br&amp;gt;        (type-error fixed1 fixed2))&amp;lt;br&amp;gt;      (-&amp;gt;dcon-exact&amp;lt;br&amp;gt;        (doall&amp;lt;br&amp;gt;          (for [[c1 c2] (map vector fixed1 fixed2)]&amp;lt;br&amp;gt;            (c-meet c1 c2 (:X c1))))&amp;lt;br&amp;gt;        (c-meet rest1 rest2 (:X rest1))))&amp;lt;br&amp;gt;    ;; redo in the other order to call the first case&amp;lt;br&amp;gt;    (and (dcon? dc1)&amp;lt;br&amp;gt;         (dcon-exact? dc2))&amp;lt;br&amp;gt;    (dcon-meet dc2 dc1)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (dcon? dc1)&amp;lt;br&amp;gt;         (not (:rest dc1))&amp;lt;br&amp;gt;         (dcon? dc2)&amp;lt;br&amp;gt;         (not (:rest dc2)))&amp;lt;br&amp;gt;    (let [{fixed1 :fixed} dc1&amp;lt;br&amp;gt;          {fixed2 :fixed} dc2]&amp;lt;br&amp;gt;      (when-not (= (count fixed1) (count fixed2))&amp;lt;br&amp;gt;        (throw (Exception. (prn-str &amp;quot;Don't match: &amp;quot; fixed1 fixed2))))&amp;lt;br&amp;gt;      (-&amp;gt;dcon&amp;lt;br&amp;gt;        (doall&amp;lt;br&amp;gt;          (for [[c1 c2] (map vector fixed1 fixed2)]&amp;lt;br&amp;gt;            (c-meet c1 c2 (:X c1))))&amp;lt;br&amp;gt;        nil))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (dcon? dc1)&amp;lt;br&amp;gt;         (not (:rest dc1))&amp;lt;br&amp;gt;         (dcon? dc2))&amp;lt;br&amp;gt;    (let [{fixed1 :fixed} dc1&amp;lt;br&amp;gt;          {fixed2 :fixed rest :rest} dc2]&amp;lt;br&amp;gt;      (when-not (&amp;gt;= (count fixed1) (count fixed2))&amp;lt;br&amp;gt;        (throw (Exception. (prn-str &amp;quot;Don't match: &amp;quot; fixed1 fixed2))))&amp;lt;br&amp;gt;      (-&amp;gt;dcon&amp;lt;br&amp;gt;        (doall&amp;lt;br&amp;gt;          (for [[c1 c2] (map vector fixed1 (concat fixed2 (repeat rest)))]&amp;lt;br&amp;gt;            (c-meet c1 c2 (:X c1))))&amp;lt;br&amp;gt;        nil))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (dcon? dc1)&amp;lt;br&amp;gt;         (dcon? dc2)&amp;lt;br&amp;gt;         (not (:rest dc2)))&amp;lt;br&amp;gt;    (dcon-meet dc2 dc1)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (dcon? dc1)&amp;lt;br&amp;gt;         (dcon? dc2))&amp;lt;br&amp;gt;    (let [{fixed1 :fixed rest1 :rest} dc1&amp;lt;br&amp;gt;          {fixed2 :fixed rest2 :rest} dc2&amp;lt;br&amp;gt;          [shorter longer srest lrest]&amp;lt;br&amp;gt;          (if (&amp;lt; (count fixed1) (count fixed2))&amp;lt;br&amp;gt;            [fixed1 fixed2 rest1 rest2]&amp;lt;br&amp;gt;            [fixed2 fixed1 rest2 rest1])]&amp;lt;br&amp;gt;      (-&amp;gt;dcon&amp;lt;br&amp;gt;        (doall&amp;lt;br&amp;gt;          (for [[c1 c2] (map vector longer (concat shorter (repeat srest)))]&amp;lt;br&amp;gt;            (c-meet c1 c2 (:X c1))))&amp;lt;br&amp;gt;        (c-meet lrest srest (:X lrest))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (dcon-dotted? dc1)&amp;lt;br&amp;gt;         (dcon-dotted? dc2))&amp;lt;br&amp;gt;    (let [{fixed1 :fixed c1 :dc {bound1 :name} :dbound} dc1&amp;lt;br&amp;gt;          {fixed2 :fixed c2 :dc {bound2 :name} :dbound} dc2]&amp;lt;br&amp;gt;      (when-not (and (= (count fixed1) (count fixed2))&amp;lt;br&amp;gt;                     (= bound1 bound2))&amp;lt;br&amp;gt;        (throw (Exception. (prn-str &amp;quot;Don't match: &amp;quot; bound1 bound2))))&amp;lt;br&amp;gt;      (-&amp;gt;dcon-dotted (doall (for [[c1 c2] (map vector fixed1 fixed2)]&amp;lt;br&amp;gt;                              (c-meet c1 c2 (:X c1))))&amp;lt;br&amp;gt;                     (c-meet c1 c2 bound1) bound1))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (dcon? dc1)&amp;lt;br&amp;gt;         (dcon-dotted? dc2))&amp;lt;br&amp;gt;    (throw (Exception. (prn-str &amp;quot;Don't match: &amp;quot; dc1 dc2)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (dcon-dotted? dc1)&amp;lt;br&amp;gt;         (dcon? dc2))&amp;lt;br&amp;gt;    (throw (Exception. (prn-str &amp;quot;Don't match: &amp;quot; dc1 dc2)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    :else (throw (Exception. (prn-str &amp;quot;Got non-dcons: &amp;quot; dc1 dc2)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dcon-meet</a>[dc1 dc2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;dcon?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord dcon [fixed rest]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? c? fixed)&amp;lt;br&amp;gt;   (or (nil? rest)&amp;lt;br&amp;gt;       (c? rest))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dcon?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-AnyType&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn declare-AnyType [a]&amp;lt;br&amp;gt;  (derive a AnyType))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-AnyType</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-alias-kind&lt;/b&gt; ([sym ty])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Declare a kind for an alias, similar to declare but on the kind level.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro declare-alias-kind&amp;lt;br&amp;gt;  &amp;quot;Declare a kind for an alias, similar to declare but on the kind level.&amp;quot;&amp;lt;br&amp;gt;  [sym ty]&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;   (do (ensure-clojure)&amp;lt;br&amp;gt;     (let [sym# '~sym&amp;lt;br&amp;gt;           qsym# (if (namespace sym#)&amp;lt;br&amp;gt;                   sym#&amp;lt;br&amp;gt;                   (symbol (name (ns-name *ns*)) (name sym#)))&amp;lt;br&amp;gt;           ty# (parse-type '~ty)]&amp;lt;br&amp;gt;       (assert (not (namespace sym#)) (str &amp;quot;Cannot declare qualified name &amp;quot; sym#))&amp;lt;br&amp;gt;       (declare ~sym)&amp;lt;br&amp;gt;       (declare-names ~sym)&amp;lt;br&amp;gt;       (declare-alias-kind* qsym# ty#)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-alias-kind</a>[sym ty]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-alias-kind*&lt;/b&gt; ([sym ty])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn declare-alias-kind* [sym ty]&amp;lt;br&amp;gt;  (add-declared-kind sym ty))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-alias-kind*</a>[sym ty]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-datatype*&lt;/b&gt; ([sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn declare-datatype* [sym]&amp;lt;br&amp;gt;  (add-type-name sym datatype-name-type)&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-datatype*</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-datatypes&lt;/b&gt; ([&amp; syms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Declare datatypes, similar to declare but on the type level.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro declare-datatypes &amp;lt;br&amp;gt;  &amp;quot;Declare datatypes, similar to declare but on the type level.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; syms]&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;  (doseq [sym# '~syms]&amp;lt;br&amp;gt;    (assert (not (or (some #(= \. %) (str sym#))&amp;lt;br&amp;gt;                     (namespace sym#)))&amp;lt;br&amp;gt;            (str &amp;quot;Cannot declare qualified datatype: &amp;quot; sym#))&amp;lt;br&amp;gt;    (let [qsym# (symbol (str (munge (name (ns-name *ns*))) \. (name sym#)))]&amp;lt;br&amp;gt;      (declare-datatype* qsym#)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-datatypes</a>[& syms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-filter&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn declare-filter [c]&amp;lt;br&amp;gt;  (derive c Filter))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-filter</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-name*&lt;/b&gt; ([sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn declare-name* [sym]&amp;lt;br&amp;gt;  {:pre [(symbol? sym)&amp;lt;br&amp;gt;         (namespace sym)]}&amp;lt;br&amp;gt;  (add-type-name sym declared-name-type)&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-name*</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-names&lt;/b&gt; ([&amp; syms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Declare names, similar to declare but on the type level.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro declare-names &amp;lt;br&amp;gt;  &amp;quot;Declare names, similar to declare but on the type level.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; syms]&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;  (doseq [sym# '~syms]&amp;lt;br&amp;gt;     (let [qsym# (if (namespace sym#)&amp;lt;br&amp;gt;                   sym#&amp;lt;br&amp;gt;                   (symbol (name (ns-name *ns*)) (name sym#)))]&amp;lt;br&amp;gt;       (declare-name* qsym#)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-names</a>[& syms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-path-elem&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn declare-path-elem [c]&amp;lt;br&amp;gt;  (derive c PathElem))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-path-elem</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-protocol*&lt;/b&gt; ([sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn declare-protocol* [sym]&amp;lt;br&amp;gt;  {:pre [(symbol? sym)&amp;lt;br&amp;gt;         (some #(= \. %) (str sym))]}&amp;lt;br&amp;gt;  (add-type-name sym protocol-name-type)&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-protocol*</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-protocols&lt;/b&gt; ([&amp; syms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Declare protocols, similar to declare but on the type level.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro declare-protocols &amp;lt;br&amp;gt;  &amp;quot;Declare protocols, similar to declare but on the type level.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; syms]&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;  (doseq [sym# '~syms]&amp;lt;br&amp;gt;     (let [qsym# (if (namespace sym#)&amp;lt;br&amp;gt;                   sym#&amp;lt;br&amp;gt;                   (symbol (str (name (ns-name *ns*))) (name sym#)))]&amp;lt;br&amp;gt;       (declare-protocol* qsym#)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-protocols</a>[& syms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-robject&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn declare-robject [c]&amp;lt;br&amp;gt;  (derive c RObject))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-robject</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;declare-type&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn declare-type [a]&amp;lt;br&amp;gt;  (derive a Type))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">declare-type</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;def-alias&lt;/b&gt; ([sym type])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a type alias&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro def-alias &amp;lt;br&amp;gt;  &amp;quot;Define a type alias&amp;quot;&amp;lt;br&amp;gt;  [sym type]&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;  (do (ensure-clojure)&amp;lt;br&amp;gt;    (let [sym# (if (namespace '~sym)&amp;lt;br&amp;gt;                 '~sym&amp;lt;br&amp;gt;                 (symbol (name (ns-name *ns*)) (name '~sym)))&amp;lt;br&amp;gt;          ty# (parse-type '~type)]&amp;lt;br&amp;gt;      (add-type-name sym# ty#)&amp;lt;br&amp;gt;      (declare ~sym)&amp;lt;br&amp;gt;      (when-let [tfn# (@DECLARED-KIND-ENV sym#)]&amp;lt;br&amp;gt;        (assert (subtype? ty# tfn#) (error-msg &amp;quot;Declared kind &amp;quot; (unparse-type tfn#)&amp;lt;br&amp;gt;                                               &amp;quot; does not match actual kind &amp;quot; (unparse-type ty#))))&amp;lt;br&amp;gt;      [sym# (unparse-type ty#)]))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">def-alias</a>[sym type]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;defprotocol&gt;&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defprotocol&amp;gt; [&amp;amp; body]&amp;lt;br&amp;gt;  &amp;quot;Define a typed protocol&amp;quot;&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;     (defprotocol ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defprotocol></a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;demote-F&lt;/b&gt; ([V X Y {:keys [name bnds], :as S} T])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn demote-F [V X Y {:keys [name bnds] :as S} T]&amp;lt;br&amp;gt;  {:pre [(F? S)]}&amp;lt;br&amp;gt;  ;constrain T to be below S (but don't mention V)&amp;lt;br&amp;gt;  (assert (contains? X name) (str X name))&amp;lt;br&amp;gt;  (when (and (F? T)&amp;lt;br&amp;gt;             (bound-index? (:name T))&amp;lt;br&amp;gt;             (not (free-in-scope (:name T))))&amp;lt;br&amp;gt;    (type-error S T))&amp;lt;br&amp;gt;  (let [dt (demote-var T V)]&amp;lt;br&amp;gt;    (-&amp;gt; (empty-cset X Y)&amp;lt;br&amp;gt;      (insert-constraint name (Bottom) dt (X name)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">demote-F</a>[V X Y {:keys [name bnds], :as S} T]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;demote-var&lt;/b&gt; ([T V])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn demote-var [T V]&amp;lt;br&amp;gt;  {:pre [(AnyType? T)&amp;lt;br&amp;gt;         (set? V)&amp;lt;br&amp;gt;         (every? symbol? V)]&amp;lt;br&amp;gt;   :post [(Type? %)]}&amp;lt;br&amp;gt;  (demote T V))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">demote-var</a>[T V]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;dmap-meet&lt;/b&gt; ([dm1 dm2])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dmap-meet [dm1 dm2]&amp;lt;br&amp;gt;  {:pre [(dmap? dm1)&amp;lt;br&amp;gt;         (dmap? dm2)]&amp;lt;br&amp;gt;   :post [(dmap? %)]}&amp;lt;br&amp;gt;  (-&amp;gt;dmap (merge-with dcon-meet (:map dm1) (:map dm2))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dmap-meet</a>[dm1 dm2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;dmap?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord dmap [map]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [((hash-c? symbol? dcon-c?) map)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dmap?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;doseq&gt;&lt;/b&gt; ([seq-exprs &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Like doseq but requires annotation for each loop variable: &lt;br&gt;  [a [1 2]] becomes [[a :- Long] [1 2]]&lt;br&gt;  &lt;br&gt;  eg.&lt;br&gt;  (doseq&gt; [[a :- (U nil AnyInteger)] [1 nil 2 3]&lt;br&gt;           :when a]&lt;br&gt;     (inc a))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro doseq&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;Like doseq but requires annotation for each loop variable: &amp;lt;br&amp;gt;  [a [1 2]] becomes [[a :- Long] [1 2]]&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  eg.&amp;lt;br&amp;gt;  (doseq&amp;gt; [[a :- (U nil AnyInteger)] [1 nil 2 3]&amp;lt;br&amp;gt;           :when a]&amp;lt;br&amp;gt;     (inc a))&amp;quot;&amp;lt;br&amp;gt;  [seq-exprs &amp;amp; body]&amp;lt;br&amp;gt;  (@#'clojure.core/assert-args&amp;lt;br&amp;gt;     (vector? seq-exprs) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;     (even? (count seq-exprs)) &amp;quot;an even number of forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;  (let [step (fn step [recform exprs]&amp;lt;br&amp;gt;               (if-not exprs&amp;lt;br&amp;gt;                 [true `(do ~@body)]&amp;lt;br&amp;gt;                 (let [k (first exprs)&amp;lt;br&amp;gt;                       v (second exprs)]&amp;lt;br&amp;gt;                   (if (keyword? k)&amp;lt;br&amp;gt;                     (let [steppair (step recform (nnext exprs))&amp;lt;br&amp;gt;                           needrec (steppair 0)&amp;lt;br&amp;gt;                           subform (steppair 1)]&amp;lt;br&amp;gt;                       (cond&amp;lt;br&amp;gt;                         (= k :let) [needrec `(let ~v ~subform)]&amp;lt;br&amp;gt;                         (= k :while) [false `(when ~v&amp;lt;br&amp;gt;                                                ~subform&amp;lt;br&amp;gt;                                                ~@(when needrec [recform]))]&amp;lt;br&amp;gt;                         (= k :when) [false `(if ~v&amp;lt;br&amp;gt;                                               (do&amp;lt;br&amp;gt;                                                 ~subform&amp;lt;br&amp;gt;                                                 ~@(when needrec [recform]))&amp;lt;br&amp;gt;                                               ~recform)]))&amp;lt;br&amp;gt;                     ;; k is [k :- k-ann]&amp;lt;br&amp;gt;                     (let [_ (assert (and (vector? k)&amp;lt;br&amp;gt;                                          (#{3} (count k))&amp;lt;br&amp;gt;                                          (#{:-} (second k))) &amp;lt;br&amp;gt;                                     &amp;quot;Binder must be of the form [lhs :- type]&amp;quot;)&amp;lt;br&amp;gt;                           k-ann (nth k 2)&amp;lt;br&amp;gt;                           k (nth k 0)&amp;lt;br&amp;gt;                           ; k is the lhs binding&amp;lt;br&amp;gt;                           seq- (gensym &amp;quot;seq_&amp;quot;)&amp;lt;br&amp;gt;                           chunk- (with-meta (gensym &amp;quot;chunk_&amp;quot;)&amp;lt;br&amp;gt;                                             {:tag 'clojure.lang.IChunk})&amp;lt;br&amp;gt;                           count- (gensym &amp;quot;count_&amp;quot;)&amp;lt;br&amp;gt;                           i- (gensym &amp;quot;i_&amp;quot;)&amp;lt;br&amp;gt;                           recform `(recur (next ~seq-) nil 0 0)&amp;lt;br&amp;gt;                           steppair (step recform (nnext exprs))&amp;lt;br&amp;gt;                           needrec (steppair 0)&amp;lt;br&amp;gt;                           subform (steppair 1)&amp;lt;br&amp;gt;                           recform-chunk &amp;lt;br&amp;gt;                             `(recur ~seq- ~chunk- ~count- (unchecked-inc ~i-))&amp;lt;br&amp;gt;                           steppair-chunk (step recform-chunk (nnext exprs))&amp;lt;br&amp;gt;                           subform-chunk (steppair-chunk 1)]&amp;lt;br&amp;gt;                       [true&amp;lt;br&amp;gt;                        `(loop&amp;gt; [[~seq- :- (~'U nil (~'clojure.lang.Seqable ~k-ann))] (seq ~v), &amp;lt;br&amp;gt;                                 [~chunk- :- (~'U nil (~'clojure.lang.IChunk ~k-ann))] nil&amp;lt;br&amp;gt;                                 [~count- :- ~'(U Integer Long)] 0,&amp;lt;br&amp;gt;                                 [~i- :- ~'(U Integer Long)] 0]&amp;lt;br&amp;gt;                           (if (and (&amp;lt; ~i- ~count-)&amp;lt;br&amp;gt;                                    ;; core.typed thinks chunk- could be nil here&amp;lt;br&amp;gt;                                    ~chunk-)&amp;lt;br&amp;gt;                             (let [;~k (.nth ~chunk- ~i-)&amp;lt;br&amp;gt;                                   ~k (nth ~chunk- ~i-)]&amp;lt;br&amp;gt;                               ~subform-chunk&amp;lt;br&amp;gt;                               ~@(when needrec [recform-chunk]))&amp;lt;br&amp;gt;                             (when-let [~seq- (seq ~seq-)]&amp;lt;br&amp;gt;                               (if (chunked-seq? ~seq-)&amp;lt;br&amp;gt;                                 (let [c# (chunk-first ~seq-)]&amp;lt;br&amp;gt;                                   (recur (chunk-rest ~seq-) c#&amp;lt;br&amp;gt;                                          (int (count c#)) (int 0)))&amp;lt;br&amp;gt;                                 (let [~k (first ~seq-)]&amp;lt;br&amp;gt;                                   ~subform&amp;lt;br&amp;gt;                                   ~@(when needrec [recform]))))))])))))]&amp;lt;br&amp;gt;    (nth (step nil (seq seq-exprs)) 1)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">doseq></a>[seq-exprs & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;dotimes&gt;&lt;/b&gt; ([bindings &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Like dotimes.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro dotimes&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;Like dotimes.&amp;quot;&amp;lt;br&amp;gt;  [bindings &amp;amp; body]&amp;lt;br&amp;gt;  (@#'clojure.core/assert-args&amp;lt;br&amp;gt;     (vector? bindings) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;     (= 2 (count bindings)) &amp;quot;exactly 2 forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;  (let [i (first bindings)&amp;lt;br&amp;gt;        n (second bindings)]&amp;lt;br&amp;gt;    `(let [n# (long ~n)]&amp;lt;br&amp;gt;       (loop&amp;gt; [[~i :- (~'U Long Integer)] 0]&amp;lt;br&amp;gt;         (when (&amp;lt; ~i n#)&amp;lt;br&amp;gt;           ~@body&amp;lt;br&amp;gt;           (recur (unchecked-inc ~i)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dotimes></a>[bindings & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;empty-cset&lt;/b&gt; ([X Y])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn empty-cset [X Y]&amp;lt;br&amp;gt;  {:pre [(every? (hash-c? symbol? Bounds?) [X Y])]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  (-&amp;gt;cset [(-&amp;gt;cset-entry (into {} (for [[x bnds] X] [x (no-constraint x bnds)]))&amp;lt;br&amp;gt;                         (-&amp;gt;dmap {})&amp;lt;br&amp;gt;                         #{})]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">empty-cset</a>[X Y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;empty-cset-projection&lt;/b&gt; ([X Y proj])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn empty-cset-projection [X Y proj]&amp;lt;br&amp;gt;  {:pre [(every? (hash-c? symbol? Bounds?) [X Y])]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  (-&amp;gt;cset [(-&amp;gt;cset-entry (into {} (for [[x bnds] X] [x (no-constraint x bnds)]))&amp;lt;br&amp;gt;                         (-&amp;gt;dmap {})&amp;lt;br&amp;gt;                         #{proj})]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">empty-cset-projection</a>[X Y proj]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ensure-clojure&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ensure-clojure []&amp;lt;br&amp;gt;  (reset! TYPED-IMPL ::clojure))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ensure-clojure</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ensure-clojurescript&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ensure-clojurescript []&amp;lt;br&amp;gt;  (reset! TYPED-IMPL ::clojurescript))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ensure-clojurescript</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;env+&lt;/b&gt; ([env fs flag])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn env+ [env fs flag]&amp;lt;br&amp;gt;  {:pre [(PropEnv? env)&amp;lt;br&amp;gt;         (every? Filter? fs)&amp;lt;br&amp;gt;         (boolean? @flag)]&amp;lt;br&amp;gt;   :post [(PropEnv? %)&amp;lt;br&amp;gt;          (boolean? @flag)]}&amp;lt;br&amp;gt;  #_(prn 'env+ fs)&amp;lt;br&amp;gt;  (let [[props atoms] (combine-props fs (:props env) flag)]&amp;lt;br&amp;gt;    (reduce (fn [env f]&amp;lt;br&amp;gt;              {:pre [(PropEnv? env)&amp;lt;br&amp;gt;                     (Filter? f)]}&amp;lt;br&amp;gt;              (let [new-env (update-in env [:l] update-composite f)]&amp;lt;br&amp;gt;                ; update flag if a variable is now bottom&amp;lt;br&amp;gt;                (when-let [bs (seq (filter (comp #{(Un)} val) (:l new-env)))]&amp;lt;br&amp;gt;                  ;(prn &amp;quot;variables are now bottom: &amp;quot; (map key bs))&amp;lt;br&amp;gt;                  (reset! flag false))&amp;lt;br&amp;gt;                new-env))&amp;lt;br&amp;gt;            (assoc env :props (set (concat atoms props)))&amp;lt;br&amp;gt;            (concat atoms props))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">env+</a>[env fs flag]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;error-msg&lt;/b&gt; ([&amp; msg])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String error-msg &amp;lt;br&amp;gt;  [&amp;amp; msg]&amp;lt;br&amp;gt;  (apply str (when *current-env*&amp;lt;br&amp;gt;               (str (:line *current-env*) &amp;quot;: &amp;quot;))&amp;lt;br&amp;gt;         (concat msg)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">error-msg</a>[& msg]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;expected-dispatch-type&lt;/b&gt; ([mm-type])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn expected-dispatch-type [mm-type]&amp;lt;br&amp;gt;  {:pre [(AnyType? mm-type)]&amp;lt;br&amp;gt;   :post [(AnyType? %)]}&amp;lt;br&amp;gt;  (fold-rhs ::expected-dispatch-type&amp;lt;br&amp;gt;            {:type-rec expected-dispatch-type}&amp;lt;br&amp;gt;            mm-type))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">expected-dispatch-type</a>[mm-type]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;fi&lt;/b&gt; ([t])&lt;br&gt; All index variables in type (dotted bounds, etc.)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fi&amp;lt;br&amp;gt;  &amp;quot;All index variables in type (dotted bounds, etc.)&amp;quot;&amp;lt;br&amp;gt;  [t]&amp;lt;br&amp;gt;  {:post [((set-c? symbol?) %)]}&amp;lt;br&amp;gt;  (set (keys (idx-variances t))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fi</a>[t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;find-val-type&lt;/b&gt; ([t k default])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-val-type [t k default]&amp;lt;br&amp;gt;  {:pre [(Type? t)&amp;lt;br&amp;gt;         (Type? k)&amp;lt;br&amp;gt;         ((some-fn nil? Type?) default)]&amp;lt;br&amp;gt;   :post [(Type? %)]}&amp;lt;br&amp;gt;  (let [t (-resolve t)]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (Nil? t) (or default -nil)&amp;lt;br&amp;gt;      (HeterogeneousMap? t) (if-let [v (get (:types t) k)]&amp;lt;br&amp;gt;                              v&amp;lt;br&amp;gt;                              (do #_(prn (error-msg &amp;quot;WARNING: Map type &amp;quot; (unparse-type t)&amp;lt;br&amp;gt;                                                  &amp;quot; does not have entry &amp;quot;&amp;lt;br&amp;gt;                                                  (unparse-type k)))&amp;lt;br&amp;gt;                                ; hmaps don't record absense of keys, so we don't actually know anything here.&amp;lt;br&amp;gt;                                #_(or default -nil)&amp;lt;br&amp;gt;                                -any))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (Record? t) (find-val-type (Record-&amp;gt;HMap t) k default)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (Intersection? t) (apply In &amp;lt;br&amp;gt;                               (for [t* (:types t)]&amp;lt;br&amp;gt;                                 (find-val-type t* k default)))&amp;lt;br&amp;gt;      (Union? t) (apply Un&amp;lt;br&amp;gt;                        (for [t* (:types t)]&amp;lt;br&amp;gt;                          (find-val-type t* k default)))&amp;lt;br&amp;gt;      (RClass? t)&amp;lt;br&amp;gt;      (-&amp;gt;&amp;lt;br&amp;gt;        (check-funapp nil nil (ret (parse-type '(All [x y] [(clojure.lang.IPersistentMap Any x) y -&amp;gt; (U x y)])))&amp;lt;br&amp;gt;                      [(ret t) (ret (or default -nil))] nil)&amp;lt;br&amp;gt;        ret-t)&amp;lt;br&amp;gt;      :else -any)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-val-type</a>[t k default]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;flatten-props&lt;/b&gt; ([ps])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn flatten-props [ps]&amp;lt;br&amp;gt;  {:post [(every? Filter? %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (empty? ps) []&amp;lt;br&amp;gt;    (AndFilter? (first ps)) (flatten-props (concat (-&amp;gt; ps first :fs) (next ps)))&amp;lt;br&amp;gt;    :else (cons (first ps) (flatten-props (next ps)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">flatten-props</a>[ps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;flip-variances&lt;/b&gt; ([vs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn flip-variances [vs]&amp;lt;br&amp;gt;  {:pre [(variance-map? vs)]}&amp;lt;br&amp;gt;  (into {} (for [[k vari] vs]&amp;lt;br&amp;gt;             [k (case vari&amp;lt;br&amp;gt;                  :covariant :contravariant&amp;lt;br&amp;gt;                  :contravariant :covariant&amp;lt;br&amp;gt;                  vari)])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">flip-variances</a>[vs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;flow-for-value&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn flow-for-value []&amp;lt;br&amp;gt;  (let [props (.props ^PropEnv *lexical-env*)&amp;lt;br&amp;gt;        flow (-flow (apply -and -top props))]&amp;lt;br&amp;gt;    flow))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">flow-for-value</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;flow-normal&lt;/b&gt; ([f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn flow-normal [f]&amp;lt;br&amp;gt;  {:pre [(FlowSet? f)]&amp;lt;br&amp;gt;   :post [(Filter? %)]}&amp;lt;br&amp;gt;  (:normal f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">flow-normal</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;fn&gt;&lt;/b&gt; ([&amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a typed anonymous function.&lt;br&gt;  (fn&gt; name? :- type? [[param :- type]* &amp; [param :- type *]?] exprs*)&lt;br&gt;  (fn&gt; name? (:- type? [[param :- type]* &amp; [param :- type *]?] exprs*)+)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro fn&amp;gt; &amp;lt;br&amp;gt;  &amp;quot;Define a typed anonymous function.&amp;lt;br&amp;gt;  (fn&amp;gt; name? :- type? [[param :- type]* &amp;amp; [param :- type *]?] exprs*)&amp;lt;br&amp;gt;  (fn&amp;gt; name? (:- type? [[param :- type]* &amp;amp; [param :- type *]?] exprs*)+)&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; forms]&amp;lt;br&amp;gt;  (let [{:keys [fn parsed-methods]} (parse-fn&amp;gt; false forms)]&amp;lt;br&amp;gt;    `(fn&amp;gt;-ann ~fn '~parsed-methods)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fn></a>[& forms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;fn&gt;-ann&lt;/b&gt; ([fn-of param-types-syn])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fn&amp;gt;-ann [fn-of param-types-syn]&amp;lt;br&amp;gt;  fn-of)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fn>-ann</a>[fn-of param-types-syn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;for&gt;&lt;/b&gt; ([tk ret-ann seq-exprs body-expr])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Like for but requires annotation for each loop variable: &lt;br&gt;  [a [1 2]] becomes [[a :- Long] [1 2]]&lt;br&gt;  Also requires annotation for return type.&lt;br&gt;  &lt;br&gt;  eg.&lt;br&gt;  (for&gt; :- Number&lt;br&gt;        [[a :- (U nil AnyInteger)] [1 nil 2 3]&lt;br&gt;         :when a]&lt;br&gt;     (inc a))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro for&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;Like for but requires annotation for each loop variable: &amp;lt;br&amp;gt;  [a [1 2]] becomes [[a :- Long] [1 2]]&amp;lt;br&amp;gt;  Also requires annotation for return type.&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  eg.&amp;lt;br&amp;gt;  (for&amp;gt; :- Number&amp;lt;br&amp;gt;        [[a :- (U nil AnyInteger)] [1 nil 2 3]&amp;lt;br&amp;gt;         :when a]&amp;lt;br&amp;gt;     (inc a))&amp;quot;&amp;lt;br&amp;gt;  [tk ret-ann seq-exprs body-expr]&amp;lt;br&amp;gt;  (@#'clojure.core/assert-args&amp;lt;br&amp;gt;     (vector? seq-exprs) &amp;quot;a vector for its binding&amp;quot;&amp;lt;br&amp;gt;     (even? (count seq-exprs)) &amp;quot;an even number of forms in binding vector&amp;quot;)&amp;lt;br&amp;gt;  (assert (#{:-} tk))&amp;lt;br&amp;gt;  (let [to-groups (fn [seq-exprs]&amp;lt;br&amp;gt;                    (@#'clojure.core/reduce1 (fn [groups [k v]]&amp;lt;br&amp;gt;                              (if (keyword? k)&amp;lt;br&amp;gt;                                (conj (pop groups) (conj (peek groups) [k v]))&amp;lt;br&amp;gt;                                (conj groups [k v])))&amp;lt;br&amp;gt;                            [] (partition 2 seq-exprs)))&amp;lt;br&amp;gt;        err (fn [&amp;amp; msg] (throw (IllegalArgumentException. ^String (apply str msg))))&amp;lt;br&amp;gt;        emit-bind (fn emit-bind [[[bind expr &amp;amp; mod-pairs]&amp;lt;br&amp;gt;                                  &amp;amp; [[_ next-expr] :as next-groups]]]&amp;lt;br&amp;gt;                    (let [_ (assert (and (vector? bind)&amp;lt;br&amp;gt;                                         (#{3} (count bind))&amp;lt;br&amp;gt;                                         (#{:-} (second bind))) &amp;lt;br&amp;gt;                                    &amp;quot;Binder must be of the form [lhs :- type]&amp;quot;)&amp;lt;br&amp;gt;                          bind-ann (nth bind 2)&amp;lt;br&amp;gt;                          bind (nth bind 0)&amp;lt;br&amp;gt;                          giter (gensym &amp;quot;iter__&amp;quot;)&amp;lt;br&amp;gt;                          gxs (gensym &amp;quot;s__&amp;quot;)&amp;lt;br&amp;gt;                          do-mod (fn do-mod [[[k v :as pair] &amp;amp; etc]]&amp;lt;br&amp;gt;                                   (cond&amp;lt;br&amp;gt;                                     (= k :let) `(let ~v ~(do-mod etc))&amp;lt;br&amp;gt;                                     (= k :while) `(when ~v ~(do-mod etc))&amp;lt;br&amp;gt;                                     (= k :when) `(if ~v&amp;lt;br&amp;gt;                                                    ~(do-mod etc)&amp;lt;br&amp;gt;                                                    (recur (rest ~gxs)))&amp;lt;br&amp;gt;                                     (keyword? k) (err &amp;quot;Invalid 'for' keyword &amp;quot; k)&amp;lt;br&amp;gt;                                     next-groups&amp;lt;br&amp;gt;                                      `(let [iterys# ~(emit-bind next-groups)&amp;lt;br&amp;gt;                                             fs# (seq (iterys# ~next-expr))]&amp;lt;br&amp;gt;                                         (if fs#&amp;lt;br&amp;gt;                                           (concat fs# (~giter (rest ~gxs)))&amp;lt;br&amp;gt;                                           (recur (rest ~gxs))))&amp;lt;br&amp;gt;                                     :else `(cons ~body-expr&amp;lt;br&amp;gt;                                                  (~giter (rest ~gxs)))))]&amp;lt;br&amp;gt;                      (if next-groups&amp;lt;br&amp;gt;                        #_&amp;quot;not the inner-most loop&amp;quot;&amp;lt;br&amp;gt;                        `(ann-form&amp;lt;br&amp;gt;                           (fn ~giter [~gxs]&amp;lt;br&amp;gt;                             (lazy-seq&amp;lt;br&amp;gt;                               (loop&amp;gt; [[~gxs :- (~'clojure.core.typed/Option (~'clojure.lang.Seqable ~bind-ann))] ~gxs]&amp;lt;br&amp;gt;                                 (when-first [~bind ~gxs]&amp;lt;br&amp;gt;                                   ~(do-mod mod-pairs)))))&amp;lt;br&amp;gt;                           [(~'clojure.core.typed/Option (~'clojure.lang.Seqable ~bind-ann)) ~'-&amp;gt; (~'clojure.lang.LazySeq ~ret-ann)])&amp;lt;br&amp;gt;                        #_&amp;quot;inner-most loop&amp;quot;&amp;lt;br&amp;gt;                        (let [gi (gensym &amp;quot;i__&amp;quot;)&amp;lt;br&amp;gt;                              gb (gensym &amp;quot;b__&amp;quot;)&amp;lt;br&amp;gt;                              do-cmod (fn do-cmod [[[k v :as pair] &amp;amp; etc]]&amp;lt;br&amp;gt;                                        (cond&amp;lt;br&amp;gt;                                          (= k :let) `(let ~v ~(do-cmod etc))&amp;lt;br&amp;gt;                                          (= k :while) `(when ~v ~(do-cmod etc))&amp;lt;br&amp;gt;                                          (= k :when) `(if ~v&amp;lt;br&amp;gt;                                                         ~(do-cmod etc)&amp;lt;br&amp;gt;                                                         (recur&amp;lt;br&amp;gt;                                                           (unchecked-inc ~gi)))&amp;lt;br&amp;gt;                                          (keyword? k)&amp;lt;br&amp;gt;                                            (err &amp;quot;Invalid 'for' keyword &amp;quot; k)&amp;lt;br&amp;gt;                                          :else&amp;lt;br&amp;gt;                                            `(do (chunk-append ~gb ~body-expr)&amp;lt;br&amp;gt;                                                 (recur (unchecked-inc ~gi)))))]&amp;lt;br&amp;gt;                          `(ann-form&amp;lt;br&amp;gt;                             (fn ~giter [~gxs]&amp;lt;br&amp;gt;                               (lazy-seq&amp;lt;br&amp;gt;                                 (loop&amp;gt; [[~gxs :- (~'clojure.core.typed/Option (~'clojure.lang.Seqable ~bind-ann))] ~gxs]&amp;lt;br&amp;gt;                                        (when-let [~gxs (seq ~gxs)]&amp;lt;br&amp;gt;                                          (if (chunked-seq? ~gxs)&amp;lt;br&amp;gt;                                            (let [c# (chunk-first ~gxs)&amp;lt;br&amp;gt;                                                  size# (int (count c#))&amp;lt;br&amp;gt;                                                  ~gb (ann-form (chunk-buffer size#)&amp;lt;br&amp;gt;                                                                (~'clojure.lang.ChunkBuffer Number))]&amp;lt;br&amp;gt;                                              (if (loop&amp;gt; [[~gi :- (~'U ~'Long ~'Integer)] (int 0)]&amp;lt;br&amp;gt;                                                         (if (&amp;lt; ~gi size#)&amp;lt;br&amp;gt;                                                           (let [;~bind (.nth c# ~gi)]&amp;lt;br&amp;gt;                                                                 ~bind (nth c# ~gi)]&amp;lt;br&amp;gt;                                                             ~(do-cmod mod-pairs))&amp;lt;br&amp;gt;                                                           true))&amp;lt;br&amp;gt;                                                (chunk-cons&amp;lt;br&amp;gt;                                                  (chunk ~gb)&amp;lt;br&amp;gt;                                                  (~giter (chunk-rest ~gxs)))&amp;lt;br&amp;gt;                                                (chunk-cons (chunk ~gb) nil)))&amp;lt;br&amp;gt;                                            (let [~bind (first ~gxs)]&amp;lt;br&amp;gt;                                              ~(do-mod mod-pairs)))))))&amp;lt;br&amp;gt;                             [(~'clojure.core.typed/Option (~'clojure.lang.Seqable ~bind-ann)) ~'-&amp;gt;&amp;lt;br&amp;gt;                              (~'clojure.lang.LazySeq ~ret-ann)])))))]&amp;lt;br&amp;gt;    `(let [iter# ~(emit-bind (to-groups seq-exprs))]&amp;lt;br&amp;gt;        (iter# ~(second seq-exprs)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">for></a>[tk ret-ann seq-exprs body-expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;free-in-scope&lt;/b&gt; ([name])&lt;br&gt; Find the free scoped as name&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn free-in-scope &amp;lt;br&amp;gt;  &amp;quot;Find the free scoped as name&amp;quot;&amp;lt;br&amp;gt;  [name]&amp;lt;br&amp;gt;  {:pre [(symbol? name)]&amp;lt;br&amp;gt;   :post [((some-fn nil? F?) %)]}&amp;lt;br&amp;gt;  (:F (*free-scope* name)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">free-in-scope</a>[name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;free-in-scope-bnds&lt;/b&gt; ([name])&lt;br&gt; Find the bounds for the free scoped as name&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn free-in-scope-bnds &amp;lt;br&amp;gt;  &amp;quot;Find the bounds for the free scoped as name&amp;quot;&amp;lt;br&amp;gt;  ^Bounds&amp;lt;br&amp;gt;  [name]&amp;lt;br&amp;gt;  {:pre [(symbol? name)]&amp;lt;br&amp;gt;   :post [((some-fn nil? Bounds?) %)]}&amp;lt;br&amp;gt;  (:bnds (*free-scope* name)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">free-in-scope-bnds</a>[name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;free-with-name&lt;/b&gt; ([name])&lt;br&gt; Find the free with the actual name name, as opposed to&lt;br&gt;  the alias used for scoping&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn free-with-name &amp;lt;br&amp;gt;  &amp;quot;Find the free with the actual name name, as opposed to&amp;lt;br&amp;gt;  the alias used for scoping&amp;quot;&amp;lt;br&amp;gt;  [name]&amp;lt;br&amp;gt;  {:pre [(symbol? name)]&amp;lt;br&amp;gt;   :post [((some-fn nil? F?) %)]}&amp;lt;br&amp;gt;  (some (fn [[_ {{fname :name :as f} :F}]]&amp;lt;br&amp;gt;          (when (= name fname)&amp;lt;br&amp;gt;            f))&amp;lt;br&amp;gt;        *free-scope*))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">free-with-name</a>[name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;free-with-name-bnds&lt;/b&gt; ([name])&lt;br&gt; Find the bounds for the free with the actual name name, as opposed to&lt;br&gt;  the alias used for scoping&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^Bounds&amp;lt;br&amp;gt;  free-with-name-bnds &amp;lt;br&amp;gt;  &amp;quot;Find the bounds for the free with the actual name name, as opposed to&amp;lt;br&amp;gt;  the alias used for scoping&amp;quot;&amp;lt;br&amp;gt;  [name]&amp;lt;br&amp;gt;  {:pre [(symbol? name)]&amp;lt;br&amp;gt;   :post [((some-fn nil? Bounds?) %)]}&amp;lt;br&amp;gt;  (some (fn [[_ {{fname :name} :F :keys [bnds]}]]&amp;lt;br&amp;gt;          (when (= name fname)&amp;lt;br&amp;gt;            bnds))&amp;lt;br&amp;gt;        *free-scope*))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">free-with-name-bnds</a>[name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;frees-in&lt;/b&gt; ([t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn frees-in [t]&amp;lt;br&amp;gt;  {:post [(variance-map? %)]}&amp;lt;br&amp;gt;  (frees t))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">frees-in</a>[t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;fully-resolve-type&lt;/b&gt; ([t seen] [t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fully-resolve-type &amp;lt;br&amp;gt;  ([t seen]&amp;lt;br&amp;gt;   (let [_ (assert (not (seen t)) &amp;quot;Infinite non-Rec type detected&amp;quot;)&amp;lt;br&amp;gt;         seen (conj seen t)]&amp;lt;br&amp;gt;     (if (requires-resolving? t)&amp;lt;br&amp;gt;       (fully-resolve-type (-resolve t) seen)&amp;lt;br&amp;gt;       t)))&amp;lt;br&amp;gt;  ([t] (fully-resolve-type t #{})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fully-resolve-type</a>[t seen] [t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;fv&lt;/b&gt; ([t])&lt;br&gt; All frees in type&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fv &amp;lt;br&amp;gt;  &amp;quot;All frees in type&amp;quot;&amp;lt;br&amp;gt;  [t]&amp;lt;br&amp;gt;  {:post [((set-c? symbol?) %)]}&amp;lt;br&amp;gt;  (set (keys (fv-variances t))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fv</a>[t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;fv-variances&lt;/b&gt; ([t])&lt;br&gt; Map of frees to their variances&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fv-variances &amp;lt;br&amp;gt;  &amp;quot;Map of frees to their variances&amp;quot;&amp;lt;br&amp;gt;  [t]&amp;lt;br&amp;gt;  {:post [(variance-map? %)]}&amp;lt;br&amp;gt;  (binding [*frees-mode* ::frees]&amp;lt;br&amp;gt;    (frees-in t)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fv-variances</a>[t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;gen-datatype*&lt;/b&gt; ([provided-name fields variances args ancests record?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn gen-datatype* [provided-name fields variances args ancests record?]&amp;lt;br&amp;gt;  (let [ctor (if record?&amp;lt;br&amp;gt;               `-&amp;gt;Record&amp;lt;br&amp;gt;               `-&amp;gt;DataType)]&amp;lt;br&amp;gt;  `(do (ensure-clojure)&amp;lt;br&amp;gt;  (let [provided-name-str# (str '~provided-name)&amp;lt;br&amp;gt;         ;_# (prn &amp;quot;provided-name-str&amp;quot; provided-name-str#)&amp;lt;br&amp;gt;         munged-ns-str# (if (some #(= \. %) provided-name-str#)&amp;lt;br&amp;gt;                          (apply str (butlast (apply concat (butlast (partition-by #(= \. %) provided-name-str#)))))&amp;lt;br&amp;gt;                          (str (munge (-&amp;gt; *ns* ns-name))))&amp;lt;br&amp;gt;         ;_# (prn &amp;quot;munged-ns-str&amp;quot; munged-ns-str#)&amp;lt;br&amp;gt;         demunged-ns-str# (str (clojure.repl/demunge munged-ns-str#))&amp;lt;br&amp;gt;         ;_# (prn &amp;quot;demunged-ns-str&amp;quot; demunged-ns-str#)&amp;lt;br&amp;gt;         local-name# (if (some #(= \. %) provided-name-str#)&amp;lt;br&amp;gt;                       (symbol (apply str (last (partition-by #(= \. %) (str provided-name-str#)))))&amp;lt;br&amp;gt;                       provided-name-str#)&amp;lt;br&amp;gt;         ;_# (prn &amp;quot;local-name&amp;quot; local-name#)&amp;lt;br&amp;gt;         s# (symbol (str munged-ns-str# \. local-name#))&amp;lt;br&amp;gt;         fs# (apply array-map (apply concat (with-frees (mapv make-F '~args)&amp;lt;br&amp;gt;                                              (mapv parse-field (partition 3 '~fields)))))&amp;lt;br&amp;gt;         as# (set (with-frees (mapv make-F '~args)&amp;lt;br&amp;gt;                    (mapv parse-type '~ancests)))&amp;lt;br&amp;gt;         _# (add-datatype-ancestors s# as#)&amp;lt;br&amp;gt;         pos-ctor-name# (symbol demunged-ns-str# (str &amp;quot;-&amp;gt;&amp;quot; local-name#))&amp;lt;br&amp;gt;         map-ctor-name# (symbol demunged-ns-str# (str &amp;quot;map-&amp;gt;&amp;quot; local-name#))&amp;lt;br&amp;gt;         args# '~args&amp;lt;br&amp;gt;         vs# '~variances&amp;lt;br&amp;gt;         dt# (if args#&amp;lt;br&amp;gt;               (Poly* args# (repeat (count args#) no-bounds)&amp;lt;br&amp;gt;                      (~ctor s# vs# (map make-F args#) fs#)&amp;lt;br&amp;gt;                      args#)&amp;lt;br&amp;gt;               (~ctor s# nil nil fs#))&amp;lt;br&amp;gt;         pos-ctor# (if args#&amp;lt;br&amp;gt;                     (Poly* args# (repeat (count args#) no-bounds)&amp;lt;br&amp;gt;                            (make-FnIntersection&amp;lt;br&amp;gt;                              (make-Function (vec (vals fs#)) (~ctor s# vs# (map make-F args#) fs#)))&amp;lt;br&amp;gt;                            args#)&amp;lt;br&amp;gt;                     (make-FnIntersection&amp;lt;br&amp;gt;                       (make-Function (vec (vals fs#)) dt#)))&amp;lt;br&amp;gt;        map-ctor# (when ~record?&amp;lt;br&amp;gt;                    (let [hmap-arg# (-hmap (zipmap (map (comp -val keyword) (keys fs#))&amp;lt;br&amp;gt;                                                   (vals fs#)))]&amp;lt;br&amp;gt;                      (if args#&amp;lt;br&amp;gt;                        (Poly* args# (repeat (count args#) no-bounds)&amp;lt;br&amp;gt;                               (make-FnIntersection&amp;lt;br&amp;gt;                                 (make-Function [hmap-arg#] (~ctor s# vs# (map make-F args#) fs#)))&amp;lt;br&amp;gt;                               args#)&amp;lt;br&amp;gt;                        (make-FnIntersection&amp;lt;br&amp;gt;                          (make-Function [hmap-arg#] dt#)))))]&amp;lt;br&amp;gt;     (do &amp;lt;br&amp;gt;       (when vs#&amp;lt;br&amp;gt;         (let [f# (mapv make-F (repeatedly (count vs#) gensym))]&amp;lt;br&amp;gt;           (alter-class* s# (RClass* (map :name f#) vs# f# s# {}))))&amp;lt;br&amp;gt;       (add-datatype s# dt#)&amp;lt;br&amp;gt;       (add-var-type pos-ctor-name# pos-ctor#)&amp;lt;br&amp;gt;       (when ~record?&amp;lt;br&amp;gt;         (add-method-override (symbol (str s#) &amp;quot;create&amp;quot;) map-ctor#)&amp;lt;br&amp;gt;         (add-var-type map-ctor-name# map-ctor#))&amp;lt;br&amp;gt;       (vec&amp;lt;br&amp;gt;         (concat [[s# (unparse-type dt#)]&amp;lt;br&amp;gt;                  [pos-ctor-name# (unparse-type pos-ctor#)]]&amp;lt;br&amp;gt;                 (when ~record?&amp;lt;br&amp;gt;                   [map-ctor-name# (unparse-type map-ctor#)]))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">gen-datatype*</a>[provided-name fields variances args ancests record?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;gen-protocol*&lt;/b&gt; ([local-varsym variances args mths])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn gen-protocol* [local-varsym variances args mths]&amp;lt;br&amp;gt;  `(do (ensure-clojure)&amp;lt;br&amp;gt;  (let [local-vsym# '~local-varsym&amp;lt;br&amp;gt;         s# (symbol (-&amp;gt; *ns* ns-name str) (str local-vsym#))&amp;lt;br&amp;gt;         on-class# (symbol (str (munge (namespace s#)) \. local-vsym#))&amp;lt;br&amp;gt;         ; add a Name so the methods can be parsed&amp;lt;br&amp;gt;         _# (declare-protocol* s#)&amp;lt;br&amp;gt;         args# '~args&amp;lt;br&amp;gt;         fs# (when args# &amp;lt;br&amp;gt;               (map make-F args#))&amp;lt;br&amp;gt;         ms# (into {} (for [[knq# v#] '~mths]&amp;lt;br&amp;gt;                        (do&amp;lt;br&amp;gt;                          (assert (not (namespace knq#))&amp;lt;br&amp;gt;                                  &amp;quot;Protocol method should be unqualified&amp;quot;)&amp;lt;br&amp;gt;                          [knq# (with-frees fs# (parse-type v#))])))&amp;lt;br&amp;gt;         t# (if fs#&amp;lt;br&amp;gt;              (Poly* (map :name fs#) (repeat (count fs#) no-bounds) &amp;lt;br&amp;gt;                     (-&amp;gt;Protocol s# '~variances fs# on-class# ms#)&amp;lt;br&amp;gt;                     (map :name fs#))&amp;lt;br&amp;gt;              (-&amp;gt;Protocol s# nil nil on-class# ms#))]&amp;lt;br&amp;gt;     (do&amp;lt;br&amp;gt;       (add-protocol s# t#)&amp;lt;br&amp;gt;       (doseq [[kuq# mt#] ms#]&amp;lt;br&amp;gt;         ;qualify method names when adding methods as vars&amp;lt;br&amp;gt;         (let [kq# (symbol (-&amp;gt; *ns* ns-name str) (str kuq#))]&amp;lt;br&amp;gt;           (add-var-type kq# mt#)))&amp;lt;br&amp;gt;       [s# (unparse-type t#)]))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">gen-protocol*</a>[local-varsym variances args mths]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;get-declared-kind&lt;/b&gt; ([sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-declared-kind [sym]&amp;lt;br&amp;gt;  (if-let [tfn (@DECLARED-KIND-ENV sym)]&amp;lt;br&amp;gt;    tfn&amp;lt;br&amp;gt;    (throw (Exception. (error-msg &amp;quot;No declared kind for Name &amp;quot; sym)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-declared-kind</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;get-multimethod-dispatch-type&lt;/b&gt; ([mmsym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-multimethod-dispatch-type [mmsym]&amp;lt;br&amp;gt;  {:pre [(symbol? mmsym)]&amp;lt;br&amp;gt;   :post [(Type? %)]}&amp;lt;br&amp;gt;  (let [t (@MULTIMETHOD-DISPATCH-ENV mmsym)]&amp;lt;br&amp;gt;    (assert t (str &amp;quot;Multimethod requires dispatch type: &amp;quot; mmsym))&amp;lt;br&amp;gt;    t))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-multimethod-dispatch-type</a>[mmsym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;i-subst-dotted?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord i-subst-dotted [types dty dbound]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? types)&amp;lt;br&amp;gt;       (every? Type? types))&amp;lt;br&amp;gt;   (Type? dty)&amp;lt;br&amp;gt;   (F? dbound)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">i-subst-dotted?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;i-subst-starred?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord i-subst-starred [types starred]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? Type? types)&amp;lt;br&amp;gt;   (Type? starred)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">i-subst-starred?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;i-subst?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord i-subst [types]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? Type? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">i-subst?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;idx-variances&lt;/b&gt; ([t])&lt;br&gt; Map of indexes to their variances&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn idx-variances &amp;lt;br&amp;gt;  &amp;quot;Map of indexes to their variances&amp;quot;&amp;lt;br&amp;gt;  [t]&amp;lt;br&amp;gt;  {:post [(variance-map? %)]}&amp;lt;br&amp;gt;  (binding [*frees-mode* ::idxs]&amp;lt;br&amp;gt;    (frees-in t)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">idx-variances</a>[t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;implied-atomic?&lt;/b&gt; ([f1 f2])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn implied-atomic? [f1 f2]&amp;lt;br&amp;gt;  (if (= f1 f2)&amp;lt;br&amp;gt;    true&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (OrFilter? f1) (boolean (some #(= % f2) (:fs f1)))&amp;lt;br&amp;gt;      (and (TypeFilter? f1)&amp;lt;br&amp;gt;           (TypeFilter? f2)) (and (= (:id f1) (:id f2))&amp;lt;br&amp;gt;                                  (subtype? (:type f2) (:type f1)))&amp;lt;br&amp;gt;      (and (NotTypeFilter? f1)&amp;lt;br&amp;gt;           (NotTypeFilter? f2)) (and (= (:id f1) (:id f2))&amp;lt;br&amp;gt;                                     (subtype? (:type f1) (:type f2)))&amp;lt;br&amp;gt;      :else false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">implied-atomic?</a>[f1 f2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;index-free-in?&lt;/b&gt; ([k type])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn index-free-in? [k type]&amp;lt;br&amp;gt;  (let [free-in? (atom false :validator boolean?)]&amp;lt;br&amp;gt;    (letfn [(for-object [o]&amp;lt;br&amp;gt;              (fold-rhs ::free-in-for-object&amp;lt;br&amp;gt;                        {:type-rec for-type&amp;lt;br&amp;gt;                         :locals {:free-in? free-in?&amp;lt;br&amp;gt;                                  :k k}}&amp;lt;br&amp;gt;                        o))&amp;lt;br&amp;gt;            (for-filter [o]&amp;lt;br&amp;gt;              (fold-rhs ::free-in-for-filter&amp;lt;br&amp;gt;                        {:type-rec for-type&amp;lt;br&amp;gt;                         :filter-rec for-filter&amp;lt;br&amp;gt;                         :locals {:free-in? free-in?&amp;lt;br&amp;gt;                                  :k k}}&amp;lt;br&amp;gt;                         o))&amp;lt;br&amp;gt;            (for-type [t]&amp;lt;br&amp;gt;              (fold-rhs ::free-in-for-type&amp;lt;br&amp;gt;                        {:type-rec for-type&amp;lt;br&amp;gt;                         :filter-rec for-filter&amp;lt;br&amp;gt;                         :object-rec for-object&amp;lt;br&amp;gt;                         :locals {:free-in? free-in?&amp;lt;br&amp;gt;                                  :k k&amp;lt;br&amp;gt;                                  :for-type for-type}}&amp;lt;br&amp;gt;                        t))]&amp;lt;br&amp;gt;      (for-type type)&amp;lt;br&amp;gt;      @free-in?)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">index-free-in?</a>[k type]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;infer&lt;/b&gt; ([X Y S T R &amp; [expected]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn infer [X Y S T R &amp;amp; [expected]]&amp;lt;br&amp;gt;  {:pre [(every? (hash-c? symbol? Bounds?) [X Y])&amp;lt;br&amp;gt;         (every? Type? S)&amp;lt;br&amp;gt;         (every? Type? T)&amp;lt;br&amp;gt;         (AnyType? R)&amp;lt;br&amp;gt;         ((some-fn nil? AnyType?) expected)]&amp;lt;br&amp;gt;   :post [((some-fn nil? true? substitution-c?) %)]}&amp;lt;br&amp;gt;;  (prn &amp;quot;infer&amp;quot; )&amp;lt;br&amp;gt;;  (prn &amp;quot;X:&amp;quot; X) &amp;lt;br&amp;gt;;  (prn &amp;quot;Y:&amp;quot; Y) &amp;lt;br&amp;gt;;  (prn &amp;quot;S:&amp;quot; (map unparse-type S))&amp;lt;br&amp;gt;;  (prn &amp;quot;T:&amp;quot; (map unparse-type T))&amp;lt;br&amp;gt;;  (when R&amp;lt;br&amp;gt;;    (prn &amp;quot;R:&amp;quot; (class R) (unparse-type R)))&amp;lt;br&amp;gt;;  (when expected&amp;lt;br&amp;gt;;    (prn &amp;quot;expected:&amp;quot; (class expected) (unparse-type expected)))&amp;lt;br&amp;gt;  (let [expected-cset (if expected&amp;lt;br&amp;gt;                        (cs-gen #{} X Y R expected)&amp;lt;br&amp;gt;                        (empty-cset {} {}))&amp;lt;br&amp;gt;        ;_ (prn &amp;quot;expected cset&amp;quot; expected-cset)&amp;lt;br&amp;gt;        cs (cs-gen-list #{} X Y S T :expected-cset expected-cset)&amp;lt;br&amp;gt;        cs* (cset-meet cs expected-cset)]&amp;lt;br&amp;gt;    ;(prn &amp;quot;final cs&amp;quot; cs*)&amp;lt;br&amp;gt;    (if R&amp;lt;br&amp;gt;      (subst-gen cs* (set (keys Y)) R)&amp;lt;br&amp;gt;      true)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">infer</a>[X Y S T R & [expected]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;infer-dots&lt;/b&gt; ([X dotted-var dotted-bnd S T T-dotted R must-vars &amp; {:keys [expected]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn infer-dots [X dotted-var dotted-bnd S T T-dotted R must-vars &amp;amp; {:keys [expected]}]&amp;lt;br&amp;gt;  {:pre [((hash-c? symbol? Bounds?) X)&amp;lt;br&amp;gt;         (symbol? dotted-var)&amp;lt;br&amp;gt;         (Bounds? dotted-bnd)&amp;lt;br&amp;gt;         (every? #(every? Type? %) [S T])&amp;lt;br&amp;gt;         (Type? T-dotted) &amp;lt;br&amp;gt;         (AnyType? R)&amp;lt;br&amp;gt;         ((set-c? symbol?) must-vars)&amp;lt;br&amp;gt;         ((some-fn nil? Type?) expected)]&amp;lt;br&amp;gt;   :post [(substitution-c? %)]}&amp;lt;br&amp;gt;  (let [[short-S rest-S] (split-at (count T) S)&amp;lt;br&amp;gt;;        _ (prn &amp;quot;short-S&amp;quot; (map unparse-type short-S))&amp;lt;br&amp;gt;;        _ (prn &amp;quot;rest-S&amp;quot; (map unparse-type rest-S))&amp;lt;br&amp;gt;        expected-cset (if expected&amp;lt;br&amp;gt;                        (cs-gen #{} X {dotted-var dotted-bnd} R expected)&amp;lt;br&amp;gt;                        (empty-cset {} {}))&amp;lt;br&amp;gt;;        _ (prn &amp;quot;expected-cset&amp;quot; expected-cset)&amp;lt;br&amp;gt;        cs-short (cs-gen-list #{} X {dotted-var dotted-bnd} short-S T&amp;lt;br&amp;gt;                              :expected-cset expected-cset)&amp;lt;br&amp;gt;        ;_ (prn &amp;quot;cs-short&amp;quot; cs-short)&amp;lt;br&amp;gt;        new-vars (var-store-take dotted-var T-dotted (count rest-S))&amp;lt;br&amp;gt;        new-Ts (doall&amp;lt;br&amp;gt;                 (for [v new-vars]&amp;lt;br&amp;gt;                   (let [target (substitute-dots (map make-F new-vars) nil dotted-var T-dotted)]&amp;lt;br&amp;gt;                     #_(prn &amp;quot;replace&amp;quot; v &amp;quot;with&amp;quot; dotted-var &amp;quot;in&amp;quot; (unparse-type target))&amp;lt;br&amp;gt;                     (substitute (make-F v) dotted-var target))))&amp;lt;br&amp;gt;        ;_ (prn &amp;quot;new-Ts&amp;quot; new-Ts)&amp;lt;br&amp;gt;        cs-dotted (cs-gen-list #{} (merge X (zipmap new-vars (repeat dotted-bnd))) {dotted-var dotted-bnd} rest-S new-Ts&amp;lt;br&amp;gt;                               :expected-cset expected-cset)&amp;lt;br&amp;gt;        ;_ (prn &amp;quot;cs-dotted&amp;quot; cs-dotted)&amp;lt;br&amp;gt;        cs-dotted (move-vars-to-dmap cs-dotted dotted-var new-vars)&amp;lt;br&amp;gt;        ;_ (prn &amp;quot;cs-dotted&amp;quot; cs-dotted)&amp;lt;br&amp;gt;        cs (cset-meet cs-short cs-dotted)&amp;lt;br&amp;gt;        ;_ (prn &amp;quot;cs&amp;quot; cs)&amp;lt;br&amp;gt;        ]&amp;lt;br&amp;gt;    (subst-gen (cset-meet cs expected-cset) #{dotted-var} R)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">infer-dots</a>[X dotted-var dotted-bnd S T T-dotted R must-vars & {:keys [expected]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;infer-vararg&lt;/b&gt; ([X Y S T T-var R &amp; [expected]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn infer-vararg [X Y S T T-var R &amp;amp; [expected]]&amp;lt;br&amp;gt;  {:pre [(every? (hash-c? symbol? Bounds?) [X Y])&amp;lt;br&amp;gt;         (every? (every-c? Type?) [S T])&amp;lt;br&amp;gt;         ((some-fn nil? Type?) T-var)&amp;lt;br&amp;gt;         (AnyType? R)&amp;lt;br&amp;gt;         ((some-fn nil? AnyType?) expected)]&amp;lt;br&amp;gt;   :post [((some-fn nil? substitution-c?) %)]}&amp;lt;br&amp;gt;  ;(prn &amp;quot;infer-vararg&amp;quot; &amp;quot;X:&amp;quot; X)&amp;lt;br&amp;gt;  (let [new-T (if T-var&amp;lt;br&amp;gt;                ;Pad out T&amp;lt;br&amp;gt;                (concat T (repeat (- (count S) (count T)) T-var))&amp;lt;br&amp;gt;                T)]&amp;lt;br&amp;gt;;    (prn &amp;quot;S&amp;quot; (map unparse-type S))&amp;lt;br&amp;gt;;    (prn &amp;quot;new-T&amp;quot; (map unparse-type new-T))&amp;lt;br&amp;gt;;    (prn &amp;quot;R&amp;quot; (unparse-type R))&amp;lt;br&amp;gt;;    (prn &amp;quot;expected&amp;quot; (class expected) (when expected (unparse-type expected)))&amp;lt;br&amp;gt;    (and (&amp;gt;= (count S) (count T))&amp;lt;br&amp;gt;         (infer X Y S new-T R expected))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">infer-vararg</a>[X Y S T T-var R & [expected]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;insert-constraint&lt;/b&gt; ([cs var S T bnds])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn insert-constraint [cs var S T bnds]&amp;lt;br&amp;gt;  {:pre [(cset? cs)&amp;lt;br&amp;gt;         (symbol? var)&amp;lt;br&amp;gt;         (Type? S)&amp;lt;br&amp;gt;         (Type? T)&amp;lt;br&amp;gt;         (Bounds? bnds)]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  (-&amp;gt;cset (doall&amp;lt;br&amp;gt;            (for [{fmap :fixed dmap :dmap} (:maps cs)]&amp;lt;br&amp;gt;              (-&amp;gt;cset-entry (assoc fmap var (-&amp;gt;c S var T bnds))&amp;lt;br&amp;gt;                            dmap&amp;lt;br&amp;gt;                            #{})))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">insert-constraint</a>[cs var S T bnds]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;inst&lt;/b&gt; ([inst-of &amp; types])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Instantiate a polymorphic type with a number of types&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro inst &amp;lt;br&amp;gt;  &amp;quot;Instantiate a polymorphic type with a number of types&amp;quot;&amp;lt;br&amp;gt;  [inst-of &amp;amp; types]&amp;lt;br&amp;gt;  `(inst-poly ~inst-of '~types))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">inst</a>[inst-of & types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;inst-ctor&lt;/b&gt; ([inst-of &amp; types])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Instantiate a call to a constructor with a number of types.&lt;br&gt;  First argument must be an immediate call to a constructor.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro inst-ctor&amp;lt;br&amp;gt;  &amp;quot;Instantiate a call to a constructor with a number of types.&amp;lt;br&amp;gt;  First argument must be an immediate call to a constructor.&amp;quot;&amp;lt;br&amp;gt;  [inst-of &amp;amp; types]&amp;lt;br&amp;gt;  `(inst-poly-ctor ~inst-of '~types))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">inst-ctor</a>[inst-of & types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;inst-poly&lt;/b&gt; ([inst-of types-syn])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn inst-poly &amp;lt;br&amp;gt;  [inst-of types-syn]&amp;lt;br&amp;gt;  inst-of)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">inst-poly</a>[inst-of types-syn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;inst-poly-ctor&lt;/b&gt; ([inst-of types-syn])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn inst-poly-ctor [inst-of types-syn]&amp;lt;br&amp;gt;  inst-of)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">inst-poly-ctor</a>[inst-of types-syn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;instantiate&lt;/b&gt; ([f sc])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn instantiate [f sc]&amp;lt;br&amp;gt;  &amp;quot;Instantiate bound name to free&amp;quot;&amp;lt;br&amp;gt;  {:pre [(symbol? f)&amp;lt;br&amp;gt;         (Scope? sc)]}&amp;lt;br&amp;gt;  (instantiate-many [f] sc))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">instantiate</a>[f sc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;instantiate-many&lt;/b&gt; ([images sc])&lt;br&gt; instantiate-many : List[Symbols] Scope^n -&gt; Type&lt;br&gt;  Instantiate de Bruijn indices in sc to frees named by&lt;br&gt;  images, preserving upper/lower bounds&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn instantiate-many &amp;lt;br&amp;gt;  &amp;quot;instantiate-many : List[Symbols] Scope^n -&amp;gt; Type&amp;lt;br&amp;gt;  Instantiate de Bruijn indices in sc to frees named by&amp;lt;br&amp;gt;  images, preserving upper/lower bounds&amp;quot;&amp;lt;br&amp;gt;  [images sc]&amp;lt;br&amp;gt;  {:pre [(every? symbol? images)&amp;lt;br&amp;gt;         (or (Scope? sc)&amp;lt;br&amp;gt;             (empty? images))]&amp;lt;br&amp;gt;   :post [((some-fn Type? TypeFn?) %)]}&amp;lt;br&amp;gt;  (letfn [(replace &amp;lt;br&amp;gt;            ([image count type] (replace image count type 0 type))&amp;lt;br&amp;gt;            ([image count type outer ty]&amp;lt;br&amp;gt;             (letfn [(sb [t] (replace image count type outer t))]&amp;lt;br&amp;gt;               (let [sf (sub-f sb ::instantiate-many)]&amp;lt;br&amp;gt;                 (fold-rhs ::instantiate-many&amp;lt;br&amp;gt;                   {:type-rec sb &amp;lt;br&amp;gt;                    :filter-rec sf &amp;lt;br&amp;gt;                    :object-rec (sub-o sb ::instantiate-many)&amp;lt;br&amp;gt;                    :locals {:count count&amp;lt;br&amp;gt;                             :outer outer&amp;lt;br&amp;gt;                             :image image&amp;lt;br&amp;gt;                             :sb sb&amp;lt;br&amp;gt;                             :type type&amp;lt;br&amp;gt;                             :replace replace}}&amp;lt;br&amp;gt;                   ty)))))]&amp;lt;br&amp;gt;    (if (empty? images)&amp;lt;br&amp;gt;      sc&amp;lt;br&amp;gt;      (let [n (count images)]&amp;lt;br&amp;gt;        (loop [ty (remove-scopes n sc)&amp;lt;br&amp;gt;               images images&amp;lt;br&amp;gt;               count (dec n)]&amp;lt;br&amp;gt;          (if (zero? count)&amp;lt;br&amp;gt;            (replace (first images) 0 ty)&amp;lt;br&amp;gt;            (recur (replace (first images) count ty)&amp;lt;br&amp;gt;                   (next images)&amp;lt;br&amp;gt;                   (dec count))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">instantiate-many</a>[images sc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;instantiate-poly&lt;/b&gt; ([t types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn instantiate-poly [t types]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (Poly? t) (do (assert (= (:nbound t) (count types)) (error-msg &amp;quot;Wrong number of arguments (&amp;quot; (count types) &amp;lt;br&amp;gt;                                                                   &amp;quot;) passed to polymorphic type: &amp;quot;&amp;lt;br&amp;gt;                                                                   (unparse-type t)&amp;lt;br&amp;gt;                                                                   (when *current-RClass-super*&amp;lt;br&amp;gt;                                                                     (str &amp;quot; when checking ancestors of &amp;quot; *current-RClass-super*))))&amp;lt;br&amp;gt;                (let [nms (repeatedly (:nbound t) gensym)&amp;lt;br&amp;gt;                      body (Poly-body* nms t)]&amp;lt;br&amp;gt;                  (subst-all (make-simple-substitution nms types) body)))&amp;lt;br&amp;gt;    ;PolyDots NYI&amp;lt;br&amp;gt;    :else (throw (Exception. &amp;quot;instantiate-poly: requires Poly, and PolyDots NYI&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">instantiate-poly</a>[t types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;instantiate-typefn&lt;/b&gt; ([t types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn instantiate-typefn [^TypeFn t types]&amp;lt;br&amp;gt;  (assert (TypeFn? t) (str &amp;quot;instantiate-typefn requires a TypeFn: &amp;quot; (unparse-type t)))&amp;lt;br&amp;gt;  (do (assert (= (.nbound t) (count types)) (error-msg &amp;quot;Wrong number of arguments passed to type function: &amp;quot;&amp;lt;br&amp;gt;                                                       (unparse-type t) (mapv unparse-type types)))&amp;lt;br&amp;gt;    (let [nms (repeatedly (.nbound t) gensym)&amp;lt;br&amp;gt;          body (TypeFn-body* nms t)]&amp;lt;br&amp;gt;      (subst-all (make-simple-substitution nms types) body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">instantiate-typefn</a>[t types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;into-array&gt;&lt;/b&gt; ([cljt coll] [javat cljt coll])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Make a Java array with Java class javat and Typed Clojure type&lt;br&gt;  cljt. Resulting array will be of type javat, but elements of coll must be under&lt;br&gt;  cljt. cljt should be a subtype of javat (the same or more specific).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro into-array&amp;gt; &amp;lt;br&amp;gt;  &amp;quot;Make a Java array with Java class javat and Typed Clojure type&amp;lt;br&amp;gt;  cljt. Resulting array will be of type javat, but elements of coll must be under&amp;lt;br&amp;gt;  cljt. cljt should be a subtype of javat (the same or more specific).&amp;quot;&amp;lt;br&amp;gt;  ([cljt coll]&amp;lt;br&amp;gt;   `(into-array&amp;gt;* '~cljt ~coll))&amp;lt;br&amp;gt;  ([javat cljt coll]&amp;lt;br&amp;gt;   `(into-array&amp;gt;* '~javat '~cljt ~coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">into-array></a>[cljt coll] [javat cljt coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;into-array&gt;*&lt;/b&gt; ([cljt coll] [javat cljt coll])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn into-array&amp;gt;* &amp;lt;br&amp;gt;  ([cljt coll]&amp;lt;br&amp;gt;   (into-array (-&amp;gt; cljt parse-type Type-&amp;gt;array-member-Class) coll))&amp;lt;br&amp;gt;  ([javat cljt coll]&amp;lt;br&amp;gt;   (into-array (-&amp;gt; javat parse-type Type-&amp;gt;array-member-Class) coll)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">into-array>*</a>[cljt coll] [javat cljt coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;inverse-atom&lt;/b&gt; ([a])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn inverse-atom [a]&amp;lt;br&amp;gt;  {:pre [((some-fn TypeFilter? NotTypeFilter?) a)]&amp;lt;br&amp;gt;   :post [((some-fn TypeFilter? NotTypeFilter?) a)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (TypeFilter? a) (-not-filter (:type a) (:id a) (:path a))&amp;lt;br&amp;gt;    (NotTypeFilter? a) (-filter (:type a) (:id a) (:path a))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">inverse-atom</a>[a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;invoke-get&lt;/b&gt; ([{:keys [args], :as expr} &amp; [expected]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn invoke-get [{:keys [args] :as expr} &amp;amp; [expected]]&amp;lt;br&amp;gt;  {:post [((some-fn &amp;lt;br&amp;gt;             #(-&amp;gt; % expr-type TCResult?)&amp;lt;br&amp;gt;             #{::not-special})&amp;lt;br&amp;gt;             %)]}&amp;lt;br&amp;gt;  (assert (#{2 3} (count args)) &amp;quot;Wrong number of args to clojure.core/get&amp;quot;)&amp;lt;br&amp;gt;  (let [[target kw default] args&amp;lt;br&amp;gt;        kwr (expr-type (check kw))]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      ((every-pred Value? (comp keyword? :val)) (ret-t kwr))&amp;lt;br&amp;gt;      (assoc expr&amp;lt;br&amp;gt;             expr-type (invoke-keyword kwr&amp;lt;br&amp;gt;                                       (expr-type (check target))&amp;lt;br&amp;gt;                                       (when default&amp;lt;br&amp;gt;                                         (expr-type (check default)))&amp;lt;br&amp;gt;                                       expected))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ((every-pred Value? (comp integer? :val)) (ret-t kwr))&amp;lt;br&amp;gt;      (throw (Exception. &amp;quot;get lookup of vector (like nth) NYI&amp;quot;))&amp;lt;br&amp;gt;      &amp;lt;br&amp;gt;      :else (do ;(prn &amp;quot;Non-special 'get'&amp;quot;)&amp;lt;br&amp;gt;              ::not-special))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">invoke-get</a>[{:keys [args], :as expr} & [expected]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;invoke-keyword&lt;/b&gt; ([kw-ret target-ret default-ret expected-ret])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn invoke-keyword [kw-ret target-ret default-ret expected-ret]&amp;lt;br&amp;gt;  {:pre [(TCResult? kw-ret)&amp;lt;br&amp;gt;         (TCResult? target-ret)&amp;lt;br&amp;gt;         ((some-fn nil? TCResult?) default-ret)&amp;lt;br&amp;gt;         ((some-fn nil? TCResult?) expected-ret)]&amp;lt;br&amp;gt;   :post [(TCResult? %)]}&amp;lt;br&amp;gt;  (let [targett (-resolve (ret-t target-ret))&amp;lt;br&amp;gt;        kwt (ret-t kw-ret)&amp;lt;br&amp;gt;        defaultt (when default-ret&amp;lt;br&amp;gt;                   (ret-t default-ret))]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      ;Keyword must be a singleton with no default&amp;lt;br&amp;gt;      (and (Value? kwt)&amp;lt;br&amp;gt;           (keyword? (:val kwt)))&amp;lt;br&amp;gt;      (let [{{path-hm :path id-hm :id :as o} :o} target-ret&amp;lt;br&amp;gt;            this-pelem (-&amp;gt;KeyPE (:val kwt))&amp;lt;br&amp;gt;            val-type (find-val-type targett kwt defaultt)]&amp;lt;br&amp;gt;        (if (not= (Un) val-type)&amp;lt;br&amp;gt;          (ret val-type&amp;lt;br&amp;gt;               (-FS (if (Path? o)&amp;lt;br&amp;gt;                      (-filter val-type id-hm (concat path-hm [this-pelem]))&amp;lt;br&amp;gt;                      (-filter-at val-type (-&amp;gt;EmptyObject)))&amp;lt;br&amp;gt;                    -top)&amp;lt;br&amp;gt;               (if (Path? o)&amp;lt;br&amp;gt;                 (update-in o [:path] #(seq (concat % [this-pelem])))&amp;lt;br&amp;gt;                 o))&amp;lt;br&amp;gt;          (throw (Exception. (error-msg &amp;quot;Keyword lookup gave bottom type: &amp;quot;&amp;lt;br&amp;gt;                                        (:val kwt) &amp;quot; &amp;quot; (unparse-type targett))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      :else (throw (Exception. (error-msg &amp;quot;keyword-invoke only supports keyword lookup, no default. Found &amp;quot; &amp;lt;br&amp;gt;                                          (unparse-type kwt)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">invoke-keyword</a>[kw-ret target-ret default-ret expected-ret]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;invoke-nth&lt;/b&gt; ([{:keys [args], :as expr} &amp; [expected]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn invoke-nth [{:keys [args] :as expr} &amp;amp; [expected]]&amp;lt;br&amp;gt;  (let [_ (assert (#{2 3} (count args)))&amp;lt;br&amp;gt;        [te ne de :as cargs] (doall (map check args))&amp;lt;br&amp;gt;        types (let [ts (-resolve (ret-t (expr-type te)))]&amp;lt;br&amp;gt;                (if (Union? ts)&amp;lt;br&amp;gt;                  (:types ts)&amp;lt;br&amp;gt;                  [ts]))&amp;lt;br&amp;gt;        num-t (ret-t (expr-type ne))&amp;lt;br&amp;gt;        default-t (when de&amp;lt;br&amp;gt;                    (ret-t (expr-type de)))]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (and (Value? num-t)&amp;lt;br&amp;gt;           (integer? (:val num-t))&amp;lt;br&amp;gt;           (every? (some-fn Nil?&amp;lt;br&amp;gt;                            HeterogeneousVector?&amp;lt;br&amp;gt;                            HeterogeneousList?&amp;lt;br&amp;gt;                            HeterogeneousSeq?)&amp;lt;br&amp;gt;                   types))&amp;lt;br&amp;gt;      (assoc expr&amp;lt;br&amp;gt;             expr-type (ret (apply Un&amp;lt;br&amp;gt;                                   (doall&amp;lt;br&amp;gt;                                     (for [t types]&amp;lt;br&amp;gt;                                       (let [res-t (cond&amp;lt;br&amp;gt;                                                     (Nil? t) (or default-t -nil)&amp;lt;br&amp;gt;                                                     :else (apply nth &amp;lt;br&amp;gt;                                                                  (:types t)&amp;lt;br&amp;gt;                                                                  (:val num-t) &amp;lt;br&amp;gt;                                                                  (when default-t&amp;lt;br&amp;gt;                                                                    [default-t])))]&amp;lt;br&amp;gt;                                         (if res-t&amp;lt;br&amp;gt;                                           res-t&amp;lt;br&amp;gt;                                           (throw (Exception. (str &amp;quot;Cannot get index &amp;quot; (:val num-t)&amp;lt;br&amp;gt;                                                                   &amp;quot; from type &amp;quot; (unparse-type t)))))))))&amp;lt;br&amp;gt;                            (let [nnth (:val num-t)&amp;lt;br&amp;gt;                                  target-o (ret-o (expr-type te))&amp;lt;br&amp;gt;                                  default-o (when de&amp;lt;br&amp;gt;                                              (ret-o (expr-type de)))&amp;lt;br&amp;gt;                                  ;; We handle filters for both arities of nth here, with and without default&amp;lt;br&amp;gt;                                  ;;&amp;lt;br&amp;gt;                                  ;;With default:&amp;lt;br&amp;gt;                                  ;; if this is a true value either:&amp;lt;br&amp;gt;                                  ;;  * target is nil or seq and default is true&amp;lt;br&amp;gt;                                  ;;  * target is seqable, default is false&amp;lt;br&amp;gt;                                  ;;    and target is at least (inc nnth) count&amp;lt;br&amp;gt;                                  default-fs+ (-or (-and (-filter-at (Un -nil (RClass-of (Class-&amp;gt;symbol ISeq) [-any])) &amp;lt;br&amp;gt;                                                                     target-o)&amp;lt;br&amp;gt;                                                         (-not-filter-at (Un -false -nil) &amp;lt;br&amp;gt;                                                                         default-o))&amp;lt;br&amp;gt;                                                   (-and (-filter-at (In (RClass-of (Class-&amp;gt;symbol Seqable) [-any])&amp;lt;br&amp;gt;                                                                         (make-CountRange (inc nnth)))&amp;lt;br&amp;gt;                                                                     target-o)&amp;lt;br&amp;gt;                                                         (-filter-at (Un -false -nil) &amp;lt;br&amp;gt;                                                                     default-o)))&amp;lt;br&amp;gt;                                  ;;Without default:&amp;lt;br&amp;gt;                                  ;; if this is a true value: &amp;lt;br&amp;gt;                                  ;;  * target is seqable of at least nnth count&amp;lt;br&amp;gt;                                  nodefault-fs+ (-filter-at (In (RClass-of (Class-&amp;gt;symbol Seqable) [-any])&amp;lt;br&amp;gt;                                                                (make-CountRange (inc nnth)))&amp;lt;br&amp;gt;                                                            target-o)]&amp;lt;br&amp;gt;                              (-FS (if default-t&amp;lt;br&amp;gt;                                     default-fs+&amp;lt;br&amp;gt;                                     nodefault-fs+)&amp;lt;br&amp;gt;                                   ; not sure if there's anything worth encoding here&amp;lt;br&amp;gt;                                   -top))))&amp;lt;br&amp;gt;      :else ::not-special)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">invoke-nth</a>[{:keys [args], :as expr} & [expected]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;is-var-mutated?&lt;/b&gt; ([id])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn is-var-mutated? [id]&amp;lt;br&amp;gt;  (contains? *mutated-bindings* id))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">is-var-mutated?</a>[id]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;join&lt;/b&gt; ([s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn join [s t] (Un s t))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">join</a>[s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;keyword-&gt;Fn&lt;/b&gt; ([kw])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn keyword-&amp;gt;Fn [kw]&amp;lt;br&amp;gt;  {:pre [(keyword? kw)]&amp;lt;br&amp;gt;   :post [(Type? %)]}&amp;lt;br&amp;gt;  (Poly* ['x]&amp;lt;br&amp;gt;         [no-bounds]&amp;lt;br&amp;gt;         (make-FnIntersection&amp;lt;br&amp;gt;           (make-Function&amp;lt;br&amp;gt;             [(Un -any&amp;lt;br&amp;gt;                  (-hmap {(-val kw) (make-F 'x)}))]&amp;lt;br&amp;gt;             (Un -nil (make-F 'x))&amp;lt;br&amp;gt;             nil nil&amp;lt;br&amp;gt;             :filter (-FS (-filter (-hmap {(-val kw) -any}) 0) -top)))&amp;lt;br&amp;gt;         ['x]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">keyword->Fn</a>[kw]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;keyword-value?&lt;/b&gt; ([val])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn keyword-value? [^Value val]&amp;lt;br&amp;gt;  (boolean&amp;lt;br&amp;gt;    (when (Value? val)&amp;lt;br&amp;gt;      (keyword? (.val val)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">keyword-value?</a>[val]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;lookup-Var&lt;/b&gt; ([nsym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lookup-Var [nsym]&amp;lt;br&amp;gt;  (assert (contains? @*var-annotations* nsym) &amp;lt;br&amp;gt;          (str (when *current-env*&amp;lt;br&amp;gt;                 (str (:line *current-env*) &amp;quot;: &amp;quot;))&amp;lt;br&amp;gt;            &amp;quot;Untyped var reference: &amp;quot; nsym))&amp;lt;br&amp;gt;  (@*var-annotations* nsym))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lookup-Var</a>[nsym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;lookup-local&lt;/b&gt; ([sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lookup-local [sym]&amp;lt;br&amp;gt;  (-&amp;gt; *lexical-env* :l sym))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lookup-local</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;loop&gt;&lt;/b&gt; ([bndings* &amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Like loop, except loop variables require annotation.&lt;br&gt;&lt;br&gt;  eg. (loop&gt; [[a :- Number] 1&lt;br&gt;              [b :- (U nil Number)] nil]&lt;br&gt;        ...)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro loop&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;Like loop, except loop variables require annotation.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  eg. (loop&amp;gt; [[a :- Number] 1&amp;lt;br&amp;gt;              [b :- (U nil Number)] nil]&amp;lt;br&amp;gt;        ...)&amp;quot;&amp;lt;br&amp;gt;  [bndings* &amp;amp; forms]&amp;lt;br&amp;gt;  (let [bnds (partition 2 bndings*)&amp;lt;br&amp;gt;        ; [[lhs :- bnd-ann] rhs]&amp;lt;br&amp;gt;        lhs (map ffirst bnds)&amp;lt;br&amp;gt;        rhs (map second bnds)&amp;lt;br&amp;gt;        bnd-anns (map #(-&amp;gt; % first next second) bnds)]&amp;lt;br&amp;gt;    `(loop&amp;gt;-ann (loop ~(vec (mapcat vector lhs rhs))&amp;lt;br&amp;gt;                  ~@forms)&amp;lt;br&amp;gt;                '~bnd-anns)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">loop></a>[bndings* & forms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;loop&gt;-ann&lt;/b&gt; ([loop-of bnding-types])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn loop&amp;gt;-ann [loop-of bnding-types]&amp;lt;br&amp;gt;  loop-of)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">loop>-ann</a>[loop-of bnding-types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;make-CountRange&lt;/b&gt; ([lower] [lower upper])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-CountRange&amp;lt;br&amp;gt;  ([lower] (make-CountRange lower nil))&amp;lt;br&amp;gt;  ([lower upper] (-&amp;gt;CountRange lower upper)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-CountRange</a>[lower] [lower upper]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;make-ExactCountRange&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-ExactCountRange [c]&amp;lt;br&amp;gt;  {:pre [(nat? c)]}&amp;lt;br&amp;gt;  (make-CountRange c c))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-ExactCountRange</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;make-F&lt;/b&gt; ([name])&lt;br&gt; Make a free variable &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-F&amp;lt;br&amp;gt;  &amp;quot;Make a free variable &amp;quot;&amp;lt;br&amp;gt;  [name] (-&amp;gt;F name))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-F</a>[name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;make-FnIntersection&lt;/b&gt; ([&amp; fns])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-FnIntersection [&amp;amp; fns]&amp;lt;br&amp;gt;  {:pre [(every? Function? fns)]}&amp;lt;br&amp;gt;  (-&amp;gt;FnIntersection fns))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-FnIntersection</a>[& fns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;make-Function&lt;/b&gt; ([dom rng] [dom rng rest] [dom rng rest drest &amp; {:keys [filter object mandatory-kws optional-kws]}])&lt;br&gt; Make a function, wrap range type in a Result.&lt;br&gt;  Accepts optional :filter and :object parameters that default to the most general filter&lt;br&gt;  and EmptyObject&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-Function&amp;lt;br&amp;gt;  &amp;quot;Make a function, wrap range type in a Result.&amp;lt;br&amp;gt;  Accepts optional :filter and :object parameters that default to the most general filter&amp;lt;br&amp;gt;  and EmptyObject&amp;quot;&amp;lt;br&amp;gt;  ([dom rng] (make-Function dom rng nil nil))&amp;lt;br&amp;gt;  ([dom rng rest] (make-Function dom rng rest nil))&amp;lt;br&amp;gt;  ([dom rng rest drest &amp;amp; {:keys [filter object mandatory-kws optional-kws]}]&amp;lt;br&amp;gt;   (-&amp;gt;Function dom (-&amp;gt;Result rng (or filter (-FS -top -top)) (or object (-&amp;gt;EmptyObject))) &amp;lt;br&amp;gt;               rest drest (when (or mandatory-kws optional-kws)&amp;lt;br&amp;gt;                            (-&amp;gt;KwArgs (or mandatory-kws {})&amp;lt;br&amp;gt;                                      (or optional-kws {}))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-Function</a>[dom rng] [dom rng rest] [dom rng rest drest & {:keys [filter object mandatory-kws optional-kws]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;make-HMap&lt;/b&gt; ([mandatory optional])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-HMap [mandatory optional]&amp;lt;br&amp;gt;  (assert (= #{}&amp;lt;br&amp;gt;             (set/intersection (-&amp;gt; mandatory keys set)&amp;lt;br&amp;gt;                               (-&amp;gt; optional keys set))))&amp;lt;br&amp;gt;  (apply Un&amp;lt;br&amp;gt;         (for [ss (map #(into {} %) (comb/subsets optional))]&amp;lt;br&amp;gt;           (-hmap (merge mandatory ss)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-HMap</a>[mandatory optional]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;make-Result&lt;/b&gt; ([t] [t f] [t f o])&lt;br&gt; Make a result. ie. the range of a Function&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-Result&amp;lt;br&amp;gt;  &amp;quot;Make a result. ie. the range of a Function&amp;quot;&amp;lt;br&amp;gt;  ([t] (make-Result t nil nil))&amp;lt;br&amp;gt;  ([t f] (make-Result t f nil))&amp;lt;br&amp;gt;  ([t f o] (-&amp;gt;Result t (or f (-FS -top -top)) (or o (-&amp;gt;EmptyObject)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-Result</a>[t] [t f] [t f o]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;make-cset-entry&lt;/b&gt; ([fixed] [fixed dmap] [fixed dmap projections])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-cset-entry&amp;lt;br&amp;gt;  ([fixed] (make-cset-entry fixed nil nil))&amp;lt;br&amp;gt;  ([fixed dmap] (make-cset-entry fixed dmap nil))&amp;lt;br&amp;gt;  ([fixed dmap projections] (-&amp;gt;cset-entry fixed &amp;lt;br&amp;gt;                                          (or dmap (-&amp;gt;dmap {}))&amp;lt;br&amp;gt;                                          (or projections #{}))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-cset-entry</a>[fixed] [fixed dmap] [fixed dmap projections]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;make-simple-substitution&lt;/b&gt; ([vs ts])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-simple-substitution [vs ts]&amp;lt;br&amp;gt;  {:pre [(every? symbol? vs)&amp;lt;br&amp;gt;         (every? Type? ts)&amp;lt;br&amp;gt;         (= (count vs)&amp;lt;br&amp;gt;            (count ts))]}&amp;lt;br&amp;gt;  (into {} (for [[v t] (map vector vs ts)]&amp;lt;br&amp;gt;             [v (-&amp;gt;t-subst t no-bounds)])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-simple-substitution</a>[vs ts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;manual-inst&lt;/b&gt; ([ptype argtys])&lt;br&gt; Poly Type^n -&gt; Type&lt;br&gt;  Substitute the type parameters of the polymorphic type&lt;br&gt;  with given types&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn manual-inst &amp;lt;br&amp;gt;  &amp;quot;Poly Type^n -&amp;gt; Type&amp;lt;br&amp;gt;  Substitute the type parameters of the polymorphic type&amp;lt;br&amp;gt;  with given types&amp;quot;&amp;lt;br&amp;gt;  [ptype argtys]&amp;lt;br&amp;gt;  {:pre [((some-fn Poly? PolyDots?) ptype)&amp;lt;br&amp;gt;         (seq argtys)&amp;lt;br&amp;gt;         (every? Type? argtys)]&amp;lt;br&amp;gt;   :post [(Type? %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (Poly? ptype)&amp;lt;br&amp;gt;    (let [^Poly ptype ptype&amp;lt;br&amp;gt;          _ (assert (= (.nbound ptype) (count argtys)) (error-msg &amp;quot;Wrong number of arguments to instantiate polymorphic type&amp;quot;))&amp;lt;br&amp;gt;          names (repeatedly (.nbound ptype) gensym)&amp;lt;br&amp;gt;          body (Poly-body* names ptype)&amp;lt;br&amp;gt;          bbnds (Poly-bbnds* names ptype)]&amp;lt;br&amp;gt;      (doseq [[nme ty ^Bounds bnds] (map vector names argtys bbnds)]&amp;lt;br&amp;gt;        (if (.higher-kind bnds)&amp;lt;br&amp;gt;          (do &amp;lt;br&amp;gt;            (if (F? ty)&amp;lt;br&amp;gt;              (assert (and (TypeFn? (.higher-kind bnds))&amp;lt;br&amp;gt;                           (let [given-bnds (free-with-name-bnds (.name ^F ty))&amp;lt;br&amp;gt;                                 _ (assert given-bnds *free-scope*)]&amp;lt;br&amp;gt;                             (and (.higher-kind given-bnds)&amp;lt;br&amp;gt;                                  (subtype? (.higher-kind given-bnds) (.higher-kind bnds)))))&amp;lt;br&amp;gt;                      (error-msg &amp;quot;Must instantitate higher-order type variable with another higher-order type variable, given: &amp;quot;&amp;lt;br&amp;gt;                                 (unparse-type ty)))&amp;lt;br&amp;gt;              (do &amp;lt;br&amp;gt;                (assert (TypeFn? ty) (error-msg &amp;quot;Must instantiate higher-order type variable with type function, given:&amp;quot;&amp;lt;br&amp;gt;                                                (unparse-type ty)))&amp;lt;br&amp;gt;                (assert (subtype? ty (.higher-kind bnds))&amp;lt;br&amp;gt;                        (error-msg &amp;quot;Higher-order type variable &amp;quot; (unparse-type ty)&amp;lt;br&amp;gt;                                   &amp;quot; does not match bound &amp;quot; (unparse-type (.higher-kind bnds)))))))&amp;lt;br&amp;gt;          (let [lower-bound (substitute-many (.lower-bound bnds) argtys names)&amp;lt;br&amp;gt;                upper-bound (substitute-many (.upper-bound bnds) argtys names)]&amp;lt;br&amp;gt;            (assert (subtype? lower-bound upper-bound)&amp;lt;br&amp;gt;                    (error-msg &amp;quot;Lower-bound &amp;quot; (unparse-type lower-bound)&amp;lt;br&amp;gt;                               &amp;quot; is not below upper-bound &amp;quot; (unparse-type upper-bound)))&amp;lt;br&amp;gt;            (assert (and (subtype? ty upper-bound)&amp;lt;br&amp;gt;                         (subtype? lower-bound ty))&amp;lt;br&amp;gt;                    (error-msg &amp;quot;Manually instantiated type &amp;quot; (unparse-type ty)&amp;lt;br&amp;gt;                               &amp;quot; is not between bounds &amp;quot; (unparse-type lower-bound)&amp;lt;br&amp;gt;                               &amp;quot; and &amp;quot; (unparse-type upper-bound))))))&amp;lt;br&amp;gt;      (substitute-many body argtys names))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (PolyDots? ptype)&amp;lt;br&amp;gt;    (let [^PolyDots ptype ptype&amp;lt;br&amp;gt;          nrequired-types (dec (.nbound ptype))&amp;lt;br&amp;gt;          _ (assert (&amp;lt;= nrequired-types (count argtys)) &amp;quot;Insufficient arguments to instantiate dotted polymorphic type&amp;quot;)&amp;lt;br&amp;gt;          names (repeatedly (.nbound ptype) gensym)&amp;lt;br&amp;gt;          body (PolyDots-body* names ptype)&amp;lt;br&amp;gt;          bbnds (PolyDots-bbnds* names ptype)]&amp;lt;br&amp;gt;      (doseq [[nme ty ^Bounds bnds] (map vector names argtys bbnds)]&amp;lt;br&amp;gt;        (assert (not (.higher-kind bnds)) &amp;quot;NYI&amp;quot;)&amp;lt;br&amp;gt;        (let [lower-bound (substitute-many (.lower-bound bnds) argtys names)&amp;lt;br&amp;gt;              upper-bound (substitute-many (.upper-bound bnds) argtys names)]&amp;lt;br&amp;gt;          (assert (subtype? lower-bound upper-bound)&amp;lt;br&amp;gt;                  (error-msg &amp;quot;Lower-bound &amp;quot; (unparse-type lower-bound)&amp;lt;br&amp;gt;                             &amp;quot; is not below upper-bound &amp;quot; (unparse-type upper-bound)))&amp;lt;br&amp;gt;          (assert (and (subtype? ty upper-bound)&amp;lt;br&amp;gt;                       (subtype? lower-bound ty))&amp;lt;br&amp;gt;                  (error-msg &amp;quot;Manually instantiated type &amp;quot; (unparse-type ty)&amp;lt;br&amp;gt;                             &amp;quot; is not between bounds &amp;quot; (unparse-type lower-bound)&amp;lt;br&amp;gt;                             &amp;quot; and &amp;quot; (unparse-type upper-bound)))))&amp;lt;br&amp;gt;      (-&amp;gt; body&amp;lt;br&amp;gt;        ; expand dotted pre-types in body&amp;lt;br&amp;gt;        (trans-dots (last names) ;the bound&amp;lt;br&amp;gt;                    (drop (dec (:nbound ptype)) argtys)) ;the types to expand pre-type with&amp;lt;br&amp;gt;        ; substitute normal variables&amp;lt;br&amp;gt;        (substitute-many (take nrequired-types argtys) (butlast names))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">manual-inst</a>[ptype argtys]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;AndFilter&lt;/b&gt; ([{:as m__10949__auto__, :keys [fs]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord AndFilter [fs]&amp;lt;br&amp;gt;  &amp;quot;Logical conjunction of filters&amp;quot;&amp;lt;br&amp;gt;  [(set? fs)&amp;lt;br&amp;gt;   (seq fs)&amp;lt;br&amp;gt;   (every? Filter? fs)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->AndFilter</a>[{:as m__10949__auto__, :keys [fs]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;AnyValue&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord AnyValue []&amp;lt;br&amp;gt;  &amp;quot;Any Value&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->AnyValue</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;App&lt;/b&gt; ([{:as m__10949__auto__, :keys [rator rands]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord App [rator rands]&amp;lt;br&amp;gt;  &amp;quot;An application of a polymorphic type to type arguments&amp;quot;&amp;lt;br&amp;gt;  [(Type? rator)&amp;lt;br&amp;gt;   (every? Type? rands)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->App</a>[{:as m__10949__auto__, :keys [rator rands]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;ArrayCLJS&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ArrayCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive array in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->ArrayCLJS</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;B&lt;/b&gt; ([{:as m__10949__auto__, :keys [idx]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord B [idx]&amp;lt;br&amp;gt;  &amp;quot;A bound variable. Should not appear outside this file&amp;quot;&amp;lt;br&amp;gt;  [(nat? idx)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->B</a>[{:as m__10949__auto__, :keys [idx]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;BooleanCLJS&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord BooleanCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive boolean in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->BooleanCLJS</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;BotFilter&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord BotFilter []&amp;lt;br&amp;gt;  &amp;quot;Always false proposition&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->BotFilter</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Bounds&lt;/b&gt; ([{:as m__10949__auto__, :keys [upper-bound lower-bound higher-kind]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Bounds [upper-bound lower-bound higher-kind]&amp;lt;br&amp;gt;  &amp;quot;A type bound or higher-kind bound on a variable&amp;quot;&amp;lt;br&amp;gt;  [(some-fn (and (every? (some-fn Type? Scope?) [upper-bound lower-bound])&amp;lt;br&amp;gt;                 (nil? higher-kind))&amp;lt;br&amp;gt;            (and (every? nil? [upper-bound lower-bound])&amp;lt;br&amp;gt;                 (TypeFn? higher-kind)))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Bounds</a>[{:as m__10949__auto__, :keys [upper-bound lower-bound higher-kind]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;ClassPE&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ClassPE []&amp;lt;br&amp;gt;  &amp;quot;A path calling clojure.core/class&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->ClassPE</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;CountPE&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord CountPE []&amp;lt;br&amp;gt;  &amp;quot;A path calling clojure.core/count&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->CountPE</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;CountRange&lt;/b&gt; ([{:as m__10949__auto__, :keys [lower upper]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord CountRange [lower upper]&amp;lt;br&amp;gt;  &amp;quot;A sequence of count between lower and upper.&amp;lt;br&amp;gt;  If upper is nil, between lower and infinity.&amp;quot;&amp;lt;br&amp;gt;  [(nat? lower)&amp;lt;br&amp;gt;   (or (nil? upper)&amp;lt;br&amp;gt;       (and (nat? upper)&amp;lt;br&amp;gt;            (&amp;lt;= lower upper)))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->CountRange</a>[{:as m__10949__auto__, :keys [lower upper]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;DataType&lt;/b&gt; ([{:as m__10949__auto__, :keys [the-class variances poly? fields]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord DataType [the-class variances poly? fields]&amp;lt;br&amp;gt;  &amp;quot;A Clojure datatype&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? variances)&amp;lt;br&amp;gt;       (and (seq variances)&amp;lt;br&amp;gt;            (every? variance? variances)))&amp;lt;br&amp;gt;   (or (nil? poly?)&amp;lt;br&amp;gt;       (and (seq poly?)&amp;lt;br&amp;gt;            (every? Type? poly?)))&amp;lt;br&amp;gt;   (symbol? the-class)&amp;lt;br&amp;gt;   ((array-map-c? symbol? (some-fn Scope? Type?)) fields)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->DataType</a>[{:as m__10949__auto__, :keys [the-class variances poly? fields]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;DottedPretype&lt;/b&gt; ([{:as m__10949__auto__, :keys [pre-type name]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord DottedPretype [pre-type name]&amp;lt;br&amp;gt;  &amp;quot;A dotted pre-type. Not a type&amp;quot;&amp;lt;br&amp;gt;  [(Type? pre-type)&amp;lt;br&amp;gt;   ((some-fn symbol? nat?) name)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->DottedPretype</a>[{:as m__10949__auto__, :keys [pre-type name]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;EmptyObject&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord EmptyObject []&amp;lt;br&amp;gt;  &amp;quot;?&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->EmptyObject</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;F&lt;/b&gt; ([{:as m__10949__auto__, :keys [name]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord F [name]&amp;lt;br&amp;gt;  &amp;quot;A named free variable&amp;quot;&amp;lt;br&amp;gt;  [(symbol? name)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->F</a>[{:as m__10949__auto__, :keys [name]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;FilterSet&lt;/b&gt; ([{:as m__10949__auto__, :keys [then else]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FilterSet [then else]&amp;lt;br&amp;gt;  &amp;quot;A set of filters: those true when the expression is a true value, and &amp;lt;br&amp;gt;  those when it is a false value.&amp;quot;&amp;lt;br&amp;gt;  [(and (or (BotFilter? then)&amp;lt;br&amp;gt;            (and (BotFilter? else)&amp;lt;br&amp;gt;               (TopFilter? then))&amp;lt;br&amp;gt;            (Filter? then))&amp;lt;br&amp;gt;        (or (BotFilter? else)&amp;lt;br&amp;gt;            (and (BotFilter? then)&amp;lt;br&amp;gt;                 (TopFilter? else))&amp;lt;br&amp;gt;            (Filter? else)))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->FilterSet</a>[{:as m__10949__auto__, :keys [then else]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;FirstPE&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FirstPE []&amp;lt;br&amp;gt;  &amp;quot;A path calling clojure.core/first&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->FirstPE</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;FlowSet&lt;/b&gt; ([{:as m__10949__auto__, :keys [normal]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FlowSet [normal]&amp;lt;br&amp;gt;  &amp;quot;The filter that is true when an expression returns normally ie. not an exception.&amp;quot;&amp;lt;br&amp;gt;  [(Filter? normal)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->FlowSet</a>[{:as m__10949__auto__, :keys [normal]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;FnIntersection&lt;/b&gt; ([{:as m__10949__auto__, :keys [types]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FnIntersection [types]&amp;lt;br&amp;gt;  &amp;quot;An ordered intersection of Functions.&amp;quot;&amp;lt;br&amp;gt;  [(seq types)&amp;lt;br&amp;gt;   (sequential? types)&amp;lt;br&amp;gt;   (every? Function? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->FnIntersection</a>[{:as m__10949__auto__, :keys [types]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;FnResult&lt;/b&gt; ([{:as m__10949__auto__, :keys [args kws rest drest body]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FnResult [args kws rest drest body]&amp;lt;br&amp;gt;  &amp;quot;Results of checking a fn method&amp;quot;&amp;lt;br&amp;gt;  [(every? symbol? (map first args))&amp;lt;br&amp;gt;   (every? Type? (map second args))&amp;lt;br&amp;gt;   (nil? kws)&amp;lt;br&amp;gt;   ((some-fn nil? (hvector-c? symbol? Type?)) rest)&amp;lt;br&amp;gt;   (nil? drest)&amp;lt;br&amp;gt;   (TCResult? body)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->FnResult</a>[{:as m__10949__auto__, :keys [args kws rest drest body]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Function&lt;/b&gt; ([{:as m__10949__auto__, :keys [dom rng rest drest kws]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Function [dom rng rest drest kws]&amp;lt;br&amp;gt;  &amp;quot;A function arity, must be part of an intersection&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? dom)&amp;lt;br&amp;gt;       (sequential? dom))&amp;lt;br&amp;gt;   (every? Type? dom)&amp;lt;br&amp;gt;   (Result? rng)&amp;lt;br&amp;gt;   ;at most one of rest drest or kws can be provided&amp;lt;br&amp;gt;   (#{0 1} (count (filter identity [rest drest kws])))&amp;lt;br&amp;gt;   (or (nil? rest)&amp;lt;br&amp;gt;       (Type? rest))&amp;lt;br&amp;gt;   (or (nil? drest)&amp;lt;br&amp;gt;       (DottedPretype? drest))&amp;lt;br&amp;gt;   (or (nil? kws)&amp;lt;br&amp;gt;       (KwArgs? kws))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Function</a>[{:as m__10949__auto__, :keys [dom rng rest drest kws]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;FunctionCLJS&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord FunctionCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive function in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->FunctionCLJS</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;GTRange&lt;/b&gt; ([{:as m__10949__auto__, :keys [n]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord GTRange [n]&amp;lt;br&amp;gt;  &amp;quot;The type of all numbers greater than n&amp;quot;&amp;lt;br&amp;gt;  [(number? n)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->GTRange</a>[{:as m__10949__auto__, :keys [n]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;HeterogeneousList&lt;/b&gt; ([{:as m__10949__auto__, :keys [types]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord HeterogeneousList [types]&amp;lt;br&amp;gt;  &amp;quot;A constant list, clojure.lang.IPersistentList&amp;quot;&amp;lt;br&amp;gt;  [(sequential? types)&amp;lt;br&amp;gt;   (every? Type? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->HeterogeneousList</a>[{:as m__10949__auto__, :keys [types]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;HeterogeneousMap&lt;/b&gt; ([{:as m__10949__auto__, :keys [types other-keys?]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord HeterogeneousMap [types other-keys?]&amp;lt;br&amp;gt;  &amp;quot;A constant map, clojure.lang.IPersistentMap&amp;quot;&amp;lt;br&amp;gt;  [((hash-c? Value? (some-fn Type? Result?))&amp;lt;br&amp;gt;     types)&amp;lt;br&amp;gt;   (boolean? other-keys?)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->HeterogeneousMap</a>[{:as m__10949__auto__, :keys [types other-keys?]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;HeterogeneousSeq&lt;/b&gt; ([{:as m__10949__auto__, :keys [types]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord HeterogeneousSeq [types]&amp;lt;br&amp;gt;  &amp;quot;A constant seq, clojure.lang.ISeq&amp;quot;&amp;lt;br&amp;gt;  [(sequential? types)&amp;lt;br&amp;gt;   (every? Type? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->HeterogeneousSeq</a>[{:as m__10949__auto__, :keys [types]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;HeterogeneousVector&lt;/b&gt; ([{:as m__10949__auto__, :keys [types]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord HeterogeneousVector [types]&amp;lt;br&amp;gt;  &amp;quot;A constant vector, clojure.lang.IPersistentVector&amp;quot;&amp;lt;br&amp;gt;  [(vector? types)&amp;lt;br&amp;gt;   (every? (some-fn Type? Result?) types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->HeterogeneousVector</a>[{:as m__10949__auto__, :keys [types]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;ImpFilter&lt;/b&gt; ([{:as m__10949__auto__, :keys [a c]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ImpFilter [a c]&amp;lt;br&amp;gt;  &amp;quot;Antecedent (filter a) implies consequent (filter c)&amp;quot;&amp;lt;br&amp;gt;  [(Filter? a)&amp;lt;br&amp;gt;   (Filter? c)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->ImpFilter</a>[{:as m__10949__auto__, :keys [a c]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Intersection&lt;/b&gt; ([{:as m__10949__auto__, :keys [types]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Intersection [types]&amp;lt;br&amp;gt;  &amp;quot;An unordered intersection of types.&amp;quot;&amp;lt;br&amp;gt;  [(seq types)&amp;lt;br&amp;gt;   (every? Type? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Intersection</a>[{:as m__10949__auto__, :keys [types]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;KeyPE&lt;/b&gt; ([{:as m__10949__auto__, :keys [val]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord KeyPE [val]&amp;lt;br&amp;gt;  &amp;quot;A key in a hash-map&amp;quot;&amp;lt;br&amp;gt;  [(keyword? val)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->KeyPE</a>[{:as m__10949__auto__, :keys [val]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;KwArgs&lt;/b&gt; ([{:as m__10949__auto__, :keys [mandatory optional]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord KwArgs [mandatory optional]&amp;lt;br&amp;gt;  &amp;quot;A set of mandatory and optional keywords&amp;quot;&amp;lt;br&amp;gt;  [(every? (hash-c? Value? Type?) [mandatory optional])])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->KwArgs</a>[{:as m__10949__auto__, :keys [mandatory optional]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;LTRange&lt;/b&gt; ([{:as m__10949__auto__, :keys [n]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord LTRange [n]&amp;lt;br&amp;gt;  &amp;quot;The type of all numbers less than n&amp;quot;&amp;lt;br&amp;gt;  [(number? n)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->LTRange</a>[{:as m__10949__auto__, :keys [n]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;ListDots&lt;/b&gt; ([{:as m__10949__auto__, :keys [pre-type bound]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ListDots [pre-type bound]&amp;lt;br&amp;gt;  &amp;quot;A dotted list&amp;quot;&amp;lt;br&amp;gt;  [(Type? pre-type)&amp;lt;br&amp;gt;   ((some-fn F? B?) bound)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->ListDots</a>[{:as m__10949__auto__, :keys [pre-type bound]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Mu&lt;/b&gt; ([{:as m__10949__auto__, :keys [scope]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Mu [scope]&amp;lt;br&amp;gt;  &amp;quot;A recursive type containing one bound variable, itself&amp;quot;&amp;lt;br&amp;gt;  [(Scope? scope)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Mu</a>[{:as m__10949__auto__, :keys [scope]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Name&lt;/b&gt; ([{:as m__10949__auto__, :keys [id]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Name [id]&amp;lt;br&amp;gt;  &amp;quot;A late bound name&amp;quot;&amp;lt;br&amp;gt;  [((every-pred (some-fn namespace (fn [a] (some (fn [c] (= \. c)) (str a))))&amp;lt;br&amp;gt;                symbol?) &amp;lt;br&amp;gt;     id)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Name</a>[{:as m__10949__auto__, :keys [id]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;NextPE&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NextPE []&amp;lt;br&amp;gt;  &amp;quot;A path calling clojure.core/next&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->NextPE</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;NoFilter&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NoFilter []&amp;lt;br&amp;gt;  &amp;quot;Represents no info about filters, used for parsing types&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->NoFilter</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;NoObject&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NoObject []&amp;lt;br&amp;gt;  &amp;quot;Represents no info about the object of this expression&amp;lt;br&amp;gt;  should only be used for parsing type annotations and expected types&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->NoObject</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;NotType&lt;/b&gt; ([{:as m__10949__auto__, :keys [type]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NotType [type]&amp;lt;br&amp;gt;  &amp;quot;A type that does not include type&amp;quot;&amp;lt;br&amp;gt;  [(Type? type)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->NotType</a>[{:as m__10949__auto__, :keys [type]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;NotTypeFilter&lt;/b&gt; ([{:as m__10949__auto__, :keys [type path id]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NotTypeFilter [type path id]&amp;lt;br&amp;gt;  &amp;quot;A filter claiming looking up id, down the given path, is NOT of given type&amp;quot;&amp;lt;br&amp;gt;  [(Type? type)&amp;lt;br&amp;gt;   (every? PathElem? path)&amp;lt;br&amp;gt;   (name-ref? id)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->NotTypeFilter</a>[{:as m__10949__auto__, :keys [type path id]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;NumberCLJS&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord NumberCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive number in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->NumberCLJS</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;ObjectCLJS&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord ObjectCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive object in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->ObjectCLJS</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;OrFilter&lt;/b&gt; ([{:as m__10949__auto__, :keys [fs]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord OrFilter [fs]&amp;lt;br&amp;gt;  &amp;quot;Logical disjunction of filters&amp;quot;&amp;lt;br&amp;gt;  [(seq fs)&amp;lt;br&amp;gt;   (set? fs)&amp;lt;br&amp;gt;   (every? Filter? fs)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->OrFilter</a>[{:as m__10949__auto__, :keys [fs]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Path&lt;/b&gt; ([{:as m__10949__auto__, :keys [path id]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Path [path id]&amp;lt;br&amp;gt;  &amp;quot;A path to a variable. Paths grow to the right, with leftmost&amp;lt;br&amp;gt;  pathelem being applied first (think of -&amp;gt; threading operator).&amp;quot;&amp;lt;br&amp;gt;  [(or (and (seq path)&amp;lt;br&amp;gt;            (sequential? path))&amp;lt;br&amp;gt;       (nil? path))&amp;lt;br&amp;gt;   (every? PathElem? path)&amp;lt;br&amp;gt;   (name-ref? id)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Path</a>[{:as m__10949__auto__, :keys [path id]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Poly&lt;/b&gt; ([{:as m__10949__auto__, :keys [nbound bbnds scope actual-frees]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Poly [nbound bbnds scope actual-frees]&amp;lt;br&amp;gt;  &amp;quot;A polymorphic type containing n bound variables, with display names actual-frees&amp;quot;&amp;lt;br&amp;gt;  [(nat? nbound)&amp;lt;br&amp;gt;   (every? Bounds? bbnds)&amp;lt;br&amp;gt;   (every? symbol? actual-frees)&amp;lt;br&amp;gt;   (apply = nbound (map count [bbnds actual-frees]))&amp;lt;br&amp;gt;   (scope-depth? scope nbound)&amp;lt;br&amp;gt;   (Scope? scope)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Poly</a>[{:as m__10949__auto__, :keys [nbound bbnds scope actual-frees]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;PolyDots&lt;/b&gt; ([{:as m__10949__auto__, :keys [nbound bbnds scope]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord PolyDots [nbound bbnds ^Scope scope]&amp;lt;br&amp;gt;  &amp;quot;A polymorphic type containing n-1 bound variables and 1 ... variable&amp;quot;&amp;lt;br&amp;gt;  [(nat? nbound)&amp;lt;br&amp;gt;   (every? Bounds? bbnds)&amp;lt;br&amp;gt;   (= nbound (count bbnds))&amp;lt;br&amp;gt;   (scope-depth? scope nbound)&amp;lt;br&amp;gt;   (Scope? scope)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->PolyDots</a>[{:as m__10949__auto__, :keys [nbound bbnds scope]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;PrimitiveArray&lt;/b&gt; ([{:as m__10949__auto__, :keys [jtype input-type output-type]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord PrimitiveArray [jtype input-type output-type]&amp;lt;br&amp;gt;  &amp;quot;A Java Primitive array&amp;quot;&amp;lt;br&amp;gt;  [(class? jtype)&amp;lt;br&amp;gt;   (Type? input-type)&amp;lt;br&amp;gt;   (Type? output-type)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->PrimitiveArray</a>[{:as m__10949__auto__, :keys [jtype input-type output-type]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Projection&lt;/b&gt; ([{:as m__10949__auto__, :keys [afn ts]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Projection [afn ts]&amp;lt;br&amp;gt;  &amp;quot;Projects type variables as arguments to afn&amp;quot;&amp;lt;br&amp;gt;  [(fn? afn)&amp;lt;br&amp;gt;   (every? AnyType? ts)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Projection</a>[{:as m__10949__auto__, :keys [afn ts]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;PropEnv&lt;/b&gt; ([{:as m__10949__auto__, :keys [l props]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord PropEnv [l props]&amp;lt;br&amp;gt;  &amp;quot;A lexical environment l, props is a list of known propositions&amp;quot;&amp;lt;br&amp;gt;  [(lex-env? l)&amp;lt;br&amp;gt;   (set? props)&amp;lt;br&amp;gt;   (every? Filter? props)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->PropEnv</a>[{:as m__10949__auto__, :keys [l props]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Protocol&lt;/b&gt; ([{:as m__10949__auto__, :keys [the-var variances poly? on-class methods]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Protocol [the-var variances poly? on-class methods]&amp;lt;br&amp;gt;  &amp;quot;A Clojure Protocol&amp;quot;&amp;lt;br&amp;gt;  [(symbol? the-var)&amp;lt;br&amp;gt;   (or (nil? variances)&amp;lt;br&amp;gt;       (and (seq variances)&amp;lt;br&amp;gt;            (every? variance? variances)))&amp;lt;br&amp;gt;   (or (nil? poly?)&amp;lt;br&amp;gt;       (and (seq poly?)&amp;lt;br&amp;gt;            (every? Type? poly?)))&amp;lt;br&amp;gt;   (= (count poly?) (count variances))&amp;lt;br&amp;gt;   (symbol? on-class)&amp;lt;br&amp;gt;   ((hash-c? (every-pred symbol? (complement namespace)) Type?) methods)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Protocol</a>[{:as m__10949__auto__, :keys [the-var variances poly? on-class methods]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;RClass&lt;/b&gt; ([{:as m__10949__auto__, :keys [variances poly? the-class replacements unchecked-ancestors]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord RClass [variances poly? the-class replacements unchecked-ancestors]&amp;lt;br&amp;gt;  &amp;quot;A restricted class, where ancestors are&amp;lt;br&amp;gt;  (replace replacements (ancestors the-class))&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? variances)&amp;lt;br&amp;gt;       (and (seq variances)&amp;lt;br&amp;gt;            (sequential? variances)&amp;lt;br&amp;gt;            (every? variance? variances)))&amp;lt;br&amp;gt;   (or (nil? poly?)&amp;lt;br&amp;gt;       (and (seq poly?)&amp;lt;br&amp;gt;            (sequential? poly?)&amp;lt;br&amp;gt;            (every? Type? poly?)))&amp;lt;br&amp;gt;   (symbol? the-class)&amp;lt;br&amp;gt;   ((hash-c? symbol? (some-fn Type? Scope?)) replacements)&amp;lt;br&amp;gt;   ((set-c? (some-fn Type? Scope?)) unchecked-ancestors)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->RClass</a>[{:as m__10949__auto__, :keys [variances poly? the-class replacements unchecked-ancestors]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Record&lt;/b&gt; ([{:as m__10949__auto__, :keys [the-class variances poly? fields]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Record [the-class variances poly? fields]&amp;lt;br&amp;gt;  &amp;quot;A Clojure record&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? variances)&amp;lt;br&amp;gt;       (and (seq variances)&amp;lt;br&amp;gt;            (every? variance? variances)))&amp;lt;br&amp;gt;   (or (nil? poly?)&amp;lt;br&amp;gt;       (and (seq poly?)&amp;lt;br&amp;gt;            (every? Type? poly?)))&amp;lt;br&amp;gt;   (symbol? the-class)&amp;lt;br&amp;gt;   ((array-map-c? symbol? (some-fn Scope? Type?)) fields)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Record</a>[{:as m__10949__auto__, :keys [the-class variances poly? fields]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;RecurTarget&lt;/b&gt; ([{:as m__10949__auto__, :keys [dom rest drest kws]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord RecurTarget [dom rest drest kws]&amp;lt;br&amp;gt;  &amp;quot;A target for recur&amp;quot;&amp;lt;br&amp;gt;  [(every? Type? dom)&amp;lt;br&amp;gt;   ((some-fn nil? Type?) rest)&amp;lt;br&amp;gt;   (nil? drest) ;TODO&amp;lt;br&amp;gt;   (nil? kws)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->RecurTarget</a>[{:as m__10949__auto__, :keys [dom rest drest kws]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Result&lt;/b&gt; ([{:as m__10949__auto__, :keys [t fl o]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Result [t fl o]&amp;lt;br&amp;gt;  &amp;quot;A result type with filter f and object o. NOT a type.&amp;quot;&amp;lt;br&amp;gt;  [(Type? t)&amp;lt;br&amp;gt;   (Filter? fl)&amp;lt;br&amp;gt;   (RObject? o)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Result</a>[{:as m__10949__auto__, :keys [t fl o]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Scope&lt;/b&gt; ([{:as m__10949__auto__, :keys [body]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Scope [body]&amp;lt;br&amp;gt;  &amp;quot;A scope that contains one bound variable, can be nested. Not used directly&amp;quot;&amp;lt;br&amp;gt;  [((some-fn Type? Scope?) body)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Scope</a>[{:as m__10949__auto__, :keys [body]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;StringCLJS&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord StringCLJS []&amp;lt;br&amp;gt;  &amp;quot;Primitive string in CLJS&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->StringCLJS</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;SymbolCLJS&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord SymbolCLJS []&amp;lt;br&amp;gt;  &amp;quot;A type for Clojurescript symbols&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->SymbolCLJS</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;TApp&lt;/b&gt; ([{:as m__10949__auto__, :keys [rator rands]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TApp [rator rands]&amp;lt;br&amp;gt;  &amp;quot;An application of a type function to arguments.&amp;quot;&amp;lt;br&amp;gt;  [((some-fn Name? TypeFn? F? B?) rator)&amp;lt;br&amp;gt;   (every? (some-fn TypeFn? Type?) rands)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->TApp</a>[{:as m__10949__auto__, :keys [rator rands]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;TCResult&lt;/b&gt; ([{:as m__10949__auto__, :keys [t fl o flow]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TCResult [t fl o flow]&amp;lt;br&amp;gt;  &amp;quot;This record represents the result of typechecking an expression&amp;quot;&amp;lt;br&amp;gt;  [(Type? t)&amp;lt;br&amp;gt;   (FilterSet? fl)&amp;lt;br&amp;gt;   (RObject? o)&amp;lt;br&amp;gt;   (FlowSet? flow)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->TCResult</a>[{:as m__10949__auto__, :keys [t fl o flow]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Top&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Top []&amp;lt;br&amp;gt;  &amp;quot;The top type&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Top</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;TopFilter&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TopFilter []&amp;lt;br&amp;gt;  &amp;quot;Trivially true proposition&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->TopFilter</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;TopFunction&lt;/b&gt; ([{:as m__10949__auto__, :keys []}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TopFunction []&amp;lt;br&amp;gt;  &amp;quot;Supertype to all functions&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->TopFunction</a>[{:as m__10949__auto__, :keys []}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;TypeFilter&lt;/b&gt; ([{:as m__10949__auto__, :keys [type path id]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TypeFilter [type path id]&amp;lt;br&amp;gt;  &amp;quot;A filter claiming looking up id, down the given path, is of given type&amp;quot;&amp;lt;br&amp;gt;  [(Type? type)&amp;lt;br&amp;gt;   (every? PathElem? path)&amp;lt;br&amp;gt;   (name-ref? id)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->TypeFilter</a>[{:as m__10949__auto__, :keys [type path id]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;TypeFn&lt;/b&gt; ([{:as m__10949__auto__, :keys [nbound variances bbnds scope]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord TypeFn [nbound variances bbnds scope]&amp;lt;br&amp;gt;  &amp;quot;A type function containing n bound variables with variances.&amp;lt;br&amp;gt;  It is of a higher kind&amp;quot;&amp;lt;br&amp;gt;  [(nat? nbound)&amp;lt;br&amp;gt;   (every? variance? variances)&amp;lt;br&amp;gt;   (every? Bounds? bbnds)&amp;lt;br&amp;gt;   (apply = nbound (map count [variances bbnds]))&amp;lt;br&amp;gt;   (scope-depth? scope nbound)&amp;lt;br&amp;gt;   (Scope? scope)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->TypeFn</a>[{:as m__10949__auto__, :keys [nbound variances bbnds scope]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Union&lt;/b&gt; ([{:as m__10949__auto__, :keys [types]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Union [types]&amp;lt;br&amp;gt;  &amp;quot;An flattened, unordered union of types&amp;quot;&amp;lt;br&amp;gt;  [(set? types)&amp;lt;br&amp;gt;   (every? Type? types)&amp;lt;br&amp;gt;   (not (some Union? types))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Union</a>[{:as m__10949__auto__, :keys [types]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;Value&lt;/b&gt; ([{:as m__10949__auto__, :keys [val]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Value [val]&amp;lt;br&amp;gt;  &amp;quot;A Clojure value&amp;quot;&amp;lt;br&amp;gt;  [])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Value</a>[{:as m__10949__auto__, :keys [val]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;c&lt;/b&gt; ([{:as m__10949__auto__, :keys [S X T bnds]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord c [S X T bnds]&amp;lt;br&amp;gt;  &amp;quot;A type constraint on a variable within an upper and lower bound&amp;quot;&amp;lt;br&amp;gt;  [(Type? S)&amp;lt;br&amp;gt;   (symbol? X)&amp;lt;br&amp;gt;   (Type? T)&amp;lt;br&amp;gt;   (Bounds? bnds)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->c</a>[{:as m__10949__auto__, :keys [S X T bnds]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;cset&lt;/b&gt; ([{:as m__10949__auto__, :keys [maps]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord cset [maps]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? cset-entry? maps)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->cset</a>[{:as m__10949__auto__, :keys [maps]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;cset-entry&lt;/b&gt; ([{:as m__10949__auto__, :keys [fixed dmap projections]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord cset-entry [fixed dmap projections]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [((hash-c? symbol? c?) fixed)&amp;lt;br&amp;gt;   (dmap? dmap)&amp;lt;br&amp;gt;   ((set-c? (hvector-c? (some-fn Type? Projection?)&amp;lt;br&amp;gt;                        (some-fn Type? Projection?)))&amp;lt;br&amp;gt;     projections)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->cset-entry</a>[{:as m__10949__auto__, :keys [fixed dmap projections]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;dcon&lt;/b&gt; ([{:as m__10949__auto__, :keys [fixed rest]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord dcon [fixed rest]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? c? fixed)&amp;lt;br&amp;gt;   (or (nil? rest)&amp;lt;br&amp;gt;       (c? rest))])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->dcon</a>[{:as m__10949__auto__, :keys [fixed rest]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;dcon-dotted&lt;/b&gt; ([{:as m__10949__auto__, :keys [fixed dc dbound]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord dcon-dotted [fixed dc dbound]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? c? fixed)&amp;lt;br&amp;gt;   (c? dc)&amp;lt;br&amp;gt;   (F? dbound)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->dcon-dotted</a>[{:as m__10949__auto__, :keys [fixed dc dbound]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;dcon-exact&lt;/b&gt; ([{:as m__10949__auto__, :keys [fixed rest]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord dcon-exact [fixed rest]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? c? fixed)&amp;lt;br&amp;gt;   (c? rest)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->dcon-exact</a>[{:as m__10949__auto__, :keys [fixed rest]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;dmap&lt;/b&gt; ([{:as m__10949__auto__, :keys [map]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord dmap [map]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [((hash-c? symbol? dcon-c?) map)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->dmap</a>[{:as m__10949__auto__, :keys [map]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;i-subst&lt;/b&gt; ([{:as m__10949__auto__, :keys [types]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord i-subst [types]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? Type? types)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->i-subst</a>[{:as m__10949__auto__, :keys [types]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;i-subst-dotted&lt;/b&gt; ([{:as m__10949__auto__, :keys [types dty dbound]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord i-subst-dotted [types dty dbound]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(or (nil? types)&amp;lt;br&amp;gt;       (every? Type? types))&amp;lt;br&amp;gt;   (Type? dty)&amp;lt;br&amp;gt;   (F? dbound)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->i-subst-dotted</a>[{:as m__10949__auto__, :keys [types dty dbound]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;i-subst-starred&lt;/b&gt; ([{:as m__10949__auto__, :keys [types starred]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord i-subst-starred [types starred]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(every? Type? types)&amp;lt;br&amp;gt;   (Type? starred)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->i-subst-starred</a>[{:as m__10949__auto__, :keys [types starred]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;map-&gt;t-subst&lt;/b&gt; ([{:as m__10949__auto__, :keys [type bnds]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord t-subst [type bnds]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(Type? type)&amp;lt;br&amp;gt;   (Bounds? bnds)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->t-subst</a>[{:as m__10949__auto__, :keys [type bnds]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;meet&lt;/b&gt; ([s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn meet [s t] (In s t))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">meet</a>[s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;merge-locals&lt;/b&gt; ([env new])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn merge-locals [env new]&amp;lt;br&amp;gt;  (-&amp;gt; env&amp;lt;br&amp;gt;    (update-in [:l] #(merge % new))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">merge-locals</a>[env new]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;method-type&lt;/b&gt; ([mname])&lt;br&gt; Given a method symbol, print the core.typed types assigned to it&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn method-type &amp;lt;br&amp;gt;  &amp;quot;Given a method symbol, print the core.typed types assigned to it&amp;quot;&amp;lt;br&amp;gt;  [mname]&amp;lt;br&amp;gt;  (let [ms (-&amp;gt;&amp;gt; (reflect/type-reflect (Class/forName (namespace mname)))&amp;lt;br&amp;gt;             :members&amp;lt;br&amp;gt;             (filter #(and (instance? clojure.reflect.Method %)&amp;lt;br&amp;gt;                           (= (str (:name %)) (name mname))))&amp;lt;br&amp;gt;             set)&amp;lt;br&amp;gt;        _ (assert (seq ms) (str &amp;quot;Method &amp;quot; mname &amp;quot; not found&amp;quot;))]&amp;lt;br&amp;gt;    (prn &amp;quot;Method name:&amp;quot; mname)&amp;lt;br&amp;gt;    (doseq [m ms]&amp;lt;br&amp;gt;      (prn (unparse-type (Method-&amp;gt;Type m))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">method-type</a>[mname]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;move-rest-to-dmap&lt;/b&gt; ([cset dbound &amp; {:keys [exact]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn move-rest-to-dmap [cset dbound &amp;amp; {:keys [exact]}]&amp;lt;br&amp;gt;  {:pre [(cset? cset)&amp;lt;br&amp;gt;         (symbol? dbound)&amp;lt;br&amp;gt;         ((some-fn nil? true?) exact)]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  (mover cset dbound nil&amp;lt;br&amp;gt;         (fn [cmap dmap]&amp;lt;br&amp;gt;           ((if exact -&amp;gt;dcon-exact -&amp;gt;dcon)&amp;lt;br&amp;gt;              nil&amp;lt;br&amp;gt;              (if-let [c (cmap dbound)]&amp;lt;br&amp;gt;                c&amp;lt;br&amp;gt;                (throw (Exception. (str &amp;quot;No constraint for bound &amp;quot; dbound))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">move-rest-to-dmap</a>[cset dbound & {:keys [exact]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;move-vars+rest-to-dmap&lt;/b&gt; ([cset dbound vars &amp; {:keys [exact]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn move-vars+rest-to-dmap [cset dbound vars &amp;amp; {:keys [exact]}]&amp;lt;br&amp;gt;  {:pre [(cset? cset)&amp;lt;br&amp;gt;         (symbol? dbound)&amp;lt;br&amp;gt;         ((set-c? symbol?) vars)&amp;lt;br&amp;gt;         ((some-fn nil? true?) exact)]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  (mover cset dbound vars&amp;lt;br&amp;gt;         (fn [cmap dmap]&amp;lt;br&amp;gt;           ((if exact -&amp;gt;dcon-exact -&amp;gt;dcon)&amp;lt;br&amp;gt;              (doall&amp;lt;br&amp;gt;                (for [v vars]&amp;lt;br&amp;gt;                  (if-let [c (cmap v)]&amp;lt;br&amp;gt;                    c&amp;lt;br&amp;gt;                    (throw (Exception. (str &amp;quot;No constraint for new var &amp;quot; v))))))&amp;lt;br&amp;gt;              (if-let [c ((:map dmap) dbound)]&amp;lt;br&amp;gt;                (cond&amp;lt;br&amp;gt;                  (and (dcon? c)&amp;lt;br&amp;gt;                       (not (:fixed c))) (:rest c)&amp;lt;br&amp;gt;                  (and (dcon-exact? c)&amp;lt;br&amp;gt;                       (not (:fixed c))) (:rest c)&amp;lt;br&amp;gt;                  :else (throw (Exception. (str &amp;quot;did not a get a rest-only dcon when moving to the dmap&amp;quot;))))&amp;lt;br&amp;gt;                (throw (Exception. (str &amp;quot;No constraint for bound &amp;quot; dbound))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">move-vars+rest-to-dmap</a>[cset dbound vars & {:keys [exact]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;move-vars-to-dmap&lt;/b&gt; ([cset dbound vars])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn move-vars-to-dmap [cset dbound vars]&amp;lt;br&amp;gt;  {:pre [(cset? cset)&amp;lt;br&amp;gt;         (symbol? dbound)&amp;lt;br&amp;gt;         (every? symbol? vars)]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  (mover cset dbound vars&amp;lt;br&amp;gt;         (fn [cmap dmap]&amp;lt;br&amp;gt;           (-&amp;gt;dcon (doall (for [v vars]&amp;lt;br&amp;gt;                            (if-let [c (cmap v)]&amp;lt;br&amp;gt;                              c&amp;lt;br&amp;gt;                              (throw (Exception. (str &amp;quot;No constraint for new var &amp;quot; v))))))&amp;lt;br&amp;gt;                   nil))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">move-vars-to-dmap</a>[cset dbound vars]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;mover&lt;/b&gt; ([cset dbound vars f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mover [cset dbound vars f]&amp;lt;br&amp;gt;  {:pre [(cset? cset)&amp;lt;br&amp;gt;         (symbol? dbound)&amp;lt;br&amp;gt;         (every? symbol? vars)]&amp;lt;br&amp;gt;   :post [(cset? %)]}&amp;lt;br&amp;gt;  (-&amp;gt;cset (map&amp;lt;br&amp;gt;            (fn [{cmap :fixed dmap :dmap}]&amp;lt;br&amp;gt;              (-&amp;gt;cset-entry (apply dissoc cmap dbound vars)&amp;lt;br&amp;gt;                            (dmap-meet &amp;lt;br&amp;gt;                              (singleton-dmap &amp;lt;br&amp;gt;                                dbound&amp;lt;br&amp;gt;                                (f cmap dmap))&amp;lt;br&amp;gt;                              (-&amp;gt;dmap (dissoc (:map dmap) dbound)))&amp;lt;br&amp;gt;                            #{}))&amp;lt;br&amp;gt;            (:maps cset))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mover</a>[cset dbound vars f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;nilable-param&lt;/b&gt; ([msym mmap])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Override which parameters in qualified method msym may accept&lt;br&gt;  nilable values. If the parameter is a parameterised type or&lt;br&gt;  an Array, this also declares the parameterised types and the Array type as nilable.&lt;br&gt;&lt;br&gt;  mmap is a map mapping arity parameter number to a set of parameter&lt;br&gt;  positions (integers). If the map contains the key :all then this overrides&lt;br&gt;  other entries. The key can also be :all, which declares all parameters nilable.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro nilable-param &amp;lt;br&amp;gt;  &amp;quot;Override which parameters in qualified method msym may accept&amp;lt;br&amp;gt;  nilable values. If the parameter is a parameterised type or&amp;lt;br&amp;gt;  an Array, this also declares the parameterised types and the Array type as nilable.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  mmap is a map mapping arity parameter number to a set of parameter&amp;lt;br&amp;gt;  positions (integers). If the map contains the key :all then this overrides&amp;lt;br&amp;gt;  other entries. The key can also be :all, which declares all parameters nilable.&amp;quot;&amp;lt;br&amp;gt;  [msym mmap]&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;  (add-method-nilable-param '~msym '~mmap)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nilable-param</a>[msym mmap]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;nilable-param?&lt;/b&gt; ([sym arity param])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn nilable-param? [sym arity param]&amp;lt;br&amp;gt;  (boolean &amp;lt;br&amp;gt;    (when-let [nilables (@METHOD-PARAM-NILABLE-ENV sym)]&amp;lt;br&amp;gt;      (when-let [params (or (nilables :all)&amp;lt;br&amp;gt;                            (nilables arity))]&amp;lt;br&amp;gt;        (or (= :all params)&amp;lt;br&amp;gt;            (params param))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nilable-param?</a>[sym arity param]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;no-constraint&lt;/b&gt; ([v bnds])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn no-constraint [v bnds]&amp;lt;br&amp;gt;  {:pre [(symbol? v)&amp;lt;br&amp;gt;         (Bounds? bnds)]}&amp;lt;br&amp;gt;  (-&amp;gt;c (Un) v (-&amp;gt;Top) bnds))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">no-constraint</a>[v bnds]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;non-nil-return&lt;/b&gt; ([msym arities])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Override the return type of qualified method msym to be non-nil.&lt;br&gt;  Takes a set of relevant arities,&lt;br&gt;  represented by the number of parameters it takes (rest parameter counts as one),&lt;br&gt;  or :all which overrides all arities.&lt;br&gt;  &lt;br&gt;  eg.  (non-nil-return java.lang.Class/getDeclaredMethod :all)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro non-nil-return &amp;lt;br&amp;gt;  &amp;quot;Override the return type of qualified method msym to be non-nil.&amp;lt;br&amp;gt;  Takes a set of relevant arities,&amp;lt;br&amp;gt;  represented by the number of parameters it takes (rest parameter counts as one),&amp;lt;br&amp;gt;  or :all which overrides all arities.&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  eg.  (non-nil-return java.lang.Class/getDeclaredMethod :all)&amp;quot;&amp;lt;br&amp;gt;  [msym arities]&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;  (add-nonnilable-method-return '~msym '~arities)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">non-nil-return</a>[msym arities]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;nonnilable-return?&lt;/b&gt; ([sym arity])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn nonnilable-return? [sym arity]&amp;lt;br&amp;gt;  (let [as (@METHOD-RETURN-NONNILABLE-ENV sym)]&amp;lt;br&amp;gt;    (boolean (or (= :all as)&amp;lt;br&amp;gt;                 (when as&amp;lt;br&amp;gt;                   (as arity))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nonnilable-return?</a>[sym arity]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;open-Result&lt;/b&gt; ([{t :t, fs :fl, old-obj :o, :as r} objs &amp; [ts]])&lt;br&gt; Substitute ids for objs in Result t&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn open-Result &amp;lt;br&amp;gt;  &amp;quot;Substitute ids for objs in Result t&amp;quot;&amp;lt;br&amp;gt;  [{t :t fs :fl old-obj :o :as r} objs &amp;amp; [ts]]&amp;lt;br&amp;gt;  {:pre [(Result? r)&amp;lt;br&amp;gt;         (every? RObject? objs)&amp;lt;br&amp;gt;         ((some-fn FilterSet? NoFilter?) fs)&amp;lt;br&amp;gt;         (RObject? old-obj)&amp;lt;br&amp;gt;         ((some-fn nil? (every-c? Type?)) ts)]&amp;lt;br&amp;gt;   :post [((hvector-c? Type? FilterSet? RObject?) %)]}&amp;lt;br&amp;gt;;  (prn &amp;quot;open-result&amp;quot;)&amp;lt;br&amp;gt;;  (prn &amp;quot;result type&amp;quot; (unparse-type t))&amp;lt;br&amp;gt;;  (prn &amp;quot;result filterset&amp;quot; (unparse-filter-set fs))&amp;lt;br&amp;gt;;  (prn &amp;quot;result (old) object&amp;quot; old-obj)&amp;lt;br&amp;gt;;  (prn &amp;quot;objs&amp;quot; objs)&amp;lt;br&amp;gt;;  (prn &amp;quot;ts&amp;quot; (mapv unparse-type ts))&amp;lt;br&amp;gt;  (reduce (fn [[t fs old-obj] [[o k] arg-ty]]&amp;lt;br&amp;gt;            {:pre [(Type? t)&amp;lt;br&amp;gt;                   ((some-fn FilterSet? NoFilter?) fs)&amp;lt;br&amp;gt;                   (RObject? old-obj)&amp;lt;br&amp;gt;                   (integer? k)&amp;lt;br&amp;gt;                   (RObject? o)&amp;lt;br&amp;gt;                   ((some-fn false? Type?) arg-ty)]&amp;lt;br&amp;gt;             :post [((hvector-c? Type? FilterSet? RObject?) %)]}&amp;lt;br&amp;gt;            (let [r [(subst-type t k o true)&amp;lt;br&amp;gt;                     (subst-filter-set fs k o true arg-ty)&amp;lt;br&amp;gt;                     (subst-object old-obj k o true)]]&amp;lt;br&amp;gt;;              (prn [(unparse-type t) (unparse-filter-set fs) old-obj])&amp;lt;br&amp;gt;;              (prn &amp;quot;r&amp;quot; r)&amp;lt;br&amp;gt;              r))&amp;lt;br&amp;gt;          [t fs old-obj]&amp;lt;br&amp;gt;          ; this is just a sequence of pairs of [nat? RObject] and Type?&amp;lt;br&amp;gt;          ; Represents the object and type of each argument, and its position&amp;lt;br&amp;gt;          (map vector &amp;lt;br&amp;gt;               (map-indexed #(vector %2 %1) ;racket's is opposite..&amp;lt;br&amp;gt;                            objs)&amp;lt;br&amp;gt;               (if ts&amp;lt;br&amp;gt;                 ts&amp;lt;br&amp;gt;                 (repeat false)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">open-Result</a>[{t :t, fs :fl, old-obj :o, :as r} objs & [ts]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;opposite?&lt;/b&gt; ([f1 f2])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn opposite? [f1 f2]&amp;lt;br&amp;gt;  {:pre [(Filter? f1)&amp;lt;br&amp;gt;         (Filter? f2)]&amp;lt;br&amp;gt;   :post [(boolean? %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (and (TypeFilter? f1)&amp;lt;br&amp;gt;         (NotTypeFilter? f2))&amp;lt;br&amp;gt;    (let [{t1 :type p1 :path i1 :id} f1&amp;lt;br&amp;gt;          {t2 :type p2 :path i2 :id} f2]&amp;lt;br&amp;gt;      (and (= p1 p2)&amp;lt;br&amp;gt;           (= i1 i2)&amp;lt;br&amp;gt;           (subtype? t1 t2)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (and (NotTypeFilter? f1)&amp;lt;br&amp;gt;         (TypeFilter? f2))&amp;lt;br&amp;gt;    (let [{t2 :type p2 :path i2 :id} f1&amp;lt;br&amp;gt;          {t1 :type p1 :path i1 :id} f2]&amp;lt;br&amp;gt;      (and (= p1 p2)&amp;lt;br&amp;gt;           (= i1 i2)&amp;lt;br&amp;gt;           (subtype? t1 t2)))&amp;lt;br&amp;gt;    :else false))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">opposite?</a>[f1 f2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;overlap&lt;/b&gt; ([t1 t2])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn overlap [t1 t2]&amp;lt;br&amp;gt;  (let [t1 (fully-resolve-type t1)&amp;lt;br&amp;gt;        t2 (fully-resolve-type t2)&amp;lt;br&amp;gt;        eq (= t1 t2)&amp;lt;br&amp;gt;        hmap-and-seq? (fn [h s] (and (HeterogeneousMap? h)&amp;lt;br&amp;gt;                                     (RClass? s)&amp;lt;br&amp;gt;                                     (= (Class-&amp;gt;symbol clojure.lang.ISeq) (:the-class s))))&amp;lt;br&amp;gt;        hvec-and-seq? (fn [h s] (and (HeterogeneousVector? h)&amp;lt;br&amp;gt;                                     (RClass? s)&amp;lt;br&amp;gt;                                     (= (Class-&amp;gt;symbol clojure.lang.ISeq) (:the-class s))))]&amp;lt;br&amp;gt;    (cond &amp;lt;br&amp;gt;      eq eq&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (Value? t1)&amp;lt;br&amp;gt;           (Value? t2))&amp;lt;br&amp;gt;      eq&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;if both are Classes, and at least one isn't an interface, then they must be subtypes to have overlap&amp;lt;br&amp;gt;      (and (RClass? t1)&amp;lt;br&amp;gt;           (RClass? t2)&amp;lt;br&amp;gt;           (let [{t1-flags :flags} (reflect/type-reflect (RClass-&amp;gt;Class t1))&amp;lt;br&amp;gt;                 {t2-flags :flags} (reflect/type-reflect (RClass-&amp;gt;Class t2))]&amp;lt;br&amp;gt;             (some (complement :interface) [t1-flags t2-flags])))&amp;lt;br&amp;gt;      (or (subtype? t1 t2)&amp;lt;br&amp;gt;          (subtype? t2 t1))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (or (Value? t1)&amp;lt;br&amp;gt;          (Value? t2)) &amp;lt;br&amp;gt;      (or (subtype? t1 t2)&amp;lt;br&amp;gt;          (subtype? t2 t1))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (CountRange? t1)&amp;lt;br&amp;gt;           (CountRange? t2)) &amp;lt;br&amp;gt;      (countrange-overlap? t1 t2)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (Union? t1)&amp;lt;br&amp;gt;      (boolean &amp;lt;br&amp;gt;        (some #(overlap % t2) (.types ^Union t1)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (Union? t2)&amp;lt;br&amp;gt;      (boolean &amp;lt;br&amp;gt;        (some #(overlap t1 %) (.types ^Union t2)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (Intersection? t1)&amp;lt;br&amp;gt;      (every? #(overlap % t2) (.types ^Intersection t1))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (Intersection? t2)&amp;lt;br&amp;gt;      (every? #(overlap t1 %) (.types ^Intersection t2))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (HeterogeneousMap? t1)&amp;lt;br&amp;gt;           (HeterogeneousMap? t2)) &amp;lt;br&amp;gt;      (and (= (set (-&amp;gt; t1 :types keys))&amp;lt;br&amp;gt;              (set (-&amp;gt; t2 :types keys)))&amp;lt;br&amp;gt;           (every? true?&amp;lt;br&amp;gt;                   (for [[k1 v1] (:types t1)]&amp;lt;br&amp;gt;                     (let [v2 ((:types t2) k1)]&amp;lt;br&amp;gt;                       (overlap v1 v2)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;for map destructuring mexpansion&amp;lt;br&amp;gt;      (or (hmap-and-seq? t1 t2)&amp;lt;br&amp;gt;          (hmap-and-seq? t2 t1))&amp;lt;br&amp;gt;      false&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;for vector destructuring mexpansion&amp;lt;br&amp;gt;      (or (hvec-and-seq? t1 t2)&amp;lt;br&amp;gt;          (hvec-and-seq? t2 t1))&amp;lt;br&amp;gt;      false&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      :else true)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">overlap</a>[t1 t2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;override-constructor&lt;/b&gt; ([ctorsym typesyn])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro override-constructor [ctorsym typesyn]&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;   (do (ensure-clojure)&amp;lt;br&amp;gt;     (let [t# (parse-type '~typesyn)&amp;lt;br&amp;gt;           s# '~ctorsym]&amp;lt;br&amp;gt;       (do (add-constructor-override s# t#)&amp;lt;br&amp;gt;         [s# (unparse-type t#)])))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">override-constructor</a>[ctorsym typesyn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;override-method&lt;/b&gt; ([methodsym typesyn])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro override-method [methodsym typesyn]&amp;lt;br&amp;gt;  `(tc-ignore&amp;lt;br&amp;gt;   (do (ensure-clojure)&amp;lt;br&amp;gt;     (let [t# (parse-type '~typesyn)&amp;lt;br&amp;gt;           s# (if (namespace '~methodsym)&amp;lt;br&amp;gt;                '~methodsym&amp;lt;br&amp;gt;                (throw (Exception. &amp;quot;Method name must be a qualified symbol&amp;quot;)))]&amp;lt;br&amp;gt;       (do (add-method-override s# t#)&amp;lt;br&amp;gt;         [s# (unparse-type t#)])))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">override-method</a>[methodsym typesyn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;parse-RClass&lt;/b&gt; ([cls-sym params-syn])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-RClass [cls-sym params-syn]&amp;lt;br&amp;gt;  (let [cls (resolve-type cls-sym)&amp;lt;br&amp;gt;        _ (assert (class? cls) (str cls-sym &amp;quot; cannot be resolved&amp;quot;))&amp;lt;br&amp;gt;        tparams (doall (map parse-type params-syn))]&amp;lt;br&amp;gt;    (RClass-of cls tparams)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-RClass</a>[cls-sym params-syn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;parse-RClass-binder&lt;/b&gt; ([bnds])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-RClass-binder [bnds]&amp;lt;br&amp;gt;  (for [[nme &amp;amp; {:keys [variance]}] bnds]&amp;lt;br&amp;gt;    [variance (make-F nme)]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-RClass-binder</a>[bnds]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;parse-field&lt;/b&gt; ([[n _ t]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-field [[n _ t]]&amp;lt;br&amp;gt;  [n (parse-type t)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-field</a>[[n _ t]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;parse-filter-set&lt;/b&gt; ([{:keys [then else], :as fsyn}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-filter-set [{:keys [then else] :as fsyn}]&amp;lt;br&amp;gt;  (-FS (if then&amp;lt;br&amp;gt;         (parse-filter then)&amp;lt;br&amp;gt;         -top)&amp;lt;br&amp;gt;       (if else&amp;lt;br&amp;gt;         (parse-filter else)&amp;lt;br&amp;gt;         -top)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-filter-set</a>[{:keys [then else], :as fsyn}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;parse-fn-intersection-type&lt;/b&gt; ([[Fn &amp; types]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-fn-intersection-type [[Fn &amp;amp; types]]&amp;lt;br&amp;gt;  (apply make-FnIntersection (mapv parse-function types)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-fn-intersection-type</a>[[Fn & types]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;parse-free&lt;/b&gt; ([f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-free [f]&amp;lt;br&amp;gt;  {:post [(hvector-c? symbol? Bounds?)]}&amp;lt;br&amp;gt;  (if (symbol? f)&amp;lt;br&amp;gt;    [f no-bounds]&amp;lt;br&amp;gt;    (let [[n &amp;amp; opts] f&amp;lt;br&amp;gt;          {upp :&amp;lt;&amp;lt;br&amp;gt;           low :&amp;gt;&amp;lt;br&amp;gt;           kind :kind} (apply hash-map opts)]&amp;lt;br&amp;gt;      [n (-&amp;gt;Bounds&amp;lt;br&amp;gt;           (when-not kind&amp;lt;br&amp;gt;             (if upp &amp;lt;br&amp;gt;               (parse-type upp)&amp;lt;br&amp;gt;               (-&amp;gt;Top)) )&amp;lt;br&amp;gt;           (when-not kind&amp;lt;br&amp;gt;             (if low&amp;lt;br&amp;gt;               (parse-type low)&amp;lt;br&amp;gt;               (Bottom)))&amp;lt;br&amp;gt;           (when kind&amp;lt;br&amp;gt;             (parse-type kind)))])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-free</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;parse-function&lt;/b&gt; ([f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-function [f]&amp;lt;br&amp;gt;  {:post [(Function? %)]}&amp;lt;br&amp;gt;  (let [all-dom (take-while #(not= '-&amp;gt; %) f)&amp;lt;br&amp;gt;        [_ rng &amp;amp; opts-flat :as chk] (drop-while #(not= '-&amp;gt; %) f) ;opts aren't used yet&amp;lt;br&amp;gt;        _ (assert (&amp;lt;= 2 (count chk)) (str &amp;quot;Missing range in &amp;quot; f))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        opts (apply hash-map opts-flat)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        {ellipsis-pos '...&amp;lt;br&amp;gt;         asterix-pos '*&amp;lt;br&amp;gt;         ampersand-pos '&amp;amp;}&amp;lt;br&amp;gt;        (zipmap all-dom (range))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        _ (assert (#{0 1} (count (filter identity [asterix-pos ellipsis-pos ampersand-pos])))&amp;lt;br&amp;gt;                  &amp;quot;Can only provide one rest argument option: &amp;amp;, ... or *&amp;quot;)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        _ (when-let [ks (seq (remove #{:filters :object} (keys opts)))]&amp;lt;br&amp;gt;            (throw (Exception. (str &amp;quot;Invalid option/s: &amp;quot; ks))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        filters (when-let [[_ fsyn] (find opts :filters)]&amp;lt;br&amp;gt;                  (parse-filter-set fsyn))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        object (when-let [[_ obj] (find opts :object)]&amp;lt;br&amp;gt;                 (parse-object obj))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        fixed-dom (cond &amp;lt;br&amp;gt;                    asterix-pos (take (dec asterix-pos) all-dom)&amp;lt;br&amp;gt;                    ellipsis-pos (take (dec ellipsis-pos) all-dom)&amp;lt;br&amp;gt;                    ampersand-pos (take ampersand-pos all-dom)&amp;lt;br&amp;gt;                    :else all-dom)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        rest-type (when asterix-pos&amp;lt;br&amp;gt;                    (nth all-dom (dec asterix-pos)))&amp;lt;br&amp;gt;        [drest-type _ drest-bnd] (when ellipsis-pos&amp;lt;br&amp;gt;                                   (drop (dec ellipsis-pos) all-dom))&amp;lt;br&amp;gt;        [optional-kws &amp;amp; {mandatory-kws :mandatory}] (when ampersand-pos&amp;lt;br&amp;gt;                                                      (drop (inc ampersand-pos) all-dom))]&amp;lt;br&amp;gt;    (make-Function (mapv parse-type fixed-dom)&amp;lt;br&amp;gt;                   (parse-type rng)&amp;lt;br&amp;gt;                   (when asterix-pos&amp;lt;br&amp;gt;                     (parse-type rest-type))&amp;lt;br&amp;gt;                   (when ellipsis-pos&amp;lt;br&amp;gt;                     (-&amp;gt;DottedPretype&amp;lt;br&amp;gt;                       (with-frees [(*dotted-scope* drest-bnd)] ;with dotted bound in scope as free&amp;lt;br&amp;gt;                         (parse-type drest-type))&amp;lt;br&amp;gt;                       (:name (*dotted-scope* drest-bnd))))&amp;lt;br&amp;gt;                   :filter filters&amp;lt;br&amp;gt;                   :object object&amp;lt;br&amp;gt;                   :optional-kws (when optional-kws&amp;lt;br&amp;gt;                                   (parse-kw-map optional-kws))&amp;lt;br&amp;gt;                   :mandatory-kws (when mandatory-kws&amp;lt;br&amp;gt;                                    (parse-kw-map mandatory-kws)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-function</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;parse-intersection-type&lt;/b&gt; ([[i &amp; types]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-intersection-type [[i &amp;amp; types]]&amp;lt;br&amp;gt;  (apply In (doall (map parse-type types))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-intersection-type</a>[[i & types]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;parse-object&lt;/b&gt; ([{:keys [id path]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-object [{:keys [id path]}]&amp;lt;br&amp;gt;  (-&amp;gt;Path (when path (mapv parse-path-elem path)) id))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-object</a>[{:keys [id path]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;parse-rec-type&lt;/b&gt; ([[rec [free-symbol :as bnder] type]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-rec-type [[rec [free-symbol :as bnder] type]]&amp;lt;br&amp;gt;  (let [_ (assert (= 1 (count bnder)) &amp;quot;Only one variable in allowed: Rec&amp;quot;)&amp;lt;br&amp;gt;        f (make-F free-symbol)&amp;lt;br&amp;gt;        body (with-frees [f]&amp;lt;br&amp;gt;               (parse-type type))&amp;lt;br&amp;gt;        &amp;lt;br&amp;gt;        _ (check-forbidden-rec f body)]&amp;lt;br&amp;gt;    (Mu* (:name f) body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-rec-type</a>[[rec [free-symbol :as bnder] type]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;parse-type-fn&lt;/b&gt; ([[_ binder bodysyn :as tfn]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-type-fn &amp;lt;br&amp;gt;  [[_ binder bodysyn :as tfn]]&amp;lt;br&amp;gt;  (assert (= 3 (count tfn)))&amp;lt;br&amp;gt;  (assert (every? vector? binder))&amp;lt;br&amp;gt;  (let [free-maps (for [[nme &amp;amp; {:keys [variance &amp;lt; &amp;gt; kind] :as opts}] binder]&amp;lt;br&amp;gt;                    (do&amp;lt;br&amp;gt;                      (assert nme)&amp;lt;br&amp;gt;                      {:nme nme :variance (or variance :invariant)&amp;lt;br&amp;gt;                       :bound (map-&amp;gt;Bounds &amp;lt;br&amp;gt;                                {:upper-bound (when-not kind&amp;lt;br&amp;gt;                                                (if (contains? opts :&amp;lt;)&amp;lt;br&amp;gt;                                                  (parse-type &amp;lt;)&amp;lt;br&amp;gt;                                                  -any))&amp;lt;br&amp;gt;                                 :lower-bound (when-not kind&amp;lt;br&amp;gt;                                                (if (contains? opts :&amp;gt;) &amp;lt;br&amp;gt;                                                  (parse-type &amp;gt;)&amp;lt;br&amp;gt;                                                  -nothing))&amp;lt;br&amp;gt;                                 :higher-kind (when kind&amp;lt;br&amp;gt;                                                (parse-type kind))})}))&amp;lt;br&amp;gt;        bodyt (with-bounded-frees (map (fn [{:keys [nme bound]}] [(make-F nme) bound])&amp;lt;br&amp;gt;                                       free-maps)&amp;lt;br&amp;gt;                (parse-type bodysyn))&amp;lt;br&amp;gt;        vs (with-bounded-frees (map (fn [{:keys [nme bound]}] [(make-F nme) bound])&amp;lt;br&amp;gt;                                    free-maps)&amp;lt;br&amp;gt;             (fv-variances bodyt))&amp;lt;br&amp;gt;        _ (doseq [{:keys [nme variance]} free-maps]&amp;lt;br&amp;gt;            (when-let [actual-v (vs nme)]&amp;lt;br&amp;gt;              (assert (= (vs nme) variance)&amp;lt;br&amp;gt;                      (error-msg &amp;quot;Type variable &amp;quot; nme &amp;quot; appears in &amp;quot; (name actual-v) &amp;quot; position &amp;quot;&amp;lt;br&amp;gt;                                 &amp;quot;when declared &amp;quot; (name variance)))))]&amp;lt;br&amp;gt;    (with-meta (TypeFn* (map :nme free-maps) (map :variance free-maps)&amp;lt;br&amp;gt;                        (map :bound free-maps) bodyt)&amp;lt;br&amp;gt;               {:actual-frees (map :nme free-maps)})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-type-fn</a>[[_ binder bodysyn :as tfn]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;parse-union-type&lt;/b&gt; ([[u &amp; types]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-union-type [[u &amp;amp; types]]&amp;lt;br&amp;gt;  (apply Un (doall (map parse-type types))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-union-type</a>[[u & types]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;pfn&gt;&lt;/b&gt; ([&amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a polymorphic typed anonymous function.&lt;br&gt;  (pfn&gt; name? [binder+] :- type? [[param :- type]* &amp; [param :- type *]?] exprs*)&lt;br&gt;  (pfn&gt; name? [binder+] (:- type? [[param :- type]* &amp; [param :- type *]?] exprs*)+)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro pfn&amp;gt; &amp;lt;br&amp;gt;  &amp;quot;Define a polymorphic typed anonymous function.&amp;lt;br&amp;gt;  (pfn&amp;gt; name? [binder+] :- type? [[param :- type]* &amp;amp; [param :- type *]?] exprs*)&amp;lt;br&amp;gt;  (pfn&amp;gt; name? [binder+] (:- type? [[param :- type]* &amp;amp; [param :- type *]?] exprs*)+)&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; forms]&amp;lt;br&amp;gt;  (let [{:keys [poly fn parsed-methods]} (parse-fn&amp;gt; true forms)]&amp;lt;br&amp;gt;    `(pfn&amp;gt;-ann ~fn '~poly '~parsed-methods)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pfn></a>[& forms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;pfn&gt;-ann&lt;/b&gt; ([fn-of polys param-types-syn])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pfn&amp;gt;-ann [fn-of polys param-types-syn]&amp;lt;br&amp;gt;  fn-of)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pfn>-ann</a>[fn-of polys param-types-syn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;plainapp-type-error&lt;/b&gt; ([fexpr args fexpr-type arg-ret-types expected])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String plainapp-type-error [fexpr args fexpr-type arg-ret-types expected]&amp;lt;br&amp;gt;  {:pre [(FnIntersection? fexpr-type)]}&amp;lt;br&amp;gt;  (app-type-error fexpr args fexpr-type arg-ret-types expected false))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">plainapp-type-error</a>[fexpr args fexpr-type arg-ret-types expected]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;polyapp-type-error&lt;/b&gt; ([fexpr args fexpr-type arg-ret-types expected])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String polyapp-type-error [fexpr args fexpr-type arg-ret-types expected]&amp;lt;br&amp;gt;  {:pre [(Poly? fexpr-type)]}&amp;lt;br&amp;gt;  (let [fin (Poly-body* (Poly-free-names* fexpr-type) fexpr-type)]&amp;lt;br&amp;gt;    (app-type-error fexpr args fin arg-ret-types expected true)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">polyapp-type-error</a>[fexpr args fexpr-type arg-ret-types expected]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;print-env&lt;/b&gt; ([debug-str])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-env [debug-str]&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-env</a>[debug-str]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;print-env*&lt;/b&gt; ([] [e])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-env*&amp;lt;br&amp;gt;  ([] (print-env* *lexical-env*))&amp;lt;br&amp;gt;  ([e]&amp;lt;br&amp;gt;   {:pre [(PropEnv? e)]}&amp;lt;br&amp;gt;   ;; DO NOT REMOVE&amp;lt;br&amp;gt;   (prn {:env (into {} (for [[k v] (:l e)]&amp;lt;br&amp;gt;                         [k (unparse-type v)]))&amp;lt;br&amp;gt;         :props (map unparse-filter (:props e))})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-env*</a>[] [e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;print-filterset&lt;/b&gt; ([debug-string frm])&lt;br&gt; Print the filter set attached to form, and debug-string&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-filterset&amp;lt;br&amp;gt;  &amp;quot;Print the filter set attached to form, and debug-string&amp;quot;&amp;lt;br&amp;gt;  [debug-string frm] &amp;lt;br&amp;gt;  frm)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-filterset</a>[debug-string frm]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;promote-F&lt;/b&gt; ([V X Y S {:keys [name], :as T}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn promote-F [V X Y S {:keys [name] :as T}]&amp;lt;br&amp;gt;  {:pre [(F? T)]}&amp;lt;br&amp;gt;  ;T is an F&amp;lt;br&amp;gt;  ;S is any Type&amp;lt;br&amp;gt;  ;constrain T to be above S (but don't mention V)&amp;lt;br&amp;gt;  (assert (contains? X name) (str X T))&amp;lt;br&amp;gt;  (when (and (F? S)&amp;lt;br&amp;gt;             (bound-index? (:name S))&amp;lt;br&amp;gt;             (not (free-in-scope (:name S))))&amp;lt;br&amp;gt;    (type-error S T))&amp;lt;br&amp;gt;  (let [ps (promote-var S V)]&amp;lt;br&amp;gt;    (-&amp;gt; (empty-cset X Y)&amp;lt;br&amp;gt;      (insert-constraint name ps -any (X name)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">promote-F</a>[V X Y S {:keys [name], :as T}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;promote-var&lt;/b&gt; ([T V])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn promote-var [T V]&amp;lt;br&amp;gt;  {:pre [(Type? T)&amp;lt;br&amp;gt;         (set? V)&amp;lt;br&amp;gt;         (every? symbol? V)]&amp;lt;br&amp;gt;   :post [(Type? %)]}&amp;lt;br&amp;gt;  (promote T V))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">promote-var</a>[T V]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;relevant-Fns&lt;/b&gt; ([required-params rest-param fin])&lt;br&gt; Given a set of required-param exprs, rest-param expr, and a FnIntersection,&lt;br&gt;  returns a seq of Functions containing Function types&lt;br&gt;  whos arities could be a subtype to the method with the fixed and rest parameters given&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn relevant-Fns&amp;lt;br&amp;gt;  &amp;quot;Given a set of required-param exprs, rest-param expr, and a FnIntersection,&amp;lt;br&amp;gt;  returns a seq of Functions containing Function types&amp;lt;br&amp;gt;  whos arities could be a subtype to the method with the fixed and rest parameters given&amp;quot;&amp;lt;br&amp;gt;  [required-params rest-param fin]&amp;lt;br&amp;gt;  {:pre [(FnIntersection? fin)]&amp;lt;br&amp;gt;   :post [(every? Function? %)]}&amp;lt;br&amp;gt;  (assert (not (some :drest (:types fin))))&amp;lt;br&amp;gt;  (let [nreq (count required-params)]&amp;lt;br&amp;gt;    ;(prn &amp;quot;nreq&amp;quot; nreq)&amp;lt;br&amp;gt;    ;(prn &amp;quot;rest-param&amp;quot; rest-param)&amp;lt;br&amp;gt;    (filter (fn [{:keys [dom rest]}]&amp;lt;br&amp;gt;              (if rest-param &amp;lt;br&amp;gt;                (and rest (&amp;lt;= nreq (count dom)))&amp;lt;br&amp;gt;                (and (not rest) (= nreq (count dom)))))&amp;lt;br&amp;gt;            (:types fin))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">relevant-Fns</a>[required-params rest-param fin]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;remove*&lt;/b&gt; ([old rem])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove* [old rem]&amp;lt;br&amp;gt;  (let [initial (if (subtype? old rem)&amp;lt;br&amp;gt;                  (Un) ;the empty type&amp;lt;br&amp;gt;                  (cond&amp;lt;br&amp;gt;                    ;FIXME TR also tests for App? here. ie (or (Name? old) (App? old))&amp;lt;br&amp;gt;                    (Name? old) ;; must be different, since they're not subtypes &amp;lt;br&amp;gt;                                ;; and n must refer to a distinct struct type&amp;lt;br&amp;gt;                    old&amp;lt;br&amp;gt;                    (Union? old) (let [l (:types old)]&amp;lt;br&amp;gt;                                   (apply Un (map (fn [e] (remove* e rem)) l)))&amp;lt;br&amp;gt;                    (Mu? old) (remove* (unfold old) rem)&amp;lt;br&amp;gt;                    (Poly? old) (let [vs (repeatedly (:nbound old) gensym)&amp;lt;br&amp;gt;                                      b (Poly-body* vs old)]&amp;lt;br&amp;gt;                                  (Poly* vs &amp;lt;br&amp;gt;                                         (Poly-bbnds* vs old)&amp;lt;br&amp;gt;                                         (remove* b rem)&amp;lt;br&amp;gt;                                         (Poly-free-names* old)))&amp;lt;br&amp;gt;                    :else old))]&amp;lt;br&amp;gt;    (if (subtype? old initial) old initial)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove*</a>[old rem]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;remove-opposite&lt;/b&gt; ([and-f atom-f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove-opposite [and-f atom-f]&amp;lt;br&amp;gt;  {:pre [(Filter? and-f)&amp;lt;br&amp;gt;         (Filter? atom-f)]&amp;lt;br&amp;gt;   :post [(Filter? %)]}&amp;lt;br&amp;gt;  (if (AndFilter? and-f)&amp;lt;br&amp;gt;    (apply -and (remove #(opposite? % atom-f) (:fs and-f)))&amp;lt;br&amp;gt;    and-f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove-opposite</a>[and-f atom-f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;remove-scopes&lt;/b&gt; ([n sc])&lt;br&gt; Unwrap n Scopes&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove-scopes &amp;lt;br&amp;gt;  &amp;quot;Unwrap n Scopes&amp;quot;&amp;lt;br&amp;gt;  [n sc]&amp;lt;br&amp;gt;  {:pre [(nat? n)&amp;lt;br&amp;gt;         (or (zero? n)&amp;lt;br&amp;gt;             (Scope? sc))]&amp;lt;br&amp;gt;   :post [(or (Scope? %) (Type? %))]}&amp;lt;br&amp;gt;  (doall&amp;lt;br&amp;gt;    (last&amp;lt;br&amp;gt;      (take (inc n) (iterate (fn [t]&amp;lt;br&amp;gt;                               (assert (Scope? t) &amp;quot;Tried to remove too many Scopes&amp;quot;)&amp;lt;br&amp;gt;                               (:body t))&amp;lt;br&amp;gt;                             sc)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove-scopes</a>[n sc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;requires-resolving?&lt;/b&gt; ([ty])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn requires-resolving? [ty]&amp;lt;br&amp;gt;  (or (Name? ty)&amp;lt;br&amp;gt;      (App? ty)&amp;lt;br&amp;gt;      (and (TApp? ty)&amp;lt;br&amp;gt;           (not (F? (.rator ^TApp ty))))&amp;lt;br&amp;gt;      (Mu? ty)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">requires-resolving?</a>[ty]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;resolve*&lt;/b&gt; ([atoms prop])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve* [atoms prop]&amp;lt;br&amp;gt;  {:pre [(every? Filter? atoms)&amp;lt;br&amp;gt;         (Filter? prop)]&amp;lt;br&amp;gt;   :post [(Filter? %)]}&amp;lt;br&amp;gt;  (reduce (fn [prop a]&amp;lt;br&amp;gt;            (cond&amp;lt;br&amp;gt;              (AndFilter? a)&amp;lt;br&amp;gt;              (loop [ps (:fs a)&amp;lt;br&amp;gt;                     result []]&amp;lt;br&amp;gt;                (if (empty? ps)&amp;lt;br&amp;gt;                  (apply -and result)&amp;lt;br&amp;gt;                  (let [p (first ps)]&amp;lt;br&amp;gt;                    (cond&amp;lt;br&amp;gt;                      (opposite? a p) -bot&amp;lt;br&amp;gt;                      (implied-atomic? p a) (recur (next ps) result)&amp;lt;br&amp;gt;                      :else (recur (next ps) (cons p result))))))&amp;lt;br&amp;gt;              :else prop))&amp;lt;br&amp;gt;          prop&amp;lt;br&amp;gt;          atoms))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve*</a>[atoms prop]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;resolve-App&lt;/b&gt; ([app])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve-App [^App app]&amp;lt;br&amp;gt;  {:pre [(App? app)]}&amp;lt;br&amp;gt;  (resolve-app* (.rator app) (.rands app)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve-App</a>[app]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;resolve-Name&lt;/b&gt; ([nme])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve-Name [nme]&amp;lt;br&amp;gt;  {:pre [(Name? nme)]}&amp;lt;br&amp;gt;  (resolve-name* (:id nme)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve-Name</a>[nme]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;resolve-TApp&lt;/b&gt; ([app])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve-TApp [^TApp app]&amp;lt;br&amp;gt;  {:pre [(TApp? app)]}&amp;lt;br&amp;gt;  (resolve-tapp* (.rator app) (.rands app)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve-TApp</a>[app]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;resolve-app*&lt;/b&gt; ([rator rands])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve-app* [rator rands]&amp;lt;br&amp;gt;  (let [rator (-resolve rator)]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (Poly? rator) (do (assert (= (count rands) (.nbound ^Poly rator))&amp;lt;br&amp;gt;                                (error-msg &amp;quot;Wrong number of arguments provided to polymorphic type&amp;quot;&amp;lt;br&amp;gt;                                     (unparse-type rator)))&amp;lt;br&amp;gt;                      (instantiate-poly rator rands))&amp;lt;br&amp;gt;      ;PolyDots NYI&amp;lt;br&amp;gt;      :else (throw (Exception. (str (when *current-env*&amp;lt;br&amp;gt;                                      (str (:line *current-env*) &amp;quot;: &amp;quot;))&amp;lt;br&amp;gt;                                    &amp;quot;Cannot apply non-polymorphic type &amp;quot; (unparse-type rator)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve-app*</a>[rator rands]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;resolve-datatype&lt;/b&gt; ([sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve-datatype [sym]&amp;lt;br&amp;gt;  (let [d (@DATATYPE-ENV sym)]&amp;lt;br&amp;gt;    (assert d (str &amp;quot;Could not resolve DataType: &amp;quot; sym))&amp;lt;br&amp;gt;    d))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve-datatype</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;resolve-protocol&lt;/b&gt; ([sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve-protocol [sym]&amp;lt;br&amp;gt;  (let [p (@PROTOCOL-ENV sym)]&amp;lt;br&amp;gt;    (assert p (str &amp;quot;Could not resolve Protocol: &amp;quot; sym))&amp;lt;br&amp;gt;    (assert (not (Poly? p)) (str &amp;quot;Protocol &amp;quot; sym &amp;quot; takes mandatory arguments, none provided&amp;quot;))&amp;lt;br&amp;gt;    p))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve-protocol</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;resolve-tapp*&lt;/b&gt; ([rator rands])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve-tapp* [rator rands]&amp;lt;br&amp;gt;  (let [^TypeFn rator (-resolve rator)&amp;lt;br&amp;gt;        _ (assert (TypeFn? rator) (unparse-type rator))]&amp;lt;br&amp;gt;    (assert (= (count rands) (.nbound rator))&amp;lt;br&amp;gt;            (error-msg &amp;quot;Wrong number of arguments provided to type function&amp;quot;&amp;lt;br&amp;gt;                       (unparse-type rator)))&amp;lt;br&amp;gt;    (instantiate-typefn rator rands)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve-tapp*</a>[rator rands]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;resolve-to-ftype&lt;/b&gt; ([expected])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resolve-to-ftype [expected]&amp;lt;br&amp;gt;  (loop [etype expected &amp;lt;br&amp;gt;         seen #{}]&amp;lt;br&amp;gt;    (if (seen etype)&amp;lt;br&amp;gt;      (throw (Exception. (error-msg &amp;quot;Stuck in loop, cannot resolve function type &amp;quot;&amp;lt;br&amp;gt;                                    (unparse-type (ret-t expected)))))&amp;lt;br&amp;gt;      (let [seen (conj seen etype)]&amp;lt;br&amp;gt;        (cond&amp;lt;br&amp;gt;          (Name? etype) (recur (resolve-Name etype) seen)&amp;lt;br&amp;gt;          (TApp? etype) (recur (resolve-TApp etype) seen)&amp;lt;br&amp;gt;          :else etype)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resolve-to-ftype</a>[expected]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;restrict&lt;/b&gt; ([t1 t2])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn restrict [t1 t2]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (subtype? t1 t2) t1 ;; already a subtype&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (not (overlap t1 t2)) (Un) ;there's no overlap, so the restriction is empty&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (Union? t1) (apply Un (map (fn [e] (restrict e t2)) (:types t1)))&amp;lt;br&amp;gt;    (Union? t2) (apply Un (map (fn [e] (restrict t1 e)) (:types t2)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (Poly? t2)&amp;lt;br&amp;gt;    (let [names (repeatedly (:nbound t2) gensym)&amp;lt;br&amp;gt;          t (Poly-body* names t2)&amp;lt;br&amp;gt;          bbnds (Poly-bbnds* names t2)&amp;lt;br&amp;gt;          subst (try &amp;lt;br&amp;gt;                  (infer (zipmap names bbnds) {} (list t1) (list t) t1)&amp;lt;br&amp;gt;                  (catch IllegalArgumentException e&amp;lt;br&amp;gt;                    (throw e))&amp;lt;br&amp;gt;                  (catch Exception e))]&amp;lt;br&amp;gt;      (and subst (restrict t1 (subst-all subst t1))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    ;TODO other cases&amp;lt;br&amp;gt;    :else (In t2 t1)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">restrict</a>[t1 t2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ret&lt;/b&gt; ([t] [t f] [t f o] [t f o flow])&lt;br&gt; Convenience function for returning the type of an expression&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ret&amp;lt;br&amp;gt;  &amp;quot;Convenience function for returning the type of an expression&amp;quot;&amp;lt;br&amp;gt;  ([t] (ret t (-FS -top -top) (-&amp;gt;EmptyObject) (-flow -top)))&amp;lt;br&amp;gt;  ([t f] (ret t f (-&amp;gt;EmptyObject) (-flow -top)))&amp;lt;br&amp;gt;  ([t f o] (ret t f o (-flow -top)))&amp;lt;br&amp;gt;  ([t f o flow]&amp;lt;br&amp;gt;   {:pre [(AnyType? t)&amp;lt;br&amp;gt;          (FilterSet? f)&amp;lt;br&amp;gt;          (RObject? o)&amp;lt;br&amp;gt;          (FlowSet? flow)]&amp;lt;br&amp;gt;    :post [(TCResult? %)]}&amp;lt;br&amp;gt;   (-&amp;gt;TCResult t f o flow)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ret</a>[t] [t f] [t f o] [t f o flow]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;ret-flow&lt;/b&gt; ([r])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ret-flow [r]&amp;lt;br&amp;gt;  {:pre [(TCResult? r)]&amp;lt;br&amp;gt;   :post [(FlowSet? %)]}&amp;lt;br&amp;gt;  (:flow r))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ret-flow</a>[r]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;rewrap-poly&lt;/b&gt; ([body orig-names inst-frees bnds poly?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rewrap-poly [body orig-names inst-frees bnds poly?]&amp;lt;br&amp;gt;  {:pre [(Type? body)&amp;lt;br&amp;gt;         (every? symbol? orig-names)&amp;lt;br&amp;gt;         (every? F? inst-frees)&amp;lt;br&amp;gt;         ((some-fn nil? #{:Poly :PolyDots}) poly?)]&amp;lt;br&amp;gt;   :post [(Type? %)]}&amp;lt;br&amp;gt;  (case poly?&amp;lt;br&amp;gt;    :Poly (Poly* (map :name inst-frees) bnds body orig-names)&amp;lt;br&amp;gt;    :PolyDots (with-meta (PolyDots* (map :name inst-frees) bnds body)&amp;lt;br&amp;gt;                         {:actual-frees orig-names})&amp;lt;br&amp;gt;    body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rewrap-poly</a>[body orig-names inst-frees bnds poly?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;scope-depth?&lt;/b&gt; ([scope depth])&lt;br&gt; True if scope is has depth number of scopes nested&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn scope-depth? &amp;lt;br&amp;gt;  &amp;quot;True if scope is has depth number of scopes nested&amp;quot;&amp;lt;br&amp;gt;  [scope depth]&amp;lt;br&amp;gt;  {:pre [(Scope? scope)&amp;lt;br&amp;gt;         (nat? depth)]}&amp;lt;br&amp;gt;  (Type? (last (take (inc depth) (iterate #(and (Scope? %)&amp;lt;br&amp;gt;                                                (:body %))&amp;lt;br&amp;gt;                                          scope)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">scope-depth?</a>[scope depth]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;simplify-prop&lt;/b&gt; ([a b])&lt;br&gt; Try and use atomic proposition a to simplify composite&lt;br&gt;  proposition b. a must be correct polarity.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn simplify-prop &amp;lt;br&amp;gt;  &amp;quot;Try and use atomic proposition a to simplify composite&amp;lt;br&amp;gt;  proposition b. a must be correct polarity.&amp;quot;&amp;lt;br&amp;gt;  [a b]&amp;lt;br&amp;gt;  {:pre [((some-fn TypeFilter? NotTypeFilter?) a)&amp;lt;br&amp;gt;         ((some-fn AndFilter? OrFilter?) b)]&amp;lt;br&amp;gt;   :post [(Filter? %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    ; assuming a wrapping OrFilter&amp;lt;br&amp;gt;    (AndFilter? b)&amp;lt;br&amp;gt;    (let [fs (set (:fs b))&amp;lt;br&amp;gt;          fs (set&amp;lt;br&amp;gt;               (for [f fs]&amp;lt;br&amp;gt;                 (cond&amp;lt;br&amp;gt;                   ; A ^ (B v A) =&amp;gt; A&amp;lt;br&amp;gt;                   (OrFilter? f) (simplify-prop a f)&amp;lt;br&amp;gt;                   :else f)))]&amp;lt;br&amp;gt;      (if (fs a)&amp;lt;br&amp;gt;        ; A v (notB ^ A) =&amp;gt; A v notB&amp;lt;br&amp;gt;        (apply -and (disj fs a))&amp;lt;br&amp;gt;        b))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    ; assuming a wrapping AndFilter&amp;lt;br&amp;gt;    (OrFilter? b)&amp;lt;br&amp;gt;    (let [fs (set (:fs b))]&amp;lt;br&amp;gt;      ; A ^ (B v A) =&amp;gt; A&amp;lt;br&amp;gt;      (if (fs a)&amp;lt;br&amp;gt;        a&amp;lt;br&amp;gt;        b))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">simplify-prop</a>[a b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;singleton-dmap&lt;/b&gt; ([dbound dcon])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn singleton-dmap [dbound dcon]&amp;lt;br&amp;gt;  (-&amp;gt;dmap {dbound dcon}))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">singleton-dmap</a>[dbound dcon]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;sub&lt;/b&gt; ([s t])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro sub [s t]&amp;lt;br&amp;gt;  `(subtype (parse-type '~s)&amp;lt;br&amp;gt;            (parse-type '~t)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sub</a>[s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subst-all&lt;/b&gt; ([s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subst-all [s t]&amp;lt;br&amp;gt;  {:pre [(substitution-c? s)&amp;lt;br&amp;gt;         (AnyType? t)]&amp;lt;br&amp;gt;   :post [(AnyType? %)]}&amp;lt;br&amp;gt;  (reduce (fn [t [v r]]&amp;lt;br&amp;gt;            (cond&amp;lt;br&amp;gt;              (t-subst? r) (substitute (:type r) v t)&amp;lt;br&amp;gt;              (i-subst? r) (substitute-dots (:types r) nil v t)&amp;lt;br&amp;gt;              (i-subst-starred? r) (substitute-dots (:types r) (:starred r) v t)&amp;lt;br&amp;gt;              (and (i-subst-dotted? r)&amp;lt;br&amp;gt;                   (empty? (:types r))) (substitute-dotted (:dty r) (:name (:dbound r)) v t)&amp;lt;br&amp;gt;              (i-subst-dotted? r) (throw (Exception. &amp;quot;i-subst-dotted nyi&amp;quot;))&amp;lt;br&amp;gt;              :else (throw (Exception. &amp;quot;Other substitutions NYI&amp;quot;))))&amp;lt;br&amp;gt;          t s))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subst-all</a>[s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subst-filter&lt;/b&gt; ([f k o polarity])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subst-filter [f k o polarity]&amp;lt;br&amp;gt;  {:pre [(Filter? f)&amp;lt;br&amp;gt;         (name-ref? k)&amp;lt;br&amp;gt;         (RObject? o)&amp;lt;br&amp;gt;         (boolean? polarity)]&amp;lt;br&amp;gt;   :post [(Filter? %)]}&amp;lt;br&amp;gt;  (letfn [(ap [f] (subst-filter f k o polarity))&amp;lt;br&amp;gt;          (tf-matcher [t p i k o polarity maker]&amp;lt;br&amp;gt;            {:pre [(Type? t)&amp;lt;br&amp;gt;                   ((some-fn EmptyObject? NoObject? Path?) o)]&amp;lt;br&amp;gt;             :post [(Filter? %)]}&amp;lt;br&amp;gt;            (cond&amp;lt;br&amp;gt;              ((some-fn EmptyObject? NoObject?)&amp;lt;br&amp;gt;                 o)&amp;lt;br&amp;gt;              (cond &amp;lt;br&amp;gt;                (= i k) (if polarity -top -bot)&amp;lt;br&amp;gt;                (index-free-in? k t) (if polarity -top -bot)&amp;lt;br&amp;gt;                :else f)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;              (Path? o) (let [{p* :path i* :id} o]&amp;lt;br&amp;gt;                          (cond&amp;lt;br&amp;gt;                            (= i k) (maker &amp;lt;br&amp;gt;                                      (subst-type t k o polarity)&amp;lt;br&amp;gt;                                      i*&amp;lt;br&amp;gt;                                      (concat p p*))&amp;lt;br&amp;gt;                            (index-free-in? k t) (if polarity -top -bot)&amp;lt;br&amp;gt;                            :else f))&amp;lt;br&amp;gt;              :else (throw (Exception. (str &amp;quot;what is this? &amp;quot; o)))))]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (ImpFilter? f) (let [{ant :a consq :c} f]&amp;lt;br&amp;gt;                       (-imp (subst-filter ant k o (not polarity)) (ap consq)))&amp;lt;br&amp;gt;      (AndFilter? f) (let [fs (:fs f)] &amp;lt;br&amp;gt;                       (apply -and (map ap fs)))&amp;lt;br&amp;gt;      (OrFilter? f) (let [fs (:fs f)]&amp;lt;br&amp;gt;                       (apply -or (map ap fs)))&amp;lt;br&amp;gt;      (BotFilter? f) -bot&amp;lt;br&amp;gt;      (TopFilter? f) -top&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (TypeFilter? f) &amp;lt;br&amp;gt;      (let [{t :type p :path i :id} f]&amp;lt;br&amp;gt;        (tf-matcher t p i k o polarity -filter))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (NotTypeFilter? f) &amp;lt;br&amp;gt;      (let [{t :type p :path i :id} f]&amp;lt;br&amp;gt;        (tf-matcher t p i k o polarity -not-filter)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subst-filter</a>[f k o polarity]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subst-filter-set&lt;/b&gt; ([fs k o polarity &amp; [t]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subst-filter-set [fs k o polarity &amp;amp; [t]]&amp;lt;br&amp;gt;  {:pre [((some-fn FilterSet? NoFilter?) fs)&amp;lt;br&amp;gt;         (name-ref? k)&amp;lt;br&amp;gt;         (RObject? o)&amp;lt;br&amp;gt;         ((some-fn nil? Type?) t)]&amp;lt;br&amp;gt;   :post [(FilterSet? %)]}&amp;lt;br&amp;gt;;  (prn &amp;quot;subst-filter-set&amp;quot;)&amp;lt;br&amp;gt;;  (prn &amp;quot;fs&amp;quot; (unparse-filter-set fs))&amp;lt;br&amp;gt;;  (prn &amp;quot;k&amp;quot; k) &amp;lt;br&amp;gt;;  (prn &amp;quot;o&amp;quot; o)&amp;lt;br&amp;gt;;  (prn &amp;quot;polarity&amp;quot; polarity) &amp;lt;br&amp;gt;;  (prn &amp;quot;t&amp;quot; (when t (unparse-type t)))&amp;lt;br&amp;gt;  (let [extra-filter (if t (-&amp;gt;TypeFilter t nil k) -top)]&amp;lt;br&amp;gt;    (letfn [(add-extra-filter [f]&amp;lt;br&amp;gt;              {:pre [(Filter? f)]&amp;lt;br&amp;gt;               :post [(Filter? %)]}&amp;lt;br&amp;gt;              (let [f* (-and extra-filter f)]&amp;lt;br&amp;gt;                (if (BotFilter? f*)&amp;lt;br&amp;gt;                  f*&amp;lt;br&amp;gt;                  f)))]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;        (FilterSet? fs) (let [^FilterSet fs fs]&amp;lt;br&amp;gt;                          (-FS (subst-filter (add-extra-filter (.then fs)) k o polarity)&amp;lt;br&amp;gt;                               (subst-filter (add-extra-filter (.else fs)) k o polarity)))&amp;lt;br&amp;gt;        :else (-FS -top -top)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subst-filter-set</a>[fs k o polarity & [t]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subst-gen&lt;/b&gt; ([C Y R])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subst-gen [C Y R]&amp;lt;br&amp;gt;  {:pre [(cset? C)&amp;lt;br&amp;gt;         ((set-c? symbol?) Y)&amp;lt;br&amp;gt;         (AnyType? R)]&amp;lt;br&amp;gt;   :post [((some-fn nil? substitution-c?) %)]}&amp;lt;br&amp;gt;  (let [var-hash (fv-variances R)&amp;lt;br&amp;gt;        idx-hash (idx-variances R)]&amp;lt;br&amp;gt;    (letfn [&amp;lt;br&amp;gt;            ;; v : Symbol - variable for which to check variance&amp;lt;br&amp;gt;            ;; h : (Hash F Variance) - hash to check variance in (either var or idx hash)&amp;lt;br&amp;gt;            ;; variable: Symbol - variable to use instead, if v was a temp var for idx extension&amp;lt;br&amp;gt;            (constraint-&amp;gt;type [{{:keys [upper-bound lower-bound higher-kind]} :bnds :keys [S X T] :as v} h &amp;amp; {:keys [variable]}]&amp;lt;br&amp;gt;              {:pre [(c? v)&amp;lt;br&amp;gt;                     (variance-map? h)&amp;lt;br&amp;gt;                     ((some-fn nil? symbol?) variable)]}&amp;lt;br&amp;gt;              (assert (subtype? S T) (type-error S T))&amp;lt;br&amp;gt;              (assert (not higher-kind) &amp;quot;NYI&amp;quot;)&amp;lt;br&amp;gt;              (let [var (h (or variable X) :constant)&amp;lt;br&amp;gt;                    inferred (case var&amp;lt;br&amp;gt;                               (:constant :covariant) S&amp;lt;br&amp;gt;                               :contravariant T&amp;lt;br&amp;gt;                               :invariant S)]&amp;lt;br&amp;gt;                inferred))&amp;lt;br&amp;gt;            ;TODO implement generalize&amp;lt;br&amp;gt;            ;                  (let [gS (generalize S)]&amp;lt;br&amp;gt;            ;                    (if (subtype? gS T)&amp;lt;br&amp;gt;            ;                      gS&amp;lt;br&amp;gt;            ;                      S))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;            ;; Since we don't add entries to the empty cset for index variables (since there is no&amp;lt;br&amp;gt;            ;; widest constraint, due to dcon-exacts), we must add substitutions here if no constraint&amp;lt;br&amp;gt;            ;; was found.  If we're at this point and had no other constraints, then adding the&amp;lt;br&amp;gt;            ;; equivalent of the constraint (dcon null (c Bot X Top)) is okay.&amp;lt;br&amp;gt;            (extend-idxs [S]&amp;lt;br&amp;gt;              {:pre [(substitution-c? S)]}&amp;lt;br&amp;gt;              (let [fi-R (fi R)] ;free indices in R&amp;lt;br&amp;gt;                ;; If the index variable v is not used in the type, then&amp;lt;br&amp;gt;                ;; we allow it to be replaced with the empty list of types;&amp;lt;br&amp;gt;                ;; otherwise we error, as we do not yet know what an appropriate&amp;lt;br&amp;gt;                ;; lower bound is.&amp;lt;br&amp;gt;                (letfn [(demote-check-free [v]&amp;lt;br&amp;gt;                          {:pre [(symbol? v)]}&amp;lt;br&amp;gt;                          (if (fi-R v)&amp;lt;br&amp;gt;                            (throw (Exception. &amp;quot;attempted to demote dotted variable&amp;quot;))&amp;lt;br&amp;gt;                            (-&amp;gt;i-subst nil)))]&amp;lt;br&amp;gt;                  ;; absent-entries is false if there's an error in the substitution, otherwise&amp;lt;br&amp;gt;                  ;; it's a list of variables that don't appear in the substitution&amp;lt;br&amp;gt;                  (let [absent-entries&amp;lt;br&amp;gt;                        (reduce (fn [no-entry v]&amp;lt;br&amp;gt;                                  {:pre [(symbol? v)]}&amp;lt;br&amp;gt;                                  (let [entry (S v)]&amp;lt;br&amp;gt;                                    ;; Make sure we got a subst entry for an index var&amp;lt;br&amp;gt;                                    ;; (i.e. a list of types for the fixed portion&amp;lt;br&amp;gt;                                    ;;  and a type for the starred portion)&amp;lt;br&amp;gt;                                    (cond&amp;lt;br&amp;gt;                                      (false? no-entry) no-entry&amp;lt;br&amp;gt;                                      (not entry) (cons v no-entry)&amp;lt;br&amp;gt;                                      (or (i-subst? entry) &amp;lt;br&amp;gt;                                          (i-subst-starred? entry)&amp;lt;br&amp;gt;                                          (i-subst-dotted? entry)) no-entry&amp;lt;br&amp;gt;                                      :else false)))&amp;lt;br&amp;gt;                                [] Y)]&amp;lt;br&amp;gt;                    (and absent-entries&amp;lt;br&amp;gt;                         (merge (into {}&amp;lt;br&amp;gt;                                      (for [missing absent-entries]&amp;lt;br&amp;gt;                                        (let [var (idx-hash missing :constant)]&amp;lt;br&amp;gt;                                          [missing&amp;lt;br&amp;gt;                                           (case var&amp;lt;br&amp;gt;                                             (:constant :covariant :invariant) (demote-check-free missing)&amp;lt;br&amp;gt;                                             :contravariant (-&amp;gt;i-subst-starred nil (-&amp;gt;Top)))])))&amp;lt;br&amp;gt;                                S))))))]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (let [{cmap :fixed dmap* :dmap} (-&amp;gt; C :maps first)&amp;lt;br&amp;gt;            _ (assert (= 1 (count (:maps C))) &amp;quot;More than one constraint set found&amp;quot;)&amp;lt;br&amp;gt;            dm (:map dmap*)&amp;lt;br&amp;gt;            subst (merge &amp;lt;br&amp;gt;                    (into {}&amp;lt;br&amp;gt;                      (for [[k dc] dm]&amp;lt;br&amp;gt;                        (cond&amp;lt;br&amp;gt;                          (and (dcon? dc) (not (:rest dc)))&amp;lt;br&amp;gt;                          [k (-&amp;gt;i-subst (doall&amp;lt;br&amp;gt;                                          (for [f (:fixed dc)]&amp;lt;br&amp;gt;                                            (constraint-&amp;gt;type f idx-hash :variable k))))]&amp;lt;br&amp;gt;                          (and (dcon? dc) (:rest dc))&amp;lt;br&amp;gt;                          [k (-&amp;gt;i-subst-starred (doall&amp;lt;br&amp;gt;                                                  (for [f (:fixed dc)]&amp;lt;br&amp;gt;                                                    (constraint-&amp;gt;type f idx-hash :variable k)))&amp;lt;br&amp;gt;                                                (constraint-&amp;gt;type (:rest dc) idx-hash))]&amp;lt;br&amp;gt;                          (dcon-exact? dc)&amp;lt;br&amp;gt;                          [k (-&amp;gt;i-subst-starred (doall&amp;lt;br&amp;gt;                                                  (for [f (:fixed dc)]&amp;lt;br&amp;gt;                                                    (constraint-&amp;gt;type f idx-hash :variable k)))&amp;lt;br&amp;gt;                                                (constraint-&amp;gt;type (:rest dc) idx-hash))]&amp;lt;br&amp;gt;                          (dcon-dotted? dc)&amp;lt;br&amp;gt;                          [k (-&amp;gt;i-subst-dotted (doall&amp;lt;br&amp;gt;                                                 (for [f (:fixed dc)]&amp;lt;br&amp;gt;                                                   (constraint-&amp;gt;type f idx-hash :variable k)))&amp;lt;br&amp;gt;                                               (constraint-&amp;gt;type (:dc dc) idx-hash :variable k)&amp;lt;br&amp;gt;                                               (:dbound dc))]&amp;lt;br&amp;gt;                          :else (throw (Exception. (prn-str &amp;quot;What is this? &amp;quot; dc))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;                    (into {}&amp;lt;br&amp;gt;                      (for [[k v] cmap]&amp;lt;br&amp;gt;                        [k (-&amp;gt;t-subst (constraint-&amp;gt;type v var-hash)&amp;lt;br&amp;gt;                                      (:bnds v))])))&amp;lt;br&amp;gt;            ;check bounds&amp;lt;br&amp;gt;            _ (let [t-substs (into {} (filter (fn [[_ v]] (t-subst? v)) subst))&amp;lt;br&amp;gt;                    [names images] (let [s (seq t-substs)]&amp;lt;br&amp;gt;                                     [(map first s)&amp;lt;br&amp;gt;                                      (map (comp :type second) s)])]&amp;lt;br&amp;gt;                (doseq [[nme {inferred :type :keys [bnds]}] t-substs]&amp;lt;br&amp;gt;                  (assert (not (:higher-kind bnds)) &amp;quot;NYI&amp;quot;)&amp;lt;br&amp;gt;                  (let [lower-bound (substitute-many (:lower-bound bnds) images names)&amp;lt;br&amp;gt;                        upper-bound (substitute-many (:upper-bound bnds) images names)]&amp;lt;br&amp;gt;                    (assert (subtype? lower-bound upper-bound)&amp;lt;br&amp;gt;                            (error-msg &amp;quot;Lower-bound &amp;quot; (unparse-type lower-bound)&amp;lt;br&amp;gt;                                       &amp;quot; is not below upper-bound &amp;quot; (unparse-type upper-bound)))&amp;lt;br&amp;gt;                    (assert (and (subtype? inferred upper-bound)&amp;lt;br&amp;gt;                                 (subtype? lower-bound inferred))&amp;lt;br&amp;gt;                            (error-msg &amp;quot;Inferred type &amp;quot; (unparse-type inferred)&amp;lt;br&amp;gt;                                       &amp;quot; is not between bounds &amp;quot; (unparse-type lower-bound)&amp;lt;br&amp;gt;                                       &amp;quot; and &amp;quot; (unparse-type upper-bound))))))]&amp;lt;br&amp;gt;        ;; verify that we got all the important variables&amp;lt;br&amp;gt;        (when-let [r (and (every? identity&amp;lt;br&amp;gt;                                  (for [v (fv R)]&amp;lt;br&amp;gt;                                    (let [entry (subst v)]&amp;lt;br&amp;gt;                                      (and entry (t-subst? entry)))))&amp;lt;br&amp;gt;                          (extend-idxs subst))]&amp;lt;br&amp;gt;          r)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subst-gen</a>[C Y R]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subst-object&lt;/b&gt; ([t k o polarity])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subst-object [t k o polarity]&amp;lt;br&amp;gt;  {:pre [(RObject? t)&amp;lt;br&amp;gt;         (name-ref? k)&amp;lt;br&amp;gt;         (RObject? o)&amp;lt;br&amp;gt;         (boolean? polarity)]&amp;lt;br&amp;gt;   :post [(RObject? %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    ((some-fn NoObject? EmptyObject?) t) t&amp;lt;br&amp;gt;    (Path? t) (let [{p :path i :id} t]&amp;lt;br&amp;gt;                (if (= i k)&amp;lt;br&amp;gt;                  (cond&amp;lt;br&amp;gt;                    (EmptyObject? o) (-&amp;gt;EmptyObject)&amp;lt;br&amp;gt;                    ;; the result is not from an annotation, so it isn't a NoObject&amp;lt;br&amp;gt;                    (NoObject? o) (-&amp;gt;EmptyObject)&amp;lt;br&amp;gt;                    (Path? o) (let [{p* :path i* :id} o]&amp;lt;br&amp;gt;                                (-&amp;gt;Path (seq (concat p p*)) i*)))&amp;lt;br&amp;gt;                  t))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subst-object</a>[t k o polarity]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subst-type&lt;/b&gt; ([t k o polarity])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subst-type [t k o polarity]&amp;lt;br&amp;gt;  {:pre [(AnyType? t)&amp;lt;br&amp;gt;         (name-ref? k)&amp;lt;br&amp;gt;         (RObject? o)&amp;lt;br&amp;gt;         (boolean? polarity)]&amp;lt;br&amp;gt;   :post [(AnyType? %)]}&amp;lt;br&amp;gt;  (letfn [(st [t*]&amp;lt;br&amp;gt;            (subst-type t* k o polarity))&amp;lt;br&amp;gt;          (sf [fs] &amp;lt;br&amp;gt;            {:pre [(FilterSet? fs)] &amp;lt;br&amp;gt;             :post [(FilterSet? %)]}&amp;lt;br&amp;gt;            (subst-filter-set fs k o polarity))]&amp;lt;br&amp;gt;    (fold-rhs ::subst-type&amp;lt;br&amp;gt;      {:type-rec st&amp;lt;br&amp;gt;       :filter-rec sf&amp;lt;br&amp;gt;       :object-rec (fn [f] (subst-object f k o polarity))&amp;lt;br&amp;gt;       :locals {:st st&amp;lt;br&amp;gt;                :k k&amp;lt;br&amp;gt;                :o o&amp;lt;br&amp;gt;                :polarity polarity}}&amp;lt;br&amp;gt;      t)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subst-type</a>[t k o polarity]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;substitute&lt;/b&gt; ([image name target])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn substitute [image name target]&amp;lt;br&amp;gt;  {:pre [(AnyType? image)&amp;lt;br&amp;gt;         (symbol? name)&amp;lt;br&amp;gt;         (AnyType? target)]&amp;lt;br&amp;gt;   :post [(AnyType? %)]}&amp;lt;br&amp;gt;  (fold-rhs ::substitute&amp;lt;br&amp;gt;            {:locals {:name name&amp;lt;br&amp;gt;                      :image image}}&amp;lt;br&amp;gt;            target))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">substitute</a>[image name target]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;substitute-dots&lt;/b&gt; ([images rimage name target])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn substitute-dots [images rimage name target]&amp;lt;br&amp;gt;  {:pre [(every? AnyType? images)&amp;lt;br&amp;gt;         ((some-fn nil? AnyType?) rimage)&amp;lt;br&amp;gt;         (symbol? name)&amp;lt;br&amp;gt;         (AnyType? target)]}&amp;lt;br&amp;gt;  ;(prn &amp;quot;substitute-dots&amp;quot; (unparse-type target) name &amp;quot;-&amp;gt;&amp;quot; (map unparse-type images))&amp;lt;br&amp;gt;  (letfn [(sb [t] (substitute-dots images rimage name t))]&amp;lt;br&amp;gt;    (if (or ((fi target) name)&amp;lt;br&amp;gt;            ((fv target) name))&amp;lt;br&amp;gt;      (fold-rhs ::substitute-dots &amp;lt;br&amp;gt;                {:type-rec sb&amp;lt;br&amp;gt;                 :filter-rec (sub-f sb ::substitute-dots)&amp;lt;br&amp;gt;                 :locals {:name name&amp;lt;br&amp;gt;                          :sb sb&amp;lt;br&amp;gt;                          :images images&amp;lt;br&amp;gt;                          :rimage rimage}}&amp;lt;br&amp;gt;                target)&amp;lt;br&amp;gt;      target)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">substitute-dots</a>[images rimage name target]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;substitute-dotted&lt;/b&gt; ([image image-bound name target])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn substitute-dotted [image image-bound name target]&amp;lt;br&amp;gt;  {:pre [(AnyType? image)&amp;lt;br&amp;gt;         (symbol? image-bound)&amp;lt;br&amp;gt;         (symbol? name)&amp;lt;br&amp;gt;         (AnyType? target)]&amp;lt;br&amp;gt;   :post [(AnyType? %)]}&amp;lt;br&amp;gt;  (letfn [(sb [t] (substitute-dotted image image-bound name t))]&amp;lt;br&amp;gt;    (if ((fi target) name)&amp;lt;br&amp;gt;      (fold-rhs ::substitute-dotted&amp;lt;br&amp;gt;                {:type-rec sb &amp;lt;br&amp;gt;                 :filter-rec (sub-f sb ::substitute-dotted)&amp;lt;br&amp;gt;                 :locals {:name name&amp;lt;br&amp;gt;                          :sb sb&amp;lt;br&amp;gt;                          :image image}}&amp;lt;br&amp;gt;                target&amp;lt;br&amp;gt;                target))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">substitute-dotted</a>[image image-bound name target]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;substitute-many&lt;/b&gt; ([target images names])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn substitute-many [target images names]&amp;lt;br&amp;gt;  (reduce (fn [t [im nme]] (substitute im nme t))&amp;lt;br&amp;gt;          target&amp;lt;br&amp;gt;          (map vector images names)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">substitute-many</a>[target images names]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subtype&lt;/b&gt; ([s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subtype [s t]&amp;lt;br&amp;gt;  {:post [(set? %)]}&amp;lt;br&amp;gt;  (subtypeA* *sub-current-seen* s t))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subtype</a>[s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subtype-TypeFn-app?&lt;/b&gt; ([tfn ltapp rtapp])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subtype-TypeFn-app?&amp;lt;br&amp;gt;  [^TypeFn tfn ^TApp ltapp ^TApp rtapp]&amp;lt;br&amp;gt;  {:pre [(TypeFn? tfn)&amp;lt;br&amp;gt;         (TApp? ltapp)&amp;lt;br&amp;gt;         (TApp? rtapp)]}&amp;lt;br&amp;gt;  (every? (fn [[v l r]]&amp;lt;br&amp;gt;            (case v&amp;lt;br&amp;gt;              :covariant (subtypeA*? *sub-current-seen* l r)&amp;lt;br&amp;gt;              :contravariant (subtypeA*? *sub-current-seen* r l)&amp;lt;br&amp;gt;              :invariant (and (subtypeA*? *sub-current-seen* l r)&amp;lt;br&amp;gt;                              (subtypeA*? *sub-current-seen* r l))))&amp;lt;br&amp;gt;          (map vector (.variances tfn) (.rands ltapp) (.rands rtapp))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subtype-TypeFn-app?</a>[tfn ltapp rtapp]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subtype?&lt;/b&gt; ([s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subtype? [s t]&amp;lt;br&amp;gt;  (try &amp;lt;br&amp;gt;    (subtype s t)&amp;lt;br&amp;gt;    true&amp;lt;br&amp;gt;    (catch IllegalArgumentException e&amp;lt;br&amp;gt;      (throw e))&amp;lt;br&amp;gt;    (catch Exception e&amp;lt;br&amp;gt;      false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subtype?</a>[s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subtypeA*&lt;/b&gt; ([A s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subtypeA* [A s t]&amp;lt;br&amp;gt;  {:post [(set? %)]}&amp;lt;br&amp;gt;  (if (or (contains? A [s t])&amp;lt;br&amp;gt;          (= s t)&amp;lt;br&amp;gt;          (Top? t)&amp;lt;br&amp;gt;          (Bottom? s))&amp;lt;br&amp;gt;    A&amp;lt;br&amp;gt;    (binding [*sub-current-seen* (conj A [s t])]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;        (and (Value? s)&amp;lt;br&amp;gt;             (Value? t))&amp;lt;br&amp;gt;        ;already (not= s t)&amp;lt;br&amp;gt;        (type-error s t)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (Name? s)&amp;lt;br&amp;gt;        (subtypeA* *sub-current-seen* (resolve-Name s) t)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (Name? t)&amp;lt;br&amp;gt;        (subtypeA* *sub-current-seen* s (resolve-Name t))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (Poly? s)&amp;lt;br&amp;gt;             (Poly? t)&amp;lt;br&amp;gt;             (= (.nbound ^Poly s) (.nbound ^Poly t)))&amp;lt;br&amp;gt;        (let [names (repeatedly (.nbound ^Poly s) gensym)&amp;lt;br&amp;gt;              b1 (Poly-body* names s)&amp;lt;br&amp;gt;              b2 (Poly-body* names t)]&amp;lt;br&amp;gt;          (subtype b1 b2))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ;use unification to see if we can use the Poly type here&amp;lt;br&amp;gt;        (and (Poly? s)&amp;lt;br&amp;gt;             (let [names (repeatedly (.nbound ^Poly s) gensym)&amp;lt;br&amp;gt;                   bnds (Poly-bbnds* names s)&amp;lt;br&amp;gt;                   b1 (Poly-body* names s)]&amp;lt;br&amp;gt;               (unify (zipmap names bnds) [b1] [t])))&amp;lt;br&amp;gt;        (let [names (repeatedly (.nbound ^Poly s) gensym)&amp;lt;br&amp;gt;              bnds (Poly-bbnds* names s)&amp;lt;br&amp;gt;              b1 (Poly-body* names s)]&amp;lt;br&amp;gt;          (if (unify (zipmap names bnds) [b1] [t])&amp;lt;br&amp;gt;            *sub-current-seen*&amp;lt;br&amp;gt;            (type-error s t)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (Poly? t)&amp;lt;br&amp;gt;             (let [names (repeatedly (.nbound ^Poly t) gensym)&amp;lt;br&amp;gt;                   b (Poly-body* names t)]&amp;lt;br&amp;gt;               (empty? (fv t))))&amp;lt;br&amp;gt;        (let [names (repeatedly (.nbound ^Poly t) gensym)&amp;lt;br&amp;gt;              b (Poly-body* names t)]&amp;lt;br&amp;gt;          (subtype s b))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (TApp? s)&amp;lt;br&amp;gt;             (TApp? t))&amp;lt;br&amp;gt;        (if (subtype-TApp? s t)&amp;lt;br&amp;gt;          *sub-current-seen*&amp;lt;br&amp;gt;          (type-error s t))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (TApp? s)&amp;lt;br&amp;gt;        (let [^TApp s s]&amp;lt;br&amp;gt;          (if (and (not (F? (.rator s)))&amp;lt;br&amp;gt;                   (subtypeA*? (conj *sub-current-seen* [s t])&amp;lt;br&amp;gt;                               (resolve-TApp s) t))&amp;lt;br&amp;gt;            *sub-current-seen*&amp;lt;br&amp;gt;            (type-error s t)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (TApp? t)&amp;lt;br&amp;gt;        (let [^TApp t t]&amp;lt;br&amp;gt;          (if (and (not (F? (.rator t)))&amp;lt;br&amp;gt;                   (subtypeA*? (conj *sub-current-seen* [s t])&amp;lt;br&amp;gt;                               s (resolve-TApp t)))&amp;lt;br&amp;gt;            *sub-current-seen*&amp;lt;br&amp;gt;            (type-error s t)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (App? s)&amp;lt;br&amp;gt;        (subtypeA* *sub-current-seen* (resolve-App s) t)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (App? t)&amp;lt;br&amp;gt;        (subtypeA* *sub-current-seen* s (resolve-App t))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (Bottom? t)&amp;lt;br&amp;gt;        (type-error s t)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (Union? s)&amp;lt;br&amp;gt;        ;use subtypeA*, throws error&amp;lt;br&amp;gt;        (if (every? #(subtypeA* *sub-current-seen* % t) (.types ^Union s))&amp;lt;br&amp;gt;          *sub-current-seen*&amp;lt;br&amp;gt;          (type-error s t))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ;use subtypeA*?, boolean result&amp;lt;br&amp;gt;        (Union? t)&amp;lt;br&amp;gt;        (if (some #(subtypeA*? *sub-current-seen* s %) (.types ^Union t))&amp;lt;br&amp;gt;          *sub-current-seen*&amp;lt;br&amp;gt;          (type-error s t))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (FnIntersection? s)&amp;lt;br&amp;gt;             (FnIntersection? t))&amp;lt;br&amp;gt;        (loop [A* *sub-current-seen*&amp;lt;br&amp;gt;               arr2 (:types t)]&amp;lt;br&amp;gt;          (let [arr1 (:types s)]&amp;lt;br&amp;gt;            (if (empty? arr2) &amp;lt;br&amp;gt;              A*&amp;lt;br&amp;gt;              (if-let [A (supertype-of-one-arr A* (first arr2) arr1)]&amp;lt;br&amp;gt;                (recur A (next arr2))&amp;lt;br&amp;gt;                (type-error s t)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (Intersection? s)&amp;lt;br&amp;gt;             (Intersection? t))&amp;lt;br&amp;gt;        (if (every? (fn [s*]&amp;lt;br&amp;gt;                      (some #(subtype? s* %) (.types ^Intersection t)))&amp;lt;br&amp;gt;                    (.types ^Intersection s))&amp;lt;br&amp;gt;          *sub-current-seen*&amp;lt;br&amp;gt;          (type-error s t))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (Intersection? s)&amp;lt;br&amp;gt;        (if (some #(subtype? % t) (.types ^Intersection s))&amp;lt;br&amp;gt;          *sub-current-seen*&amp;lt;br&amp;gt;          (type-error s t))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (Intersection? t)&amp;lt;br&amp;gt;        (if (every? #(subtype? s %) (.types ^Intersection t))&amp;lt;br&amp;gt;          *sub-current-seen*&amp;lt;br&amp;gt;          (type-error s t))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (TopFunction? t)&amp;lt;br&amp;gt;             (FnIntersection? s))&amp;lt;br&amp;gt;        *sub-current-seen*&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (HeterogeneousVector? s)&amp;lt;br&amp;gt;             (HeterogeneousVector? t))&amp;lt;br&amp;gt;        (if (= (count (:types s))&amp;lt;br&amp;gt;               (count (:types t)))&amp;lt;br&amp;gt;          (or (last (doall (map #(subtype %1 %2) (:types s) (:types t))))&amp;lt;br&amp;gt;              #{})&amp;lt;br&amp;gt;          (type-error s t))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (HeterogeneousList? s)&amp;lt;br&amp;gt;             (HeterogeneousList? t))&amp;lt;br&amp;gt;        (if (= (count (:types s))&amp;lt;br&amp;gt;               (count (:types t)))&amp;lt;br&amp;gt;          (or (last (doall (map #(subtype %1 %2) (:types s) (:types t))))&amp;lt;br&amp;gt;              #{})&amp;lt;br&amp;gt;          (type-error s t))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        (and (HeterogeneousSeq? s)&amp;lt;br&amp;gt;             (HeterogeneousSeq? t))&amp;lt;br&amp;gt;        (if (= (count (:types s))&amp;lt;br&amp;gt;               (count (:types t)))&amp;lt;br&amp;gt;          (or (last (doall (map #(subtype %1 %2) (:types s) (:types t))))&amp;lt;br&amp;gt;              #{})&amp;lt;br&amp;gt;          (type-error s t))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        ;values are subtypes of their classes&amp;lt;br&amp;gt;        (and (Value? s)&amp;lt;br&amp;gt;             (checking-clojure?))&amp;lt;br&amp;gt;        (let [^Value s s]&amp;lt;br&amp;gt;          (if (nil? (.val s))&amp;lt;br&amp;gt;            (type-error s t)&amp;lt;br&amp;gt;            (subtype (apply In (RClass-of (class (.val s)))&amp;lt;br&amp;gt;                            (cond&amp;lt;br&amp;gt;                              ;keyword values are functions&amp;lt;br&amp;gt;                              (keyword? (.val s)) [(keyword-&amp;gt;Fn (.val s))]&amp;lt;br&amp;gt;                              ;strings have a known length as a seqable&amp;lt;br&amp;gt;                              (string? (.val s)) [(make-ExactCountRange (count (.val s)))]))&amp;lt;br&amp;gt;                     t)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        :else (subtype* s t)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subtypeA*</a>[A s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subtypeA*?&lt;/b&gt; ([A s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subtypeA*? [A s t]&amp;lt;br&amp;gt;  (try (subtypeA* A s t)&amp;lt;br&amp;gt;    true&amp;lt;br&amp;gt;    (catch IllegalArgumentException e&amp;lt;br&amp;gt;      (throw e))&amp;lt;br&amp;gt;    (catch Exception e&amp;lt;br&amp;gt;      false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subtypeA*?</a>[A s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subtypes*-varargs&lt;/b&gt; ([A0 argtys dom rst])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subtypes*-varargs [A0 argtys dom rst]&amp;lt;br&amp;gt;  (loop [dom dom&amp;lt;br&amp;gt;         argtys argtys&amp;lt;br&amp;gt;         A A0]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (and (empty? dom) (empty? argtys)) A&amp;lt;br&amp;gt;      (empty? argtys) (throw (Exception. (prn-str &amp;quot;Expected arguments: &amp;quot; (map unparse-type dom)&amp;lt;br&amp;gt;                                                  &amp;quot; Actual: &amp;quot;(map unparse-type argtys))))&amp;lt;br&amp;gt;      (and (empty? dom) rst)&amp;lt;br&amp;gt;      (if-let [A (subtypeA* A (first argtys) rst)]&amp;lt;br&amp;gt;        (recur dom (next argtys) A)&amp;lt;br&amp;gt;        (type-error (first argtys) rst))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (empty? dom) (throw (Exception. (prn-str &amp;quot;Expected arguments: &amp;quot; (map unparse-type dom)&amp;lt;br&amp;gt;                                               &amp;quot; Actual: &amp;quot;(map unparse-type argtys))))&amp;lt;br&amp;gt;      :else&amp;lt;br&amp;gt;      (if-let [A (subtypeA* A0 (first argtys) (first dom))]&amp;lt;br&amp;gt;        (recur (next dom) (next argtys) A)&amp;lt;br&amp;gt;        (type-error (first argtys) (first dom))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subtypes*-varargs</a>[A0 argtys dom rst]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;subtypes-varargs?&lt;/b&gt; ([argtys dom rst])&lt;br&gt; True if argtys are under dom&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subtypes-varargs?&amp;lt;br&amp;gt;  &amp;quot;True if argtys are under dom&amp;quot;&amp;lt;br&amp;gt;  [argtys dom rst]&amp;lt;br&amp;gt;  (try &amp;lt;br&amp;gt;    (subtypes*-varargs #{} argtys dom rst)&amp;lt;br&amp;gt;    true&amp;lt;br&amp;gt;    (catch Exception e&amp;lt;br&amp;gt;      false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subtypes-varargs?</a>[argtys dom rst]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;supertype-of-one-arr&lt;/b&gt; ([A s ts])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn supertype-of-one-arr [A s ts]&amp;lt;br&amp;gt;  (some #(try (arr-subtype A % s)&amp;lt;br&amp;gt;           (catch IllegalArgumentException e&amp;lt;br&amp;gt;             (throw e))&amp;lt;br&amp;gt;           (catch Exception e))&amp;lt;br&amp;gt;        ts))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">supertype-of-one-arr</a>[A s ts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;symbol-&gt;PArray&lt;/b&gt; ([sym nilable?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn symbol-&amp;gt;PArray [sym nilable?]&amp;lt;br&amp;gt;  {:pre [(symbol? sym)&amp;lt;br&amp;gt;         (boolean? nilable?)]&amp;lt;br&amp;gt;   :post [((some-fn nil? PrimitiveArray?) %)]}&amp;lt;br&amp;gt;  (let [s (str sym)]&amp;lt;br&amp;gt;    (when (.endsWith s &amp;quot;&amp;lt;&amp;gt;&amp;quot;)&amp;lt;br&amp;gt;      (let [^String s-nosuffix (apply str (drop-last 2 s))]&amp;lt;br&amp;gt;        (assert (not (.contains s-nosuffix &amp;quot;&amp;lt;&amp;gt;&amp;quot;)))&amp;lt;br&amp;gt;        ;Nullable elements&amp;lt;br&amp;gt;        (let [t (Java-symbol-&amp;gt;Type (symbol s-nosuffix) nilable?)&amp;lt;br&amp;gt;              c (let [c (or (when-let [rclass (primitives (symbol s-nosuffix))]&amp;lt;br&amp;gt;                              (RClass-&amp;gt;Class rclass))&amp;lt;br&amp;gt;                            (resolve (symbol s-nosuffix)))&amp;lt;br&amp;gt;                      _ (assert (class? c) s-nosuffix)]&amp;lt;br&amp;gt;                  c)]&amp;lt;br&amp;gt;          (-&amp;gt;PrimitiveArray c t t))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">symbol->PArray</a>[sym nilable?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;t-subst?&lt;/b&gt; ([r__10948__auto__])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord t-subst [type bnds]&amp;lt;br&amp;gt;  &amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [(Type? type)&amp;lt;br&amp;gt;   (Bounds? bnds)])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">t-subst?</a>[r__10948__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;tc&lt;/b&gt; ([form])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro tc [form]&amp;lt;br&amp;gt;  `(do (ensure-clojure)&amp;lt;br&amp;gt;     (-&amp;gt; (check-top-level (symbol (ns-name *ns*))&amp;lt;br&amp;gt;                          '~form)&amp;lt;br&amp;gt;       expr-type unparse-type)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tc</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;tc-equiv&lt;/b&gt; ([comparator &amp; vs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tc-equiv [comparator &amp;amp; vs]&amp;lt;br&amp;gt;  {:pre [(every? TCResult? vs)]&amp;lt;br&amp;gt;   :post [(TCResult? %)]}&amp;lt;br&amp;gt;  (assert (#{:=} comparator))&amp;lt;br&amp;gt;  (let [thn-fls (set (apply concat&amp;lt;br&amp;gt;                            (for [[{t1 :t fl1 :fl o1 :o}&amp;lt;br&amp;gt;                                   {t2 :t fl2 :fl o2 :o}]&amp;lt;br&amp;gt;                                  (comb/combinations vs 2)]&amp;lt;br&amp;gt;                              (concat (when (Path? o2)&amp;lt;br&amp;gt;                                        [(-filter t1 (:id o2) (:path o2))])&amp;lt;br&amp;gt;                                      (when (Path? o1)&amp;lt;br&amp;gt;                                        [(-filter t2 (:id o1) (:path o1))])))))&amp;lt;br&amp;gt;        els-fls (set (apply concat&amp;lt;br&amp;gt;                            (for [[{t1 :t fl1 :fl o1 :o}&amp;lt;br&amp;gt;                                   {t2 :t fl2 :fl o2 :o}]&amp;lt;br&amp;gt;                                  (comb/combinations vs 2)]&amp;lt;br&amp;gt;                              (concat (when (Path? o2)&amp;lt;br&amp;gt;                                        [(-not-filter t1 (:id o2) (:path o2))])&amp;lt;br&amp;gt;                                      (when (Path? o1)&amp;lt;br&amp;gt;                                        [(-not-filter t2 (:id o1) (:path o1))])))))]&amp;lt;br&amp;gt;  (ret (Un -false -true)&amp;lt;br&amp;gt;       (-FS (if (empty? thn-fls)&amp;lt;br&amp;gt;              -top&amp;lt;br&amp;gt;              (apply -and thn-fls))&amp;lt;br&amp;gt;            (if (empty? els-fls)&amp;lt;br&amp;gt;              -top&amp;lt;br&amp;gt;              (apply -or els-fls)))&amp;lt;br&amp;gt;       -empty)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tc-equiv</a>[comparator & vs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;tc-ignore&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Ignore forms in body during type checking&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro tc-ignore &amp;lt;br&amp;gt;  &amp;quot;Ignore forms in body during type checking&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;  `(do ~@(map (fn [b] `(tc-ignore-forms* ~b)) body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tc-ignore</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;tc-ignore-forms*&lt;/b&gt; ([r])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tc-ignore-forms* [r]&amp;lt;br&amp;gt;  r)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tc-ignore-forms*</a>[r]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;tc-isa?&lt;/b&gt; ([child-ret parent-ret])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tc-isa? [child-ret parent-ret]&amp;lt;br&amp;gt;  {:pre [(TCResult? child-ret)&amp;lt;br&amp;gt;         (TCResult? parent-ret)]&amp;lt;br&amp;gt;   :post [(TCResult? %)]}&amp;lt;br&amp;gt;;  (prn &amp;quot;tc-isa?&amp;quot;)&amp;lt;br&amp;gt;;  (prn &amp;quot;child-ret&amp;quot; child-ret)&amp;lt;br&amp;gt;;  (prn &amp;quot;parent-ret&amp;quot; parent-ret)&amp;lt;br&amp;gt;  (let [parent-t (ret-t parent-ret)&amp;lt;br&amp;gt;        fs (-FS (-filter-at parent-t (ret-o child-ret))&amp;lt;br&amp;gt;                (-not-filter-at parent-t (ret-o child-ret)))]&amp;lt;br&amp;gt;;    (prn &amp;quot;fs&amp;quot; fs)&amp;lt;br&amp;gt;;    (prn &amp;quot;child object&amp;quot; (ret-o child-ret))&amp;lt;br&amp;gt;    (ret (Un -true -false) fs -empty)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tc-isa?</a>[child-ret parent-ret]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;tc-t&lt;/b&gt; ([form])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro tc-t [form]&amp;lt;br&amp;gt;  `(do (ensure-clojure)&amp;lt;br&amp;gt;     (-&amp;gt; (check-top-level (symbol (ns-name *ns*))&amp;lt;br&amp;gt;                          '~form)&amp;lt;br&amp;gt;       expr-type)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tc-t</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;tfn-bound&lt;/b&gt; ([tfn])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tfn-bound [tfn]&amp;lt;br&amp;gt;  (-&amp;gt;Bounds nil nil tfn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tfn-bound</a>[tfn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;trepl&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn trepl []&amp;lt;br&amp;gt;  (clojure.main/repl &amp;lt;br&amp;gt;    :eval (fn [f] &amp;lt;br&amp;gt;            (let [t (do (ensure-clojure)&amp;lt;br&amp;gt;                      (-&amp;gt; (analyze/analyze-form f) hygienic/ast-hy&amp;lt;br&amp;gt;                        check expr-type unparse-TCResult))]&amp;lt;br&amp;gt;              (prn t) &amp;lt;br&amp;gt;              (eval f)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trepl</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;type-error&lt;/b&gt; ([s t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn type-error [s t]&amp;lt;br&amp;gt;  (throw (Exception. (str &amp;quot;Type Error&amp;quot;&amp;lt;br&amp;gt;                          (when *current-env*&amp;lt;br&amp;gt;                            (str &amp;quot;, &amp;quot; (:source *current-env*) &amp;quot;:&amp;quot; (:line *current-env*)))&amp;lt;br&amp;gt;                          &amp;quot;\n\nActual type\n\t&amp;quot;&amp;lt;br&amp;gt;                          (or (-&amp;gt; s meta :source-Name)&amp;lt;br&amp;gt;                              (with-out-str (pr (unparse-type s))))&amp;lt;br&amp;gt;                          &amp;quot;\nis not a subtype of Expected type\n\t&amp;quot; &amp;lt;br&amp;gt;                          (or (-&amp;gt; t meta :source-Name)&amp;lt;br&amp;gt;                              (with-out-str (pr (unparse-type t))))&amp;lt;br&amp;gt;                          (when *current-expr*&amp;lt;br&amp;gt;                            (str &amp;quot;\n\nForm: &amp;quot; (emit-form-fn *current-expr*)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">type-error</a>[s t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;type-of&lt;/b&gt; ([sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn type-of [sym]&amp;lt;br&amp;gt;  {:pre [(symbol? sym)]&amp;lt;br&amp;gt;   :post [(or (Type? %)&amp;lt;br&amp;gt;              (TCResult? %))]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (not (namespace sym)) (if-let [t (lookup-local sym)]&amp;lt;br&amp;gt;                            t&amp;lt;br&amp;gt;                            (throw (Exception. (str (when *current-env*&amp;lt;br&amp;gt;                                                      (str (:line *current-env*) &amp;quot;: &amp;quot;))&amp;lt;br&amp;gt;                                                    &amp;quot;Reference to untyped binding: &amp;quot; sym))))&amp;lt;br&amp;gt;    :else (lookup-Var sym)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">type-of</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;unfold&lt;/b&gt; ([t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unfold [t]&amp;lt;br&amp;gt;  {:pre [(Mu? t)]&amp;lt;br&amp;gt;   :post [(Type? %)]}&amp;lt;br&amp;gt;  (let [sym (gensym)&amp;lt;br&amp;gt;        body (Mu-body* sym t)]&amp;lt;br&amp;gt;    (substitute t sym body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unfold</a>[t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;unify&lt;/b&gt; ([X S T])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unify [X S T]&amp;lt;br&amp;gt;  (boolean (infer X {} S T -any)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unify</a>[X S T]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;unp&lt;/b&gt; ([t])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unp [t] (prn (unparse-type t)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unp</a>[t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;unparse-TCResult&lt;/b&gt; ([r])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unparse-TCResult [r]&amp;lt;br&amp;gt;  (let [t (unparse-type (ret-t r))&amp;lt;br&amp;gt;        fs (unparse-filter-set (ret-f r))&amp;lt;br&amp;gt;        o (unparse-object (ret-o r))]&amp;lt;br&amp;gt;    (if (and (= (-FS -top -top) (ret-f r))&amp;lt;br&amp;gt;             (= (ret-o r) -empty))&amp;lt;br&amp;gt;      t&amp;lt;br&amp;gt;      (if (= (ret-o r) -empty)&amp;lt;br&amp;gt;        [t fs]&amp;lt;br&amp;gt;        [t fs o]))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unparse-TCResult</a>[r]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;unparse-filter&lt;/b&gt; ([f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unparse-filter [f]&amp;lt;br&amp;gt;  (unparse-filter* f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unparse-filter</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;unparse-filter-set&lt;/b&gt; ([{:keys [then else], :as fs}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unparse-filter-set [{:keys [then else] :as fs}]&amp;lt;br&amp;gt;  {:pre [(FilterSet? fs)]}&amp;lt;br&amp;gt;  {:then (unparse-filter then)&amp;lt;br&amp;gt;   :else (unparse-filter else)})&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unparse-filter-set</a>[{:keys [then else], :as fs}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;unsafe-ann-form&lt;/b&gt; ([form ty])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro unsafe-ann-form [form ty]&amp;lt;br&amp;gt;  `(unsafe-ann-form* ~form '~ty))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unsafe-ann-form</a>[form ty]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;unsafe-ann-form*&lt;/b&gt; ([form ty])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unsafe-ann-form* [form ty]&amp;lt;br&amp;gt;  form)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unsafe-ann-form*</a>[form ty]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;unwrap-datatype&lt;/b&gt; ([dt nms] [dt])&lt;br&gt; Takes a possibly polymorphic DataType and returns the &lt;br&gt;  DataType after instantiating it&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unwrap-datatype &amp;lt;br&amp;gt;  &amp;quot;Takes a possibly polymorphic DataType and returns the &amp;lt;br&amp;gt;  DataType after instantiating it&amp;quot;&amp;lt;br&amp;gt;  ([dt nms]&amp;lt;br&amp;gt;   {:pre [((some-fn DataType? Poly?) dt)&amp;lt;br&amp;gt;          (every? symbol? nms)]&amp;lt;br&amp;gt;    :post [(DataType? %)]}&amp;lt;br&amp;gt;   (if (Poly? dt)&amp;lt;br&amp;gt;     (Poly-body* nms dt)&amp;lt;br&amp;gt;     dt))&amp;lt;br&amp;gt;  ([dt] (let [nms (when (Poly? dt)&amp;lt;br&amp;gt;                    (repeatedly (:nbound dt) gensym))]&amp;lt;br&amp;gt;          (unwrap-datatype dt nms))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unwrap-datatype</a>[dt nms] [dt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;unwrap-poly&lt;/b&gt; ([t])&lt;br&gt; Return a pair vector of the instantiated body of the possibly polymorphic&lt;br&gt;  type and the names used&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn unwrap-poly&amp;lt;br&amp;gt;  &amp;quot;Return a pair vector of the instantiated body of the possibly polymorphic&amp;lt;br&amp;gt;  type and the names used&amp;quot;&amp;lt;br&amp;gt;  [t]&amp;lt;br&amp;gt;  {:pre [(Type? t)]&amp;lt;br&amp;gt;   :post [((hvector-c? Type? &amp;lt;br&amp;gt;                       (some-fn nil? (every-c? symbol?))&amp;lt;br&amp;gt;                       (some-fn nil? (every-c? F?))&amp;lt;br&amp;gt;                       (some-fn nil? (every-c? Bounds?))&amp;lt;br&amp;gt;                       (some-fn nil? #{:Poly :PolyDots})) %)]}&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (Poly? t) (let [_ (assert (Poly-free-names* t) (unparse-type t))&amp;lt;br&amp;gt;                    old-nmes (Poly-free-names* t)&amp;lt;br&amp;gt;                    _ (assert ((every-pred seq (every-c? symbol?)) old-nmes))&amp;lt;br&amp;gt;                    new-nmes (repeatedly (:nbound t) gensym)&amp;lt;br&amp;gt;                    new-frees (map make-F new-nmes)]&amp;lt;br&amp;gt;                (prn &amp;quot;there&amp;quot;)&amp;lt;br&amp;gt;                [(Poly-body* new-nmes t) old-nmes new-frees (Poly-bbnds* new-nmes t) :Poly])&amp;lt;br&amp;gt;    (PolyDots? t) (let [_ (assert (-&amp;gt; t meta :actual-frees))&amp;lt;br&amp;gt;                        old-nmes (-&amp;gt; t meta :actual-frees)&amp;lt;br&amp;gt;                        _ (assert ((every-pred seq (every-c? symbol?)) old-nmes))&amp;lt;br&amp;gt;                        new-nmes (repeatedly (:nbound t) gensym)&amp;lt;br&amp;gt;                        new-frees (map make-F new-nmes)]&amp;lt;br&amp;gt;                    (prn &amp;quot;here&amp;quot;)&amp;lt;br&amp;gt;                    [(PolyDots-body* new-nmes t) old-nmes new-frees (PolyDots-bbnds* new-nmes t) :PolyDots])&amp;lt;br&amp;gt;    :else [t nil nil nil nil]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unwrap-poly</a>[t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;update&lt;/b&gt; ([t lo])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn update [t lo]&amp;lt;br&amp;gt;  (let [t (fully-resolve-type t)]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (and (TypeFilter? lo)&amp;lt;br&amp;gt;           (empty? (:path lo))) &amp;lt;br&amp;gt;      (let [u (:type lo)&amp;lt;br&amp;gt;            _ (assert (Type? u))&amp;lt;br&amp;gt;            r (restrict u t)]&amp;lt;br&amp;gt;        r)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (NotTypeFilter? lo)&amp;lt;br&amp;gt;           (empty? (:path lo))) &amp;lt;br&amp;gt;      (let [u (:type lo)]&amp;lt;br&amp;gt;        (assert (Type? u))&amp;lt;br&amp;gt;        (remove* t u))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;heterogeneous map ops&amp;lt;br&amp;gt;      (and (TypeFilter? lo)&amp;lt;br&amp;gt;           (KeyPE? (first (:path lo)))&amp;lt;br&amp;gt;           (HeterogeneousMap? t)) &amp;lt;br&amp;gt;      (let [{:keys [type path id]} lo&amp;lt;br&amp;gt;            [{fpth-kw :val} &amp;amp; rstpth] path&amp;lt;br&amp;gt;            fpth (-&amp;gt;Value fpth-kw)&amp;lt;br&amp;gt;            type-at-pth (get (:types t) fpth)]&amp;lt;br&amp;gt;        (if type-at-pth &amp;lt;br&amp;gt;          (-hmap (assoc (:types t) fpth (update type-at-pth (-filter type id rstpth))))&amp;lt;br&amp;gt;          (Bottom)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (NotTypeFilter? lo)&amp;lt;br&amp;gt;           (KeyPE? (first (:path lo)))&amp;lt;br&amp;gt;           (HeterogeneousMap? t)) &amp;lt;br&amp;gt;      (let [{:keys [type path id]} lo&amp;lt;br&amp;gt;            [{fpth-kw :val} &amp;amp; rstpth] path&amp;lt;br&amp;gt;            fpth (-&amp;gt;Value fpth-kw)&amp;lt;br&amp;gt;            type-at-pth (get (:types t) fpth)]&amp;lt;br&amp;gt;        (if type-at-pth &amp;lt;br&amp;gt;          (-hmap (assoc (:types t) fpth (update type-at-pth (-not-filter type id rstpth))))&amp;lt;br&amp;gt;          (Bottom)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (and (TypeFilter? lo)&amp;lt;br&amp;gt;           (CountPE? (first (:path lo))))&amp;lt;br&amp;gt;      (let [u (:type lo)]&amp;lt;br&amp;gt;        (if-let [cnt (when (and (Value? u) (integer? (:val u)))&amp;lt;br&amp;gt;                       (make-ExactCountRange (:val u)))]&amp;lt;br&amp;gt;          (restrict cnt t)&amp;lt;br&amp;gt;          (do (prn &amp;quot;WARNING:&amp;quot; (str &amp;quot;Cannot infer Count from type &amp;quot; (unparse-type u)))&amp;lt;br&amp;gt;            t)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;can't do much without a NotCountRange type or difference type&amp;lt;br&amp;gt;      (and (NotTypeFilter? lo)&amp;lt;br&amp;gt;           (CountPE? (first (:path lo))))&amp;lt;br&amp;gt;      t&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ;ClassPE&amp;lt;br&amp;gt;      (and (TypeFilter? lo)&amp;lt;br&amp;gt;           (ClassPE? (-&amp;gt; lo :path first)))&amp;lt;br&amp;gt;      (let [_ (assert (empty? (rest (:path lo))))&amp;lt;br&amp;gt;            u (:type lo)]&amp;lt;br&amp;gt;        (cond &amp;lt;br&amp;gt;          ;restrict the obvious case where the path is the same as a Class Value&amp;lt;br&amp;gt;          ; eg. #(= (class %) Number)&amp;lt;br&amp;gt;          (and (Value? u)&amp;lt;br&amp;gt;               (class? (:val u)))&amp;lt;br&amp;gt;          (restrict (RClass-of (:val u)) t)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;          ; handle (class nil) =&amp;gt; nil&amp;lt;br&amp;gt;          (Nil? u)&amp;lt;br&amp;gt;          (restrict -nil t)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;          :else&amp;lt;br&amp;gt;          (do (prn &amp;quot;WARNING:&amp;quot; (str &amp;quot;Cannot infer type via ClassPE from type &amp;quot; (unparse-type u)))&amp;lt;br&amp;gt;            t)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      ; Does not tell us anything.&amp;lt;br&amp;gt;      ; eg. (= Number (class x)) ;=&amp;gt; false&amp;lt;br&amp;gt;      ;     does not reveal whether x is a subtype of Number, eg. (= Integer (class %))&amp;lt;br&amp;gt;      (and (NotTypeFilter? lo)&amp;lt;br&amp;gt;           (ClassPE? (-&amp;gt; lo :path first)))&amp;lt;br&amp;gt;      t&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (Union? t) (let [ts (:types t)&amp;lt;br&amp;gt;                       new-ts (mapv (fn [t] &amp;lt;br&amp;gt;                                      (let [n (update t lo)]&amp;lt;br&amp;gt;                                        n))&amp;lt;br&amp;gt;                                    ts)]&amp;lt;br&amp;gt;                   (apply Un new-ts))&amp;lt;br&amp;gt;      (Intersection? t) (let [ts (:types t)]&amp;lt;br&amp;gt;                          (apply In (doall (map (fn [t] (update t lo)) ts))))&amp;lt;br&amp;gt;      &amp;lt;br&amp;gt;      ;keyword invoke of non-hmaps&amp;lt;br&amp;gt;      ;FIXME TypeFilter case can refine type further&amp;lt;br&amp;gt;      (and (or (TypeFilter? lo)&amp;lt;br&amp;gt;               (NotTypeFilter? lo))&amp;lt;br&amp;gt;           (KeyPE? (first (:path lo))))&amp;lt;br&amp;gt;      (do (assert (= (count (:path lo)) 1) &amp;lt;br&amp;gt;                  (str &amp;quot;Further path NYI &amp;quot; (pr-str (:path lo))&amp;lt;br&amp;gt;                       (unparse-type t)))&amp;lt;br&amp;gt;        t)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      :else (throw (Exception. (error-msg &amp;quot;update along ill-typed path &amp;quot; (unparse-type t) &amp;quot; &amp;quot; (with-out-str (pr lo))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">update</a>[t lo]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;update-composite&lt;/b&gt; ([bnd-env f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn update-composite [bnd-env f]&amp;lt;br&amp;gt;  {:pre [(lex-env? bnd-env)&amp;lt;br&amp;gt;         (Filter? f)]&amp;lt;br&amp;gt;   :post [(lex-env? %)]}&amp;lt;br&amp;gt;  ;(prn &amp;quot;update-composite&amp;quot; bnd-env f)&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;;    (and (AndFilter? f) &amp;lt;br&amp;gt;;         (every? atomic-filter? (.fs f)))&amp;lt;br&amp;gt;;    (reduce (fn [env a] (update-composite env a))&amp;lt;br&amp;gt;;            bnd-env (.fs f))&amp;lt;br&amp;gt;;    (and (OrFilter? f) &amp;lt;br&amp;gt;;         (every? atomic-filter? (.fs f)))&amp;lt;br&amp;gt;    (BotFilter? f)&amp;lt;br&amp;gt;    (zipmap (:keys bnd-env) (Un))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (or (TypeFilter? f)&amp;lt;br&amp;gt;        (NotTypeFilter? f))&amp;lt;br&amp;gt;    (let [x (:id f)]&amp;lt;br&amp;gt;      (update-in bnd-env [x] (fn [t]&amp;lt;br&amp;gt;                               ;check if var is ever a target of a set!&amp;lt;br&amp;gt;                               (if (is-var-mutated? x)&amp;lt;br&amp;gt;                                 ; if it is, we do nothing&amp;lt;br&amp;gt;                                 t&amp;lt;br&amp;gt;                                 ;otherwise, refine the type&amp;lt;br&amp;gt;                                 (let [t (or t (-&amp;gt;Top))&amp;lt;br&amp;gt;                                       new-t (update t f)]&amp;lt;br&amp;gt;                                   new-t)))))&amp;lt;br&amp;gt;    :else bnd-env))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">update-composite</a>[bnd-env f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;variance?&lt;/b&gt; ([v])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn variance? [v]&amp;lt;br&amp;gt;  (contains? variances v))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">variance?</a>[v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;visit-bounds&lt;/b&gt; ([ty f])&lt;br&gt; Apply f to each element of bounds&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn visit-bounds &amp;lt;br&amp;gt;  &amp;quot;Apply f to each element of bounds&amp;quot;&amp;lt;br&amp;gt;  [ty f]&amp;lt;br&amp;gt;  {:pre [(Bounds? ty)]&amp;lt;br&amp;gt;   :post [(Bounds? ty)]}&amp;lt;br&amp;gt;  (-&amp;gt; ty&amp;lt;br&amp;gt;    (update-in [:upper-bound] #(when %&amp;lt;br&amp;gt;                                 (f %)))&amp;lt;br&amp;gt;    (update-in [:lower-bound] #(when %&amp;lt;br&amp;gt;                                 (f %)))&amp;lt;br&amp;gt;    (update-in [:higher-kind] #(when %&amp;lt;br&amp;gt;                                 (f %)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">visit-bounds</a>[ty f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;with-altered-specials&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-altered-specials&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;  `(try&amp;lt;br&amp;gt;     (alter-var-root #'cljs.analyzer/specials (constantly new-specials))&amp;lt;br&amp;gt;     ~@body&amp;lt;br&amp;gt;     (finally&amp;lt;br&amp;gt;       (alter-var-root #'cljs.analyzer/specials (constantly orig-specials)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-altered-specials</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;with-bounded-frees&lt;/b&gt; ([bfrees &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-bounded-frees [bfrees &amp;amp; body]&amp;lt;br&amp;gt;  `(with-free-mappings (into {} (for [[f# bnds#] ~bfrees]&amp;lt;br&amp;gt;                                  [(:name f#) {:F f# :bnds bnds#}]))&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-bounded-frees</a>[bfrees & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;with-dotted&lt;/b&gt; ([dvars &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-dotted [dvars &amp;amp; body]&amp;lt;br&amp;gt;  `(with-dotted-mappings (into {} (for [v# ~dvars]&amp;lt;br&amp;gt;                                    [(:name v#) v#]))&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-dotted</a>[dvars & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;with-dotted-mappings&lt;/b&gt; ([dvar-map &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-dotted-mappings [dvar-map &amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*dotted-scope* (merge *dotted-scope* ~dvar-map)]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-dotted-mappings</a>[dvar-map & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;with-free-mappings&lt;/b&gt; ([frees-map &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-free-mappings [frees-map &amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*free-scope* (merge *free-scope* ~frees-map)]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-free-mappings</a>[frees-map & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;with-frees&lt;/b&gt; ([frees &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-frees [frees &amp;amp; body]&amp;lt;br&amp;gt;  `(with-free-mappings (into {} (for [f# ~frees]&amp;lt;br&amp;gt;                                  [(:name f#) {:F f# :bnds no-bounds}]))&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-frees</a>[frees & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;with-lexical-env&lt;/b&gt; ([env &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-lexical-env [env &amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*lexical-env* ~env]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-lexical-env</a>[env & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;with-locals&lt;/b&gt; ([locals &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-locals [locals &amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*lexical-env* (merge-locals *lexical-env* ~locals)]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-locals</a>[locals & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed&lt;/i&gt;&lt;b&gt;with-recur-target&lt;/b&gt; ([tgt &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-recur-target [tgt &amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*recur-target* ~tgt]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-recur-target</a>[tgt & body]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.typed.utils</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed.utils&lt;/i&gt;&lt;b&gt;=-c?&lt;/b&gt; ([&amp; as])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn =-c? [&amp;amp; as]&amp;lt;br&amp;gt;  #(apply = (concat as %&amp;amp;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">=-c?</a>[& as]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed.utils&lt;/i&gt;&lt;b&gt;Class-&gt;symbol&lt;/b&gt; ([cls])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn Class-&amp;gt;symbol [^Class cls]&amp;lt;br&amp;gt;  {:pre [(class? cls)]&amp;lt;br&amp;gt;   :post [(symbol? %)]}&amp;lt;br&amp;gt;  (symbol (.getName cls)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">Class->symbol</a>[cls]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed.utils&lt;/i&gt;&lt;b&gt;array-map-c?&lt;/b&gt; ([ks-c? vs-c?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn array-map-c? [ks-c? vs-c?]&amp;lt;br&amp;gt;  (every-pred #(instance? PersistentArrayMap %)&amp;lt;br&amp;gt;              #(every? ks-c? (keys %))&amp;lt;br&amp;gt;              #(every? vs-c? (vals %))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">array-map-c?</a>[ks-c? vs-c?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed.utils&lt;/i&gt;&lt;b&gt;defrecord&lt;/b&gt; ([name slots inv-description invariants &amp; etc])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defrecord [name slots inv-description invariants &amp;amp; etc]&amp;lt;br&amp;gt;  ;only define record if symbol doesn't resolve, not completely sure if this behaves like defonce&amp;lt;br&amp;gt;  (when-not (resolve name)&amp;lt;br&amp;gt;    `(contracts/defconstrainedrecord ~name ~slots ~inv-description ~invariants ~@etc)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defrecord</a>[name slots inv-description invariants & etc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed.utils&lt;/i&gt;&lt;b&gt;every-c?&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn every-c? [c]&amp;lt;br&amp;gt;  #(every? c %))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">every-c?</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed.utils&lt;/i&gt;&lt;b&gt;hash-c?&lt;/b&gt; ([ks-c? vs-c?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hash-c? [ks-c? vs-c?]&amp;lt;br&amp;gt;  (every-pred map?&amp;lt;br&amp;gt;              #(every? ks-c? (keys %))&amp;lt;br&amp;gt;              #(every? vs-c? (vals %))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hash-c?</a>[ks-c? vs-c?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed.utils&lt;/i&gt;&lt;b&gt;hmap-c?&lt;/b&gt; ([&amp; key-vals])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hmap-c? [&amp;amp; key-vals]&amp;lt;br&amp;gt;  (every-pred map?&amp;lt;br&amp;gt;              #(every? identity &amp;lt;br&amp;gt;                       (for [[k vc] (partition 2 key-vals)]&amp;lt;br&amp;gt;                         (and (contains? % k)&amp;lt;br&amp;gt;                              (vc (get % k)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hmap-c?</a>[& key-vals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed.utils&lt;/i&gt;&lt;b&gt;hvector-c?&lt;/b&gt; ([&amp; ps])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hvector-c? [&amp;amp; ps]&amp;lt;br&amp;gt;  (apply every-pred vector?&amp;lt;br&amp;gt;         (map (fn [p i] #(p (nth % i false))) ps (range))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hvector-c?</a>[& ps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed.utils&lt;/i&gt;&lt;b&gt;sequential-c?&lt;/b&gt; ([c?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sequential-c? [c?]&amp;lt;br&amp;gt;  (every-pred sequential?&amp;lt;br&amp;gt;              (every-c? c?)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sequential-c?</a>[c?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed.utils&lt;/i&gt;&lt;b&gt;set-c?&lt;/b&gt; ([c?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-c? [c?]&amp;lt;br&amp;gt;  (every-pred set?&amp;lt;br&amp;gt;              #(every? c? %)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-c?</a>[c?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed.utils&lt;/i&gt;&lt;b&gt;symbol-&gt;Class&lt;/b&gt; ([sym])&lt;br&gt; Returns the Class represented by the symbol. Works for&lt;br&gt;  primitives (eg. byte, int). Does not further resolve the symbol.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn symbol-&amp;gt;Class &amp;lt;br&amp;gt;  &amp;quot;Returns the Class represented by the symbol. Works for&amp;lt;br&amp;gt;  primitives (eg. byte, int). Does not further resolve the symbol.&amp;quot;&amp;lt;br&amp;gt;  [sym]&amp;lt;br&amp;gt;  {:pre [(symbol? sym)]&amp;lt;br&amp;gt;   :post [(class? %)]}&amp;lt;br&amp;gt;  (case sym&amp;lt;br&amp;gt;    byte Byte/TYPE&amp;lt;br&amp;gt;    short Short/TYPE&amp;lt;br&amp;gt;    int Integer/TYPE&amp;lt;br&amp;gt;    long Long/TYPE&amp;lt;br&amp;gt;    float Float/TYPE&amp;lt;br&amp;gt;    double Double/TYPE&amp;lt;br&amp;gt;    boolean Boolean/TYPE&amp;lt;br&amp;gt;    char Character/TYPE&amp;lt;br&amp;gt;    (Class/forName (str sym))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">symbol->Class</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.typed.utils&lt;/i&gt;&lt;b&gt;var-&gt;symbol&lt;/b&gt; ([var])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn var-&amp;gt;symbol [var]&amp;lt;br&amp;gt;  {:pre [(var? var)]&amp;lt;br&amp;gt;   :post [(symbol? %)&amp;lt;br&amp;gt;          (namespace %)]}&amp;lt;br&amp;gt;  (symbol (str (ns-name (.ns ^Var var)))&amp;lt;br&amp;gt;          (str (.sym ^Var var))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">var->symbol</a>[var]</div></div></div><div class="row"><div class="namespace"><h4>clojure.core.unify</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;create-var-unification-fn&lt;/b&gt; ([want-occurs?])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro create-var-unification-fn&amp;lt;br&amp;gt;  [want-occurs?]&amp;lt;br&amp;gt;  (let [varp  (gensym)&amp;lt;br&amp;gt;        v     (gensym)&amp;lt;br&amp;gt;        expr  (gensym)&amp;lt;br&amp;gt;        binds (gensym)]&amp;lt;br&amp;gt;    `(fn var-unify&amp;lt;br&amp;gt;       [~varp ~v ~expr ~binds]&amp;lt;br&amp;gt;       (if-let [vb# (~binds ~v)] &amp;lt;br&amp;gt;         (garner-unifiers ~varp vb# ~expr ~binds)&amp;lt;br&amp;gt;         (if-let [vexpr# (and (~varp ~expr) (~binds ~expr))]&amp;lt;br&amp;gt;           (garner-unifiers ~varp ~v vexpr# ~binds)&amp;lt;br&amp;gt;           ~(determine-occursness want-occurs? varp v expr binds))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">create-var-unification-fn</a>[want-occurs?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;extract-lvars&lt;/b&gt; ([form] [lv-fn form])&lt;br&gt; Takes a datastructure and returns a distinct set of the logical&lt;br&gt;   variables found within.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn extract-lvars&amp;lt;br&amp;gt;  &amp;quot;Takes a datastructure and returns a distinct set of the logical&amp;lt;br&amp;gt;   variables found within.&amp;quot;&amp;lt;br&amp;gt;  ([form]&amp;lt;br&amp;gt;     (extract-lvars lvar? form))&amp;lt;br&amp;gt;  ([lv-fn form]&amp;lt;br&amp;gt;     (set&amp;lt;br&amp;gt;      (walk/walk #(when (lv-fn %) %)&amp;lt;br&amp;gt;                 #(keep identity %)&amp;lt;br&amp;gt;                 form))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">extract-lvars</a>[form] [lv-fn form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;flatten-bindings&lt;/b&gt; ([binds] [variable? binds])&lt;br&gt; Flattens recursive bindings in the given map to the same ground (if possible).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn flatten-bindings&amp;lt;br&amp;gt;  &amp;quot;Flattens recursive bindings in the given map to the same ground (if possible).&amp;quot;&amp;lt;br&amp;gt;  ([binds] (flatten-bindings lvar? binds))&amp;lt;br&amp;gt;  ([variable? binds]&amp;lt;br&amp;gt;     (into {}&amp;lt;br&amp;gt;           (remove (comp nil? second)&amp;lt;br&amp;gt;                   (map (fn [[k v]]&amp;lt;br&amp;gt;                          [k (loop [v v]&amp;lt;br&amp;gt;                               (if (variable? v)&amp;lt;br&amp;gt;                                 (recur (binds v))&amp;lt;br&amp;gt;                                 v))])&amp;lt;br&amp;gt;                        binds)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">flatten-bindings</a>[binds] [variable? binds]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;ignore-variable?&lt;/b&gt; ([sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ignore-variable? [sym] (= '_ sym))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ignore-variable?</a>[sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;make-occurs-subst-fn&lt;/b&gt; ([variable-fn])&lt;br&gt; Given a function to recognize unification variables, returns a function that&lt;br&gt;   will attempt to substitute unification bindings between two expressions.&lt;br&gt;   This function uses an 'occurs check' methodology for detecting cycles.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-occurs-subst-fn&amp;lt;br&amp;gt;  &amp;quot;Given a function to recognize unification variables, returns a function that&amp;lt;br&amp;gt;   will attempt to substitute unification bindings between two expressions.&amp;lt;br&amp;gt;   This function uses an 'occurs check' methodology for detecting cycles.&amp;quot;&amp;lt;br&amp;gt;  [variable-fn]&amp;lt;br&amp;gt;  (partial try-subst variable-fn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-occurs-subst-fn</a>[variable-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;make-occurs-unifier-fn&lt;/b&gt; ([variable-fn])&lt;br&gt; Given a function to recognize unification variables, returns a function to&lt;br&gt;   perform the unification of two expressions. This function uses an 'occurs check'&lt;br&gt;   methodology for detecting cycles.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-occurs-unifier-fn&amp;lt;br&amp;gt;  &amp;quot;Given a function to recognize unification variables, returns a function to&amp;lt;br&amp;gt;   perform the unification of two expressions. This function uses an 'occurs check'&amp;lt;br&amp;gt;   methodology for detecting cycles.&amp;quot;&amp;lt;br&amp;gt;  [variable-fn]&amp;lt;br&amp;gt;  (partial unifier* variable-fn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-occurs-unifier-fn</a>[variable-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;make-occurs-unify-fn&lt;/b&gt; ([variable-fn])&lt;br&gt; Given a function to recognize unification variables, returns a function to&lt;br&gt;   return a bindings map for two expressions.  This function uses an 'occurs check'&lt;br&gt;   methodology for detecting cycles.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-occurs-unify-fn&amp;lt;br&amp;gt;  &amp;quot;Given a function to recognize unification variables, returns a function to&amp;lt;br&amp;gt;   return a bindings map for two expressions.  This function uses an 'occurs check'&amp;lt;br&amp;gt;   methodology for detecting cycles.&amp;quot;&amp;lt;br&amp;gt;  [variable-fn]&amp;lt;br&amp;gt;  (fn&amp;lt;br&amp;gt;    ([x y] (garner-unifiers unify-variable variable-fn x y {}))&amp;lt;br&amp;gt;    ([x y binds] (garner-unifiers unify-variable variable-fn x y binds))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-occurs-unify-fn</a>[variable-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;make-subst-fn&lt;/b&gt; ([variable-fn])&lt;br&gt; Given a function to recognize unification variables, returns a function that&lt;br&gt;   will attempt to substitute unification bindings between two expressions.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-subst-fn&amp;lt;br&amp;gt;  &amp;quot;Given a function to recognize unification variables, returns a function that&amp;lt;br&amp;gt;   will attempt to substitute unification bindings between two expressions.&amp;quot;&amp;lt;br&amp;gt;  [variable-fn]&amp;lt;br&amp;gt;  (partial try-subst variable-fn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-subst-fn</a>[variable-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;make-unifier-fn&lt;/b&gt; ([variable-fn])&lt;br&gt; Given a function to recognize unification variables, returns a function to&lt;br&gt;   perform the unification of two expressions.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-unifier-fn&amp;lt;br&amp;gt;  &amp;quot;Given a function to recognize unification variables, returns a function to&amp;lt;br&amp;gt;   perform the unification of two expressions.&amp;quot;&amp;lt;br&amp;gt;  [variable-fn]&amp;lt;br&amp;gt;  (fn [x y]&amp;lt;br&amp;gt;    (unifier* variable-fn&amp;lt;br&amp;gt;              x&amp;lt;br&amp;gt;              y&amp;lt;br&amp;gt;              (garner-unifiers unify-variable- variable-fn x y {}))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-unifier-fn</a>[variable-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;make-unify-fn&lt;/b&gt; ([variable-fn])&lt;br&gt; Given a function to recognize unification variables, returns a function to&lt;br&gt;   return a bindings map for two expressions.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-unify-fn&amp;lt;br&amp;gt;  &amp;quot;Given a function to recognize unification variables, returns a function to&amp;lt;br&amp;gt;   return a bindings map for two expressions.&amp;quot;&amp;lt;br&amp;gt;  [variable-fn]&amp;lt;br&amp;gt;  (fn&amp;lt;br&amp;gt;    ([x y] (garner-unifiers unify-variable- variable-fn x y {}))&amp;lt;br&amp;gt;    ([x y binds] (garner-unifiers unify-variable- variable-fn x y binds))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-unify-fn</a>[variable-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;subst&lt;/b&gt; ([expression bindings])&lt;br&gt; Attempts to substitute the bindings in the appropriate locations in the given expression.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def ^{:doc      (:doc (meta #'try-subst))&amp;lt;br&amp;gt;       :arglists '([expression bindings])}&amp;lt;br&amp;gt;  subst   (make-occurs-subst-fn lvar?))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subst</a>[expression bindings]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;unifier&lt;/b&gt; ([expression1 expression2])&lt;br&gt; Attempts the entire unification process from garnering the bindings to substituting&lt;br&gt;   the appropriate bindings.  Note: This function is implemented with an occurs-check.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def ^{:doc      (str (:doc (meta #'unifier*))&amp;lt;br&amp;gt;                      &amp;quot;  Note: This function is implemented with an occurs-check.&amp;quot;)&amp;lt;br&amp;gt;       :arglists '([expression1 expression2])}&amp;lt;br&amp;gt;  unifier (make-occurs-unifier-fn lvar?))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unifier</a>[expression1 expression2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;unifier-&lt;/b&gt; ([expression1 expression2])&lt;br&gt; Attempts the entire unification process from garnering the bindings to substituting&lt;br&gt;   the appropriate bindings.  Note: This function is implemented **without** an occurs-check.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def ^{:doc      (str (:doc (meta #'unifier*))&amp;lt;br&amp;gt;                      &amp;quot;  Note: This function is implemented **without** an occurs-check.&amp;quot;)&amp;lt;br&amp;gt;       :arglists '([expression1 expression2])}&amp;lt;br&amp;gt;  unifier- (make-unifier-fn lvar?))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unifier-</a>[expression1 expression2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;unify&lt;/b&gt; ([expression1 expression2])&lt;br&gt; Attempt to unify x and y with the given bindings (if any). Potentially returns a map of the &lt;br&gt;   unifiers (bindings) found.  Will throw an `IllegalStateException` if the expressions&lt;br&gt;   contain a cycle relationship.  Will also throw an `IllegalArgumentException` if the&lt;br&gt;   sub-expressions clash.  Note: This function is implemented with an occurs-check.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def ^{:doc      (str (:doc (meta #'garner-unifiers))&amp;lt;br&amp;gt;                      &amp;quot;  Note: This function is implemented with an occurs-check.&amp;quot;)&amp;lt;br&amp;gt;       :arglists '([expression1 expression2])}&amp;lt;br&amp;gt;  unify   (make-occurs-unify-fn lvar?))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unify</a>[expression1 expression2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;unify-&lt;/b&gt; ([expression1 expression2])&lt;br&gt; Attempt to unify x and y with the given bindings (if any). Potentially returns a map of the &lt;br&gt;   unifiers (bindings) found.  Will throw an `IllegalStateException` if the expressions&lt;br&gt;   contain a cycle relationship.  Will also throw an `IllegalArgumentException` if the&lt;br&gt;   sub-expressions clash.  Note: This function is implemented **without** an occurs-check.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(def ^{:doc      (str (:doc (meta #'garner-unifiers))&amp;lt;br&amp;gt;                      &amp;quot;  Note: This function is implemented **without** an occurs-check.&amp;quot;)&amp;lt;br&amp;gt;       :arglists '([expression1 expression2])}&amp;lt;br&amp;gt;  unify-   (make-unify-fn lvar?))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">unify-</a>[expression1 expression2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.core.unify&lt;/i&gt;&lt;b&gt;wildcard?&lt;/b&gt; ([form])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wildcard? [form]&amp;lt;br&amp;gt;  (and (composite? form)&amp;lt;br&amp;gt;       (#{'&amp;amp;} (first form))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wildcard?</a>[form]</div></div></div><div class="row"><div class="namespace"><h4>clojure.data</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data&lt;/i&gt;&lt;b&gt;diff&lt;/b&gt; ([a b])&lt;br&gt; Recursively compares a and b, returning a tuple of&lt;br&gt;  [things-only-in-a things-only-in-b things-in-both].&lt;br&gt;  Comparison rules:&lt;br&gt;&lt;br&gt;  * For equal a and b, return [nil nil a].&lt;br&gt;  * Maps are subdiffed where keys match and values differ.&lt;br&gt;  * Sets are never subdiffed.&lt;br&gt;  * All sequential things are treated as associative collections&lt;br&gt;    by their indexes, with results returned as vectors.&lt;br&gt;  * Everything else (including strings!) is treated as&lt;br&gt;    an atom and compared for equality.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn diff&amp;lt;br&amp;gt;  &amp;quot;Recursively compares a and b, returning a tuple of&amp;lt;br&amp;gt;  [things-only-in-a things-only-in-b things-in-both].&amp;lt;br&amp;gt;  Comparison rules:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  * For equal a and b, return [nil nil a].&amp;lt;br&amp;gt;  * Maps are subdiffed where keys match and values differ.&amp;lt;br&amp;gt;  * Sets are never subdiffed.&amp;lt;br&amp;gt;  * All sequential things are treated as associative collections&amp;lt;br&amp;gt;    by their indexes, with results returned as vectors.&amp;lt;br&amp;gt;  * Everything else (including strings!) is treated as&amp;lt;br&amp;gt;    an atom and compared for equality.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [a b]&amp;lt;br&amp;gt;  (if (= a b)&amp;lt;br&amp;gt;    [nil nil a]&amp;lt;br&amp;gt;    (if (= (equality-partition a) (equality-partition b))&amp;lt;br&amp;gt;      (diff-similar a b)&amp;lt;br&amp;gt;      (atom-diff a b))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">diff</a>[a b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data&lt;/i&gt;&lt;b&gt;diff-similar&lt;/b&gt; ([a b])&lt;br&gt; Implementation detail. Subject to change.&lt;/div&gt;" data-placement="right">diff-similar</a>[a b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data&lt;/i&gt;&lt;b&gt;equality-partition&lt;/b&gt; ([x])&lt;br&gt; Implementation detail. Subject to change.&lt;/div&gt;" data-placement="right">equality-partition</a>[x]</div></div></div><div class="row"><div class="namespace"><h4>clojure.data.codec.base64</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.codec.base64&lt;/i&gt;&lt;b&gt;dec-length&lt;/b&gt; ([in-length pad-length])&lt;br&gt; Calculates what would be the length after decoding of an input array of length&lt;br&gt;   in-length with the specified padding length.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dec-length&amp;lt;br&amp;gt;  &amp;quot;Calculates what would be the length after decoding of an input array of length&amp;lt;br&amp;gt;   in-length with the specified padding length.&amp;quot;&amp;lt;br&amp;gt;  ^long [^long in-length ^long pad-length]&amp;lt;br&amp;gt;  (-&amp;gt; in-length&amp;lt;br&amp;gt;    (quot 4)&amp;lt;br&amp;gt;    (* 3)&amp;lt;br&amp;gt;    (- pad-length)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dec-length</a>[in-length pad-length]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.codec.base64&lt;/i&gt;&lt;b&gt;decode&lt;/b&gt; ([input] [input offset length])&lt;br&gt; Returns a base64 decoded byte array.&lt;br&gt;&lt;br&gt;  Note: length must be a multiple of 4.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn decode&amp;lt;br&amp;gt;  &amp;quot;Returns a base64 decoded byte array.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Note: length must be a multiple of 4.&amp;quot;&amp;lt;br&amp;gt;  ([^bytes input]&amp;lt;br&amp;gt;    (decode input 0 (alength input)))&amp;lt;br&amp;gt;  ([^bytes input ^long offset ^long length]&amp;lt;br&amp;gt;    (let [dest (byte-array (dec-length length (pad-length input offset length)))]&amp;lt;br&amp;gt;      (decode! input offset length dest)&amp;lt;br&amp;gt;      dest)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">decode</a>[input] [input offset length]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.codec.base64&lt;/i&gt;&lt;b&gt;decode!&lt;/b&gt; ([input offset length output])&lt;br&gt; Reads from the input byte array for the specified length starting at the offset&lt;br&gt;   index, and base64 decodes into the output array starting at index 0. Returns the&lt;br&gt;   length written to output.&lt;br&gt;&lt;br&gt;   Note: length must be a multiple of 4.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn decode!&amp;lt;br&amp;gt;  &amp;quot;Reads from the input byte array for the specified length starting at the offset&amp;lt;br&amp;gt;   index, and base64 decodes into the output array starting at index 0. Returns the&amp;lt;br&amp;gt;   length written to output.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Note: length must be a multiple of 4.&amp;quot;&amp;lt;br&amp;gt;  ^long [^bytes input ^long offset ^long length ^bytes output]&amp;lt;br&amp;gt;  (let [in-end (+ offset length -1)&amp;lt;br&amp;gt;        pad-len (pad-length input offset length)&amp;lt;br&amp;gt;        out-len (dec-length length pad-len)&amp;lt;br&amp;gt;        out-end (dec out-len)&amp;lt;br&amp;gt;        tail-len (rem out-len 3)&amp;lt;br&amp;gt;        loop-lim (- out-len tail-len)]&amp;lt;br&amp;gt;    (loop [i offset j 0]&amp;lt;br&amp;gt;      (when (&amp;lt; j loop-lim)&amp;lt;br&amp;gt;        (let [a (long (aget dec-bytes (aget input i)))&amp;lt;br&amp;gt;              b (long (aget dec-bytes (aget input (inc i))))&amp;lt;br&amp;gt;              c (long (aget dec-bytes (aget input (+ 2 i))))&amp;lt;br&amp;gt;              d (long (aget dec-bytes (aget input (+ 3 i))))&amp;lt;br&amp;gt;              x1 (-&amp;gt; a&amp;lt;br&amp;gt;                   (bit-and 0x3F)&amp;lt;br&amp;gt;                   (bit-shift-left 2))&amp;lt;br&amp;gt;              x2 (-&amp;gt; b&amp;lt;br&amp;gt;                   (bit-shift-right 4)&amp;lt;br&amp;gt;                   (bit-and 0x3))&amp;lt;br&amp;gt;              y1 (-&amp;gt;&amp;lt;br&amp;gt;                   (bit-and b 0xF)&amp;lt;br&amp;gt;                   (bit-shift-left 4))&amp;lt;br&amp;gt;              y2 (-&amp;gt; c&amp;lt;br&amp;gt;                   (bit-shift-right 2)&amp;lt;br&amp;gt;                   (bit-and 0xF))&amp;lt;br&amp;gt;              z1 (-&amp;gt; c&amp;lt;br&amp;gt;                   (bit-and 0x3)&amp;lt;br&amp;gt;                   (bit-shift-left 6))&amp;lt;br&amp;gt;              z2 (bit-and d 0x3F)&amp;lt;br&amp;gt;              x (bit-or x1 x2)&amp;lt;br&amp;gt;              y (bit-or y1 y2)&amp;lt;br&amp;gt;              z (bit-or z1 z2)]&amp;lt;br&amp;gt;          (aset output j (byte x))&amp;lt;br&amp;gt;          (aset output (inc j) (byte y))&amp;lt;br&amp;gt;          (aset output (+ 2 j) (byte z)))&amp;lt;br&amp;gt;        (recur (+ 4 i) (+ 3 j))))&amp;lt;br&amp;gt;    ; handle padded section&amp;lt;br&amp;gt;    (case tail-len&amp;lt;br&amp;gt;      0 nil&amp;lt;br&amp;gt;      1 (let [i (- in-end 3)&amp;lt;br&amp;gt;              j out-end&amp;lt;br&amp;gt;              a (long (aget dec-bytes (aget input i)))&amp;lt;br&amp;gt;              b (long (aget dec-bytes (aget input (inc i))))&amp;lt;br&amp;gt;              x1 (-&amp;gt; a&amp;lt;br&amp;gt;                   (bit-and 0x3F)&amp;lt;br&amp;gt;                   (bit-shift-left 2))&amp;lt;br&amp;gt;              x2 (-&amp;gt; b&amp;lt;br&amp;gt;                   (bit-shift-right 4)&amp;lt;br&amp;gt;                   (bit-and 0x3))&amp;lt;br&amp;gt;              x (bit-or x1 x2)]&amp;lt;br&amp;gt;          (aset output j (byte x)))&amp;lt;br&amp;gt;      2 (let [i (- in-end 3)&amp;lt;br&amp;gt;              j (dec out-end)&amp;lt;br&amp;gt;              a (long (aget dec-bytes (aget input i)))&amp;lt;br&amp;gt;              b (long (aget dec-bytes (aget input (inc i))))&amp;lt;br&amp;gt;              c (long (aget dec-bytes (aget input (+ 2 i))))&amp;lt;br&amp;gt;              x1 (-&amp;gt; a&amp;lt;br&amp;gt;                   (bit-and 0x3F)&amp;lt;br&amp;gt;                   (bit-shift-left 2))&amp;lt;br&amp;gt;              x2 (-&amp;gt; b&amp;lt;br&amp;gt;                   (bit-shift-right 4)&amp;lt;br&amp;gt;                   (bit-and 0x3))&amp;lt;br&amp;gt;              y1 (-&amp;gt;&amp;lt;br&amp;gt;                   (bit-and b 0xF)&amp;lt;br&amp;gt;                   (bit-shift-left 4))&amp;lt;br&amp;gt;              y2 (-&amp;gt; c&amp;lt;br&amp;gt;                   (bit-shift-right 2)&amp;lt;br&amp;gt;                   (bit-and 0xF))&amp;lt;br&amp;gt;              x (bit-or x1 x2)&amp;lt;br&amp;gt;              y (bit-or y1 y2)]&amp;lt;br&amp;gt;          (aset output j (byte x))&amp;lt;br&amp;gt;          (aset output (inc j) (byte y))))&amp;lt;br&amp;gt;    out-len))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">decode!</a>[input offset length output]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.codec.base64&lt;/i&gt;&lt;b&gt;decoding-transfer&lt;/b&gt; ([input-stream output-stream &amp; opts])&lt;br&gt; Base64 decodes from input-stream to output-stream. Returns nil or throws IOException.&lt;br&gt;&lt;br&gt;  Options are key/value pairs and may be one of&lt;br&gt;    :buffer-size  read buffer size to use, must be a multiple of 4; default is 8192.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn decoding-transfer&amp;lt;br&amp;gt;  &amp;quot;Base64 decodes from input-stream to output-stream. Returns nil or throws IOException.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Options are key/value pairs and may be one of&amp;lt;br&amp;gt;    :buffer-size  read buffer size to use, must be a multiple of 4; default is 8192.&amp;quot;&amp;lt;br&amp;gt;  [^InputStream input-stream ^OutputStream output-stream &amp;amp; opts]&amp;lt;br&amp;gt;  (let [opts (when opts (apply hash-map opts))&amp;lt;br&amp;gt;        in-size (buf-size opts 8192 4)&amp;lt;br&amp;gt;        out-size (if (== in-size 8192) 6144 (dec-length in-size 0))&amp;lt;br&amp;gt;        in-buf (byte-array in-size)&amp;lt;br&amp;gt;        out-buf (byte-array out-size)]&amp;lt;br&amp;gt;    (loop []&amp;lt;br&amp;gt;      (let [in-size (read-fully input-stream in-buf)]&amp;lt;br&amp;gt;        (when (pos? in-size)&amp;lt;br&amp;gt;          (let [out-size (decode! in-buf 0 in-size out-buf)]&amp;lt;br&amp;gt;            (.write output-stream out-buf 0 out-size)&amp;lt;br&amp;gt;            (recur)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">decoding-transfer</a>[input-stream output-stream & opts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.codec.base64&lt;/i&gt;&lt;b&gt;enc-length&lt;/b&gt; ([n])&lt;br&gt; Calculates what would be the length after encoding of an input array of length n.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn enc-length&amp;lt;br&amp;gt;  &amp;quot;Calculates what would be the length after encoding of an input array of length n.&amp;quot;&amp;lt;br&amp;gt;  ^long [^long n]&amp;lt;br&amp;gt;  (-&amp;gt; n&amp;lt;br&amp;gt;    (+ 2)&amp;lt;br&amp;gt;    (quot 3)&amp;lt;br&amp;gt;    (* 4)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">enc-length</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.codec.base64&lt;/i&gt;&lt;b&gt;encode&lt;/b&gt; ([input] [input offset length])&lt;br&gt; Returns a base64 encoded byte array.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn encode&amp;lt;br&amp;gt;  &amp;quot;Returns a base64 encoded byte array.&amp;quot;&amp;lt;br&amp;gt;  ([^bytes input]&amp;lt;br&amp;gt;    (encode input 0 (alength input)))&amp;lt;br&amp;gt;  ([^bytes input ^long offset ^long length]&amp;lt;br&amp;gt;    (let [dest (byte-array (enc-length length))]&amp;lt;br&amp;gt;      (encode! input offset length dest)&amp;lt;br&amp;gt;      dest)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">encode</a>[input] [input offset length]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.codec.base64&lt;/i&gt;&lt;b&gt;encode!&lt;/b&gt; ([input offset length output])&lt;br&gt; Reads from the input byte array for the specified length starting at the offset&lt;br&gt;   index, and base64 encodes into the output array starting at index 0. Returns the&lt;br&gt;   length written to output.&lt;br&gt;&lt;br&gt;   Note: if using partial input, length must be a multiple of 3 to avoid padding.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn encode!&amp;lt;br&amp;gt;  &amp;quot;Reads from the input byte array for the specified length starting at the offset&amp;lt;br&amp;gt;   index, and base64 encodes into the output array starting at index 0. Returns the&amp;lt;br&amp;gt;   length written to output.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Note: if using partial input, length must be a multiple of 3 to avoid padding.&amp;quot;&amp;lt;br&amp;gt;  ^long [^bytes input ^long offset ^long length ^bytes output]&amp;lt;br&amp;gt;  (let [tail-len (rem length 3)&amp;lt;br&amp;gt;        loop-lim (- (+ offset length) tail-len)&amp;lt;br&amp;gt;        in-end (dec (+ offset length))&amp;lt;br&amp;gt;        out-len (enc-length length)&amp;lt;br&amp;gt;        out-end (dec out-len)]&amp;lt;br&amp;gt;    (loop [i offset j 0]&amp;lt;br&amp;gt;      (when (&amp;lt; i loop-lim)&amp;lt;br&amp;gt;        (let [x (long (aget input i))&amp;lt;br&amp;gt;              y (long (aget input (inc i)))&amp;lt;br&amp;gt;              z (long (aget input (+ 2 i)))&amp;lt;br&amp;gt;              a (-&amp;gt; x&amp;lt;br&amp;gt;                  (bit-shift-right 2)&amp;lt;br&amp;gt;                  (bit-and 0x3F))&amp;lt;br&amp;gt;              b1 (-&amp;gt; x&amp;lt;br&amp;gt;                   (bit-and 0x3)&amp;lt;br&amp;gt;                   (bit-shift-left 4))&amp;lt;br&amp;gt;              b2 (-&amp;gt; y&amp;lt;br&amp;gt;                   (bit-shift-right 4)&amp;lt;br&amp;gt;                   (bit-and 0xF))&amp;lt;br&amp;gt;              b (bit-or b1 b2)&amp;lt;br&amp;gt;              c1 (-&amp;gt; y&amp;lt;br&amp;gt;                   (bit-and 0xF)&amp;lt;br&amp;gt;                   (bit-shift-left 2))&amp;lt;br&amp;gt;              c2 (-&amp;gt; z&amp;lt;br&amp;gt;                   (bit-shift-right 6)&amp;lt;br&amp;gt;                   (bit-and 0x3))&amp;lt;br&amp;gt;              c (bit-or c1 c2)&amp;lt;br&amp;gt;              d (bit-and z 0x3F)]&amp;lt;br&amp;gt;          (aset output j (aget enc-bytes a))&amp;lt;br&amp;gt;          (aset output (inc j) (aget enc-bytes b))&amp;lt;br&amp;gt;          (aset output (+ 2 j) (aget enc-bytes c))&amp;lt;br&amp;gt;          (aset output (+ 3 j) (aget enc-bytes d)))&amp;lt;br&amp;gt;        (recur (+ 3 i) (+ 4 j))))&amp;lt;br&amp;gt;    ; write padded section&amp;lt;br&amp;gt;    (case tail-len&amp;lt;br&amp;gt;      0 nil&amp;lt;br&amp;gt;      1 (let [i in-end&amp;lt;br&amp;gt;              j (- out-end 3)&amp;lt;br&amp;gt;              x (long (aget input i))&amp;lt;br&amp;gt;              a (-&amp;gt; x&amp;lt;br&amp;gt;                  (bit-shift-right 2)&amp;lt;br&amp;gt;                  (bit-and 0x3F))&amp;lt;br&amp;gt;              b1 (-&amp;gt; x&amp;lt;br&amp;gt;                   (bit-and 0x3)&amp;lt;br&amp;gt;                   (bit-shift-left 4))]&amp;lt;br&amp;gt;          (aset output j (aget enc-bytes a))&amp;lt;br&amp;gt;          (aset output (inc j) (aget enc-bytes b1))&amp;lt;br&amp;gt;          (aset output (+ 2 j) (byte 61))&amp;lt;br&amp;gt;          (aset output (+ 3 j) (byte 61)))&amp;lt;br&amp;gt;      2 (let [i (dec in-end)&amp;lt;br&amp;gt;              j (- out-end 3)&amp;lt;br&amp;gt;              x (long (aget input i))&amp;lt;br&amp;gt;              y (long (aget input (inc i)))&amp;lt;br&amp;gt;              a (-&amp;gt; x&amp;lt;br&amp;gt;                  (bit-shift-right 2)&amp;lt;br&amp;gt;                  (bit-and 0x3F))&amp;lt;br&amp;gt;              b1 (-&amp;gt; x&amp;lt;br&amp;gt;                   (bit-and 0x3)&amp;lt;br&amp;gt;                   (bit-shift-left 4))&amp;lt;br&amp;gt;              b2 (-&amp;gt; y&amp;lt;br&amp;gt;                   (bit-shift-right 4)&amp;lt;br&amp;gt;                   (bit-and 0xF))&amp;lt;br&amp;gt;              b (bit-or b1 b2)&amp;lt;br&amp;gt;              c1 (-&amp;gt; y&amp;lt;br&amp;gt;                   (bit-and 0xF)&amp;lt;br&amp;gt;                   (bit-shift-left 2))]&amp;lt;br&amp;gt;          (aset output j (aget enc-bytes a))&amp;lt;br&amp;gt;          (aset output (inc j) (aget enc-bytes b))&amp;lt;br&amp;gt;          (aset output (+ 2 j) (aget enc-bytes c1))&amp;lt;br&amp;gt;          (aset output (+ 3 j) (byte 61))))&amp;lt;br&amp;gt;    out-len))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">encode!</a>[input offset length output]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.codec.base64&lt;/i&gt;&lt;b&gt;encoding-transfer&lt;/b&gt; ([input-stream output-stream &amp; opts])&lt;br&gt; Base64 encodes from input-stream to output-stream. Returns nil or throws IOException.&lt;br&gt;&lt;br&gt;  Options are key/value pairs and may be one of&lt;br&gt;    :buffer-size  read buffer size to use, must be a multiple of 3; default is 6144.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn encoding-transfer&amp;lt;br&amp;gt;  &amp;quot;Base64 encodes from input-stream to output-stream. Returns nil or throws IOException.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Options are key/value pairs and may be one of&amp;lt;br&amp;gt;    :buffer-size  read buffer size to use, must be a multiple of 3; default is 6144.&amp;quot;&amp;lt;br&amp;gt;  [^InputStream input-stream ^OutputStream output-stream &amp;amp; opts]&amp;lt;br&amp;gt;  (let [opts (when opts (apply hash-map opts))&amp;lt;br&amp;gt;        in-size (buf-size opts 6144 3)&amp;lt;br&amp;gt;        out-size (if (== in-size 6144) 8192 (enc-length in-size))&amp;lt;br&amp;gt;        in-buf (byte-array in-size)&amp;lt;br&amp;gt;        out-buf (byte-array out-size)]&amp;lt;br&amp;gt;    (loop []&amp;lt;br&amp;gt;      (let [in-size (read-fully input-stream in-buf)]&amp;lt;br&amp;gt;        (when (pos? in-size)&amp;lt;br&amp;gt;          (let [out-size (encode! in-buf 0 in-size out-buf)]&amp;lt;br&amp;gt;            (.write output-stream out-buf 0 out-size)&amp;lt;br&amp;gt;            (recur)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">encoding-transfer</a>[input-stream output-stream & opts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.codec.base64&lt;/i&gt;&lt;b&gt;pad-length&lt;/b&gt; ([input offset length])&lt;br&gt; Returns the length of padding on the end of the input array.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pad-length&amp;lt;br&amp;gt;  &amp;quot;Returns the length of padding on the end of the input array.&amp;quot;&amp;lt;br&amp;gt;  ^long [^bytes input ^long offset ^long length]&amp;lt;br&amp;gt;  (let [end (+ offset length -1)]&amp;lt;br&amp;gt;    (if (== 61 (long (aget input end)))&amp;lt;br&amp;gt;      (if (== 61 (long (aget input (dec end))))&amp;lt;br&amp;gt;        2&amp;lt;br&amp;gt;        1)&amp;lt;br&amp;gt;      0)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pad-length</a>[input offset length]</div></div></div><div class="row"><div class="namespace"><h4>clojure.data.csv</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.csv&lt;/i&gt;&lt;b&gt;read-csv&lt;/b&gt; ([input &amp; options])&lt;br&gt; Reads CSV-data from input (String or java.io.Reader) into a lazy&lt;br&gt;  sequence of vectors.&lt;br&gt;&lt;br&gt;   Valid options are&lt;br&gt;     :separator (default \,)&lt;br&gt;     :quote (default \&quot;)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-csv&amp;lt;br&amp;gt;  &amp;quot;Reads CSV-data from input (String or java.io.Reader) into a lazy&amp;lt;br&amp;gt;  sequence of vectors.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Valid options are&amp;lt;br&amp;gt;     :separator (default \\,)&amp;lt;br&amp;gt;     :quote (default \\\&amp;quot;)&amp;quot;&amp;lt;br&amp;gt;  [input &amp;amp; options]&amp;lt;br&amp;gt;  (let [{:keys [separator quote] :or {separator \, quote \&amp;quot;}} options]&amp;lt;br&amp;gt;    (read-csv-from input (int separator) (int quote))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-csv</a>[input & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.csv&lt;/i&gt;&lt;b&gt;read-csv-from&lt;/b&gt; ([input sep quote])&lt;br&gt; &lt;/div&gt;" data-placement="right">read-csv-from</a>[input sep quote]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.csv&lt;/i&gt;&lt;b&gt;write-csv&lt;/b&gt; ([writer data &amp; options])&lt;br&gt; Writes data to writer in CSV-format.&lt;br&gt;&lt;br&gt;   Valid options are&lt;br&gt;     :separator (Default \,)&lt;br&gt;     :quote (Default \&quot;)&lt;br&gt;     :guote? (A predicate function which determines if a string should be quoted. Defaults to quoting only when necessary.)&lt;br&gt;     :newline (:lf (default) or :cr+lf)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn write-csv&amp;lt;br&amp;gt;  &amp;quot;Writes data to writer in CSV-format.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Valid options are&amp;lt;br&amp;gt;     :separator (Default \\,)&amp;lt;br&amp;gt;     :quote (Default \\\&amp;quot;)&amp;lt;br&amp;gt;     :guote? (A predicate function which determines if a string should be quoted. Defaults to quoting only when necessary.)&amp;lt;br&amp;gt;     :newline (:lf (default) or :cr+lf)&amp;quot;&amp;lt;br&amp;gt;  [writer data &amp;amp; options]&amp;lt;br&amp;gt;  (let [opts (apply hash-map options)&amp;lt;br&amp;gt;        separator (or (:separator opts) \,)&amp;lt;br&amp;gt;        quote (or (:quote opts) \&amp;quot;)&amp;lt;br&amp;gt;        quote? (or (:quote? opts) #(some #{separator quote \return \newline} %))&amp;lt;br&amp;gt;        newline (or (:newline opts) :lf)]&amp;lt;br&amp;gt;    (write-csv* writer&amp;lt;br&amp;gt;		data&amp;lt;br&amp;gt;		separator&amp;lt;br&amp;gt;		quote&amp;lt;br&amp;gt;                quote?&amp;lt;br&amp;gt;		({:lf &amp;quot;\n&amp;quot; :cr+lf &amp;quot;\r\n&amp;quot;} newline))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">write-csv</a>[writer data & options]</div></div></div><div class="row"><div class="namespace"><h4>clojure.data.finger-tree</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;-&gt;CountedDoubleList&lt;/b&gt; ([tree])&lt;br&gt; Positional factory function for class clojure.data.finger_tree.CountedDoubleList.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype CountedDoubleList [tree]&amp;lt;br&amp;gt;  Sequential&amp;lt;br&amp;gt;  Seqable&amp;lt;br&amp;gt;    (seq [this] (when (seq tree) this))&amp;lt;br&amp;gt;  IPersistentCollection&amp;lt;br&amp;gt;    (cons [this x] (conjr this x))&amp;lt;br&amp;gt;    (empty [_] (CountedDoubleList. (empty tree)))&amp;lt;br&amp;gt;    (equiv [_ x] false) ; TBD&amp;lt;br&amp;gt;  ISeq&amp;lt;br&amp;gt;    (first [_] (first tree))&amp;lt;br&amp;gt;    (more [_] (CountedDoubleList. (rest tree)))&amp;lt;br&amp;gt;    (next [_] (if-let [t (next tree)] (CountedDoubleList. t)))&amp;lt;br&amp;gt;  IPersistentStack&amp;lt;br&amp;gt;    (peek [_] (peek tree))&amp;lt;br&amp;gt;    (pop [_] (CountedDoubleList. (pop tree)))&amp;lt;br&amp;gt;  Reversible&amp;lt;br&amp;gt;    (rseq [_] (rseq tree)) ; not 'this' because tree ops can't be reversed&amp;lt;br&amp;gt;  DoubleSeq&amp;lt;br&amp;gt;    (consl [_ a] (CountedDoubleList. (consl tree a)))&amp;lt;br&amp;gt;    (conjr [_ b] (CountedDoubleList. (conjr tree b)))&amp;lt;br&amp;gt;  Measured&amp;lt;br&amp;gt;    (measured [_] (measured tree))&amp;lt;br&amp;gt;    (getMeter [_] (getMeter tree)) ; not needed?&amp;lt;br&amp;gt;  SplitAt&amp;lt;br&amp;gt;    (ft-split-at [this n notfound]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;        (&amp;lt; n 0) [(empty this) notfound this]&amp;lt;br&amp;gt;        (&amp;lt; n (count this))&amp;lt;br&amp;gt;          (let [[pre m post] (split-tree tree #(&amp;gt; % n))]&amp;lt;br&amp;gt;            [(CountedDoubleList. pre) m (CountedDoubleList. post)])&amp;lt;br&amp;gt;        :else [this notfound (empty this)]))&amp;lt;br&amp;gt;    (ft-split-at [this n]&amp;lt;br&amp;gt;      (ft-split-at this n nil))&amp;lt;br&amp;gt;  Tree&amp;lt;br&amp;gt;    (app3 [_ ts t2]&amp;lt;br&amp;gt;      (CountedDoubleList. (app3 tree ts (.tree ^CountedDoubleList t2))))&amp;lt;br&amp;gt;    ;(app3deep [_ ts t1] (CountedDoubleList. (app3deep tree ts t1)))&amp;lt;br&amp;gt;    (measureMore [_] (measureMore tree))&amp;lt;br&amp;gt;    (measurePop [_] (measurePop tree))&amp;lt;br&amp;gt;  Counted&amp;lt;br&amp;gt;    (count [_] (measured tree))&amp;lt;br&amp;gt;  Associative&amp;lt;br&amp;gt;    (assoc [this k v]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;        (== k -1) (consl this v)&amp;lt;br&amp;gt;        (== k (measured tree)) (conjr this v)&amp;lt;br&amp;gt;        (&amp;lt; -1 k (measured tree))&amp;lt;br&amp;gt;          (let [[pre mid post] (split-tree tree #(&amp;gt; % k))]&amp;lt;br&amp;gt;            (CountedDoubleList. (ft-concat (conjr pre v) post)))&amp;lt;br&amp;gt;        :else (throw (IndexOutOfBoundsException.))))&amp;lt;br&amp;gt;    (containsKey [_ k] (&amp;lt; -1 k (measured tree)))&amp;lt;br&amp;gt;    (entryAt [_ n] (clojure.lang.MapEntry.&amp;lt;br&amp;gt;                     n (second (split-tree tree #(&amp;gt; % n)))))&amp;lt;br&amp;gt;    (valAt [this n notfound] (if (.containsKey this n)&amp;lt;br&amp;gt;                               (second (split-tree tree #(&amp;gt; % n)))&amp;lt;br&amp;gt;                               notfound))&amp;lt;br&amp;gt;    (valAt [this n] (.valAt this n nil))&amp;lt;br&amp;gt;  Indexed&amp;lt;br&amp;gt;    (nth [this n notfound] (if (.containsKey this n)&amp;lt;br&amp;gt;                             (second (split-tree tree #(&amp;gt; % n)))&amp;lt;br&amp;gt;                             notfound))&amp;lt;br&amp;gt;    (nth [this n] (if (.containsKey this n)&amp;lt;br&amp;gt;                    (second (split-tree tree #(&amp;gt; % n)))&amp;lt;br&amp;gt;                    (throw (IndexOutOfBoundsException.)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->CountedDoubleList</a>[tree]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;-&gt;CountedSortedSet&lt;/b&gt; ([cmpr tree])&lt;br&gt; Positional factory function for class clojure.data.finger_tree.CountedSortedSet.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype CountedSortedSet [cmpr tree]&amp;lt;br&amp;gt;  Sequential&amp;lt;br&amp;gt;  Seqable&amp;lt;br&amp;gt;    (seq [this] (when (seq tree) this))&amp;lt;br&amp;gt;  IPersistentCollection&amp;lt;br&amp;gt;    (cons [this value]&amp;lt;br&amp;gt;      (if (empty? tree)&amp;lt;br&amp;gt;        (CountedSortedSet. cmpr (conjr tree value))&amp;lt;br&amp;gt;        (let [[l x r] (split-tree tree #(&amp;gt;= 0 (cmpr value (:right %))))&amp;lt;br&amp;gt;              compared (cmpr value x)]&amp;lt;br&amp;gt;          (if (zero? compared)&amp;lt;br&amp;gt;            this ; already in set&amp;lt;br&amp;gt;            (let [[a b] (if (&amp;gt;= 0 compared) [value x] [x value])]&amp;lt;br&amp;gt;              (CountedSortedSet. cmpr (ft-concat (conjr l a) (consl r b))))))))&amp;lt;br&amp;gt;    (empty [_] (CountedSortedSet. cmpr (empty tree)))&amp;lt;br&amp;gt;    (equiv [_ x] false) ; TBD&amp;lt;br&amp;gt;  ISeq&amp;lt;br&amp;gt;    (first [_] (first tree))&amp;lt;br&amp;gt;    (more [_] (CountedSortedSet. cmpr (rest tree)))&amp;lt;br&amp;gt;    (next [_] (if-let [t (next tree)] (CountedSortedSet. cmpr t)))&amp;lt;br&amp;gt;  IPersistentStack&amp;lt;br&amp;gt;    (peek [_] (peek tree))&amp;lt;br&amp;gt;    (pop [_] (CountedSortedSet. cmpr (pop tree)))&amp;lt;br&amp;gt;  Reversible&amp;lt;br&amp;gt;    (rseq [_] (rseq tree)) ; not 'this' because tree ops can't be reversed&amp;lt;br&amp;gt;  Measured&amp;lt;br&amp;gt;    (measured [_] (measured tree))&amp;lt;br&amp;gt;    (getMeter [_] (getMeter tree)) ; not needed?&amp;lt;br&amp;gt;  SplitAt&amp;lt;br&amp;gt;    (ft-split-at [this n notfound]&amp;lt;br&amp;gt;      (cond&amp;lt;br&amp;gt;        (&amp;lt; n 0) [(empty this) notfound this]&amp;lt;br&amp;gt;        (&amp;lt; n (count this)) (let [[l x r] (split-tree tree #(&amp;gt; (:len %) n))]&amp;lt;br&amp;gt;                             [(CountedSortedSet. cmpr l) x&amp;lt;br&amp;gt;                              (CountedSortedSet. cmpr r)])&amp;lt;br&amp;gt;        :else [this notfound (empty this)]))&amp;lt;br&amp;gt;    (ft-split-at [this n]&amp;lt;br&amp;gt;      (ft-split-at this n nil))&amp;lt;br&amp;gt;  Counted&amp;lt;br&amp;gt;    (count [_] (:len (measured tree)))&amp;lt;br&amp;gt;  ILookup&amp;lt;br&amp;gt;    (valAt [_ k notfound]&amp;lt;br&amp;gt;      (if (empty? tree)&amp;lt;br&amp;gt;        notfound&amp;lt;br&amp;gt;        (let [x (second (split-tree tree #(&amp;gt;= 0 (cmpr k (:right %)))))]&amp;lt;br&amp;gt;          (if (= x k)&amp;lt;br&amp;gt;            k&amp;lt;br&amp;gt;            notfound))))&amp;lt;br&amp;gt;    (valAt [this k]&amp;lt;br&amp;gt;      (.valAt this k nil))&amp;lt;br&amp;gt;  IPersistentSet&amp;lt;br&amp;gt;    (disjoin [this k]&amp;lt;br&amp;gt;      (if (empty? tree)&amp;lt;br&amp;gt;        this&amp;lt;br&amp;gt;        (let [[l x r] (split-tree tree #(&amp;gt;= 0 (cmpr k (:right %))))]&amp;lt;br&amp;gt;          (if (= x k)&amp;lt;br&amp;gt;            (CountedSortedSet. cmpr (ft-concat l r))&amp;lt;br&amp;gt;            this))))&amp;lt;br&amp;gt;    (get [this k] (.valAt this k nil))&amp;lt;br&amp;gt;  Indexed&amp;lt;br&amp;gt;    (nth [this n notfound] (if (&amp;lt; -1 n (:len (measured tree)))&amp;lt;br&amp;gt;                             (second (split-tree tree #(&amp;gt; (:len %) n)))&amp;lt;br&amp;gt;                             notfound))&amp;lt;br&amp;gt;    (nth [this n] (if (&amp;lt; -1 n (:len (measured tree)))&amp;lt;br&amp;gt;                    (second (split-tree tree #(&amp;gt; (:len %) n)))&amp;lt;br&amp;gt;                    (throw (IndexOutOfBoundsException.))))&amp;lt;br&amp;gt;  Sorted&amp;lt;br&amp;gt;    (comparator [_] cmpr)&amp;lt;br&amp;gt;    (entryKey [_ x] x)&amp;lt;br&amp;gt;    (seq [this ascending?] (if ascending?  (.seq this) (rseq tree)))&amp;lt;br&amp;gt;    (seqFrom [_ k ascending?]&amp;lt;br&amp;gt;      (let [[l x r] (split-tree tree #(&amp;gt;= 0 (cmpr k (:right %))))]&amp;lt;br&amp;gt;        (if ascending?&amp;lt;br&amp;gt;          (CountedSortedSet. cmpr (consl r x))&amp;lt;br&amp;gt;          (rseq (conjr l x))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->CountedSortedSet</a>[cmpr tree]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;-&gt;DeepTree&lt;/b&gt; ([meter-obj pre mid suf mval])&lt;br&gt; Positional factory function for class clojure.data.finger_tree.DeepTree.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype DeepTree [meter-obj pre mid suf mval]&amp;lt;br&amp;gt;  Seqable&amp;lt;br&amp;gt;    (seq [this] this)&amp;lt;br&amp;gt;  IPersistentCollection&amp;lt;br&amp;gt;    (cons [this x] (conjr this x))&amp;lt;br&amp;gt;    (count [_]) ; not needed?&amp;lt;br&amp;gt;    (empty [_] (newEmptyTree meter-obj))&amp;lt;br&amp;gt;    (equiv [_ x] false) ; TBD&amp;lt;br&amp;gt;  ISeq&amp;lt;br&amp;gt;    (first [_] (first pre))&amp;lt;br&amp;gt;    (more [_] (deep-left (rest pre) mid suf))&amp;lt;br&amp;gt;    (next [this] (seq (rest this)))&amp;lt;br&amp;gt;  IPersistentStack&amp;lt;br&amp;gt;    (peek [_] (peek suf))&amp;lt;br&amp;gt;    (pop [_] (deep-right pre mid (pop suf)))&amp;lt;br&amp;gt;  Reversible&amp;lt;br&amp;gt;    (rseq [this] (lazy-seq (cons (peek this) (rseq (pop this)))))&amp;lt;br&amp;gt;  DoubleSeq&amp;lt;br&amp;gt;    (consl [_ a] (if (&amp;lt; (count pre) 4)&amp;lt;br&amp;gt;                   (deep (consl pre a) mid suf)&amp;lt;br&amp;gt;                   (let [[b c d e] pre&amp;lt;br&amp;gt;                         n (digit meter-obj c d e)]&amp;lt;br&amp;gt;                     (deep (digit meter-obj a b) (consl mid n) suf))))&amp;lt;br&amp;gt;    (conjr [_ a] (if (&amp;lt; (count suf) 4)&amp;lt;br&amp;gt;                   (deep pre mid (conjr suf a))&amp;lt;br&amp;gt;                   (let [[e d c b] suf&amp;lt;br&amp;gt;                         n (digit meter-obj e d c)]&amp;lt;br&amp;gt;                     (deep pre (conjr mid n) (digit meter-obj b a)))))&amp;lt;br&amp;gt;  Measured&amp;lt;br&amp;gt;    (measured [_] @mval)&amp;lt;br&amp;gt;    (getMeter [_] (getMeter pre)) ; not needed?&amp;lt;br&amp;gt;  Splittable ; allow to fail if op is nil:&amp;lt;br&amp;gt;    (split [_ pred acc]&amp;lt;br&amp;gt;      (let [op (opfn meter-obj)&amp;lt;br&amp;gt;            vpr (op acc (measured pre))]&amp;lt;br&amp;gt;        (if (pred vpr)&amp;lt;br&amp;gt;          (let [[sl sx sr] (split pre pred acc)]&amp;lt;br&amp;gt;            [(to-tree meter-obj sl) sx (deep-left sr mid suf)])&amp;lt;br&amp;gt;          (let [vm (op vpr (measured mid))]&amp;lt;br&amp;gt;            (if (pred vm)&amp;lt;br&amp;gt;              (let [[ml xs mr] (split mid pred vpr)&amp;lt;br&amp;gt;                    [sl sx sr] (split xs pred (op vpr (measured ml)))]&amp;lt;br&amp;gt;                [(deep-right pre ml sl) sx (deep-left sr mr suf)])&amp;lt;br&amp;gt;              (let [[sl sx sr] (split suf pred vm)]&amp;lt;br&amp;gt;                [(deep-right pre mid sl)&amp;lt;br&amp;gt;                  sx&amp;lt;br&amp;gt;                  (to-tree meter-obj sr)]))))))&amp;lt;br&amp;gt;  Tree&amp;lt;br&amp;gt;    (app3 [this ts t2] (app3deep t2 ts this))&amp;lt;br&amp;gt;    (app3deep [_ ts t1]&amp;lt;br&amp;gt;      (deep (.pre ^DeepTree t1)&amp;lt;br&amp;gt;            (app3 (.mid ^DeepTree t1)&amp;lt;br&amp;gt;                  (nodes meter-obj (concat (.suf ^DeepTree t1) ts pre))&amp;lt;br&amp;gt;                  mid)&amp;lt;br&amp;gt;            suf))&amp;lt;br&amp;gt;    (measureMore [this] (measured3 meter-obj (rest pre) mid suf))&amp;lt;br&amp;gt;    (measurePop  [this] (measured3 meter-obj pre mid (pop suf))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->DeepTree</a>[meter-obj pre mid suf mval]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;-&gt;DelayedTree&lt;/b&gt; ([tree-ref mval])&lt;br&gt; Positional factory function for class clojure.data.finger_tree.DelayedTree.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype DelayedTree [tree-ref mval]&amp;lt;br&amp;gt;  Seqable&amp;lt;br&amp;gt;    (seq [this] this)&amp;lt;br&amp;gt;  IPersistentCollection&amp;lt;br&amp;gt;    (cons [this x] (conjr this x))&amp;lt;br&amp;gt;    (count [_]) ; not needed?&amp;lt;br&amp;gt;    (empty [_] (empty @tree-ref))&amp;lt;br&amp;gt;    (equiv [_ x] false) ; TBD&amp;lt;br&amp;gt;  ISeq&amp;lt;br&amp;gt;    (first [_] (first @tree-ref))&amp;lt;br&amp;gt;    (more [_] (rest @tree-ref))&amp;lt;br&amp;gt;    (next [_] (next @tree-ref))&amp;lt;br&amp;gt;  IPersistentStack&amp;lt;br&amp;gt;    (peek [_] (peek @tree-ref))&amp;lt;br&amp;gt;    (pop [_] (pop @tree-ref))&amp;lt;br&amp;gt;  Reversible&amp;lt;br&amp;gt;    (rseq [_] (rseq @tree-ref)) ; not this because tree ops can't be reversed&amp;lt;br&amp;gt;  DoubleSeq&amp;lt;br&amp;gt;    (consl [_ a] (consl @tree-ref a))&amp;lt;br&amp;gt;    (conjr [_ b] (conjr @tree-ref b))&amp;lt;br&amp;gt;  Measured&amp;lt;br&amp;gt;    (measured [_] mval)&amp;lt;br&amp;gt;    (getMeter [_] (getMeter @tree-ref)) ; not needed?&amp;lt;br&amp;gt;  Splittable&amp;lt;br&amp;gt;    (split [_ pred acc] (split @tree-ref pred acc))&amp;lt;br&amp;gt;  Tree&amp;lt;br&amp;gt;    (app3 [_ ts t2] (app3 @tree-ref ts t2))&amp;lt;br&amp;gt;    (app3deep [_ ts t1] (app3deep @tree-ref ts t1))&amp;lt;br&amp;gt;    (measureMore [_] (measureMore @tree-ref))&amp;lt;br&amp;gt;    (measurePop [_] (measurePop @tree-ref)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->DelayedTree</a>[tree-ref mval]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;-&gt;Digit1&lt;/b&gt; ([a meter-obj measure-ref])&lt;br&gt; Positional factory function for class clojure.data.finger_tree.Digit1.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defdigit a)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Digit1</a>[a meter-obj measure-ref]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;-&gt;Digit2&lt;/b&gt; ([a b meter-obj measure-ref])&lt;br&gt; Positional factory function for class clojure.data.finger_tree.Digit2.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defdigit a b)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Digit2</a>[a b meter-obj measure-ref]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;-&gt;Digit3&lt;/b&gt; ([a b c meter-obj measure-ref])&lt;br&gt; Positional factory function for class clojure.data.finger_tree.Digit3.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defdigit a b c)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Digit3</a>[a b c meter-obj measure-ref]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;-&gt;Digit4&lt;/b&gt; ([a b c d meter-obj measure-ref])&lt;br&gt; Positional factory function for class clojure.data.finger_tree.Digit4.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defdigit a b c d)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Digit4</a>[a b c d meter-obj measure-ref]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;-&gt;DoubleList&lt;/b&gt; ([tree])&lt;br&gt; Positional factory function for class clojure.data.finger_tree.DoubleList.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype DoubleList [tree]&amp;lt;br&amp;gt;  Sequential&amp;lt;br&amp;gt;  Seqable&amp;lt;br&amp;gt;    (seq [this] (when (seq tree) this))&amp;lt;br&amp;gt;  IPersistentCollection&amp;lt;br&amp;gt;    (cons [this x] (conjr this x))&amp;lt;br&amp;gt;    (count [_] (count (seq tree))) ; Slow!&amp;lt;br&amp;gt;    (empty [_] (DoubleList. (empty tree)))&amp;lt;br&amp;gt;    (equiv [_ x] false) ; TBD&amp;lt;br&amp;gt;  ISeq&amp;lt;br&amp;gt;    (first [_] (first tree))&amp;lt;br&amp;gt;    (more [_] (DoubleList. (rest tree)))&amp;lt;br&amp;gt;    (next [_] (if-let [t (next tree)] (DoubleList. t)))&amp;lt;br&amp;gt;  IPersistentStack ; actually, queue&amp;lt;br&amp;gt;    (peek [_] (peek tree))&amp;lt;br&amp;gt;    (pop [_] (DoubleList. (pop tree)))&amp;lt;br&amp;gt;  Reversible&amp;lt;br&amp;gt;    (rseq [_] (rseq tree)) ; not 'this' because tree ops can't be reversed&amp;lt;br&amp;gt;  DoubleSeq&amp;lt;br&amp;gt;    (consl [_ a] (DoubleList. (consl tree a)))&amp;lt;br&amp;gt;    (conjr [_ b] (DoubleList. (conjr tree b)))&amp;lt;br&amp;gt;  Measured&amp;lt;br&amp;gt;    (measured [_] (measured tree))&amp;lt;br&amp;gt;    (getMeter [_] (getMeter tree))&amp;lt;br&amp;gt;  Tree&amp;lt;br&amp;gt;    (app3 [_ ts t2] (DoubleList. (app3 tree ts t2)))&amp;lt;br&amp;gt;    (app3deep [_ ts t1] (DoubleList. (app3deep tree ts t1))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->DoubleList</a>[tree]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;-&gt;EmptyTree&lt;/b&gt; ([meter-obj])&lt;br&gt; Positional factory function for class clojure.data.finger_tree.EmptyTree.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype EmptyTree [meter-obj]&amp;lt;br&amp;gt;  Seqable&amp;lt;br&amp;gt;    (seq [_] nil)&amp;lt;br&amp;gt;  IPersistentCollection&amp;lt;br&amp;gt;    (cons [this x] (conjr this x))&amp;lt;br&amp;gt;    (count [_] 0) ; not needed?&amp;lt;br&amp;gt;    (empty [this] this)&amp;lt;br&amp;gt;    (equiv [_ x] false) ; TBD&amp;lt;br&amp;gt;  ISeq&amp;lt;br&amp;gt;    (first [_] nil)&amp;lt;br&amp;gt;    (more [this] this)&amp;lt;br&amp;gt;    (next [_] nil)&amp;lt;br&amp;gt;  IPersistentStack&amp;lt;br&amp;gt;    (peek [_] nil)&amp;lt;br&amp;gt;    (pop [this] this)&amp;lt;br&amp;gt;  Reversible&amp;lt;br&amp;gt;    (rseq [_] nil)&amp;lt;br&amp;gt;  DoubleSeq&amp;lt;br&amp;gt;    (consl [_ a] (newSingleTree meter-obj a))&amp;lt;br&amp;gt;    (conjr [_ b] (newSingleTree meter-obj b))&amp;lt;br&amp;gt;  Measured&amp;lt;br&amp;gt;    (measured [_] (idElem meter-obj))&amp;lt;br&amp;gt;    (getMeter [_] meter-obj) ; not needed?&amp;lt;br&amp;gt;;  Splittable&amp;lt;br&amp;gt;;    (split [pred acc]) ; TBD -- not needed??&amp;lt;br&amp;gt;  Tree&amp;lt;br&amp;gt;    (app3 [_ ts t2] (reduce consl t2 (reverse ts)))&amp;lt;br&amp;gt;    (app3deep [_ ts t1] (reduce conjr t1 ts))&amp;lt;br&amp;gt;    (measureMore [_] (idElem meter-obj))&amp;lt;br&amp;gt;    (measurePop [_] (idElem meter-obj)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->EmptyTree</a>[meter-obj]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;-&gt;Len-Right-Meter&lt;/b&gt; ([len right])&lt;br&gt; Positional factory function for class clojure.data.finger_tree.Len-Right-Meter.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Len-Right-Meter [^int len right])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Len-Right-Meter</a>[len right]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;-&gt;SingleTree&lt;/b&gt; ([meter-obj x])&lt;br&gt; Positional factory function for class clojure.data.finger_tree.SingleTree.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype SingleTree [meter-obj x]&amp;lt;br&amp;gt;  Seqable&amp;lt;br&amp;gt;    (seq [this] this)&amp;lt;br&amp;gt;  IPersistentCollection&amp;lt;br&amp;gt;    (cons [this x] (conjr this x))&amp;lt;br&amp;gt;    (count [_]) ; not needed?&amp;lt;br&amp;gt;    (empty [_] (EmptyTree. meter-obj)) ; not needed?&amp;lt;br&amp;gt;    (equiv [_ x] false) ; TBD&amp;lt;br&amp;gt;  ISeq&amp;lt;br&amp;gt;    (first [_] x)&amp;lt;br&amp;gt;    (more [_] (EmptyTree. meter-obj))&amp;lt;br&amp;gt;    (next [_] nil)&amp;lt;br&amp;gt;  IPersistentStack&amp;lt;br&amp;gt;    (peek [_] x)&amp;lt;br&amp;gt;    (pop [_] (EmptyTree. meter-obj))&amp;lt;br&amp;gt;  Reversible&amp;lt;br&amp;gt;    (rseq [_] (list x)) ; not 'this' because tree ops can't be reversed&amp;lt;br&amp;gt;  DoubleSeq&amp;lt;br&amp;gt;    (consl [_ a] (deep (digit meter-obj a)&amp;lt;br&amp;gt;                       (EmptyTree. (finger-meter meter-obj))&amp;lt;br&amp;gt;                       (digit meter-obj x)))&amp;lt;br&amp;gt;    (conjr [_ b] (deep (digit meter-obj x)&amp;lt;br&amp;gt;                       (EmptyTree. (finger-meter meter-obj))&amp;lt;br&amp;gt;                       (digit meter-obj b)))&amp;lt;br&amp;gt;  Measured&amp;lt;br&amp;gt;    (measured [_] (measure meter-obj x))&amp;lt;br&amp;gt;    (getMeter [_] meter-obj) ; not needed?&amp;lt;br&amp;gt;  Splittable&amp;lt;br&amp;gt;    (split [this pred acc] (let [e (empty this)] [e x e]))&amp;lt;br&amp;gt;  Tree&amp;lt;br&amp;gt;    (app3 [this ts t2] (consl (app3 (empty this) ts t2) x))&amp;lt;br&amp;gt;    (app3deep [_ ts t1] (conjr (reduce conjr t1 ts) x))&amp;lt;br&amp;gt;    (measureMore [_] (idElem meter-obj))&amp;lt;br&amp;gt;    (measurePop [_] (idElem meter-obj)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->SingleTree</a>[meter-obj x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;app3&lt;/b&gt; ([t1 ts t2])&lt;br&gt; Append ts and (possibly deep) t2 to tree t1&lt;/div&gt;" data-placement="right">app3</a>[t1 ts t2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;app3deep&lt;/b&gt; ([t2 ts t1])&lt;br&gt; Append ts and t2 to deep tree t1&lt;/div&gt;" data-placement="right">app3deep</a>[t2 ts t1]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;conjr&lt;/b&gt; ([s b])&lt;br&gt; Append b to the right-hand side of s&lt;/div&gt;" data-placement="right">conjr</a>[s b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;consl&lt;/b&gt; ([s a])&lt;br&gt; Append a to the left-hand side of s&lt;/div&gt;" data-placement="right">consl</a>[s a]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;counted-double-list&lt;/b&gt; ([&amp; args])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn counted-double-list [&amp;amp; args]&amp;lt;br&amp;gt;  (into empty-counted-double-list args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">counted-double-list</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;counted-sorted-set&lt;/b&gt; ([&amp; args])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;  (defn counted-sorted-set [&amp;amp; args]&amp;lt;br&amp;gt;    (into default-empty-set args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">counted-sorted-set</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;counted-sorted-set-by&lt;/b&gt; ([cmpr &amp; args])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;  (defn counted-sorted-set-by [cmpr &amp;amp; args]&amp;lt;br&amp;gt;    (into (CountedSortedSet. cmpr empty-tree) args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">counted-sorted-set-by</a>[cmpr & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;deep&lt;/b&gt; ([pre m suf])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn deep [pre m suf]&amp;lt;br&amp;gt;  (let [meter-obj (getMeter pre)&amp;lt;br&amp;gt;        op (opfn meter-obj)]&amp;lt;br&amp;gt;    (newDeepTree meter-obj pre m suf&amp;lt;br&amp;gt;                 (when op&amp;lt;br&amp;gt;                   (delay (if (seq m)&amp;lt;br&amp;gt;                            (measured3 meter-obj pre m suf)&amp;lt;br&amp;gt;                            (op (measured pre) (measured suf))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">deep</a>[pre m suf]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;deep-left&lt;/b&gt; ([pre m suf])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn deep-left [pre m suf]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (seq pre) (deep pre m suf)&amp;lt;br&amp;gt;    (empty? (first m)) (to-tree (getMeter suf) suf)&amp;lt;br&amp;gt;    :else (deep (first m)&amp;lt;br&amp;gt;                (delay-ft (rest m) (measureMore m))&amp;lt;br&amp;gt;                suf)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">deep-left</a>[pre m suf]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;deep-right&lt;/b&gt; ([pre m suf])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn deep-right [pre m suf]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (seq suf) (deep pre m suf)&amp;lt;br&amp;gt;    (empty? (peek m)) (to-tree (getMeter pre) pre)&amp;lt;br&amp;gt;    :else (deep pre&amp;lt;br&amp;gt;                (delay-ft (pop m) (measurePop m))&amp;lt;br&amp;gt;                (peek m))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">deep-right</a>[pre m suf]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;digit&lt;/b&gt; ([meter-obj a] [meter-obj a b] [meter-obj a b c] [meter-obj a b c d])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn digit&amp;lt;br&amp;gt;  ([meter-obj a]       (make-digit meter-obj a))&amp;lt;br&amp;gt;  ([meter-obj a b]     (make-digit meter-obj a b))&amp;lt;br&amp;gt;  ([meter-obj a b c]   (make-digit meter-obj a b c))&amp;lt;br&amp;gt;  ([meter-obj a b c d] (make-digit meter-obj a b c d)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">digit</a>[meter-obj a] [meter-obj a b] [meter-obj a b c] [meter-obj a b c d]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;double-list&lt;/b&gt; ([&amp; args])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn double-list [&amp;amp; args]&amp;lt;br&amp;gt;  (into (DoubleList. (EmptyTree. nil)) args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">double-list</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;finger-meter&lt;/b&gt; ([meter-obj])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static finger-meter [meter-obj]&amp;lt;br&amp;gt;  (when meter-obj&amp;lt;br&amp;gt;    (meter&amp;lt;br&amp;gt;      #(measured %)&amp;lt;br&amp;gt;      (idElem meter-obj)&amp;lt;br&amp;gt;      (opfn meter-obj))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">finger-meter</a>[meter-obj]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;finger-tree&lt;/b&gt; ([meter-obj &amp; xs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static finger-tree [meter-obj &amp;amp; xs]&amp;lt;br&amp;gt;  (to-tree meter-obj xs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">finger-tree</a>[meter-obj & xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;ft-concat&lt;/b&gt; ([t1 t2])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ft-concat [t1 t2]&amp;lt;br&amp;gt;  (assert (= (getMeter t1) (getMeter t2))) ;meters must be the same&amp;lt;br&amp;gt;  (app3 t1 nil t2))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ft-concat</a>[t1 t2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;ft-split-at&lt;/b&gt; ([o k notfound] [o k])&lt;br&gt; Return [pre m post] where pre and post are trees&lt;/div&gt;" data-placement="right">ft-split-at</a>[o k notfound] [o k]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;getMeter&lt;/b&gt; ([o])&lt;br&gt; Return the meter object for o&lt;/div&gt;" data-placement="right">getMeter</a>[o]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;idElem&lt;/b&gt; ([_])&lt;br&gt; Return the identity element for this meter&lt;/div&gt;" data-placement="right">idElem</a>[_]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;map-&gt;Len-Right-Meter&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.data.finger_tree.Len-Right-Meter, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Len-Right-Meter [^int len right])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Len-Right-Meter</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;measure&lt;/b&gt; ([_ o])&lt;br&gt; Return the measured value of o (same type as idElem)&lt;/div&gt;" data-placement="right">measure</a>[_ o]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;measureMore&lt;/b&gt; ([o])&lt;br&gt; Return the measure of o not including the leftmost item&lt;/div&gt;" data-placement="right">measureMore</a>[o]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;measurePop&lt;/b&gt; ([o])&lt;br&gt; Return the measure of o not including the rightmost item&lt;/div&gt;" data-placement="right">measurePop</a>[o]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;measured&lt;/b&gt; ([o])&lt;br&gt; Return the measured value of o&lt;/div&gt;" data-placement="right">measured</a>[o]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;meter&lt;/b&gt; ([measure idElem op])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro meter [measure idElem op]&amp;lt;br&amp;gt;  `(reify ObjMeter&amp;lt;br&amp;gt;      (measure [_ a#] (~measure a#))&amp;lt;br&amp;gt;      (idElem [_] ~idElem)&amp;lt;br&amp;gt;      (opfn [_] ~op)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">meter</a>[measure idElem op]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;newDeepTree&lt;/b&gt; ([meter-obj pre mid suf mval])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static newDeepTree [meter-obj pre mid suf mval]&amp;lt;br&amp;gt;  (DeepTree. meter-obj pre mid suf mval))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">newDeepTree</a>[meter-obj pre mid suf mval]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;newEmptyTree&lt;/b&gt; ([meter-obj])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static newEmptyTree [meter-obj]&amp;lt;br&amp;gt;  (EmptyTree. meter-obj))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">newEmptyTree</a>[meter-obj]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;newSingleTree&lt;/b&gt; ([meter-obj x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static newSingleTree [meter-obj x]&amp;lt;br&amp;gt;  (SingleTree. meter-obj x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">newSingleTree</a>[meter-obj x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;nodes&lt;/b&gt; ([mfns xs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static nodes [mfns xs]&amp;lt;br&amp;gt;  (let [v (vec xs), c (count v)]&amp;lt;br&amp;gt;    (seq&amp;lt;br&amp;gt;      (loop [i (int 0), nds []]&amp;lt;br&amp;gt;        (condp == (- c i)&amp;lt;br&amp;gt;          (int 2) (-&amp;gt; nds (conj (digit mfns (v i) (v (+ (int 1) i)))))&amp;lt;br&amp;gt;          (int 3) (-&amp;gt; nds (conj (digit mfns (v i) (v (+ (int 1) i))&amp;lt;br&amp;gt;                                       (v (+ (int 2) i)))))&amp;lt;br&amp;gt;          (int 4) (-&amp;gt; nds (conj (digit mfns (v i) (v (+ (int 1) i))))&amp;lt;br&amp;gt;                    (conj (digit mfns (v (+ (int 2) i))&amp;lt;br&amp;gt;                                 (v (+ (int 3) i)))))&amp;lt;br&amp;gt;          (recur (+ (int 3) i)&amp;lt;br&amp;gt;                 (-&amp;gt; nds&amp;lt;br&amp;gt;                   (conj (digit mfns (v i) (v (+ (int 1) i))&amp;lt;br&amp;gt;                                (v (+ (int 2) i)))))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">nodes</a>[mfns xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;opfn&lt;/b&gt; ([_])&lt;br&gt; Return an associative function of two args for combining measures&lt;/div&gt;" data-placement="right">opfn</a>[_]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;print-tree&lt;/b&gt; ([tree])&lt;br&gt; &lt;/div&gt;" data-placement="right">print-tree</a>[tree]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;split&lt;/b&gt; ([o pred acc])&lt;br&gt; Return [pre m post] where pre and post are trees&lt;/div&gt;" data-placement="right">split</a>[o pred acc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;split-tree&lt;/b&gt; ([t p])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn split-tree [t p]&amp;lt;br&amp;gt;  (split t p (idElem (getMeter t))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">split-tree</a>[t p]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.finger-tree&lt;/i&gt;&lt;b&gt;to-tree&lt;/b&gt; ([meter-obj coll])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^:static to-tree [meter-obj coll]&amp;lt;br&amp;gt;  (reduce conjr (EmptyTree. meter-obj) coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">to-tree</a>[meter-obj coll]</div></div></div><div class="row"><div class="namespace"><h4>clojure.data.generators</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;anything&lt;/b&gt; ([])&lt;br&gt; Returns a scalar or collection based on *rnd*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn anything&amp;lt;br&amp;gt;  &amp;quot;Returns a scalar or collection based on *rnd*.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (one-of scalar collection))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">anything</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;bigdec&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bigdec&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (BigDecimal. (.toBigInteger (bigint)) (geometric 0.01)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bigdec</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;bigint&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bigint&amp;lt;br&amp;gt;  ^clojure.lang.BigInt []&amp;lt;br&amp;gt;  (loop []&amp;lt;br&amp;gt;    (let [i (try&amp;lt;br&amp;gt;             (BigInteger. ^bytes (byte-array byte))&amp;lt;br&amp;gt;             (catch NumberFormatException e :retry))]&amp;lt;br&amp;gt;      (if (= i :retry) (recur) (core/bigint i)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bigint</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;boolean&lt;/b&gt; ([])&lt;br&gt; Returns a bool based on *rnd*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn boolean&amp;lt;br&amp;gt;  &amp;quot;Returns a bool based on *rnd*.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (.nextBoolean *rnd*))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">boolean</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;boolean-array&lt;/b&gt; ([f] [f sizer])&lt;br&gt; Create an array with elements from f and sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(primitive-arrays [&amp;quot;byte&amp;quot; &amp;quot;short&amp;quot; &amp;quot;long&amp;quot; &amp;quot;char&amp;quot; &amp;quot;double&amp;quot; &amp;quot;float&amp;quot; &amp;quot;int&amp;quot; &amp;quot;boolean&amp;quot;])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">boolean-array</a>[f] [f sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;byte&lt;/b&gt; ([])&lt;br&gt; Returns a long based on *rnd* in the byte range.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn byte&amp;lt;br&amp;gt;  &amp;quot;Returns a long based on *rnd* in the byte range.&amp;quot;&amp;lt;br&amp;gt;  ^long []&amp;lt;br&amp;gt;  (uniform Byte/MIN_VALUE (inc (core/int Byte/MAX_VALUE))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">byte</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;byte-array&lt;/b&gt; ([f] [f sizer])&lt;br&gt; Create an array with elements from f and sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(primitive-arrays [&amp;quot;byte&amp;quot; &amp;quot;short&amp;quot; &amp;quot;long&amp;quot; &amp;quot;char&amp;quot; &amp;quot;double&amp;quot; &amp;quot;float&amp;quot; &amp;quot;int&amp;quot; &amp;quot;boolean&amp;quot;])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">byte-array</a>[f] [f sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;char&lt;/b&gt; ([])&lt;br&gt; Returns a character based on *rnd* in the range 0-65536.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn char&amp;lt;br&amp;gt;  &amp;quot;Returns a character based on *rnd* in the range 0-65536.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (core/char (uniform 0 65536)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">char</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;char-array&lt;/b&gt; ([f] [f sizer])&lt;br&gt; Create an array with elements from f and sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(primitive-arrays [&amp;quot;byte&amp;quot; &amp;quot;short&amp;quot; &amp;quot;long&amp;quot; &amp;quot;char&amp;quot; &amp;quot;double&amp;quot; &amp;quot;float&amp;quot; &amp;quot;int&amp;quot; &amp;quot;boolean&amp;quot;])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">char-array</a>[f] [f sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;collection&lt;/b&gt; ([])&lt;br&gt; Returns a collection of scalar elements based on *rnd*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn collection&amp;lt;br&amp;gt;  &amp;quot;Returns a collection of scalar elements based on *rnd*.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (let [[coll args] (rand-nth collections)]&amp;lt;br&amp;gt;    (apply coll (map rand-nth args))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">collection</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;date&lt;/b&gt; ([] [base])&lt;br&gt; Create a date with geoemetric mean around base. Defaults to&lt;br&gt;   #inst &quot;2007-10-16T00:00:00.000-00:00&quot;&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn date&amp;lt;br&amp;gt;  &amp;quot;Create a date with geoemetric mean around base. Defaults to&amp;lt;br&amp;gt;   #inst \&amp;quot;2007-10-16T00:00:00.000-00:00\&amp;quot;&amp;quot;&amp;lt;br&amp;gt;  ([] (date #inst &amp;quot;2007-10-16T00:00:00.000-00:00&amp;quot;))&amp;lt;br&amp;gt;  ([^java.util.Date base]&amp;lt;br&amp;gt;     (java.util.Date. (geometric (/ 1 (.getTime base))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">date</a>[] [base]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;default-sizer&lt;/b&gt; ([])&lt;br&gt; Default sizer used to run tests. If you want a specific distribution,&lt;br&gt;   create your own and pass it to a fn that wants a sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn default-sizer&amp;lt;br&amp;gt;  &amp;quot;Default sizer used to run tests. If you want a specific distribution,&amp;lt;br&amp;gt;   create your own and pass it to a fn that wants a sizer.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (dec (geometric 0.02)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">default-sizer</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;double&lt;/b&gt; ([])&lt;br&gt; Generate a double between 0 and 1 based on *rnd*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn double&amp;lt;br&amp;gt;  &amp;quot;Generate a double between 0 and 1 based on *rnd*.&amp;quot;&amp;lt;br&amp;gt;  ^double []&amp;lt;br&amp;gt;  (.nextDouble *rnd*))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">double</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;double-array&lt;/b&gt; ([f] [f sizer])&lt;br&gt; Create an array with elements from f and sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(primitive-arrays [&amp;quot;byte&amp;quot; &amp;quot;short&amp;quot; &amp;quot;long&amp;quot; &amp;quot;char&amp;quot; &amp;quot;double&amp;quot; &amp;quot;float&amp;quot; &amp;quot;int&amp;quot; &amp;quot;boolean&amp;quot;])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">double-array</a>[f] [f sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;float&lt;/b&gt; ([])&lt;br&gt; Generate af float between 0 and 1 based on *rnd*&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn float&amp;lt;br&amp;gt;  &amp;quot;Generate af float between 0 and 1 based on *rnd*&amp;quot;&amp;lt;br&amp;gt;  ^double []&amp;lt;br&amp;gt;  (.nextFloat *rnd*))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">float</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;float-array&lt;/b&gt; ([f] [f sizer])&lt;br&gt; Create an array with elements from f and sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(primitive-arrays [&amp;quot;byte&amp;quot; &amp;quot;short&amp;quot; &amp;quot;long&amp;quot; &amp;quot;char&amp;quot; &amp;quot;double&amp;quot; &amp;quot;float&amp;quot; &amp;quot;int&amp;quot; &amp;quot;boolean&amp;quot;])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">float-array</a>[f] [f sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;geometric&lt;/b&gt; ([p])&lt;br&gt; Geometric distribution with mean 1/p.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn geometric&amp;lt;br&amp;gt;  &amp;quot;Geometric distribution with mean 1/p.&amp;quot;&amp;lt;br&amp;gt;  ^long [p]&amp;lt;br&amp;gt;  (core/long (Math/ceil (/ (Math/log (.nextDouble *rnd*))&amp;lt;br&amp;gt;                           (Math/log (- 1.0 p))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">geometric</a>[p]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;hash-map&lt;/b&gt; ([fk fv] [fk fv sizer])&lt;br&gt; Create a hash-map with keys from fk, vals from fv, and&lt;br&gt;   sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hash-map&amp;lt;br&amp;gt;  &amp;quot;Create a hash-map with keys from fk, vals from fv, and&amp;lt;br&amp;gt;   sized from sizer.&amp;quot;&amp;lt;br&amp;gt;  ([fk fv] (hash-map fk fv default-sizer))&amp;lt;br&amp;gt;  ([fk fv sizer]&amp;lt;br&amp;gt;     (into {}&amp;lt;br&amp;gt;           (zipmap (reps sizer fk)&amp;lt;br&amp;gt;                   (reps sizer fv)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hash-map</a>[fk fv] [fk fv sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;int&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn int&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  &amp;quot;Returns a long based on *rnd* in the int range.&amp;quot;&amp;lt;br&amp;gt;  (uniform Integer/MIN_VALUE (inc Integer/MAX_VALUE)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">int</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;int-array&lt;/b&gt; ([f] [f sizer])&lt;br&gt; Create an array with elements from f and sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(primitive-arrays [&amp;quot;byte&amp;quot; &amp;quot;short&amp;quot; &amp;quot;long&amp;quot; &amp;quot;char&amp;quot; &amp;quot;double&amp;quot; &amp;quot;float&amp;quot; &amp;quot;int&amp;quot; &amp;quot;boolean&amp;quot;])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">int-array</a>[f] [f sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;keyword&lt;/b&gt; ([] [sizer])&lt;br&gt; Create a non-namespaced keyword sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn keyword&amp;lt;br&amp;gt;  &amp;quot;Create a non-namespaced keyword sized from sizer.&amp;quot;&amp;lt;br&amp;gt;  ([] (keyword default-sizer))&amp;lt;br&amp;gt;  ([sizer] (core/keyword (name sizer))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">keyword</a>[] [sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;list&lt;/b&gt; ([f] [f sizer])&lt;br&gt; Create a list with elements from f and sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn list&amp;lt;br&amp;gt;  &amp;quot;Create a list with elements from f and sized from sizer.&amp;quot;&amp;lt;br&amp;gt;  ([f] (list f default-sizer))&amp;lt;br&amp;gt;  ([f sizer]&amp;lt;br&amp;gt;     (reps sizer f)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">list</a>[f] [f sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;long-array&lt;/b&gt; ([f] [f sizer])&lt;br&gt; Create an array with elements from f and sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(primitive-arrays [&amp;quot;byte&amp;quot; &amp;quot;short&amp;quot; &amp;quot;long&amp;quot; &amp;quot;char&amp;quot; &amp;quot;double&amp;quot; &amp;quot;float&amp;quot; &amp;quot;int&amp;quot; &amp;quot;boolean&amp;quot;])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">long-array</a>[f] [f sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;one-of&lt;/b&gt; ([&amp; specs])&lt;br&gt; Generates one of the specs passed in, with equal probability.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn one-of&amp;lt;br&amp;gt;  &amp;quot;Generates one of the specs passed in, with equal probability.&amp;quot;&amp;lt;br&amp;gt;  ([&amp;amp; specs]&amp;lt;br&amp;gt;     (weighted (zipmap specs (repeat 1)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">one-of</a>[& specs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;primitive-array&lt;/b&gt; ([type])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro primitive-array&amp;lt;br&amp;gt;  [type]&amp;lt;br&amp;gt;  (let [fn-name (core/symbol (str type &amp;quot;-array&amp;quot;))&amp;lt;br&amp;gt;        factory-name (core/symbol (str &amp;quot;core/&amp;quot; fn-name))&amp;lt;br&amp;gt;        cast-name (core/symbol (str &amp;quot;core/&amp;quot; type))]&amp;lt;br&amp;gt;    `(defn ~fn-name&amp;lt;br&amp;gt;       &amp;quot;Create an array with elements from f and sized from sizer.&amp;quot;&amp;lt;br&amp;gt;       ([~'f]&amp;lt;br&amp;gt;          (~fn-name ~'f default-sizer))&amp;lt;br&amp;gt;       ([~'f ~'sizer]&amp;lt;br&amp;gt;          (let [~'arr (~factory-name (call-through ~'sizer))]&amp;lt;br&amp;gt;            (dotimes [~'i (count ~'arr)]&amp;lt;br&amp;gt;              (aset ~'arr ~'i (~cast-name (call-through ~'f))))&amp;lt;br&amp;gt;            ~'arr)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">primitive-array</a>[type]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;primitive-arrays&lt;/b&gt; ([types])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro primitive-arrays&amp;lt;br&amp;gt;  [types]&amp;lt;br&amp;gt;  `(do ~@(map (fn [type] `(primitive-array ~type)) types)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">primitive-arrays</a>[types]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;printable-ascii-char&lt;/b&gt; ([])&lt;br&gt; Returns a char based on *rnd* in the printable ascii range.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn printable-ascii-char&amp;lt;br&amp;gt;  &amp;quot;Returns a char based on *rnd* in the printable ascii range.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (core/char (uniform 32 127)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">printable-ascii-char</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;rand-nth&lt;/b&gt; ([coll])&lt;br&gt; Replacement of core/rand-nth that allows control of the&lt;br&gt;   randomization basis (through binding *rnd*).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rand-nth&amp;lt;br&amp;gt;  &amp;quot;Replacement of core/rand-nth that allows control of the&amp;lt;br&amp;gt;   randomization basis (through binding *rnd*).&amp;quot;&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;  (nth coll (uniform 0 (count coll))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rand-nth</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;ratio&lt;/b&gt; ([] [num-gen denom-gen])&lt;br&gt; Generate a ratio, with numerator and denominator uniform longs&lt;br&gt;   or as specified&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ratio&amp;lt;br&amp;gt;  &amp;quot;Generate a ratio, with numerator and denominator uniform longs&amp;lt;br&amp;gt;   or as specified&amp;quot;&amp;lt;br&amp;gt;  ([] (ratio long long))&amp;lt;br&amp;gt;  ([num-gen denom-gen] (/ (num-gen) (denom-gen))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ratio</a>[] [num-gen denom-gen]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;reps&lt;/b&gt; ([sizer f])&lt;br&gt; Returns sizer repetitions of f (or (f) if f is a fn).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reps&amp;lt;br&amp;gt;  &amp;quot;Returns sizer repetitions of f (or (f) if f is a fn).&amp;quot;&amp;lt;br&amp;gt;  [sizer f]&amp;lt;br&amp;gt;  (let [count (call-through sizer)]&amp;lt;br&amp;gt;    (if (fn? f)&amp;lt;br&amp;gt;      (repeatedly count f)&amp;lt;br&amp;gt;      (repeat count f))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reps</a>[sizer f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;reservoir-sample&lt;/b&gt; ([ct coll])&lt;br&gt; Reservoir sample ct items from coll, using *rnd*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reservoir-sample&amp;lt;br&amp;gt;  &amp;quot;Reservoir sample ct items from coll, using *rnd*.&amp;quot;&amp;lt;br&amp;gt;  [ct coll]&amp;lt;br&amp;gt;  (loop [result (transient (core/vec (take ct coll)))&amp;lt;br&amp;gt;         n ct&amp;lt;br&amp;gt;         coll (drop ct coll)]&amp;lt;br&amp;gt;    (if (seq coll)&amp;lt;br&amp;gt;      (let [pos (uniform 0 n)]&amp;lt;br&amp;gt;        (recur (if (&amp;lt; pos ct) &amp;lt;br&amp;gt;                 (assoc! result pos (first coll)) &amp;lt;br&amp;gt;                 result)&amp;lt;br&amp;gt;               (inc n)&amp;lt;br&amp;gt;               (rest coll)))&amp;lt;br&amp;gt;      (persistent! result))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reservoir-sample</a>[ct coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;scalar&lt;/b&gt; ([])&lt;br&gt; Returns a scalar based on *rnd*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn scalar&amp;lt;br&amp;gt;  &amp;quot;Returns a scalar based on *rnd*.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (call-through (rand-nth scalars)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">scalar</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;set&lt;/b&gt; ([f] [f sizer])&lt;br&gt; Create a set with elements from f and sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set&amp;lt;br&amp;gt;  &amp;quot;Create a set with elements from f and sized from sizer.&amp;quot;&amp;lt;br&amp;gt;  ([f] (set f default-sizer))&amp;lt;br&amp;gt;  ([f sizer]&amp;lt;br&amp;gt;     (into #{} (reps sizer f))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set</a>[f] [f sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;short&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn short&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  &amp;quot;Returns a long based on *rnd* in the short range.&amp;quot;&amp;lt;br&amp;gt;  (uniform Short/MIN_VALUE (inc (core/long Short/MAX_VALUE))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">short</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;short-array&lt;/b&gt; ([f] [f sizer])&lt;br&gt; Create an array with elements from f and sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(primitive-arrays [&amp;quot;byte&amp;quot; &amp;quot;short&amp;quot; &amp;quot;long&amp;quot; &amp;quot;char&amp;quot; &amp;quot;double&amp;quot; &amp;quot;float&amp;quot; &amp;quot;int&amp;quot; &amp;quot;boolean&amp;quot;])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">short-array</a>[f] [f sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;shuffle&lt;/b&gt; ([coll])&lt;br&gt; Shuffle coll based on *rnd*&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn shuffle&amp;lt;br&amp;gt;  &amp;quot;Shuffle coll based on *rnd*&amp;quot;&amp;lt;br&amp;gt;  [coll]&amp;lt;br&amp;gt;  ;; using our own fischer-yates instead of core/shuffle so that&amp;lt;br&amp;gt;  ;; we'll get the same shuffle, given the same *rnd*.&amp;lt;br&amp;gt;  (fisher-yates coll))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">shuffle</a>[coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;string&lt;/b&gt; ([] [f] [f sizer])&lt;br&gt; Create a string with chars from v and sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn string&amp;lt;br&amp;gt;  &amp;quot;Create a string with chars from v and sized from sizer.&amp;quot;&amp;lt;br&amp;gt;  ([] (string printable-ascii-char))&amp;lt;br&amp;gt;  ([f] (string f default-sizer))&amp;lt;br&amp;gt;  ([f sizer] (apply str (reps sizer f))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">string</a>[] [f] [f sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;symbol&lt;/b&gt; ([] [sizer])&lt;br&gt; Create a non-namepsaced symbol sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn symbol&amp;lt;br&amp;gt;  &amp;quot;Create a non-namepsaced symbol sized from sizer.&amp;quot;&amp;lt;br&amp;gt;  ([] (symbol default-sizer))&amp;lt;br&amp;gt;  ([sizer] (core/symbol (name sizer))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">symbol</a>[] [sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;tuple&lt;/b&gt; ([&amp; generators])&lt;br&gt; Generate a tuple with one element from each generator.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tuple&amp;lt;br&amp;gt;  &amp;quot;Generate a tuple with one element from each generator.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; generators]&amp;lt;br&amp;gt;  (into [] (map #(%) generators)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tuple</a>[& generators]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;uniform&lt;/b&gt; ([] [lo hi])&lt;br&gt; Uniform distribution from lo (inclusive) to high (exclusive).&lt;br&gt;   Defaults to range of Java long.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn uniform&amp;lt;br&amp;gt;  &amp;quot;Uniform distribution from lo (inclusive) to high (exclusive).&amp;lt;br&amp;gt;   Defaults to range of Java long.&amp;quot;&amp;lt;br&amp;gt;  (^long [] (.nextLong *rnd*))&amp;lt;br&amp;gt;  (^long[lo hi] {:pre [(&amp;lt; lo hi)]}&amp;lt;br&amp;gt;         (clojure.core/long (Math/floor (+ lo (* (.nextDouble *rnd*) (- hi lo)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">uniform</a>[] [lo hi]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;uuid&lt;/b&gt; ([])&lt;br&gt; Create a UUID based on uniform distribution of low and high parts.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn uuid&amp;lt;br&amp;gt;  &amp;quot;Create a UUID based on uniform distribution of low and high parts.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (java.util.UUID. (long) (long)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">uuid</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;vec&lt;/b&gt; ([f] [f sizer])&lt;br&gt; Create a vec with elements from f and sized from sizer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn vec&amp;lt;br&amp;gt;  &amp;quot;Create a vec with elements from f and sized from sizer.&amp;quot;&amp;lt;br&amp;gt;  ([f] (vec f default-sizer))&amp;lt;br&amp;gt;  ([f sizer]&amp;lt;br&amp;gt;     (into [] (reps sizer f))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">vec</a>[f] [f sizer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.generators&lt;/i&gt;&lt;b&gt;weighted&lt;/b&gt; ([m])&lt;br&gt; Given a map of generators and weights, return a value from one of&lt;br&gt;   the generators, selecting generator based on weights.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn weighted&amp;lt;br&amp;gt;  &amp;quot;Given a map of generators and weights, return a value from one of&amp;lt;br&amp;gt;   the generators, selecting generator based on weights.&amp;quot;&amp;lt;br&amp;gt;  [m]&amp;lt;br&amp;gt;  (let [weights   (reductions + (vals m))&amp;lt;br&amp;gt;        total   (last weights)&amp;lt;br&amp;gt;        choices (map vector (keys m) weights)]&amp;lt;br&amp;gt;    (let [choice (uniform 0 total)]&amp;lt;br&amp;gt;      (loop [[[c w] &amp;amp; more] choices]&amp;lt;br&amp;gt;        (when w&amp;lt;br&amp;gt;          (if (&amp;lt; choice w)&amp;lt;br&amp;gt;            (call-through c)&amp;lt;br&amp;gt;            (recur more)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">weighted</a>[m]</div></div></div><div class="row"><div class="namespace"><h4>clojure.data.json</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.json&lt;/i&gt;&lt;b&gt;-write&lt;/b&gt; ([object out])&lt;br&gt; Print object to PrintWriter out as JSON&lt;/div&gt;" data-placement="right">-write</a>[object out]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.json&lt;/i&gt;&lt;b&gt;json-str&lt;/b&gt; ([x &amp; options])&lt;br&gt; DEPRECATED; replaced by 'write-str'.&lt;br&gt;&lt;br&gt;  Converts x to a JSON-formatted string.&lt;br&gt;&lt;br&gt;  Valid options are:&lt;br&gt;    :escape-unicode false&lt;br&gt;        to turn of \uXXXX escapes of Unicode characters.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn json-str&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; replaced by 'write-str'.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Converts x to a JSON-formatted string.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Valid options are:&amp;lt;br&amp;gt;    :escape-unicode false&amp;lt;br&amp;gt;        to turn of \\uXXXX escapes of Unicode characters.&amp;quot;&amp;lt;br&amp;gt;  [x &amp;amp; options]&amp;lt;br&amp;gt;  (apply write-str x options))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">json-str</a>[x & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.json&lt;/i&gt;&lt;b&gt;pprint&lt;/b&gt; ([x &amp; options])&lt;br&gt; Pretty-prints JSON representation of x to *out*. Options are the&lt;br&gt;  same as for write except :value-fn, which is not supported.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pprint&amp;lt;br&amp;gt;  &amp;quot;Pretty-prints JSON representation of x to *out*. Options are the&amp;lt;br&amp;gt;  same as for write except :value-fn, which is not supported.&amp;quot;&amp;lt;br&amp;gt;  [x &amp;amp; options]&amp;lt;br&amp;gt;  (let [{:keys [escape-unicode escape-slash key-fn]&amp;lt;br&amp;gt;         :or {escape-unicode true&amp;lt;br&amp;gt;              escape-slash true&amp;lt;br&amp;gt;              key-fn default-write-key-fn}} options]&amp;lt;br&amp;gt;    (binding [*escape-unicode* escape-unicode&amp;lt;br&amp;gt;              *escape-slash* escape-slash&amp;lt;br&amp;gt;              *key-fn* key-fn]&amp;lt;br&amp;gt;      (pprint/write x :dispatch pprint-dispatch))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pprint</a>[x & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.json&lt;/i&gt;&lt;b&gt;pprint-json&lt;/b&gt; ([x &amp; options])&lt;br&gt; DEPRECATED; replaced by 'pprint'.&lt;br&gt;&lt;br&gt;  Pretty-prints JSON representation of x to *out*.&lt;br&gt;&lt;br&gt;  Valid options are:&lt;br&gt;    :escape-unicode false&lt;br&gt;        to turn off \uXXXX escapes of Unicode characters.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pprint-json&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; replaced by 'pprint'.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Pretty-prints JSON representation of x to *out*.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Valid options are:&amp;lt;br&amp;gt;    :escape-unicode false&amp;lt;br&amp;gt;        to turn off \\uXXXX escapes of Unicode characters.&amp;quot;&amp;lt;br&amp;gt;  [x &amp;amp; options]&amp;lt;br&amp;gt;  (apply pprint x options))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pprint-json</a>[x & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.json&lt;/i&gt;&lt;b&gt;print-json&lt;/b&gt; ([x &amp; options])&lt;br&gt; DEPRECATED; replaced by 'write' to *out*.&lt;br&gt;&lt;br&gt;  Write JSON-formatted output to *out*.&lt;br&gt;&lt;br&gt;  Valid options are:&lt;br&gt;    :escape-unicode false&lt;br&gt;        to turn off \uXXXX escapes of Unicode characters.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-json&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; replaced by 'write' to *out*.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Write JSON-formatted output to *out*.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Valid options are:&amp;lt;br&amp;gt;    :escape-unicode false&amp;lt;br&amp;gt;        to turn off \\uXXXX escapes of Unicode characters.&amp;quot;&amp;lt;br&amp;gt;  [x &amp;amp; options]&amp;lt;br&amp;gt;  (apply write x *out* options))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-json</a>[x & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.json&lt;/i&gt;&lt;b&gt;read&lt;/b&gt; ([reader &amp; options])&lt;br&gt; Reads a single item of JSON data from a java.io.Reader. Options are&lt;br&gt;  key-value pairs, valid options are:&lt;br&gt;&lt;br&gt;     :eof-error? boolean&lt;br&gt;&lt;br&gt;        If true (default) will throw exception if the stream is empty.&lt;br&gt;&lt;br&gt;     :eof-value Object&lt;br&gt;&lt;br&gt;        Object to return if the stream is empty and eof-error? is&lt;br&gt;        false. Default is nil.&lt;br&gt;&lt;br&gt;     :bigdec boolean&lt;br&gt;&lt;br&gt;        If true use BigDecimal for decimal numbers instead of Double.&lt;br&gt;        Default is false.&lt;br&gt;&lt;br&gt;     :key-fn function&lt;br&gt;&lt;br&gt;        Single-argument function called on JSON property names; return&lt;br&gt;        value will replace the property names in the output. Default&lt;br&gt;        is clojure.core/identity, use clojure.core/keyword to get&lt;br&gt;        keyword properties.&lt;br&gt;&lt;br&gt;     :value-fn function&lt;br&gt;&lt;br&gt;        Function to transform values in the output. For each JSON&lt;br&gt;        property, value-fn is called with two arguments: the property&lt;br&gt;        name (transformed by key-fn) and the value. The return value&lt;br&gt;        of value-fn will replace the value in the output. If value-fn&lt;br&gt;        returns itself, the property will be omitted from the output.&lt;br&gt;        The default value-fn returns the value unchanged.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read&amp;lt;br&amp;gt;  &amp;quot;Reads a single item of JSON data from a java.io.Reader. Options are&amp;lt;br&amp;gt;  key-value pairs, valid options are:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     :eof-error? boolean&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        If true (default) will throw exception if the stream is empty.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     :eof-value Object&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        Object to return if the stream is empty and eof-error? is&amp;lt;br&amp;gt;        false. Default is nil.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     :bigdec boolean&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        If true use BigDecimal for decimal numbers instead of Double.&amp;lt;br&amp;gt;        Default is false.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     :key-fn function&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        Single-argument function called on JSON property names; return&amp;lt;br&amp;gt;        value will replace the property names in the output. Default&amp;lt;br&amp;gt;        is clojure.core/identity, use clojure.core/keyword to get&amp;lt;br&amp;gt;        keyword properties.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     :value-fn function&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        Function to transform values in the output. For each JSON&amp;lt;br&amp;gt;        property, value-fn is called with two arguments: the property&amp;lt;br&amp;gt;        name (transformed by key-fn) and the value. The return value&amp;lt;br&amp;gt;        of value-fn will replace the value in the output. If value-fn&amp;lt;br&amp;gt;        returns itself, the property will be omitted from the output.&amp;lt;br&amp;gt;        The default value-fn returns the value unchanged.&amp;quot;&amp;lt;br&amp;gt;  [reader &amp;amp; options]&amp;lt;br&amp;gt;  (let [{:keys [eof-error? eof-value bigdec key-fn value-fn]&amp;lt;br&amp;gt;         :or {bigdec false&amp;lt;br&amp;gt;              eof-error? true&amp;lt;br&amp;gt;              key-fn identity&amp;lt;br&amp;gt;              value-fn default-value-fn}} options]&amp;lt;br&amp;gt;    (binding [*bigdec* bigdec&amp;lt;br&amp;gt;              *key-fn* key-fn&amp;lt;br&amp;gt;              *value-fn* value-fn]&amp;lt;br&amp;gt;      (-read (PushbackReader. reader) eof-error? eof-value))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read</a>[reader & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.json&lt;/i&gt;&lt;b&gt;read-json&lt;/b&gt; ([input] [input keywordize?] [input keywordize? eof-error? eof-value])&lt;br&gt; DEPRECATED; replaced by read-str.&lt;br&gt;&lt;br&gt;  Reads one JSON value from input String or Reader. If keywordize? is&lt;br&gt;  true (default), object keys will be converted to keywords. If&lt;br&gt;  eof-error? is true (default), empty input will throw an&lt;br&gt;  EOFException; if false EOF will return eof-value.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-json&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; replaced by read-str.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Reads one JSON value from input String or Reader. If keywordize? is&amp;lt;br&amp;gt;  true (default), object keys will be converted to keywords. If&amp;lt;br&amp;gt;  eof-error? is true (default), empty input will throw an&amp;lt;br&amp;gt;  EOFException; if false EOF will return eof-value.&amp;quot;&amp;lt;br&amp;gt;  ([input]&amp;lt;br&amp;gt;     (read-json input true true nil))&amp;lt;br&amp;gt;  ([input keywordize?]&amp;lt;br&amp;gt;     (read-json input keywordize? true nil))&amp;lt;br&amp;gt;  ([input keywordize? eof-error? eof-value]&amp;lt;br&amp;gt;     (let [key-fn (if keywordize? keyword identity)]&amp;lt;br&amp;gt;       (condp instance? input&amp;lt;br&amp;gt;         String&amp;lt;br&amp;gt;         (read-str input&amp;lt;br&amp;gt;                   :key-fn key-fn&amp;lt;br&amp;gt;                   :eof-error? eof-error?&amp;lt;br&amp;gt;                   :eof-value eof-value)&amp;lt;br&amp;gt;         java.io.Reader&amp;lt;br&amp;gt;         (read input&amp;lt;br&amp;gt;               :key-fn key-fn&amp;lt;br&amp;gt;               :eof-error? eof-error?&amp;lt;br&amp;gt;               :eof-value eof-value)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-json</a>[input] [input keywordize?] [input keywordize? eof-error? eof-value]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.json&lt;/i&gt;&lt;b&gt;read-str&lt;/b&gt; ([string &amp; options])&lt;br&gt; Reads one JSON value from input String. Options are the same as for&lt;br&gt;  read.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-str&amp;lt;br&amp;gt;  &amp;quot;Reads one JSON value from input String. Options are the same as for&amp;lt;br&amp;gt;  read.&amp;quot;&amp;lt;br&amp;gt;  [string &amp;amp; options]&amp;lt;br&amp;gt;  (apply read (StringReader. string) options))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-str</a>[string & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.json&lt;/i&gt;&lt;b&gt;write&lt;/b&gt; ([x writer &amp; options])&lt;br&gt; Write JSON-formatted output to a java.io.Writer. Options are&lt;br&gt;   key-value pairs, valid options are:&lt;br&gt;&lt;br&gt;    :escape-unicode boolean&lt;br&gt;&lt;br&gt;       If true (default) non-ASCII characters are escaped as \uXXXX&lt;br&gt;&lt;br&gt;    :escape-slash boolean&lt;br&gt;&lt;br&gt;       If true (default) the slash / is escaped as \/&lt;br&gt;&lt;br&gt;    :key-fn function&lt;br&gt;&lt;br&gt;        Single-argument function called on map keys; return value will&lt;br&gt;        replace the property names in the output. Must return a&lt;br&gt;        string. Default calls clojure.core/name on symbols and&lt;br&gt;        keywords and clojure.core/str on everything else.&lt;br&gt;&lt;br&gt;    :value-fn function&lt;br&gt;&lt;br&gt;        Function to transform values before writing. For each&lt;br&gt;        key-value pair in the input, called with two arguments: the&lt;br&gt;        key (BEFORE transformation by key-fn) and the value. The&lt;br&gt;        return value of value-fn will replace the value in the output.&lt;br&gt;        If the return value is a number, boolean, string, or nil it&lt;br&gt;        will be included literally in the output. If the return value&lt;br&gt;        is a non-map collection, it will be processed recursively. If&lt;br&gt;        the return value is a map, it will be processed recursively,&lt;br&gt;        calling value-fn again on its key-value pairs. If value-fn&lt;br&gt;        returns itself, the key-value pair will be omitted from the&lt;br&gt;        output.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn write&amp;lt;br&amp;gt;  &amp;quot;Write JSON-formatted output to a java.io.Writer. Options are&amp;lt;br&amp;gt;   key-value pairs, valid options are:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    :escape-unicode boolean&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       If true (default) non-ASCII characters are escaped as \\uXXXX&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    :escape-slash boolean&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       If true (default) the slash / is escaped as \\/&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    :key-fn function&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        Single-argument function called on map keys; return value will&amp;lt;br&amp;gt;        replace the property names in the output. Must return a&amp;lt;br&amp;gt;        string. Default calls clojure.core/name on symbols and&amp;lt;br&amp;gt;        keywords and clojure.core/str on everything else.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    :value-fn function&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        Function to transform values before writing. For each&amp;lt;br&amp;gt;        key-value pair in the input, called with two arguments: the&amp;lt;br&amp;gt;        key (BEFORE transformation by key-fn) and the value. The&amp;lt;br&amp;gt;        return value of value-fn will replace the value in the output.&amp;lt;br&amp;gt;        If the return value is a number, boolean, string, or nil it&amp;lt;br&amp;gt;        will be included literally in the output. If the return value&amp;lt;br&amp;gt;        is a non-map collection, it will be processed recursively. If&amp;lt;br&amp;gt;        the return value is a map, it will be processed recursively,&amp;lt;br&amp;gt;        calling value-fn again on its key-value pairs. If value-fn&amp;lt;br&amp;gt;        returns itself, the key-value pair will be omitted from the&amp;lt;br&amp;gt;        output.&amp;quot;&amp;lt;br&amp;gt;  [x ^Writer writer &amp;amp; options]&amp;lt;br&amp;gt;  (let [{:keys [escape-unicode escape-slash key-fn value-fn]&amp;lt;br&amp;gt;         :or {escape-unicode true&amp;lt;br&amp;gt;              escape-slash true&amp;lt;br&amp;gt;              key-fn default-write-key-fn&amp;lt;br&amp;gt;              value-fn default-value-fn}} options]&amp;lt;br&amp;gt;    (binding [*escape-unicode* escape-unicode&amp;lt;br&amp;gt;              *escape-slash* escape-slash&amp;lt;br&amp;gt;              *key-fn* key-fn&amp;lt;br&amp;gt;              *value-fn* value-fn]&amp;lt;br&amp;gt;      (-write x (PrintWriter. writer)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">write</a>[x writer & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.json&lt;/i&gt;&lt;b&gt;write-json&lt;/b&gt; ([x out escape-unicode?])&lt;br&gt; DEPRECATED; replaced by 'write'.&lt;br&gt;&lt;br&gt;  Print object to PrintWriter out as JSON&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn write-json&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; replaced by 'write'.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Print object to PrintWriter out as JSON&amp;quot;&amp;lt;br&amp;gt;  [x out escape-unicode?]&amp;lt;br&amp;gt;  (write x *out* :escape-unicode escape-unicode?))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">write-json</a>[x out escape-unicode?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.json&lt;/i&gt;&lt;b&gt;write-str&lt;/b&gt; ([x &amp; options])&lt;br&gt; Converts x to a JSON-formatted string. Options are the same as&lt;br&gt;  write.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn write-str&amp;lt;br&amp;gt;  &amp;quot;Converts x to a JSON-formatted string. Options are the same as&amp;lt;br&amp;gt;  write.&amp;quot;&amp;lt;br&amp;gt;  [x &amp;amp; options]&amp;lt;br&amp;gt;  (let [sw (StringWriter.)]&amp;lt;br&amp;gt;    (apply write x sw options)&amp;lt;br&amp;gt;    (.toString sw)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">write-str</a>[x & options]</div></div></div><div class="row"><div class="namespace"><h4>clojure.data.priority-map</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.priority-map&lt;/i&gt;&lt;b&gt;-&gt;PersistentPriorityMap&lt;/b&gt; ([priority-&gt;set-of-items item-&gt;priority _meta])&lt;br&gt; Positional factory function for class clojure.data.priority_map.PersistentPriorityMap.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype PersistentPriorityMap [priority-&amp;gt;set-of-items item-&amp;gt;priority _meta]&amp;lt;br&amp;gt;  Object&amp;lt;br&amp;gt;  (toString [this] (str (.seq this)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.ILookup&amp;lt;br&amp;gt;  ; valAt gives (get pm key) and (get pm key not-found) behavior&amp;lt;br&amp;gt;  (valAt [this item] (get item-&amp;gt;priority item))&amp;lt;br&amp;gt;  (valAt [this item not-found] (get item-&amp;gt;priority item not-found))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IPersistentMap&amp;lt;br&amp;gt;  (count [this] (count item-&amp;gt;priority))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (assoc [this item priority]&amp;lt;br&amp;gt;    (let [current-priority (get item-&amp;gt;priority item nil)]&amp;lt;br&amp;gt;      (if current-priority&amp;lt;br&amp;gt;        ;Case 1 - item is already in priority map, so this is a reassignment&amp;lt;br&amp;gt;        (if (= current-priority priority)&amp;lt;br&amp;gt;          ;Subcase 1 - no change in priority, do nothing&amp;lt;br&amp;gt;          this&amp;lt;br&amp;gt;          (let [item-set (get priority-&amp;gt;set-of-items current-priority)]&amp;lt;br&amp;gt;            (if (= (count item-set) 1)&amp;lt;br&amp;gt;              ;Subcase 2 - it was the only item of this priority&amp;lt;br&amp;gt;              ;so remove old priority entirely&amp;lt;br&amp;gt;              ;and conj item onto new priority's set&amp;lt;br&amp;gt;              (PersistentPriorityMap.&amp;lt;br&amp;gt;                (assoc (dissoc priority-&amp;gt;set-of-items current-priority)&amp;lt;br&amp;gt;                  priority (conj (get priority-&amp;gt;set-of-items priority #{}) item))&amp;lt;br&amp;gt;                (assoc item-&amp;gt;priority item priority)&amp;lt;br&amp;gt;                (meta this))&amp;lt;br&amp;gt;              ;Subcase 3 - there were many items associated with the item's original priority,&amp;lt;br&amp;gt;              ;so remove it from the old set and conj it onto the new one.&amp;lt;br&amp;gt;              (PersistentPriorityMap.&amp;lt;br&amp;gt;                (assoc priority-&amp;gt;set-of-items&amp;lt;br&amp;gt;                  current-priority (disj (get priority-&amp;gt;set-of-items current-priority) item)&amp;lt;br&amp;gt;                  priority (conj (get priority-&amp;gt;set-of-items priority #{}) item))&amp;lt;br&amp;gt;                (assoc item-&amp;gt;priority item priority)&amp;lt;br&amp;gt;                (meta this)))))&amp;lt;br&amp;gt;        ; Case 2: Item is new to the priority map, so just add it.&amp;lt;br&amp;gt;        (PersistentPriorityMap.&amp;lt;br&amp;gt;          (assoc priority-&amp;gt;set-of-items&amp;lt;br&amp;gt;            priority (conj (get priority-&amp;gt;set-of-items priority #{}) item))&amp;lt;br&amp;gt;          (assoc item-&amp;gt;priority item priority)&amp;lt;br&amp;gt;          (meta this)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (empty [this] pm-empty)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  ; cons defines conj behavior&amp;lt;br&amp;gt;  (cons [this e] (let [[item priority] e] (.assoc this item priority)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  ; Like sorted maps, priority maps are equal to other maps provided&amp;lt;br&amp;gt;  ; their key-value pairs are the same.&amp;lt;br&amp;gt;  (equiv [this o] (.equiv item-&amp;gt;priority o))&amp;lt;br&amp;gt;  (hashCode [this] (.hashCode item-&amp;gt;priority))&amp;lt;br&amp;gt;  (equals [this o] (or (identical? this o) (.equals item-&amp;gt;priority o)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  ;containsKey implements (contains? pm k) behavior&amp;lt;br&amp;gt;  (containsKey [this item] (contains? item-&amp;gt;priority item))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (entryAt [this k]&amp;lt;br&amp;gt;    (let [v (.valAt this k this)]&amp;lt;br&amp;gt;      (when-not (identical? v this)&amp;lt;br&amp;gt;        (MapEntry. k v))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (seq [this]&amp;lt;br&amp;gt;    (seq (for [[priority item-set] priority-&amp;gt;set-of-items, item item-set]&amp;lt;br&amp;gt;           (MapEntry. item priority))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  ;without implements (dissoc pm k) behavior&amp;lt;br&amp;gt;  (without&amp;lt;br&amp;gt;    [this item]&amp;lt;br&amp;gt;    (let [priority (item-&amp;gt;priority item ::not-found)]&amp;lt;br&amp;gt;      (if (= priority ::not-found)&amp;lt;br&amp;gt;	;; If item is not in map, return the map unchanged.&amp;lt;br&amp;gt;	this&amp;lt;br&amp;gt;	(let [item-set (priority-&amp;gt;set-of-items priority)]&amp;lt;br&amp;gt;	  (if (= (count item-set) 1)&amp;lt;br&amp;gt;	    ;;If it is the only item with this priority, remove that priority's set completely&amp;lt;br&amp;gt;	    (PersistentPriorityMap. (dissoc priority-&amp;gt;set-of-items priority)&amp;lt;br&amp;gt;				    (dissoc item-&amp;gt;priority item)&amp;lt;br&amp;gt;                    (meta this))&amp;lt;br&amp;gt;	    ;;Otherwise, just remove the item from the priority's set.&amp;lt;br&amp;gt;	    (PersistentPriorityMap.&amp;lt;br&amp;gt;	     (assoc priority-&amp;gt;set-of-items priority (disj item-set item)),&amp;lt;br&amp;gt;	     (dissoc item-&amp;gt;priority item)&amp;lt;br&amp;gt;         (meta this)))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  java.io.Serializable  ;Serialization comes for free with the other things implemented&amp;lt;br&amp;gt;  clojure.lang.MapEquivalence&amp;lt;br&amp;gt;  Map ;Makes this compatible with java's map&amp;lt;br&amp;gt;  (size [this] (count item-&amp;gt;priority))&amp;lt;br&amp;gt;  (isEmpty [this] (zero? (count item-&amp;gt;priority)))&amp;lt;br&amp;gt;  (containsValue [this v] (contains? (priority-&amp;gt;set-of-items this) v))&amp;lt;br&amp;gt;  (get [this k] (.valAt this k))&amp;lt;br&amp;gt;  (put [this k v] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;  (remove [this k] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;  (putAll [this m] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;  (clear [this] (throw (UnsupportedOperationException.)))&amp;lt;br&amp;gt;  (keySet [this] (set (keys this)))&amp;lt;br&amp;gt;  (values [this] (vals this))&amp;lt;br&amp;gt;  (entrySet [this] (set this))&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  Iterable&amp;lt;br&amp;gt;  (iterator [this] (clojure.lang.SeqIterator. (seq this)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IPersistentStack&amp;lt;br&amp;gt;  (peek [this]&amp;lt;br&amp;gt;    (when-not (.isEmpty this)&amp;lt;br&amp;gt;      (let [f (first priority-&amp;gt;set-of-items)]&amp;lt;br&amp;gt;        (MapEntry. (first (val f)) (key f)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (pop [this]&amp;lt;br&amp;gt;    (if (.isEmpty this) (throw (IllegalStateException. &amp;quot;Can't pop empty priority map&amp;quot;))&amp;lt;br&amp;gt;      (let [f (first priority-&amp;gt;set-of-items),&amp;lt;br&amp;gt;            item-set (val f)&amp;lt;br&amp;gt;            item (first item-set),&amp;lt;br&amp;gt;            priority (key f)]&amp;lt;br&amp;gt;        (if (= (count item-set) 1)&amp;lt;br&amp;gt;          ;If the first item is the only item with its priority, remove that priority's set completely&amp;lt;br&amp;gt;          (PersistentPriorityMap.&amp;lt;br&amp;gt;            (dissoc priority-&amp;gt;set-of-items priority)&amp;lt;br&amp;gt;            (dissoc item-&amp;gt;priority item)&amp;lt;br&amp;gt;            (meta this))&amp;lt;br&amp;gt;          ;Otherwise, just remove the item from the priority's set.&amp;lt;br&amp;gt;          (PersistentPriorityMap.&amp;lt;br&amp;gt;            (assoc priority-&amp;gt;set-of-items priority (disj item-set item)),&amp;lt;br&amp;gt;            (dissoc item-&amp;gt;priority item)&amp;lt;br&amp;gt;            (meta this))))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IFn&amp;lt;br&amp;gt;  ;makes priority map usable as a function&amp;lt;br&amp;gt;  (invoke [this k] (.valAt this k))&amp;lt;br&amp;gt;  (invoke [this k not-found] (.valAt this k not-found))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.IObj&amp;lt;br&amp;gt;  ;adds metadata support&amp;lt;br&amp;gt;  (meta [this] _meta)&amp;lt;br&amp;gt;  (withMeta [this m] (PersistentPriorityMap. priority-&amp;gt;set-of-items item-&amp;gt;priority m))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  clojure.lang.Reversible&amp;lt;br&amp;gt;  (rseq [this]&amp;lt;br&amp;gt;    (seq (for [[priority item-set] (rseq priority-&amp;gt;set-of-items), item item-set]&amp;lt;br&amp;gt;           (MapEntry. item priority)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->PersistentPriorityMap</a>[priority->set-of-items item->priority _meta]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.priority-map&lt;/i&gt;&lt;b&gt;priority-map&lt;/b&gt; ([&amp; keyvals])&lt;br&gt; keyval =&gt; key val&lt;br&gt;Returns a new priority map with supplied mappings&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn priority-map&amp;lt;br&amp;gt;  &amp;quot;keyval =&amp;gt; key val&amp;lt;br&amp;gt;Returns a new priority map with supplied mappings&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; keyvals]&amp;lt;br&amp;gt;  (reduce conj pm-empty (partition 2 keyvals)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">priority-map</a>[& keyvals]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.priority-map&lt;/i&gt;&lt;b&gt;priority-map-by&lt;/b&gt; ([comparator &amp; keyvals])&lt;br&gt; keyval =&gt; key val&lt;br&gt;Returns a new priority map with supplied mappings&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn priority-map-by&amp;lt;br&amp;gt;  &amp;quot;keyval =&amp;gt; key val&amp;lt;br&amp;gt;Returns a new priority map with supplied mappings&amp;quot;&amp;lt;br&amp;gt;  [comparator &amp;amp; keyvals]&amp;lt;br&amp;gt;  (reduce conj (pm-empty-by comparator) (partition 2 keyvals)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">priority-map-by</a>[comparator & keyvals]</div></div></div><div class="row"><div class="namespace"><h4>clojure.data.xml</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;-&gt;CData&lt;/b&gt; ([content])&lt;br&gt; Positional factory function for class clojure.data.xml.CData.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord CData [content])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->CData</a>[content]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;-&gt;Comment&lt;/b&gt; ([content])&lt;br&gt; Positional factory function for class clojure.data.xml.Comment.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Comment [content])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Comment</a>[content]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;-&gt;Element&lt;/b&gt; ([tag attrs content])&lt;br&gt; Positional factory function for class clojure.data.xml.Element.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Element [tag attrs content])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Element</a>[tag attrs content]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;-&gt;Event&lt;/b&gt; ([type name attrs str])&lt;br&gt; Positional factory function for class clojure.data.xml.Event.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Event [type name attrs str])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Event</a>[type name attrs str]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;as-elements&lt;/b&gt; ([expr])&lt;br&gt; Return a seq of elements represented by an expression.&lt;/div&gt;" data-placement="right">as-elements</a>[expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;cdata&lt;/b&gt; ([content])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cdata [content]&amp;lt;br&amp;gt;  (CData. content))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cdata</a>[content]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;check-stream-encoding&lt;/b&gt; ([stream xml-encoding])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn check-stream-encoding [^java.io.OutputStreamWriter stream xml-encoding]&amp;lt;br&amp;gt;  (when (not= (Charset/forName xml-encoding) (Charset/forName (.getEncoding stream)))&amp;lt;br&amp;gt;    (throw (Exception. (str &amp;quot;Output encoding of stream (&amp;quot; xml-encoding&amp;lt;br&amp;gt;                            &amp;quot;) doesn't match declaration (&amp;quot;&amp;lt;br&amp;gt;                            (.getEncoding stream) &amp;quot;)&amp;quot;)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">check-stream-encoding</a>[stream xml-encoding]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;element&lt;/b&gt; ([tag &amp; [attrs &amp; content]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn element [tag &amp;amp; [attrs &amp;amp; content]]&amp;lt;br&amp;gt;  (Element. tag (or attrs {}) (remove nil? content)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">element</a>[tag & [attrs & content]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;emit&lt;/b&gt; ([e stream &amp; {:as opts}])&lt;br&gt; Prints the given Element tree as XML text to stream.&lt;br&gt;   Options:&lt;br&gt;    :encoding &lt;str&gt;          Character encoding to use&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit&amp;lt;br&amp;gt;  &amp;quot;Prints the given Element tree as XML text to stream.&amp;lt;br&amp;gt;   Options:&amp;lt;br&amp;gt;    :encoding &amp;lt;str&amp;gt;          Character encoding to use&amp;quot;&amp;lt;br&amp;gt;  [e ^java.io.Writer stream &amp;amp; {:as opts}]&amp;lt;br&amp;gt;  (let [^javax.xml.stream.XMLStreamWriter writer (-&amp;gt; (javax.xml.stream.XMLOutputFactory/newInstance)&amp;lt;br&amp;gt;                                                     (.createXMLStreamWriter stream))]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (when (instance? java.io.OutputStreamWriter stream)&amp;lt;br&amp;gt;      (check-stream-encoding stream (or (:encoding opts) &amp;quot;UTF-8&amp;quot;)))&amp;lt;br&amp;gt;    &amp;lt;br&amp;gt;    (.writeStartDocument writer (or (:encoding opts) &amp;quot;UTF-8&amp;quot;) &amp;quot;1.0&amp;quot;)&amp;lt;br&amp;gt;    (doseq [event (flatten-elements [e])]&amp;lt;br&amp;gt;      (emit-event event writer))&amp;lt;br&amp;gt;    (.writeEndDocument writer)&amp;lt;br&amp;gt;    stream))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit</a>[e stream & {:as opts}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;emit-cdata&lt;/b&gt; ([cdata-str writer])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-cdata [^String cdata-str writer]&amp;lt;br&amp;gt;  (when-not (str-empty? cdata-str) &amp;lt;br&amp;gt;    (let [idx (.indexOf cdata-str &amp;quot;]]&amp;gt;&amp;quot;)]&amp;lt;br&amp;gt;      (if (= idx -1)&amp;lt;br&amp;gt;        (.writeCData writer cdata-str )&amp;lt;br&amp;gt;        (do&amp;lt;br&amp;gt;          (.writeCData writer (subs cdata-str 0 idx))&amp;lt;br&amp;gt;          (recur (subs cdata-str (+ idx 3)) writer))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-cdata</a>[cdata-str writer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;emit-event&lt;/b&gt; ([event writer])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-event [event ^javax.xml.stream.XMLStreamWriter writer]&amp;lt;br&amp;gt;  (case (:type event)&amp;lt;br&amp;gt;    :start-element (emit-start-tag event writer)&amp;lt;br&amp;gt;    :end-element (.writeEndElement writer)&amp;lt;br&amp;gt;    :chars (.writeCharacters writer (:str event))&amp;lt;br&amp;gt;    :cdata (emit-cdata (:str event) writer)&amp;lt;br&amp;gt;    :comment (.writeComment writer (:str event))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-event</a>[event writer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;emit-start-tag&lt;/b&gt; ([event writer])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-start-tag [event ^javax.xml.stream.XMLStreamWriter writer]&amp;lt;br&amp;gt;  (let [[nspace qname] (qualified-name (:name event))]&amp;lt;br&amp;gt;    (.writeStartElement writer &amp;quot;&amp;quot; qname (or nspace &amp;quot;&amp;quot;))&amp;lt;br&amp;gt;    (write-attributes (:attrs event) writer)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-start-tag</a>[event writer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;emit-str&lt;/b&gt; ([e])&lt;br&gt; Emits the Element to String and returns it&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-str&amp;lt;br&amp;gt;  &amp;quot;Emits the Element to String and returns it&amp;quot;&amp;lt;br&amp;gt;  [e]&amp;lt;br&amp;gt;  (let [^java.io.StringWriter sw (java.io.StringWriter.)]&amp;lt;br&amp;gt;    (emit e sw)&amp;lt;br&amp;gt;    (.toString sw)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-str</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;event&lt;/b&gt; ([type name &amp; [attrs str]])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn event [type name &amp;amp; [attrs str]]&amp;lt;br&amp;gt;  (Event. type name attrs str))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">event</a>[type name & [attrs str]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;event-tree&lt;/b&gt; ([events])&lt;br&gt; Returns a lazy tree of Element objects for the given seq of Event&lt;br&gt;  objects. See source-seq and parse.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn event-tree&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy tree of Element objects for the given seq of Event&amp;lt;br&amp;gt;  objects. See source-seq and parse.&amp;quot;&amp;lt;br&amp;gt;  [events]&amp;lt;br&amp;gt;  (ffirst&amp;lt;br&amp;gt;   (seq-tree&amp;lt;br&amp;gt;    (fn [^Event event contents]&amp;lt;br&amp;gt;      (when (= :start-element (.type event))&amp;lt;br&amp;gt;        (Element. (.name event) (.attrs event) contents)))&amp;lt;br&amp;gt;    (fn [^Event event] (= :end-element (.type event)))&amp;lt;br&amp;gt;    (fn [^Event event] (.str event))&amp;lt;br&amp;gt;    events)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">event-tree</a>[events]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;flatten-elements&lt;/b&gt; ([elements])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn flatten-elements [elements]&amp;lt;br&amp;gt;  (when (seq elements)&amp;lt;br&amp;gt;    (lazy-seq&amp;lt;br&amp;gt;     (let [e (first elements)]&amp;lt;br&amp;gt;       (cons (gen-event e)&amp;lt;br&amp;gt;             (flatten-elements (next-events e (rest elements))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">flatten-elements</a>[elements]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;gen-event&lt;/b&gt; ([item])&lt;br&gt; Function to generate an event for e.&lt;/div&gt;" data-placement="right">gen-event</a>[item]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;indent&lt;/b&gt; ([e stream &amp; {:as opts}])&lt;br&gt; Emits the XML and indents the result.  WARNING: this is slow&lt;br&gt;   it will emit the XML and read it in again to indent it.  Intended for &lt;br&gt;   debugging/testing only.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn indent&amp;lt;br&amp;gt;  &amp;quot;Emits the XML and indents the result.  WARNING: this is slow&amp;lt;br&amp;gt;   it will emit the XML and read it in again to indent it.  Intended for &amp;lt;br&amp;gt;   debugging/testing only.&amp;quot;&amp;lt;br&amp;gt;  [e ^java.io.Writer stream &amp;amp; {:as opts}]&amp;lt;br&amp;gt;  (let [sw (java.io.StringWriter.)&amp;lt;br&amp;gt;        _ (apply emit e sw (apply concat opts))&amp;lt;br&amp;gt;        source (-&amp;gt; sw .toString java.io.StringReader. javax.xml.transform.stream.StreamSource.)&amp;lt;br&amp;gt;        result (javax.xml.transform.stream.StreamResult. stream)]&amp;lt;br&amp;gt;    (.transform (indenting-transformer) source result)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">indent</a>[e stream & {:as opts}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;indent-str&lt;/b&gt; ([e])&lt;br&gt; Emits the XML and indents the result.  Writes the results to a String and returns it&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn indent-str&amp;lt;br&amp;gt;  &amp;quot;Emits the XML and indents the result.  Writes the results to a String and returns it&amp;quot;&amp;lt;br&amp;gt;  [e]&amp;lt;br&amp;gt;  (let [^java.io.StringWriter sw (java.io.StringWriter.)]&amp;lt;br&amp;gt;    (indent e sw)&amp;lt;br&amp;gt;    (.toString sw)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">indent-str</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;indenting-transformer&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^javax.xml.transform.Transformer indenting-transformer []&amp;lt;br&amp;gt;  (doto (-&amp;gt; (javax.xml.transform.TransformerFactory/newInstance) .newTransformer)&amp;lt;br&amp;gt;    (.setOutputProperty (javax.xml.transform.OutputKeys/INDENT) &amp;quot;yes&amp;quot;)&amp;lt;br&amp;gt;    (.setOutputProperty (javax.xml.transform.OutputKeys/METHOD) &amp;quot;xml&amp;quot;)&amp;lt;br&amp;gt;    (.setOutputProperty &amp;quot;{http://xml.apache.org/xslt}indent-amount&amp;quot; &amp;quot;2&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">indenting-transformer</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;map-&gt;CData&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.data.xml.CData, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord CData [content])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->CData</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;map-&gt;Comment&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.data.xml.Comment, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Comment [content])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Comment</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;map-&gt;Element&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.data.xml.Element, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Element [tag attrs content])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Element</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;map-&gt;Event&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.data.xml.Event, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Event [type name attrs str])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Event</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;next-events&lt;/b&gt; ([item next-items])&lt;br&gt; Returns the next set of events that should occur after e.  next-events are the&lt;br&gt;     events that should be generated after this one is complete.&lt;/div&gt;" data-placement="right">next-events</a>[item next-items]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;parse&lt;/b&gt; ([source &amp; props])&lt;br&gt; Parses the source, which can be an&lt;br&gt;   InputStream or Reader, and returns a lazy tree of Element records. Accepts key pairs&lt;br&gt;   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html&lt;br&gt;   and xml-input-factory-props for more information. Defaults coalescing true.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse&amp;lt;br&amp;gt;  &amp;quot;Parses the source, which can be an&amp;lt;br&amp;gt;   InputStream or Reader, and returns a lazy tree of Element records. Accepts key pairs&amp;lt;br&amp;gt;   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html&amp;lt;br&amp;gt;   and xml-input-factory-props for more information. Defaults coalescing true.&amp;quot;&amp;lt;br&amp;gt;  [source &amp;amp; props]&amp;lt;br&amp;gt;  (event-tree (apply source-seq source props)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse</a>[source & props]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;parse-str&lt;/b&gt; ([s &amp; props])&lt;br&gt; Parses the passed in string to Clojure data structures.  Accepts key pairs&lt;br&gt;   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html&lt;br&gt;   and xml-input-factory-props for more information. Defaults coalescing true.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-str&amp;lt;br&amp;gt;  &amp;quot;Parses the passed in string to Clojure data structures.  Accepts key pairs&amp;lt;br&amp;gt;   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html&amp;lt;br&amp;gt;   and xml-input-factory-props for more information. Defaults coalescing true.&amp;quot;&amp;lt;br&amp;gt;  [s &amp;amp; props]&amp;lt;br&amp;gt;  (let [sr (java.io.StringReader. s)]&amp;lt;br&amp;gt;    (apply parse sr props)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-str</a>[s & props]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;qualified-name&lt;/b&gt; ([event-name])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn qualified-name [event-name]&amp;lt;br&amp;gt;  (if (instance? clojure.lang.Named event-name)&amp;lt;br&amp;gt;   [(namespace event-name) (name event-name)]&amp;lt;br&amp;gt;   (let [name-parts (str/split event-name #&amp;quot;/&amp;quot; 2)]&amp;lt;br&amp;gt;     (if (= 2 (count name-parts))&amp;lt;br&amp;gt;       name-parts&amp;lt;br&amp;gt;       [nil (first name-parts)]))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">qualified-name</a>[event-name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;seq-tree&lt;/b&gt; ([parent exit? node coll])&lt;br&gt; Takes a seq of events that logically represents&lt;br&gt;  a tree by each event being one of: enter-sub-tree event,&lt;br&gt;  exit-sub-tree event, or node event.&lt;br&gt;&lt;br&gt;  Returns a lazy sequence whose first element is a sequence of&lt;br&gt;  sub-trees and whose remaining elements are events that are not&lt;br&gt;  siblings or descendants of the initial event.&lt;br&gt;&lt;br&gt;  The given exit? function must return true for any exit-sub-tree&lt;br&gt;  event.  parent must be a function of two arguments: the first is an&lt;br&gt;  event, the second a sequence of nodes or subtrees that are children&lt;br&gt;  of the event.  parent must return nil or false if the event is not&lt;br&gt;  an enter-sub-tree event.  Any other return value will become&lt;br&gt;  a sub-tree of the output tree and should normally contain in some&lt;br&gt;  way the children passed as the second arg.  The node function is&lt;br&gt;  called with a single event arg on every event that is neither parent&lt;br&gt;  nor exit, and its return value will become a node of the output tree.&lt;br&gt;&lt;br&gt;  (seq-tree #(when (= %1 :&lt;) (vector %2)) #{:&gt;} str&lt;br&gt;            [1 2 :&lt; 3 :&lt; 4 :&gt; :&gt; 5 :&gt; 6])&lt;br&gt;  ;=&gt; ((&quot;1&quot; &quot;2&quot; [(&quot;3&quot; [(&quot;4&quot;)])] &quot;5&quot;) 6)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn seq-tree&amp;lt;br&amp;gt;  &amp;quot;Takes a seq of events that logically represents&amp;lt;br&amp;gt;  a tree by each event being one of: enter-sub-tree event,&amp;lt;br&amp;gt;  exit-sub-tree event, or node event.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Returns a lazy sequence whose first element is a sequence of&amp;lt;br&amp;gt;  sub-trees and whose remaining elements are events that are not&amp;lt;br&amp;gt;  siblings or descendants of the initial event.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The given exit? function must return true for any exit-sub-tree&amp;lt;br&amp;gt;  event.  parent must be a function of two arguments: the first is an&amp;lt;br&amp;gt;  event, the second a sequence of nodes or subtrees that are children&amp;lt;br&amp;gt;  of the event.  parent must return nil or false if the event is not&amp;lt;br&amp;gt;  an enter-sub-tree event.  Any other return value will become&amp;lt;br&amp;gt;  a sub-tree of the output tree and should normally contain in some&amp;lt;br&amp;gt;  way the children passed as the second arg.  The node function is&amp;lt;br&amp;gt;  called with a single event arg on every event that is neither parent&amp;lt;br&amp;gt;  nor exit, and its return value will become a node of the output tree.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (seq-tree #(when (= %1 :&amp;lt;) (vector %2)) #{:&amp;gt;} str&amp;lt;br&amp;gt;            [1 2 :&amp;lt; 3 :&amp;lt; 4 :&amp;gt; :&amp;gt; 5 :&amp;gt; 6])&amp;lt;br&amp;gt;  ;=&amp;gt; ((\&amp;quot;1\&amp;quot; \&amp;quot;2\&amp;quot; [(\&amp;quot;3\&amp;quot; [(\&amp;quot;4\&amp;quot;)])] \&amp;quot;5\&amp;quot;) 6)&amp;quot;&amp;lt;br&amp;gt; [parent exit? node coll]&amp;lt;br&amp;gt;  (lazy-seq&amp;lt;br&amp;gt;    (when-let [[event] (seq coll)]&amp;lt;br&amp;gt;      (let [more (rest coll)]&amp;lt;br&amp;gt;        (if (exit? event)&amp;lt;br&amp;gt;          (cons nil more)&amp;lt;br&amp;gt;          (let [tree (seq-tree parent exit? node more)]&amp;lt;br&amp;gt;            (if-let [p (parent event (lazy-seq (first tree)))]&amp;lt;br&amp;gt;              (let [subtree (seq-tree parent exit? node (lazy-seq (rest tree)))]&amp;lt;br&amp;gt;                (cons (cons p (lazy-seq (first subtree)))&amp;lt;br&amp;gt;                      (lazy-seq (rest subtree))))&amp;lt;br&amp;gt;              (cons (cons (node event) (lazy-seq (first tree)))&amp;lt;br&amp;gt;                    (lazy-seq (rest tree))))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">seq-tree</a>[parent exit? node coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;sexp-as-element&lt;/b&gt; ([sexp])&lt;br&gt; Convert a single sexp into an Element&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sexp-as-element&amp;lt;br&amp;gt;  &amp;quot;Convert a single sexp into an Element&amp;quot;&amp;lt;br&amp;gt;  [sexp]&amp;lt;br&amp;gt;  (let [[root &amp;amp; more] (sexps-as-fragment sexp)]&amp;lt;br&amp;gt;    (when more&amp;lt;br&amp;gt;      (throw&amp;lt;br&amp;gt;       (IllegalArgumentException.&amp;lt;br&amp;gt;        &amp;quot;Cannot have multiple root elements; try creating a fragment instead&amp;quot;)))&amp;lt;br&amp;gt;    root))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sexp-as-element</a>[sexp]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;sexp-element&lt;/b&gt; ([tag attrs child])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sexp-element [tag attrs child]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;   (= :-cdata tag) (CData. (first child))&amp;lt;br&amp;gt;   (= :-comment tag) (Comment. (first child))&amp;lt;br&amp;gt;   :else (Element. tag attrs (mapcat as-elements child))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sexp-element</a>[tag attrs child]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;sexps-as-fragment&lt;/b&gt; ([] [sexp] [sexp &amp; sexps])&lt;br&gt; Convert a compact prxml/hiccup-style data structure into the more formal&lt;br&gt;   tag/attrs/content format. A seq of elements will be returned, which may&lt;br&gt;   not be suitable for immediate use as there is no root element. See also&lt;br&gt;   sexp-as-element.&lt;br&gt;&lt;br&gt;   The format is [:tag-name attr-map? content*]. Each vector opens a new tag;&lt;br&gt;   seqs do not open new tags, and are just used for inserting groups of elements&lt;br&gt;   into the parent tag. A bare keyword not in a vector creates an empty element.&lt;br&gt;&lt;br&gt;   To provide XML conversion for your own data types, extend the AsElements&lt;br&gt;   protocol to them.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sexps-as-fragment&amp;lt;br&amp;gt;  &amp;quot;Convert a compact prxml/hiccup-style data structure into the more formal&amp;lt;br&amp;gt;   tag/attrs/content format. A seq of elements will be returned, which may&amp;lt;br&amp;gt;   not be suitable for immediate use as there is no root element. See also&amp;lt;br&amp;gt;   sexp-as-element.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   The format is [:tag-name attr-map? content*]. Each vector opens a new tag;&amp;lt;br&amp;gt;   seqs do not open new tags, and are just used for inserting groups of elements&amp;lt;br&amp;gt;   into the parent tag. A bare keyword not in a vector creates an empty element.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   To provide XML conversion for your own data types, extend the AsElements&amp;lt;br&amp;gt;   protocol to them.&amp;quot;&amp;lt;br&amp;gt;  ([] nil)&amp;lt;br&amp;gt;  ([sexp] (as-elements sexp))&amp;lt;br&amp;gt;  ([sexp &amp;amp; sexps] (mapcat as-elements (cons sexp sexps))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sexps-as-fragment</a>[] [sexp] [sexp & sexps]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;source-seq&lt;/b&gt; ([s &amp; {:as props}])&lt;br&gt; Parses the XML InputSource source using a pull-parser. Returns&lt;br&gt;   a lazy sequence of Event records.  Accepts key pairs&lt;br&gt;   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html&lt;br&gt;   and xml-input-factory-props for more information. Defaults coalescing true.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn source-seq&amp;lt;br&amp;gt;  &amp;quot;Parses the XML InputSource source using a pull-parser. Returns&amp;lt;br&amp;gt;   a lazy sequence of Event records.  Accepts key pairs&amp;lt;br&amp;gt;   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html&amp;lt;br&amp;gt;   and xml-input-factory-props for more information. Defaults coalescing true.&amp;quot;&amp;lt;br&amp;gt;  [s &amp;amp; {:as props}]&amp;lt;br&amp;gt;  (let [fac (new-xml-input-factory (merge {:coalescing true} props))&amp;lt;br&amp;gt;        ;; Reflection on following line cannot be eliminated via a&amp;lt;br&amp;gt;        ;; type hint, because s is advertised by fn parse to be an&amp;lt;br&amp;gt;        ;; InputStream or Reader, and there are different&amp;lt;br&amp;gt;        ;; createXMLStreamReader signatures for each of those types.&amp;lt;br&amp;gt;        sreader (.createXMLStreamReader fac s)]&amp;lt;br&amp;gt;    (pull-seq sreader)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">source-seq</a>[s & {:as props}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;str-empty?&lt;/b&gt; ([s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn str-empty? [s]&amp;lt;br&amp;gt;  (or (nil? s)&amp;lt;br&amp;gt;      (= s &amp;quot;&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">str-empty?</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;write-attributes&lt;/b&gt; ([attrs writer])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn write-attributes [attrs ^javax.xml.stream.XMLStreamWriter writer]&amp;lt;br&amp;gt;  (doseq [[k v] attrs]&amp;lt;br&amp;gt;    (let [[attr-ns attr-name] (qualified-name k)]&amp;lt;br&amp;gt;      (if attr-ns&amp;lt;br&amp;gt;        (.writeAttribute writer attr-ns attr-name (str v))&amp;lt;br&amp;gt;        (.writeAttribute writer attr-name (str v))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">write-attributes</a>[attrs writer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.xml&lt;/i&gt;&lt;b&gt;xml-comment&lt;/b&gt; ([content])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn xml-comment [content]&amp;lt;br&amp;gt;  (Comment. content))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">xml-comment</a>[content]</div></div></div><div class="row"><div class="namespace"><h4>clojure.data.zip</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.zip&lt;/i&gt;&lt;b&gt;ancestors&lt;/b&gt; ([loc])&lt;br&gt; Returns a lazy sequence of all ancestors of location loc, starting&lt;br&gt;  with loc and proceeding to loc's parent node and on through to the&lt;br&gt;  root of the tree.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ancestors&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of all ancestors of location loc, starting&amp;lt;br&amp;gt;  with loc and proceeding to loc's parent node and on through to the&amp;lt;br&amp;gt;  root of the tree.&amp;quot;&amp;lt;br&amp;gt;  [loc] (lazy-seq (when loc (cons (auto false loc) (ancestors (zip/up loc))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ancestors</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.zip&lt;/i&gt;&lt;b&gt;auto&lt;/b&gt; ([v x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn auto&amp;lt;br&amp;gt;  [v x] (with-meta x ((if v dissoc assoc) (meta x) :zip-filter/no-auto? true)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">auto</a>[v x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.zip&lt;/i&gt;&lt;b&gt;auto?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn auto?&amp;lt;br&amp;gt;  [x] (not (:zip-filter/no-auto? (meta x))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">auto?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.zip&lt;/i&gt;&lt;b&gt;children&lt;/b&gt; ([loc])&lt;br&gt; Returns a lazy sequence of all immediate children of location loc,&lt;br&gt;  left-to-right.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn children&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of all immediate children of location loc,&amp;lt;br&amp;gt;  left-to-right.&amp;quot;&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;  (when (zip/branch? loc)&amp;lt;br&amp;gt;    (map #(auto false %) (right-locs (zip/down loc)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">children</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.zip&lt;/i&gt;&lt;b&gt;children-auto&lt;/b&gt; ([loc])&lt;br&gt; Returns a lazy sequence of all immediate children of location loc,&lt;br&gt;  left-to-right, marked so that a following tag= predicate will auto-descend.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn children-auto&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of all immediate children of location loc,&amp;lt;br&amp;gt;  left-to-right, marked so that a following tag= predicate will auto-descend.&amp;quot;&amp;lt;br&amp;gt;  ^{:private true}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;  (when (zip/branch? loc)&amp;lt;br&amp;gt;    (map #(auto true %) (right-locs (zip/down loc)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">children-auto</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.zip&lt;/i&gt;&lt;b&gt;descendants&lt;/b&gt; ([loc])&lt;br&gt; Returns a lazy sequence of all descendants of location loc, in&lt;br&gt;  depth-first order, left-to-right, starting with loc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn descendants&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of all descendants of location loc, in&amp;lt;br&amp;gt;  depth-first order, left-to-right, starting with loc.&amp;quot;&amp;lt;br&amp;gt;  [loc] (lazy-seq (cons (auto false loc) (mapcat descendants (children loc)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">descendants</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.zip&lt;/i&gt;&lt;b&gt;left-locs&lt;/b&gt; ([loc])&lt;br&gt; Returns a lazy sequence of locations to the left of loc, starting with loc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn left-locs&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of locations to the left of loc, starting with loc.&amp;quot;&amp;lt;br&amp;gt;  [loc] (lazy-seq (when loc (cons (auto false loc) (left-locs (zip/left loc))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">left-locs</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.zip&lt;/i&gt;&lt;b&gt;leftmost?&lt;/b&gt; ([loc])&lt;br&gt; Returns true if there are no more nodes to the left of location loc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn leftmost?&amp;lt;br&amp;gt;  &amp;quot;Returns true if there are no more nodes to the left of location loc.&amp;quot;&amp;lt;br&amp;gt;  [loc] (nil? (zip/left loc)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">leftmost?</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.zip&lt;/i&gt;&lt;b&gt;mapcat-chain&lt;/b&gt; ([loc preds mkpred])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mapcat-chain&amp;lt;br&amp;gt;  ^{:private true}&amp;lt;br&amp;gt;  [loc preds mkpred]&amp;lt;br&amp;gt;  (reduce (fn [prevseq expr]&amp;lt;br&amp;gt;            (mapcat #(fixup-apply (or (mkpred expr) expr) %) prevseq))&amp;lt;br&amp;gt;          (list (with-meta loc (assoc (meta loc) :zip-filter/is-node? true)))&amp;lt;br&amp;gt;          preds))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mapcat-chain</a>[loc preds mkpred]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.zip&lt;/i&gt;&lt;b&gt;right-locs&lt;/b&gt; ([loc])&lt;br&gt; Returns a lazy sequence of locations to the right of loc, starting with loc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn right-locs&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy sequence of locations to the right of loc, starting with loc.&amp;quot;&amp;lt;br&amp;gt;  [loc] (lazy-seq (when loc (cons (auto false loc) (right-locs (zip/right loc))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">right-locs</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.data.zip&lt;/i&gt;&lt;b&gt;rightmost?&lt;/b&gt; ([loc])&lt;br&gt; Returns true if there are no more nodes to the right of location loc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rightmost?&amp;lt;br&amp;gt;  &amp;quot;Returns true if there are no more nodes to the right of location loc.&amp;quot;&amp;lt;br&amp;gt;  [loc] (nil? (zip/right loc)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rightmost?</a>[loc]</div></div></div><div class="row"><div class="namespace"><h4>clojure.edn</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.edn&lt;/i&gt;&lt;b&gt;read&lt;/b&gt; ([] [stream] [opts stream])&lt;br&gt; Reads the next object from stream, which must be an instance of&lt;br&gt;  java.io.PushbackReader or some derivee.  stream defaults to the&lt;br&gt;  current value of *in*.&lt;br&gt;&lt;br&gt;  Reads data in the edn format (subset of Clojure data):&lt;br&gt;  http://edn-format.org&lt;br&gt;&lt;br&gt;  opts is a map that can include the following keys:&lt;br&gt;  :eof - value to return on end-of-file. When not supplied, eof throws an exception.&lt;br&gt;  :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.&lt;br&gt;              When not supplied, only the default-data-readers will be used.&lt;br&gt;  :default - A function of two args, that will, if present and no reader is found for a tag,&lt;br&gt;             be called with the tag and the value.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read&amp;lt;br&amp;gt;  &amp;quot;Reads the next object from stream, which must be an instance of&amp;lt;br&amp;gt;  java.io.PushbackReader or some derivee.  stream defaults to the&amp;lt;br&amp;gt;  current value of *in*.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Reads data in the edn format (subset of Clojure data):&amp;lt;br&amp;gt;  http://edn-format.org&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  opts is a map that can include the following keys:&amp;lt;br&amp;gt;  :eof - value to return on end-of-file. When not supplied, eof throws an exception.&amp;lt;br&amp;gt;  :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.&amp;lt;br&amp;gt;              When not supplied, only the default-data-readers will be used.&amp;lt;br&amp;gt;  :default - A function of two args, that will, if present and no reader is found for a tag,&amp;lt;br&amp;gt;             be called with the tag and the value.&amp;quot;&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  ([]&amp;lt;br&amp;gt;   (read *in*))&amp;lt;br&amp;gt;  ([stream]&amp;lt;br&amp;gt;   (read {} stream))&amp;lt;br&amp;gt;  ([opts stream]&amp;lt;br&amp;gt;     (clojure.lang.EdnReader/read stream opts)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read</a>[] [stream] [opts stream]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.edn&lt;/i&gt;&lt;b&gt;read-string&lt;/b&gt; ([s] [opts s])&lt;br&gt; Reads one object from the string s. Returns nil when s is nil or empty.&lt;br&gt;&lt;br&gt;  Reads data in the edn format (subset of Clojure data):&lt;br&gt;  http://edn-format.org&lt;br&gt;&lt;br&gt;  opts is a map as per clojure.edn/read&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-string&amp;lt;br&amp;gt;  &amp;quot;Reads one object from the string s. Returns nil when s is nil or empty.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Reads data in the edn format (subset of Clojure data):&amp;lt;br&amp;gt;  http://edn-format.org&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  opts is a map as per clojure.edn/read&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  ([s] (read-string {:eof nil} s))&amp;lt;br&amp;gt;  ([opts s] (when s (clojure.lang.EdnReader/readString s opts))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-string</a>[s] [opts s]</div></div></div><div class="row"><div class="namespace"><h4>clojure.inspector</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.inspector&lt;/i&gt;&lt;b&gt;atom?&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn atom? [x]&amp;lt;br&amp;gt;  (not (coll? x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">atom?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.inspector&lt;/i&gt;&lt;b&gt;collection-tag&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn collection-tag [x]&amp;lt;br&amp;gt;  (cond &amp;lt;br&amp;gt;   (instance? java.util.Map$Entry x) :entry&amp;lt;br&amp;gt;   (instance? java.util.Map x) :map&amp;lt;br&amp;gt;   (sequential? x) :seq&amp;lt;br&amp;gt;   :else :atom))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">collection-tag</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.inspector&lt;/i&gt;&lt;b&gt;inspect&lt;/b&gt; ([x])&lt;br&gt; creates a graphical (Swing) inspector on the supplied object&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn inspect&amp;lt;br&amp;gt;  &amp;quot;creates a graphical (Swing) inspector on the supplied object&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [x]&amp;lt;br&amp;gt;  (doto (JFrame. &amp;quot;Clojure Inspector&amp;quot;)&amp;lt;br&amp;gt;    (.add&amp;lt;br&amp;gt;      (doto (JPanel. (BorderLayout.))&amp;lt;br&amp;gt;        (.add (doto (JToolBar.)&amp;lt;br&amp;gt;                (.add (JButton. &amp;quot;Back&amp;quot;))&amp;lt;br&amp;gt;                (.addSeparator)&amp;lt;br&amp;gt;                (.add (JButton. &amp;quot;List&amp;quot;))&amp;lt;br&amp;gt;                (.add (JButton. &amp;quot;Table&amp;quot;))&amp;lt;br&amp;gt;                (.add (JButton. &amp;quot;Bean&amp;quot;))&amp;lt;br&amp;gt;                (.add (JButton. &amp;quot;Line&amp;quot;))&amp;lt;br&amp;gt;                (.add (JButton. &amp;quot;Bar&amp;quot;))&amp;lt;br&amp;gt;                (.addSeparator)&amp;lt;br&amp;gt;                (.add (JButton. &amp;quot;Prev&amp;quot;))&amp;lt;br&amp;gt;                (.add (JButton. &amp;quot;Next&amp;quot;)))&amp;lt;br&amp;gt;              BorderLayout/NORTH)&amp;lt;br&amp;gt;        (.add&amp;lt;br&amp;gt;          (JScrollPane. &amp;lt;br&amp;gt;            (doto (JTable. (list-model (list-provider x)))&amp;lt;br&amp;gt;              (.setAutoResizeMode JTable/AUTO_RESIZE_LAST_COLUMN)))&amp;lt;br&amp;gt;          BorderLayout/CENTER)))&amp;lt;br&amp;gt;    (.setSize 400 400)&amp;lt;br&amp;gt;    (.setVisible true)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">inspect</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.inspector&lt;/i&gt;&lt;b&gt;inspect-table&lt;/b&gt; ([data])&lt;br&gt; creates a graphical (Swing) inspector on the supplied regular&lt;br&gt;  data, which must be a sequential data structure of data structures&lt;br&gt;  of equal length&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn inspect-table &amp;lt;br&amp;gt;  &amp;quot;creates a graphical (Swing) inspector on the supplied regular&amp;lt;br&amp;gt;  data, which must be a sequential data structure of data structures&amp;lt;br&amp;gt;  of equal length&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;    [data]&amp;lt;br&amp;gt;  (doto (JFrame. &amp;quot;Clojure Inspector&amp;quot;)&amp;lt;br&amp;gt;    (.add (JScrollPane. (JTable. (old-table-model data))))&amp;lt;br&amp;gt;    (.setSize 400 600)&amp;lt;br&amp;gt;    (.setVisible true)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">inspect-table</a>[data]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.inspector&lt;/i&gt;&lt;b&gt;inspect-tree&lt;/b&gt; ([data])&lt;br&gt; creates a graphical (Swing) inspector on the supplied hierarchical data&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn inspect-tree &amp;lt;br&amp;gt;  &amp;quot;creates a graphical (Swing) inspector on the supplied hierarchical data&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [data]&amp;lt;br&amp;gt;  (doto (JFrame. &amp;quot;Clojure Inspector&amp;quot;)&amp;lt;br&amp;gt;    (.add (JScrollPane. (JTree. (tree-model data))))&amp;lt;br&amp;gt;    (.setSize 400 600)&amp;lt;br&amp;gt;    (.setVisible true)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">inspect-tree</a>[data]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.inspector&lt;/i&gt;&lt;b&gt;list-model&lt;/b&gt; ([provider])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn list-model [provider]&amp;lt;br&amp;gt;  (let [{:keys [nrows get-value get-label]} provider]&amp;lt;br&amp;gt;    (proxy [AbstractTableModel] []&amp;lt;br&amp;gt;      (getColumnCount [] 2)&amp;lt;br&amp;gt;      (getRowCount [] nrows)&amp;lt;br&amp;gt;      (getValueAt [rowIndex columnIndex]&amp;lt;br&amp;gt;        (cond &amp;lt;br&amp;gt;         (= 0 columnIndex) (get-label rowIndex)&amp;lt;br&amp;gt;         (= 1 columnIndex) (print-str (get-value rowIndex)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">list-model</a>[provider]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.inspector&lt;/i&gt;&lt;b&gt;old-table-model&lt;/b&gt; ([data])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn old-table-model [data]&amp;lt;br&amp;gt;  (let [row1 (first data)&amp;lt;br&amp;gt;	colcnt (count row1)&amp;lt;br&amp;gt;	cnt (count data)&amp;lt;br&amp;gt;	vals (if (map? row1) vals identity)]&amp;lt;br&amp;gt;    (proxy [TableModel] []&amp;lt;br&amp;gt;      (addTableModelListener [tableModelListener])&amp;lt;br&amp;gt;      (getColumnClass [columnIndex] Object)&amp;lt;br&amp;gt;      (getColumnCount [] colcnt)&amp;lt;br&amp;gt;      (getColumnName [columnIndex]&amp;lt;br&amp;gt;	(if (map? row1)&amp;lt;br&amp;gt;	  (name (nth (keys row1) columnIndex))&amp;lt;br&amp;gt;	  (str columnIndex)))&amp;lt;br&amp;gt;      (getRowCount [] cnt)&amp;lt;br&amp;gt;      (getValueAt [rowIndex columnIndex]&amp;lt;br&amp;gt;	(nth (vals (nth data rowIndex)) columnIndex))&amp;lt;br&amp;gt;      (isCellEditable [rowIndex columnIndex] false)&amp;lt;br&amp;gt;      (removeTableModelListener [tableModelListener]))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">old-table-model</a>[data]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.inspector&lt;/i&gt;&lt;b&gt;tree-model&lt;/b&gt; ([data])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tree-model [data]&amp;lt;br&amp;gt;  (proxy [TreeModel] []&amp;lt;br&amp;gt;    (getRoot [] data)&amp;lt;br&amp;gt;    (addTreeModelListener [treeModelListener])&amp;lt;br&amp;gt;    (getChild [parent index]&amp;lt;br&amp;gt;      (get-child parent index))&amp;lt;br&amp;gt;    (getChildCount [parent]&amp;lt;br&amp;gt;       (get-child-count parent))&amp;lt;br&amp;gt;    (isLeaf [node]&amp;lt;br&amp;gt;      (is-leaf node))&amp;lt;br&amp;gt;    (valueForPathChanged [path newValue])&amp;lt;br&amp;gt;    (getIndexOfChild [parent child]&amp;lt;br&amp;gt;      -1)&amp;lt;br&amp;gt;    (removeTreeModelListener [treeModelListener])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tree-model</a>[data]</div></div></div><div class="row"><div class="namespace"><h4>clojure.instant</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.instant&lt;/i&gt;&lt;b&gt;validated&lt;/b&gt; ([new-instance])&lt;br&gt; Return a function which constructs and instant by calling constructor&lt;br&gt;after first validting that those arguments are in range and otherwise&lt;br&gt;plausible. The resulting function will throw an exception if called&lt;br&gt;with invalid arguments.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn validated&amp;lt;br&amp;gt;  &amp;quot;Return a function which constructs and instant by calling constructor&amp;lt;br&amp;gt;after first validting that those arguments are in range and otherwise&amp;lt;br&amp;gt;plausible. The resulting function will throw an exception if called&amp;lt;br&amp;gt;with invalid arguments.&amp;quot;&amp;lt;br&amp;gt;  [new-instance]&amp;lt;br&amp;gt;  (fn [years months days hours minutes seconds nanoseconds&amp;lt;br&amp;gt;       offset-sign offset-hours offset-minutes]&amp;lt;br&amp;gt;    (verify (&amp;lt;= 1 months 12))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 1 days (days-in-month months (leap-year? years))))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 0 hours 23))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 0 minutes 59))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 0 seconds (if (= minutes 59) 60 59)))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 0 nanoseconds 999999999))&amp;lt;br&amp;gt;    (verify (&amp;lt;= -1 offset-sign 1))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 0 offset-hours 23))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 0 offset-minutes 59))&amp;lt;br&amp;gt;    (new-instance years months days hours minutes seconds nanoseconds&amp;lt;br&amp;gt;                  offset-sign offset-hours offset-minutes)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">validated</a>[new-instance]</div></div></div><div class="row"><div class="namespace"><h4>clojure.java.browse</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.browse&lt;/i&gt;&lt;b&gt;browse-url&lt;/b&gt; ([url])&lt;br&gt; Open url in a browser&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn browse-url&amp;lt;br&amp;gt;  &amp;quot;Open url in a browser&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [url]&amp;lt;br&amp;gt;  (or (open-url-in-browser url)&amp;lt;br&amp;gt;      (when *open-url-script* (sh/sh *open-url-script* (str url)) true)&amp;lt;br&amp;gt;      (open-url-in-swing url)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">browse-url</a>[url]</div></div></div><div class="row"><div class="namespace"><h4>clojure.java.classpath</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.classpath&lt;/i&gt;&lt;b&gt;classpath&lt;/b&gt; ([classloader] [])&lt;br&gt; Returns a sequence of File objects of the elements on the classpath.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn classpath&amp;lt;br&amp;gt;  &amp;quot;Returns a sequence of File objects of the elements on the classpath.&amp;quot;&amp;lt;br&amp;gt;  ([classloader]&amp;lt;br&amp;gt;     (distinct&amp;lt;br&amp;gt;      (mapcat&amp;lt;br&amp;gt;       loader-classpath&amp;lt;br&amp;gt;       (take-while&amp;lt;br&amp;gt;        identity&amp;lt;br&amp;gt;        (iterate #(.getParent ^ClassLoader %) classloader)))))&amp;lt;br&amp;gt;  ([] (classpath (clojure.lang.RT/baseLoader))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">classpath</a>[classloader] []</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.classpath&lt;/i&gt;&lt;b&gt;classpath-directories&lt;/b&gt; ([])&lt;br&gt; Returns a sequence of File objects for the directories on classpath.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn classpath-directories&amp;lt;br&amp;gt;  &amp;quot;Returns a sequence of File objects for the directories on classpath.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (filter #(.isDirectory ^File %) (classpath)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">classpath-directories</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.classpath&lt;/i&gt;&lt;b&gt;classpath-jarfiles&lt;/b&gt; ([])&lt;br&gt; Returns a sequence of JarFile objects for the JAR files on classpath.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn classpath-jarfiles&amp;lt;br&amp;gt;  &amp;quot;Returns a sequence of JarFile objects for the JAR files on classpath.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (map #(JarFile. ^File %) (filter jar-file? (classpath))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">classpath-jarfiles</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.classpath&lt;/i&gt;&lt;b&gt;filenames-in-jar&lt;/b&gt; ([jar-file])&lt;br&gt; Returns a sequence of Strings naming the non-directory entries in&lt;br&gt;  the JAR file.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn filenames-in-jar&amp;lt;br&amp;gt;  &amp;quot;Returns a sequence of Strings naming the non-directory entries in&amp;lt;br&amp;gt;  the JAR file.&amp;quot;&amp;lt;br&amp;gt;  [^JarFile jar-file]&amp;lt;br&amp;gt;  (map #(.getName ^JarEntry %)&amp;lt;br&amp;gt;       (filter #(not (.isDirectory ^JarEntry %))&amp;lt;br&amp;gt;               (enumeration-seq (.entries jar-file)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">filenames-in-jar</a>[jar-file]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.classpath&lt;/i&gt;&lt;b&gt;jar-file?&lt;/b&gt; ([f])&lt;br&gt; Returns true if file is a normal file with a .jar or .JAR extension.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn jar-file?&amp;lt;br&amp;gt;  &amp;quot;Returns true if file is a normal file with a .jar or .JAR extension.&amp;quot;&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (let [file (io/file f)]&amp;lt;br&amp;gt;    (and (.isFile file)&amp;lt;br&amp;gt;         (or (.endsWith (.getName file) &amp;quot;.jar&amp;quot;)&amp;lt;br&amp;gt;             (.endsWith (.getName file) &amp;quot;.JAR&amp;quot;)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">jar-file?</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.classpath&lt;/i&gt;&lt;b&gt;loader-classpath&lt;/b&gt; ([loader])&lt;br&gt; Returns a sequence of File paths from a classloader.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn loader-classpath&amp;lt;br&amp;gt;  &amp;quot;Returns a sequence of File paths from a classloader.&amp;quot;&amp;lt;br&amp;gt;  [loader]&amp;lt;br&amp;gt;  (when (instance? java.net.URLClassLoader loader)&amp;lt;br&amp;gt;    (map io/as-file (.getURLs ^java.net.URLClassLoader loader))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">loader-classpath</a>[loader]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.classpath&lt;/i&gt;&lt;b&gt;system-classpath&lt;/b&gt; ([])&lt;br&gt; Returns a sequence of File paths from the 'java.class.path' system&lt;br&gt;  property.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn system-classpath&amp;lt;br&amp;gt;  &amp;quot;Returns a sequence of File paths from the 'java.class.path' system&amp;lt;br&amp;gt;  property.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (map #(File. ^String %)&amp;lt;br&amp;gt;       (.split (System/getProperty &amp;quot;java.class.path&amp;quot;)&amp;lt;br&amp;gt;               (System/getProperty &amp;quot;path.separator&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">system-classpath</a>[]</div></div></div><div class="row"><div class="namespace"><h4>clojure.java.data</h4></div></div><div class="row"><div class="namespace"><h4>clojure.java.io</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;as-file&lt;/b&gt; ([x])&lt;br&gt; Coerce argument to a file.&lt;/div&gt;" data-placement="right">as-file</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;as-relative-path&lt;/b&gt; ([x])&lt;br&gt; Take an as-file-able thing and return a string if it is&lt;br&gt;   a relative path, else IllegalArgumentException.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String as-relative-path&amp;lt;br&amp;gt;  &amp;quot;Take an as-file-able thing and return a string if it is&amp;lt;br&amp;gt;   a relative path, else IllegalArgumentException.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [x]&amp;lt;br&amp;gt;  (let [^File f (as-file x)]&amp;lt;br&amp;gt;    (if (.isAbsolute f)&amp;lt;br&amp;gt;      (throw (IllegalArgumentException. (str f &amp;quot; is not a relative path&amp;quot;)))&amp;lt;br&amp;gt;      (.getPath f))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">as-relative-path</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;as-url&lt;/b&gt; ([x])&lt;br&gt; Coerce argument to a URL.&lt;/div&gt;" data-placement="right">as-url</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;copy&lt;/b&gt; ([input output &amp; opts])&lt;br&gt; Copies input to output.  Returns nil or throws IOException.&lt;br&gt;  Input may be an InputStream, Reader, File, byte[], or String.&lt;br&gt;  Output may be an OutputStream, Writer, or File.&lt;br&gt;&lt;br&gt;  Options are key/value pairs and may be one of&lt;br&gt;&lt;br&gt;    :buffer-size  buffer size to use, default is 1024.&lt;br&gt;    :encoding     encoding to use if converting between&lt;br&gt;                  byte and char streams.   &lt;br&gt;&lt;br&gt;  Does not close any streams except those it opens itself &lt;br&gt;  (on a File).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn copy&amp;lt;br&amp;gt;  &amp;quot;Copies input to output.  Returns nil or throws IOException.&amp;lt;br&amp;gt;  Input may be an InputStream, Reader, File, byte[], or String.&amp;lt;br&amp;gt;  Output may be an OutputStream, Writer, or File.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Options are key/value pairs and may be one of&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    :buffer-size  buffer size to use, default is 1024.&amp;lt;br&amp;gt;    :encoding     encoding to use if converting between&amp;lt;br&amp;gt;                  byte and char streams.   &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Does not close any streams except those it opens itself &amp;lt;br&amp;gt;  (on a File).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [input output &amp;amp; opts]&amp;lt;br&amp;gt;  (do-copy input output (when opts (apply hash-map opts))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">copy</a>[input output & opts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;delete-file&lt;/b&gt; ([f &amp; [silently]])&lt;br&gt; Delete file f. Raise an exception if it fails unless silently is true.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn delete-file&amp;lt;br&amp;gt;  &amp;quot;Delete file f. Raise an exception if it fails unless silently is true.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [f &amp;amp; [silently]]&amp;lt;br&amp;gt;  (or (.delete (file f))&amp;lt;br&amp;gt;      silently&amp;lt;br&amp;gt;      (throw (java.io.IOException. (str &amp;quot;Couldn't delete &amp;quot; f)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">delete-file</a>[f & [silently]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;file&lt;/b&gt; ([arg] [parent child] [parent child &amp; more])&lt;br&gt; Returns a java.io.File, passing each arg to as-file.  Multiple-arg&lt;br&gt;   versions treat the first argument as parent and subsequent args as&lt;br&gt;   children relative to the parent.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^File file&amp;lt;br&amp;gt;  &amp;quot;Returns a java.io.File, passing each arg to as-file.  Multiple-arg&amp;lt;br&amp;gt;   versions treat the first argument as parent and subsequent args as&amp;lt;br&amp;gt;   children relative to the parent.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  ([arg]                      &amp;lt;br&amp;gt;     (as-file arg))&amp;lt;br&amp;gt;  ([parent child]             &amp;lt;br&amp;gt;     (File. ^File (as-file parent) ^String (as-relative-path child)))&amp;lt;br&amp;gt;  ([parent child &amp;amp; more]&amp;lt;br&amp;gt;     (reduce file (file parent child) more)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">file</a>[arg] [parent child] [parent child & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;input-stream&lt;/b&gt; ([x &amp; opts])&lt;br&gt; Attempts to coerce its argument into an open java.io.InputStream.&lt;br&gt;   Default implementations always return a java.io.BufferedInputStream.&lt;br&gt;&lt;br&gt;   Default implementations are defined for OutputStream, File, URI, URL,&lt;br&gt;   Socket, byte array, and String arguments.&lt;br&gt;&lt;br&gt;   If the argument is a String, it tries to resolve it first as a URI, then&lt;br&gt;   as a local file name.  URIs with a 'file' protocol are converted to&lt;br&gt;   local file names.&lt;br&gt;&lt;br&gt;   Should be used inside with-open to ensure the InputStream is properly&lt;br&gt;   closed.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^InputStream input-stream&amp;lt;br&amp;gt;  &amp;quot;Attempts to coerce its argument into an open java.io.InputStream.&amp;lt;br&amp;gt;   Default implementations always return a java.io.BufferedInputStream.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Default implementations are defined for OutputStream, File, URI, URL,&amp;lt;br&amp;gt;   Socket, byte array, and String arguments.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   If the argument is a String, it tries to resolve it first as a URI, then&amp;lt;br&amp;gt;   as a local file name.  URIs with a 'file' protocol are converted to&amp;lt;br&amp;gt;   local file names.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Should be used inside with-open to ensure the InputStream is properly&amp;lt;br&amp;gt;   closed.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [x &amp;amp; opts]&amp;lt;br&amp;gt;  (make-input-stream x (when opts (apply hash-map opts))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">input-stream</a>[x & opts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;make-input-stream&lt;/b&gt; ([x opts])&lt;br&gt; Creates a BufferedInputStream. See also IOFactory docs.&lt;/div&gt;" data-placement="right">make-input-stream</a>[x opts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;make-output-stream&lt;/b&gt; ([x opts])&lt;br&gt; Creates a BufferedOutputStream. See also IOFactory docs.&lt;/div&gt;" data-placement="right">make-output-stream</a>[x opts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;make-parents&lt;/b&gt; ([f &amp; more])&lt;br&gt; Given the same arg(s) as for file, creates all parent directories of&lt;br&gt;   the file they represent.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-parents&amp;lt;br&amp;gt;  &amp;quot;Given the same arg(s) as for file, creates all parent directories of&amp;lt;br&amp;gt;   the file they represent.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [f &amp;amp; more]&amp;lt;br&amp;gt;  (when-let [parent (.getParentFile ^File (apply file f more))]&amp;lt;br&amp;gt;    (.mkdirs parent)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-parents</a>[f & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;make-reader&lt;/b&gt; ([x opts])&lt;br&gt; Creates a BufferedReader. See also IOFactory docs.&lt;/div&gt;" data-placement="right">make-reader</a>[x opts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;make-writer&lt;/b&gt; ([x opts])&lt;br&gt; Creates a BufferedWriter. See also IOFactory docs.&lt;/div&gt;" data-placement="right">make-writer</a>[x opts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;output-stream&lt;/b&gt; ([x &amp; opts])&lt;br&gt; Attempts to coerce its argument into an open java.io.OutputStream.&lt;br&gt;   Default implementations always return a java.io.BufferedOutputStream.&lt;br&gt;&lt;br&gt;   Default implementations are defined for OutputStream, File, URI, URL,&lt;br&gt;   Socket, and String arguments.&lt;br&gt;&lt;br&gt;   If the argument is a String, it tries to resolve it first as a URI, then&lt;br&gt;   as a local file name.  URIs with a 'file' protocol are converted to&lt;br&gt;   local file names.&lt;br&gt;&lt;br&gt;   Should be used inside with-open to ensure the OutputStream is&lt;br&gt;   properly closed.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^OutputStream output-stream&amp;lt;br&amp;gt;  &amp;quot;Attempts to coerce its argument into an open java.io.OutputStream.&amp;lt;br&amp;gt;   Default implementations always return a java.io.BufferedOutputStream.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Default implementations are defined for OutputStream, File, URI, URL,&amp;lt;br&amp;gt;   Socket, and String arguments.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   If the argument is a String, it tries to resolve it first as a URI, then&amp;lt;br&amp;gt;   as a local file name.  URIs with a 'file' protocol are converted to&amp;lt;br&amp;gt;   local file names.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Should be used inside with-open to ensure the OutputStream is&amp;lt;br&amp;gt;   properly closed.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [x &amp;amp; opts]&amp;lt;br&amp;gt;  (make-output-stream x (when opts (apply hash-map opts))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">output-stream</a>[x & opts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;reader&lt;/b&gt; ([x &amp; opts])&lt;br&gt; Attempts to coerce its argument into an open java.io.Reader.&lt;br&gt;   Default implementations always return a java.io.BufferedReader.&lt;br&gt;&lt;br&gt;   Default implementations are provided for Reader, BufferedReader,&lt;br&gt;   InputStream, File, URI, URL, Socket, byte arrays, character arrays,&lt;br&gt;   and String.&lt;br&gt;&lt;br&gt;   If argument is a String, it tries to resolve it first as a URI, then&lt;br&gt;   as a local file name.  URIs with a 'file' protocol are converted to&lt;br&gt;   local file names.&lt;br&gt;&lt;br&gt;   Should be used inside with-open to ensure the Reader is properly&lt;br&gt;   closed.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^Reader reader&amp;lt;br&amp;gt;  &amp;quot;Attempts to coerce its argument into an open java.io.Reader.&amp;lt;br&amp;gt;   Default implementations always return a java.io.BufferedReader.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Default implementations are provided for Reader, BufferedReader,&amp;lt;br&amp;gt;   InputStream, File, URI, URL, Socket, byte arrays, character arrays,&amp;lt;br&amp;gt;   and String.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   If argument is a String, it tries to resolve it first as a URI, then&amp;lt;br&amp;gt;   as a local file name.  URIs with a 'file' protocol are converted to&amp;lt;br&amp;gt;   local file names.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Should be used inside with-open to ensure the Reader is properly&amp;lt;br&amp;gt;   closed.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [x &amp;amp; opts]&amp;lt;br&amp;gt;  (make-reader x (when opts (apply hash-map opts))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reader</a>[x & opts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;resource&lt;/b&gt; ([n] [n loader])&lt;br&gt; Returns the URL for a named resource. Use the context class loader&lt;br&gt;   if no loader is specified.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^URL resource&amp;lt;br&amp;gt;  &amp;quot;Returns the URL for a named resource. Use the context class loader&amp;lt;br&amp;gt;   if no loader is specified.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  ([n] (resource n (.getContextClassLoader (Thread/currentThread))))&amp;lt;br&amp;gt;  ([n ^ClassLoader loader] (.getResource loader n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resource</a>[n] [n loader]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.io&lt;/i&gt;&lt;b&gt;writer&lt;/b&gt; ([x &amp; opts])&lt;br&gt; Attempts to coerce its argument into an open java.io.Writer.&lt;br&gt;   Default implementations always return a java.io.BufferedWriter.&lt;br&gt;&lt;br&gt;   Default implementations are provided for Writer, BufferedWriter,&lt;br&gt;   OutputStream, File, URI, URL, Socket, and String.&lt;br&gt;&lt;br&gt;   If the argument is a String, it tries to resolve it first as a URI, then&lt;br&gt;   as a local file name.  URIs with a 'file' protocol are converted to&lt;br&gt;   local file names.&lt;br&gt;&lt;br&gt;   Should be used inside with-open to ensure the Writer is properly&lt;br&gt;   closed.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^Writer writer&amp;lt;br&amp;gt;  &amp;quot;Attempts to coerce its argument into an open java.io.Writer.&amp;lt;br&amp;gt;   Default implementations always return a java.io.BufferedWriter.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Default implementations are provided for Writer, BufferedWriter,&amp;lt;br&amp;gt;   OutputStream, File, URI, URL, Socket, and String.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   If the argument is a String, it tries to resolve it first as a URI, then&amp;lt;br&amp;gt;   as a local file name.  URIs with a 'file' protocol are converted to&amp;lt;br&amp;gt;   local file names.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Should be used inside with-open to ensure the Writer is properly&amp;lt;br&amp;gt;   closed.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [x &amp;amp; opts]&amp;lt;br&amp;gt;  (make-writer x (when opts (apply hash-map opts))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">writer</a>[x & opts]</div></div></div><div class="row"><div class="namespace"><h4>clojure.java.javadoc</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.javadoc&lt;/i&gt;&lt;b&gt;add-local-javadoc&lt;/b&gt; ([path])&lt;br&gt; Adds to the list of local Javadoc paths.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-local-javadoc&amp;lt;br&amp;gt;  &amp;quot;Adds to the list of local Javadoc paths.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [path]&amp;lt;br&amp;gt;  (dosync (commute *local-javadocs* conj path)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-local-javadoc</a>[path]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.javadoc&lt;/i&gt;&lt;b&gt;add-remote-javadoc&lt;/b&gt; ([package-prefix url])&lt;br&gt; Adds to the list of remote Javadoc URLs.  package-prefix is the&lt;br&gt;  beginning of the package name that has docs at this URL.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-remote-javadoc&amp;lt;br&amp;gt;  &amp;quot;Adds to the list of remote Javadoc URLs.  package-prefix is the&amp;lt;br&amp;gt;  beginning of the package name that has docs at this URL.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [package-prefix url]&amp;lt;br&amp;gt;  (dosync (commute *remote-javadocs* assoc package-prefix url)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-remote-javadoc</a>[package-prefix url]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.javadoc&lt;/i&gt;&lt;b&gt;javadoc&lt;/b&gt; ([class-or-object])&lt;br&gt; Opens a browser window displaying the javadoc for the argument.&lt;br&gt;  Tries *local-javadocs* first, then *remote-javadocs*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn javadoc&amp;lt;br&amp;gt;  &amp;quot;Opens a browser window displaying the javadoc for the argument.&amp;lt;br&amp;gt;  Tries *local-javadocs* first, then *remote-javadocs*.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [class-or-object]&amp;lt;br&amp;gt;  (let [^Class c (if (instance? Class class-or-object) &amp;lt;br&amp;gt;                    class-or-object &amp;lt;br&amp;gt;                    (class class-or-object))]&amp;lt;br&amp;gt;    (if-let [url (javadoc-url (.getName c))]&amp;lt;br&amp;gt;      (browse-url url)&amp;lt;br&amp;gt;      (println &amp;quot;Could not find Javadoc for&amp;quot; c))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">javadoc</a>[class-or-object]</div></div></div><div class="row"><div class="namespace"><h4>clojure.java.jdbc</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;as-identifier&lt;/b&gt; ([x] [x f-entity])&lt;br&gt; Given a keyword, convert it to a string using the current naming&lt;br&gt;   strategy.&lt;br&gt;   Given a string, return it as-is.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn as-identifier&amp;lt;br&amp;gt;  &amp;quot;Given a keyword, convert it to a string using the current naming&amp;lt;br&amp;gt;   strategy.&amp;lt;br&amp;gt;   Given a string, return it as-is.&amp;quot;&amp;lt;br&amp;gt;  ([x] (as-identifier x *as-str*))&amp;lt;br&amp;gt;  ([x f-entity] (as-str f-entity x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">as-identifier</a>[x] [x f-entity]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;as-key&lt;/b&gt; ([f x])&lt;br&gt; Given a naming strategy and a string, return the string as a&lt;br&gt;   keyword per that naming strategy. Given (a naming strategy and)&lt;br&gt;   a keyword, return it as-is.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn as-key&amp;lt;br&amp;gt;  &amp;quot;Given a naming strategy and a string, return the string as a&amp;lt;br&amp;gt;   keyword per that naming strategy. Given (a naming strategy and)&amp;lt;br&amp;gt;   a keyword, return it as-is.&amp;quot;&amp;lt;br&amp;gt;  [f x]&amp;lt;br&amp;gt;  (if (instance? clojure.lang.Named x)&amp;lt;br&amp;gt;    x&amp;lt;br&amp;gt;    (keyword (f (str x)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">as-key</a>[f x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;as-keyword&lt;/b&gt; ([x] [x f-keyword])&lt;br&gt; Given an entity name (string), convert it to a keyword using the&lt;br&gt;   current naming strategy.&lt;br&gt;   Given a keyword, return it as-is.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn as-keyword&amp;lt;br&amp;gt;  &amp;quot;Given an entity name (string), convert it to a keyword using the&amp;lt;br&amp;gt;   current naming strategy.&amp;lt;br&amp;gt;   Given a keyword, return it as-is.&amp;quot;&amp;lt;br&amp;gt;  ([x] (as-keyword x *as-key*))&amp;lt;br&amp;gt;  ([x f-keyword] (as-key f-keyword x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">as-keyword</a>[x] [x f-keyword]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;as-named-identifier&lt;/b&gt; ([naming-strategy x])&lt;br&gt; Given a naming strategy and a keyword, return the keyword as a string using the &lt;br&gt;   entity naming strategy.&lt;br&gt;   Given a naming strategy and a string, return the string as-is.&lt;br&gt;   The naming strategy should either be a function (the entity naming strategy) or &lt;br&gt;   a map containing :entity and/or :keyword keys which provide the entity naming&lt;br&gt;   strategy and/or keyword naming strategy respectively.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn as-named-identifier&amp;lt;br&amp;gt;  &amp;quot;Given a naming strategy and a keyword, return the keyword as a string using the &amp;lt;br&amp;gt;   entity naming strategy.&amp;lt;br&amp;gt;   Given a naming strategy and a string, return the string as-is.&amp;lt;br&amp;gt;   The naming strategy should either be a function (the entity naming strategy) or &amp;lt;br&amp;gt;   a map containing :entity and/or :keyword keys which provide the entity naming&amp;lt;br&amp;gt;   strategy and/or keyword naming strategy respectively.&amp;quot;&amp;lt;br&amp;gt;  [naming-strategy x]&amp;lt;br&amp;gt;  (as-identifier x (if (map? naming-strategy) (or (:entity naming-strategy) identity) naming-strategy)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">as-named-identifier</a>[naming-strategy x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;as-named-keyword&lt;/b&gt; ([naming-strategy x])&lt;br&gt; Given a naming strategy and a string, return the string as a keyword using the &lt;br&gt;   keyword naming strategy.&lt;br&gt;   Given a naming strategy and a keyword, return the keyword as-is.&lt;br&gt;   The naming strategy should either be a function (the entity naming strategy) or &lt;br&gt;   a map containing :entity and/or :keyword keys which provide the entity naming&lt;br&gt;   strategy and/or keyword naming strategy respectively.&lt;br&gt;   Note that providing a single function will cause the default keyword naming&lt;br&gt;   strategy to be used!&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn as-named-keyword&amp;lt;br&amp;gt;  &amp;quot;Given a naming strategy and a string, return the string as a keyword using the &amp;lt;br&amp;gt;   keyword naming strategy.&amp;lt;br&amp;gt;   Given a naming strategy and a keyword, return the keyword as-is.&amp;lt;br&amp;gt;   The naming strategy should either be a function (the entity naming strategy) or &amp;lt;br&amp;gt;   a map containing :entity and/or :keyword keys which provide the entity naming&amp;lt;br&amp;gt;   strategy and/or keyword naming strategy respectively.&amp;lt;br&amp;gt;   Note that providing a single function will cause the default keyword naming&amp;lt;br&amp;gt;   strategy to be used!&amp;quot;&amp;lt;br&amp;gt;  [naming-strategy x]&amp;lt;br&amp;gt;  (as-keyword x (if (and (map? naming-strategy) (:keyword naming-strategy)) (:keyword naming-strategy) str/lower-case)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">as-named-keyword</a>[naming-strategy x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;as-quoted-identifier&lt;/b&gt; ([q x])&lt;br&gt; Given a quote pattern - either a single character or a pair of characters in&lt;br&gt;   a vector - and a keyword, return the keyword as a string using a simple&lt;br&gt;   quoting naming strategy.&lt;br&gt;   Given a qote pattern and a string, return the string as-is.&lt;br&gt;     (as-quoted-identifier X :name) will return XnameX as a string.&lt;br&gt;     (as-quoted-identifier [A B] :name) will return AnameB as a string.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn as-quoted-identifier&amp;lt;br&amp;gt;  &amp;quot;Given a quote pattern - either a single character or a pair of characters in&amp;lt;br&amp;gt;   a vector - and a keyword, return the keyword as a string using a simple&amp;lt;br&amp;gt;   quoting naming strategy.&amp;lt;br&amp;gt;   Given a qote pattern and a string, return the string as-is.&amp;lt;br&amp;gt;     (as-quoted-identifier X :name) will return XnameX as a string.&amp;lt;br&amp;gt;     (as-quoted-identifier [A B] :name) will return AnameB as a string.&amp;quot;&amp;lt;br&amp;gt;  [q x]&amp;lt;br&amp;gt;  (as-identifier x (partial as-quoted-str q)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">as-quoted-identifier</a>[q x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;as-quoted-str&lt;/b&gt; ([q x])&lt;br&gt; Given a quoting pattern - either a single character or a vector pair of&lt;br&gt;   characters - and a string, return the quoted string:&lt;br&gt;     (as-quoted-str X foo) will return XfooX&lt;br&gt;     (as-quoted-str [A B] foo) will return AfooB&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn as-quoted-str&amp;lt;br&amp;gt;  &amp;quot;Given a quoting pattern - either a single character or a vector pair of&amp;lt;br&amp;gt;   characters - and a string, return the quoted string:&amp;lt;br&amp;gt;     (as-quoted-str X foo) will return XfooX&amp;lt;br&amp;gt;     (as-quoted-str [A B] foo) will return AfooB&amp;quot;&amp;lt;br&amp;gt;  [q x]&amp;lt;br&amp;gt;  (if (vector? q)&amp;lt;br&amp;gt;    (str (first q) x (last q))&amp;lt;br&amp;gt;    (str q x q)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">as-quoted-str</a>[q x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;as-str&lt;/b&gt; ([f x])&lt;br&gt; Given a naming strategy and a keyword, return the keyword as a&lt;br&gt;   string per that naming strategy. Given (a naming strategy and)&lt;br&gt;   a string, return it as-is.&lt;br&gt;   A keyword of the form :x.y is treated as keywords :x and :y,&lt;br&gt;   both are turned into strings via the naming strategy and then&lt;br&gt;   joined back together so :x.y might become `x`.`y` if the naming&lt;br&gt;   strategy quotes identifiers with `.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn as-str&amp;lt;br&amp;gt;  &amp;quot;Given a naming strategy and a keyword, return the keyword as a&amp;lt;br&amp;gt;   string per that naming strategy. Given (a naming strategy and)&amp;lt;br&amp;gt;   a string, return it as-is.&amp;lt;br&amp;gt;   A keyword of the form :x.y is treated as keywords :x and :y,&amp;lt;br&amp;gt;   both are turned into strings via the naming strategy and then&amp;lt;br&amp;gt;   joined back together so :x.y might become `x`.`y` if the naming&amp;lt;br&amp;gt;   strategy quotes identifiers with `.&amp;quot;&amp;lt;br&amp;gt;  [f x]&amp;lt;br&amp;gt;  (if (instance? clojure.lang.Named x)&amp;lt;br&amp;gt;    (let [n (name x)&amp;lt;br&amp;gt;          i (.indexOf n (int \.))]&amp;lt;br&amp;gt;      (if (= -1 i)&amp;lt;br&amp;gt;        (f n)&amp;lt;br&amp;gt;        (str/join &amp;quot;.&amp;quot; (map f (.split n &amp;quot;\\.&amp;quot;)))))&amp;lt;br&amp;gt;    (str x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">as-str</a>[f x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;connection&lt;/b&gt; ([])&lt;br&gt; Returns the current database connection (or throws if there is none)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn connection&amp;lt;br&amp;gt;  &amp;quot;Returns the current database connection (or throws if there is none)&amp;quot;&amp;lt;br&amp;gt;  ^java.sql.Connection []&amp;lt;br&amp;gt;  (or (find-connection)&amp;lt;br&amp;gt;      (throw (Exception. &amp;quot;no current database connection&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">connection</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;create-table&lt;/b&gt; ([name &amp; specs])&lt;br&gt; Creates a table on the open database connection given a table name and&lt;br&gt;  specs. Each spec is either a column spec: a vector containing a column&lt;br&gt;  name and optionally a type and other constraints, or a table-level&lt;br&gt;  constraint: a vector containing words that express the constraint. An&lt;br&gt;  optional suffix to the CREATE TABLE DDL describing table attributes may&lt;br&gt;  by provided as :table-spec {table-attributes-string}. All words used to&lt;br&gt;  describe the table may be supplied as strings or keywords.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn create-table&amp;lt;br&amp;gt;  &amp;quot;Creates a table on the open database connection given a table name and&amp;lt;br&amp;gt;  specs. Each spec is either a column spec: a vector containing a column&amp;lt;br&amp;gt;  name and optionally a type and other constraints, or a table-level&amp;lt;br&amp;gt;  constraint: a vector containing words that express the constraint. An&amp;lt;br&amp;gt;  optional suffix to the CREATE TABLE DDL describing table attributes may&amp;lt;br&amp;gt;  by provided as :table-spec {table-attributes-string}. All words used to&amp;lt;br&amp;gt;  describe the table may be supplied as strings or keywords.&amp;quot;&amp;lt;br&amp;gt;  [name &amp;amp; specs]&amp;lt;br&amp;gt;  (do-commands (apply create-table-ddl name specs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">create-table</a>[name & specs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;create-table-ddl&lt;/b&gt; ([name &amp; specs])&lt;br&gt; Given a table name and column specs with an optional table-spec&lt;br&gt;   return the DDL string for creating a table based on that.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn create-table-ddl&amp;lt;br&amp;gt;  &amp;quot;Given a table name and column specs with an optional table-spec&amp;lt;br&amp;gt;   return the DDL string for creating a table based on that.&amp;quot;&amp;lt;br&amp;gt;  [name &amp;amp; specs]&amp;lt;br&amp;gt;  (let [split-specs (partition-by #(= :table-spec %) specs)&amp;lt;br&amp;gt;        col-specs (first split-specs)&amp;lt;br&amp;gt;        table-spec (first (second (rest split-specs)))&amp;lt;br&amp;gt;        table-spec-str (or (and table-spec (str &amp;quot; &amp;quot; table-spec)) &amp;quot;&amp;quot;)&amp;lt;br&amp;gt;        specs-to-string (fn [specs]&amp;lt;br&amp;gt;                          (apply str&amp;lt;br&amp;gt;                                 (map as-identifier&amp;lt;br&amp;gt;                                      (apply concat&amp;lt;br&amp;gt;                                             (interpose [&amp;quot;, &amp;quot;]&amp;lt;br&amp;gt;                                                        (map (partial interpose &amp;quot; &amp;quot;) specs))))))]&amp;lt;br&amp;gt;    (format &amp;quot;CREATE TABLE %s (%s)%s&amp;quot;&amp;lt;br&amp;gt;            (as-identifier name)&amp;lt;br&amp;gt;            (specs-to-string col-specs)&amp;lt;br&amp;gt;            table-spec-str)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">create-table-ddl</a>[name & specs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;delete-rows&lt;/b&gt; ([table where-params])&lt;br&gt; Deletes rows from a table. where-params is a vector containing a string&lt;br&gt;  providing the (optionally parameterized) selection criteria followed by&lt;br&gt;  values for any parameters.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn delete-rows&amp;lt;br&amp;gt;  &amp;quot;Deletes rows from a table. where-params is a vector containing a string&amp;lt;br&amp;gt;  providing the (optionally parameterized) selection criteria followed by&amp;lt;br&amp;gt;  values for any parameters.&amp;quot;&amp;lt;br&amp;gt;  [table where-params]&amp;lt;br&amp;gt;  (let [[where &amp;amp; params] where-params]&amp;lt;br&amp;gt;    (do-prepared&amp;lt;br&amp;gt;      (format &amp;quot;DELETE FROM %s WHERE %s&amp;quot;&amp;lt;br&amp;gt;              (as-identifier table) where)&amp;lt;br&amp;gt;      params)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">delete-rows</a>[table where-params]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;do-commands&lt;/b&gt; ([&amp; commands])&lt;br&gt; Executes SQL commands on the open database connection.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn do-commands&amp;lt;br&amp;gt;  &amp;quot;Executes SQL commands on the open database connection.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; commands]&amp;lt;br&amp;gt;  (with-open [^Statement stmt (let [^java.sql.Connection con (connection)] (.createStatement con))]&amp;lt;br&amp;gt;    (doseq [^String cmd commands]&amp;lt;br&amp;gt;      (.addBatch stmt cmd))&amp;lt;br&amp;gt;    (transaction&amp;lt;br&amp;gt;     (execute-batch stmt))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">do-commands</a>[& commands]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;do-prepared&lt;/b&gt; ([sql &amp; param-groups])&lt;br&gt; Executes an (optionally parameterized) SQL prepared statement on the&lt;br&gt;  open database connection. Each param-group is a seq of values for all of&lt;br&gt;  the parameters.&lt;br&gt;  Return a seq of update counts (one count for each param-group).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn do-prepared&amp;lt;br&amp;gt;  &amp;quot;Executes an (optionally parameterized) SQL prepared statement on the&amp;lt;br&amp;gt;  open database connection. Each param-group is a seq of values for all of&amp;lt;br&amp;gt;  the parameters.&amp;lt;br&amp;gt;  Return a seq of update counts (one count for each param-group).&amp;quot;&amp;lt;br&amp;gt;  [sql &amp;amp; param-groups]&amp;lt;br&amp;gt;  (with-open [^PreparedStatement stmt (prepare-statement (connection) sql)]&amp;lt;br&amp;gt;    (if (empty? param-groups)&amp;lt;br&amp;gt;      (transaction* (fn [] (vector (.executeUpdate stmt))))&amp;lt;br&amp;gt;      (do&amp;lt;br&amp;gt;        (doseq [param-group param-groups]&amp;lt;br&amp;gt;          (set-parameters stmt param-group)&amp;lt;br&amp;gt;          (.addBatch stmt))&amp;lt;br&amp;gt;        (transaction* (fn [] (execute-batch stmt)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">do-prepared</a>[sql & param-groups]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;do-prepared-return-keys&lt;/b&gt; ([sql param-group])&lt;br&gt; Executes an (optionally parameterized) SQL prepared statement on the&lt;br&gt;  open database connection. The param-group is a seq of values for all of&lt;br&gt;  the parameters.&lt;br&gt;  Return the generated keys for the (single) update/insert.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn do-prepared-return-keys&amp;lt;br&amp;gt;  &amp;quot;Executes an (optionally parameterized) SQL prepared statement on the&amp;lt;br&amp;gt;  open database connection. The param-group is a seq of values for all of&amp;lt;br&amp;gt;  the parameters.&amp;lt;br&amp;gt;  Return the generated keys for the (single) update/insert.&amp;quot;&amp;lt;br&amp;gt;  [sql param-group]&amp;lt;br&amp;gt;  (with-open [^PreparedStatement stmt (prepare-statement (connection) sql :return-keys true)]&amp;lt;br&amp;gt;    (set-parameters stmt param-group)&amp;lt;br&amp;gt;    (transaction* (fn [] (let [counts (.executeUpdate stmt)]&amp;lt;br&amp;gt;                          (try&amp;lt;br&amp;gt;                            (let [rs (.getGeneratedKeys stmt)&amp;lt;br&amp;gt;                                  result (first (resultset-seq rs))]&amp;lt;br&amp;gt;                              ;; sqlite (and maybe others?) requires&amp;lt;br&amp;gt;                              ;; record set to be closed&amp;lt;br&amp;gt;                              (.close rs)&amp;lt;br&amp;gt;                              result)&amp;lt;br&amp;gt;                            (catch Exception _&amp;lt;br&amp;gt;                              ;; assume generated keys is unsupported and return counts instead: &amp;lt;br&amp;gt;                              counts)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">do-prepared-return-keys</a>[sql param-group]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;drop-table&lt;/b&gt; ([name])&lt;br&gt; Drops a table on the open database connection given its name, a string&lt;br&gt;  or keyword&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn drop-table&amp;lt;br&amp;gt;  &amp;quot;Drops a table on the open database connection given its name, a string&amp;lt;br&amp;gt;  or keyword&amp;quot;&amp;lt;br&amp;gt;  [name]&amp;lt;br&amp;gt;  (do-commands&amp;lt;br&amp;gt;    (format &amp;quot;DROP TABLE %s&amp;quot; (as-identifier name))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">drop-table</a>[name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;find-connection&lt;/b&gt; ([])&lt;br&gt; Returns the current database connection (or nil if there is none)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-connection&amp;lt;br&amp;gt;  &amp;quot;Returns the current database connection (or nil if there is none)&amp;quot;&amp;lt;br&amp;gt;  ^java.sql.Connection []&amp;lt;br&amp;gt;  (:connection *db*))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-connection</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;insert-record&lt;/b&gt; ([table record])&lt;br&gt; Inserts a single record into a table. A record is a map from strings or&lt;br&gt;  keywords (identifying columns) to values.&lt;br&gt;  Returns a map of the generated keys.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn insert-record&amp;lt;br&amp;gt;  &amp;quot;Inserts a single record into a table. A record is a map from strings or&amp;lt;br&amp;gt;  keywords (identifying columns) to values.&amp;lt;br&amp;gt;  Returns a map of the generated keys.&amp;quot;&amp;lt;br&amp;gt;  [table record]&amp;lt;br&amp;gt;  (let [keys (insert-records table record)]&amp;lt;br&amp;gt;    (first keys)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">insert-record</a>[table record]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;insert-records&lt;/b&gt; ([table &amp; records])&lt;br&gt; Inserts records into a table. records are maps from strings or keywords&lt;br&gt;  (identifying columns) to values. Inserts the records one at a time.&lt;br&gt;  Returns a sequence of maps containing the generated keys for each record.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn insert-records&amp;lt;br&amp;gt;  &amp;quot;Inserts records into a table. records are maps from strings or keywords&amp;lt;br&amp;gt;  (identifying columns) to values. Inserts the records one at a time.&amp;lt;br&amp;gt;  Returns a sequence of maps containing the generated keys for each record.&amp;quot;&amp;lt;br&amp;gt;  [table &amp;amp; records]&amp;lt;br&amp;gt;  (let [ins-v (fn [record] (insert-values table (keys record) (vals record)))]&amp;lt;br&amp;gt;    (doall (map ins-v records))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">insert-records</a>[table & records]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;insert-rows&lt;/b&gt; ([table &amp; rows])&lt;br&gt; Inserts complete rows into a table. Each row is a vector of values for&lt;br&gt;  each of the table's columns in order.&lt;br&gt;  If a single row is inserted, returns a map of the generated keys.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn insert-rows&amp;lt;br&amp;gt;  &amp;quot;Inserts complete rows into a table. Each row is a vector of values for&amp;lt;br&amp;gt;  each of the table's columns in order.&amp;lt;br&amp;gt;  If a single row is inserted, returns a map of the generated keys.&amp;quot;&amp;lt;br&amp;gt;  [table &amp;amp; rows]&amp;lt;br&amp;gt;  (apply insert-values table nil rows))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">insert-rows</a>[table & rows]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;insert-values&lt;/b&gt; ([table column-names &amp; value-groups])&lt;br&gt; Inserts rows into a table with values for specified columns only.&lt;br&gt;  column-names is a vector of strings or keywords identifying columns. Each&lt;br&gt;  value-group is a vector containing a values for each column in&lt;br&gt;  order. When inserting complete rows (all columns), consider using&lt;br&gt;  insert-rows instead.&lt;br&gt;  If a single set of values is inserted, returns a map of the generated keys.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn insert-values&amp;lt;br&amp;gt;  &amp;quot;Inserts rows into a table with values for specified columns only.&amp;lt;br&amp;gt;  column-names is a vector of strings or keywords identifying columns. Each&amp;lt;br&amp;gt;  value-group is a vector containing a values for each column in&amp;lt;br&amp;gt;  order. When inserting complete rows (all columns), consider using&amp;lt;br&amp;gt;  insert-rows instead.&amp;lt;br&amp;gt;  If a single set of values is inserted, returns a map of the generated keys.&amp;quot;&amp;lt;br&amp;gt;  [table column-names &amp;amp; value-groups]&amp;lt;br&amp;gt;  (let [column-strs (map as-identifier column-names)&amp;lt;br&amp;gt;        n (count (first value-groups))&amp;lt;br&amp;gt;        return-keys (= 1 (count value-groups))&amp;lt;br&amp;gt;        prepared-statement (if return-keys do-prepared-return-keys do-prepared)&amp;lt;br&amp;gt;        template (apply str (interpose &amp;quot;,&amp;quot; (repeat n &amp;quot;?&amp;quot;)))&amp;lt;br&amp;gt;        columns (if (seq column-names)&amp;lt;br&amp;gt;                  (format &amp;quot;(%s)&amp;quot; (apply str (interpose &amp;quot;,&amp;quot; column-strs)))&amp;lt;br&amp;gt;                  &amp;quot;&amp;quot;)]&amp;lt;br&amp;gt;    (apply prepared-statement&amp;lt;br&amp;gt;           (format &amp;quot;INSERT INTO %s %s VALUES (%s)&amp;quot;&amp;lt;br&amp;gt;                   (as-identifier table) columns template)&amp;lt;br&amp;gt;           value-groups)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">insert-values</a>[table column-names & value-groups]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;is-rollback-only&lt;/b&gt; ([])&lt;br&gt; Returns true if the outermost transaction will rollback rather than&lt;br&gt;  commit when complete&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn is-rollback-only&amp;lt;br&amp;gt;  &amp;quot;Returns true if the outermost transaction will rollback rather than&amp;lt;br&amp;gt;  commit when complete&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (rollback))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">is-rollback-only</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;prepare-statement&lt;/b&gt; ([con sql &amp; {:keys [return-keys result-type concurrency cursors fetch-size max-rows]}])&lt;br&gt; Create a prepared statement from a connection, a SQL string and an&lt;br&gt;   optional list of parameters:&lt;br&gt;     :return-keys true | false - default false&lt;br&gt;     :result-type :forward-only | :scroll-insensitive | :scroll-sensitive&lt;br&gt;     :concurrency :read-only | :updatable&lt;br&gt;     :fetch-size n&lt;br&gt;     :max-rows n&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn prepare-statement&amp;lt;br&amp;gt;  &amp;quot;Create a prepared statement from a connection, a SQL string and an&amp;lt;br&amp;gt;   optional list of parameters:&amp;lt;br&amp;gt;     :return-keys true | false - default false&amp;lt;br&amp;gt;     :result-type :forward-only | :scroll-insensitive | :scroll-sensitive&amp;lt;br&amp;gt;     :concurrency :read-only | :updatable&amp;lt;br&amp;gt;     :fetch-size n&amp;lt;br&amp;gt;     :max-rows n&amp;quot;&amp;lt;br&amp;gt;  [^java.sql.Connection con ^String sql &amp;amp; {:keys [return-keys result-type concurrency cursors fetch-size max-rows]}]&amp;lt;br&amp;gt;  (let [^PreparedStatement stmt (cond&amp;lt;br&amp;gt;                                  return-keys (try&amp;lt;br&amp;gt;                                                (.prepareStatement con sql java.sql.Statement/RETURN_GENERATED_KEYS)&amp;lt;br&amp;gt;                                                (catch Exception _&amp;lt;br&amp;gt;                                                  ;; assume it is unsupported and try basic PreparedStatement:&amp;lt;br&amp;gt;                                                  (.prepareStatement con sql)))&amp;lt;br&amp;gt;                                  (and result-type concurrency) (if cursors&amp;lt;br&amp;gt;                                                                  (.prepareStatement con sql &amp;lt;br&amp;gt;                                                                                     (result-type result-set-type)&amp;lt;br&amp;gt;                                                                                     (concurrency result-set-concurrency)&amp;lt;br&amp;gt;                                                                                     (cursors result-set-holdability))&amp;lt;br&amp;gt;                                                                  (.prepareStatement con sql &amp;lt;br&amp;gt;                                                                                     (result-type result-set-type)&amp;lt;br&amp;gt;                                                                                     (concurrency result-set-concurrency)))&amp;lt;br&amp;gt;                                  :else (.prepareStatement con sql))]&amp;lt;br&amp;gt;    (when fetch-size (.setFetchSize stmt fetch-size))&amp;lt;br&amp;gt;    (when max-rows (.setMaxRows stmt max-rows))&amp;lt;br&amp;gt;    stmt))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">prepare-statement</a>[con sql & {:keys [return-keys result-type concurrency cursors fetch-size max-rows]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;print-sql-exception&lt;/b&gt; ([exception])&lt;br&gt; Prints the contents of an SQLException to *out*&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-sql-exception&amp;lt;br&amp;gt;  &amp;quot;Prints the contents of an SQLException to *out*&amp;quot;&amp;lt;br&amp;gt;  [^SQLException exception]&amp;lt;br&amp;gt;  (let [^Class exception-class (class exception)]&amp;lt;br&amp;gt;    (println&amp;lt;br&amp;gt;      (format (str &amp;quot;%s:&amp;quot; \newline&amp;lt;br&amp;gt;                   &amp;quot; Message: %s&amp;quot; \newline&amp;lt;br&amp;gt;                   &amp;quot; SQLState: %s&amp;quot; \newline&amp;lt;br&amp;gt;                   &amp;quot; Error Code: %d&amp;quot;)&amp;lt;br&amp;gt;              (.getSimpleName exception-class)&amp;lt;br&amp;gt;              (.getMessage exception)&amp;lt;br&amp;gt;              (.getSQLState exception)&amp;lt;br&amp;gt;              (.getErrorCode exception)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-sql-exception</a>[exception]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;print-sql-exception-chain&lt;/b&gt; ([exception])&lt;br&gt; Prints a chain of SQLExceptions to *out*&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-sql-exception-chain&amp;lt;br&amp;gt;  &amp;quot;Prints a chain of SQLExceptions to *out*&amp;quot;&amp;lt;br&amp;gt;  [^SQLException exception]&amp;lt;br&amp;gt;  (loop [e exception]&amp;lt;br&amp;gt;    (when e&amp;lt;br&amp;gt;      (print-sql-exception e)&amp;lt;br&amp;gt;      (recur (.getNextException e)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-sql-exception-chain</a>[exception]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;print-update-counts&lt;/b&gt; ([exception])&lt;br&gt; Prints the update counts from a BatchUpdateException to *out*&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-update-counts&amp;lt;br&amp;gt;  &amp;quot;Prints the update counts from a BatchUpdateException to *out*&amp;quot;&amp;lt;br&amp;gt;  [^BatchUpdateException exception]&amp;lt;br&amp;gt;  (println &amp;quot;Update counts:&amp;quot;)&amp;lt;br&amp;gt;  (dorun &amp;lt;br&amp;gt;    (map-indexed &amp;lt;br&amp;gt;      (fn [index count] &amp;lt;br&amp;gt;        (println (format &amp;quot; Statement %d: %s&amp;quot;&amp;lt;br&amp;gt;                         index&amp;lt;br&amp;gt;                         (get special-counts count count)))) &amp;lt;br&amp;gt;      (.getUpdateCounts exception))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-update-counts</a>[exception]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;resultset-seq&lt;/b&gt; ([rs])&lt;br&gt; Creates and returns a lazy sequence of maps corresponding to&lt;br&gt;   the rows in the java.sql.ResultSet rs. Based on clojure.core/resultset-seq&lt;br&gt;   but it respects the current naming strategy. Duplicate column names are&lt;br&gt;   made unique by appending _N before applying the naming strategy (where&lt;br&gt;   N is a unique integer).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resultset-seq&amp;lt;br&amp;gt;  &amp;quot;Creates and returns a lazy sequence of maps corresponding to&amp;lt;br&amp;gt;   the rows in the java.sql.ResultSet rs. Based on clojure.core/resultset-seq&amp;lt;br&amp;gt;   but it respects the current naming strategy. Duplicate column names are&amp;lt;br&amp;gt;   made unique by appending _N before applying the naming strategy (where&amp;lt;br&amp;gt;   N is a unique integer).&amp;quot;&amp;lt;br&amp;gt;  [^ResultSet rs]&amp;lt;br&amp;gt;    (let [rsmeta (.getMetaData rs)&amp;lt;br&amp;gt;          idxs (range 1 (inc (.getColumnCount rsmeta)))&amp;lt;br&amp;gt;          keys (-&amp;gt;&amp;gt; idxs&amp;lt;br&amp;gt;                 (map (fn [^Integer i] (.getColumnLabel rsmeta i)))&amp;lt;br&amp;gt;                 make-cols-unique&amp;lt;br&amp;gt;                 (map (comp keyword *as-key*)))&amp;lt;br&amp;gt;          row-values (fn [] (map (fn [^Integer i] (.getObject rs i)) idxs))&amp;lt;br&amp;gt;          ;; This used to use create-struct (on keys) and then struct to populate each row.&amp;lt;br&amp;gt;          ;; That had the side effect of preserving the order of columns in each row. As&amp;lt;br&amp;gt;          ;; part of JDBC-15, this was changed because structmaps are deprecated. We don't&amp;lt;br&amp;gt;          ;; want to switch to records so we're using regular maps instead. We no longer&amp;lt;br&amp;gt;          ;; guarantee column order in rows but using into {} should preserve order for up&amp;lt;br&amp;gt;          ;; to 16 columns (because it will use a PersistentArrayMap). If someone is relying&amp;lt;br&amp;gt;          ;; on the order-preserving behavior of structmaps, we can reconsider...&amp;lt;br&amp;gt;          rows (fn thisfn []&amp;lt;br&amp;gt;                 (when (.next rs)&amp;lt;br&amp;gt;                   (cons (zipmap keys (row-values)) (lazy-seq (thisfn)))))]&amp;lt;br&amp;gt;      (rows)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resultset-seq</a>[rs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;set-rollback-only&lt;/b&gt; ([])&lt;br&gt; Marks the outermost transaction such that it will rollback rather than&lt;br&gt;  commit when complete&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-rollback-only&amp;lt;br&amp;gt;  &amp;quot;Marks the outermost transaction such that it will rollback rather than&amp;lt;br&amp;gt;  commit when complete&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (rollback true))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-rollback-only</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;transaction&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates body as a transaction on the open database connection. Any&lt;br&gt;  nested transactions are absorbed into the outermost transaction. By&lt;br&gt;  default, all database updates are committed together as a group after&lt;br&gt;  evaluating the outermost body, or rolled back on any uncaught&lt;br&gt;  exception. If set-rollback-only is called within scope of the outermost&lt;br&gt;  transaction, the entire transaction will be rolled back rather than&lt;br&gt;  committed when complete.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro transaction&amp;lt;br&amp;gt;  &amp;quot;Evaluates body as a transaction on the open database connection. Any&amp;lt;br&amp;gt;  nested transactions are absorbed into the outermost transaction. By&amp;lt;br&amp;gt;  default, all database updates are committed together as a group after&amp;lt;br&amp;gt;  evaluating the outermost body, or rolled back on any uncaught&amp;lt;br&amp;gt;  exception. If set-rollback-only is called within scope of the outermost&amp;lt;br&amp;gt;  transaction, the entire transaction will be rolled back rather than&amp;lt;br&amp;gt;  committed when complete.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;  `(transaction* (fn [] ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">transaction</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;transaction*&lt;/b&gt; ([func])&lt;br&gt; Evaluates func as a transaction on the open database connection. Any&lt;br&gt;  nested transactions are absorbed into the outermost transaction. By&lt;br&gt;  default, all database updates are committed together as a group after&lt;br&gt;  evaluating the outermost body, or rolled back on any uncaught&lt;br&gt;  exception. If rollback is set within scope of the outermost transaction,&lt;br&gt;  the entire transaction will be rolled back rather than committed when&lt;br&gt;  complete.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn transaction*&amp;lt;br&amp;gt;  &amp;quot;Evaluates func as a transaction on the open database connection. Any&amp;lt;br&amp;gt;  nested transactions are absorbed into the outermost transaction. By&amp;lt;br&amp;gt;  default, all database updates are committed together as a group after&amp;lt;br&amp;gt;  evaluating the outermost body, or rolled back on any uncaught&amp;lt;br&amp;gt;  exception. If rollback is set within scope of the outermost transaction,&amp;lt;br&amp;gt;  the entire transaction will be rolled back rather than committed when&amp;lt;br&amp;gt;  complete.&amp;quot;&amp;lt;br&amp;gt;  [func]&amp;lt;br&amp;gt;  (binding [*db* (update-in *db* [:level] inc)]&amp;lt;br&amp;gt;    ;; This ugliness makes it easier to catch SQLException objects&amp;lt;br&amp;gt;    ;; rather than something wrapped in a RuntimeException which&amp;lt;br&amp;gt;    ;; can really obscure your code when working with JDBC from&amp;lt;br&amp;gt;    ;; Clojure... :(&amp;lt;br&amp;gt;    (letfn [(throw-non-rte [^Throwable ex]&amp;lt;br&amp;gt;              (cond (instance? java.sql.SQLException ex) (throw ex)&amp;lt;br&amp;gt;                    (and (instance? RuntimeException ex) (.getCause ex)) (throw-non-rte (.getCause ex))&amp;lt;br&amp;gt;                    :else (throw ex)))]&amp;lt;br&amp;gt;      (if (= (:level *db*) 1)&amp;lt;br&amp;gt;        (let [^java.sql.Connection con (connection)&amp;lt;br&amp;gt;              auto-commit (.getAutoCommit con)]&amp;lt;br&amp;gt;          (io!&amp;lt;br&amp;gt;           (.setAutoCommit con false)&amp;lt;br&amp;gt;           (try&amp;lt;br&amp;gt;             (let [result (func)]&amp;lt;br&amp;gt;               (if (rollback)&amp;lt;br&amp;gt;                 (.rollback con)&amp;lt;br&amp;gt;                 (.commit con))&amp;lt;br&amp;gt;               result)&amp;lt;br&amp;gt;             (catch Exception e&amp;lt;br&amp;gt;               (.rollback con)&amp;lt;br&amp;gt;               (throw-non-rte e))&amp;lt;br&amp;gt;             (finally&amp;lt;br&amp;gt;              (rollback false)&amp;lt;br&amp;gt;              (.setAutoCommit con auto-commit)))))&amp;lt;br&amp;gt;        (try&amp;lt;br&amp;gt;          (func)&amp;lt;br&amp;gt;          (catch Exception e&amp;lt;br&amp;gt;            (throw-non-rte e)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">transaction*</a>[func]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;update-or-insert-values&lt;/b&gt; ([table where-params record])&lt;br&gt; Updates values on selected rows in a table, or inserts a new row when no&lt;br&gt;  existing row matches the selection criteria. where-params is a vector&lt;br&gt;  containing a string providing the (optionally parameterized) selection&lt;br&gt;  criteria followed by values for any parameters. record is a map from&lt;br&gt;  strings or keywords (identifying columns) to updated values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn update-or-insert-values&amp;lt;br&amp;gt;  &amp;quot;Updates values on selected rows in a table, or inserts a new row when no&amp;lt;br&amp;gt;  existing row matches the selection criteria. where-params is a vector&amp;lt;br&amp;gt;  containing a string providing the (optionally parameterized) selection&amp;lt;br&amp;gt;  criteria followed by values for any parameters. record is a map from&amp;lt;br&amp;gt;  strings or keywords (identifying columns) to updated values.&amp;quot;&amp;lt;br&amp;gt;  [table where-params record]&amp;lt;br&amp;gt;  (transaction&amp;lt;br&amp;gt;   (let [result (update-values table where-params record)]&amp;lt;br&amp;gt;     (if (zero? (first result))&amp;lt;br&amp;gt;       (insert-values table (keys record) (vals record))&amp;lt;br&amp;gt;       result))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">update-or-insert-values</a>[table where-params record]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;update-values&lt;/b&gt; ([table where-params record])&lt;br&gt; Updates values on selected rows in a table. where-params is a vector&lt;br&gt;  containing a string providing the (optionally parameterized) selection&lt;br&gt;  criteria followed by values for any parameters. record is a map from&lt;br&gt;  strings or keywords (identifying columns) to updated values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn update-values&amp;lt;br&amp;gt;  &amp;quot;Updates values on selected rows in a table. where-params is a vector&amp;lt;br&amp;gt;  containing a string providing the (optionally parameterized) selection&amp;lt;br&amp;gt;  criteria followed by values for any parameters. record is a map from&amp;lt;br&amp;gt;  strings or keywords (identifying columns) to updated values.&amp;quot;&amp;lt;br&amp;gt;  [table where-params record]&amp;lt;br&amp;gt;  (let [[where &amp;amp; params] where-params&amp;lt;br&amp;gt;        column-strs (map as-identifier (keys record))&amp;lt;br&amp;gt;        columns (apply str (concat (interpose &amp;quot;=?, &amp;quot; column-strs) &amp;quot;=?&amp;quot;))]&amp;lt;br&amp;gt;    (do-prepared&amp;lt;br&amp;gt;      (format &amp;quot;UPDATE %s SET %s WHERE %s&amp;quot;&amp;lt;br&amp;gt;              (as-identifier table) columns where)&amp;lt;br&amp;gt;      (concat (vals record) params))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">update-values</a>[table where-params record]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;with-connection&lt;/b&gt; ([db-spec &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates body in the context of a new connection to a database then&lt;br&gt;  closes the connection. db-spec is a map containing values for one of the&lt;br&gt;  following parameter sets:&lt;br&gt;&lt;br&gt;  Factory:&lt;br&gt;    :factory     (required) a function of one argument, a map of params&lt;br&gt;    (others)     (optional) passed to the factory function in a map&lt;br&gt;&lt;br&gt;  DriverManager:&lt;br&gt;    :subprotocol (required) a String, the jdbc subprotocol&lt;br&gt;    :subname     (required) a String, the jdbc subname&lt;br&gt;    :classname   (optional) a String, the jdbc driver class name&lt;br&gt;    (others)     (optional) passed to the driver as properties.&lt;br&gt;&lt;br&gt;  DataSource:&lt;br&gt;    :datasource  (required) a javax.sql.DataSource&lt;br&gt;    :username    (optional) a String&lt;br&gt;    :password    (optional) a String, required if :username is supplied&lt;br&gt;&lt;br&gt;  JNDI:&lt;br&gt;    :name        (required) a String or javax.naming.Name&lt;br&gt;    :environment (optional) a java.util.Map&lt;br&gt;&lt;br&gt;  Raw:&lt;br&gt;    :connection-uri (required) a String&lt;br&gt;                 Passed directly to DriverManager/getConnection&lt;br&gt;&lt;br&gt;  URI:&lt;br&gt;    Parsed JDBC connection string - see below&lt;br&gt;  &lt;br&gt;  String:&lt;br&gt;    subprotocol://user:password@host:post/subname&lt;br&gt;                 An optional prefix of jdbc: is allowed.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-connection&amp;lt;br&amp;gt;  &amp;quot;Evaluates body in the context of a new connection to a database then&amp;lt;br&amp;gt;  closes the connection. db-spec is a map containing values for one of the&amp;lt;br&amp;gt;  following parameter sets:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Factory:&amp;lt;br&amp;gt;    :factory     (required) a function of one argument, a map of params&amp;lt;br&amp;gt;    (others)     (optional) passed to the factory function in a map&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  DriverManager:&amp;lt;br&amp;gt;    :subprotocol (required) a String, the jdbc subprotocol&amp;lt;br&amp;gt;    :subname     (required) a String, the jdbc subname&amp;lt;br&amp;gt;    :classname   (optional) a String, the jdbc driver class name&amp;lt;br&amp;gt;    (others)     (optional) passed to the driver as properties.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  DataSource:&amp;lt;br&amp;gt;    :datasource  (required) a javax.sql.DataSource&amp;lt;br&amp;gt;    :username    (optional) a String&amp;lt;br&amp;gt;    :password    (optional) a String, required if :username is supplied&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  JNDI:&amp;lt;br&amp;gt;    :name        (required) a String or javax.naming.Name&amp;lt;br&amp;gt;    :environment (optional) a java.util.Map&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Raw:&amp;lt;br&amp;gt;    :connection-uri (required) a String&amp;lt;br&amp;gt;                 Passed directly to DriverManager/getConnection&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  URI:&amp;lt;br&amp;gt;    Parsed JDBC connection string - see below&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  String:&amp;lt;br&amp;gt;    subprotocol://user:password@host:post/subname&amp;lt;br&amp;gt;                 An optional prefix of jdbc: is allowed.&amp;quot;&amp;lt;br&amp;gt;  [db-spec &amp;amp; body]&amp;lt;br&amp;gt;  `(with-connection* ~db-spec (fn [] ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-connection</a>[db-spec & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;with-connection*&lt;/b&gt; ([db-spec func])&lt;br&gt; Evaluates func in the context of a new connection to a database then&lt;br&gt;  closes the connection.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn with-connection*&amp;lt;br&amp;gt;  &amp;quot;Evaluates func in the context of a new connection to a database then&amp;lt;br&amp;gt;  closes the connection.&amp;quot;&amp;lt;br&amp;gt;  [db-spec func]&amp;lt;br&amp;gt;  (with-open [^java.sql.Connection con (get-connection db-spec)]&amp;lt;br&amp;gt;    (binding [*db* (assoc *db* :connection con :level 0 :rollback (atom false))]&amp;lt;br&amp;gt;      (func))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-connection*</a>[db-spec func]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;with-naming-strategy&lt;/b&gt; ([naming-strategy &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates body in the context of a naming strategy.&lt;br&gt;   The naming strategy is either a function - the entity naming strategy - or&lt;br&gt;   a map containing :entity and/or :keyword keys which provide the entity naming&lt;br&gt;   strategy and/or the keyword naming strategy respectively. The default entity&lt;br&gt;   naming strategy is identity; the default keyword naming strategy is lower-case.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-naming-strategy&amp;lt;br&amp;gt;  &amp;quot;Evaluates body in the context of a naming strategy.&amp;lt;br&amp;gt;   The naming strategy is either a function - the entity naming strategy - or&amp;lt;br&amp;gt;   a map containing :entity and/or :keyword keys which provide the entity naming&amp;lt;br&amp;gt;   strategy and/or the keyword naming strategy respectively. The default entity&amp;lt;br&amp;gt;   naming strategy is identity; the default keyword naming strategy is lower-case.&amp;quot;&amp;lt;br&amp;gt;  [naming-strategy &amp;amp; body ]&amp;lt;br&amp;gt;  `(binding [*as-str* (if (map? ~naming-strategy) (or (:entity ~naming-strategy) identity) ~naming-strategy)&amp;lt;br&amp;gt;             *as-key* (if (map? ~naming-strategy) (or (:keyword ~naming-strategy) str/lower-case))] ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-naming-strategy</a>[naming-strategy & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;with-query-results&lt;/b&gt; ([results sql-params &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Executes a query, then evaluates body with results bound to a seq of the&lt;br&gt;  results. sql-params is a vector containing either:&lt;br&gt;    [sql &amp; params] - a SQL query, followed by any parameters it needs&lt;br&gt;    [stmt &amp; params] - a PreparedStatement, followed by any parameters it needs&lt;br&gt;                      (the PreparedStatement already contains the SQL query)&lt;br&gt;    [options sql &amp; params] - options and a SQL query for creating a&lt;br&gt;                      PreparedStatement, follwed by any parameters it needs&lt;br&gt;  See prepare-statement for supported options.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-query-results&amp;lt;br&amp;gt;  &amp;quot;Executes a query, then evaluates body with results bound to a seq of the&amp;lt;br&amp;gt;  results. sql-params is a vector containing either:&amp;lt;br&amp;gt;    [sql &amp;amp; params] - a SQL query, followed by any parameters it needs&amp;lt;br&amp;gt;    [stmt &amp;amp; params] - a PreparedStatement, followed by any parameters it needs&amp;lt;br&amp;gt;                      (the PreparedStatement already contains the SQL query)&amp;lt;br&amp;gt;    [options sql &amp;amp; params] - options and a SQL query for creating a&amp;lt;br&amp;gt;                      PreparedStatement, follwed by any parameters it needs&amp;lt;br&amp;gt;  See prepare-statement for supported options.&amp;quot;&amp;lt;br&amp;gt;  [results sql-params &amp;amp; body]&amp;lt;br&amp;gt;  `(with-query-results* ~sql-params (fn [~results] ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-query-results</a>[results sql-params & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;with-query-results*&lt;/b&gt; ([sql-params func])&lt;br&gt; Executes a query, then evaluates func passing in a seq of the results as&lt;br&gt;  an argument. The first argument is a vector containing either:&lt;br&gt;    [sql &amp; params] - a SQL query, followed by any parameters it needs&lt;br&gt;    [stmt &amp; params] - a PreparedStatement, followed by any parameters it needs&lt;br&gt;                      (the PreparedStatement already contains the SQL query)&lt;br&gt;    [options sql &amp; params] - options and a SQL query for creating a&lt;br&gt;                      PreparedStatement, follwed by any parameters it needs&lt;br&gt;  See prepare-statement for supported options.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn with-query-results*&amp;lt;br&amp;gt;  &amp;quot;Executes a query, then evaluates func passing in a seq of the results as&amp;lt;br&amp;gt;  an argument. The first argument is a vector containing either:&amp;lt;br&amp;gt;    [sql &amp;amp; params] - a SQL query, followed by any parameters it needs&amp;lt;br&amp;gt;    [stmt &amp;amp; params] - a PreparedStatement, followed by any parameters it needs&amp;lt;br&amp;gt;                      (the PreparedStatement already contains the SQL query)&amp;lt;br&amp;gt;    [options sql &amp;amp; params] - options and a SQL query for creating a&amp;lt;br&amp;gt;                      PreparedStatement, follwed by any parameters it needs&amp;lt;br&amp;gt;  See prepare-statement for supported options.&amp;quot;&amp;lt;br&amp;gt;  [sql-params func]&amp;lt;br&amp;gt;  (when-not (vector? sql-params)&amp;lt;br&amp;gt;    (let [^Class sql-params-class (class sql-params)&amp;lt;br&amp;gt;          ^String msg (format &amp;quot;\&amp;quot;%s\&amp;quot; expected %s %s, found %s %s&amp;quot;&amp;lt;br&amp;gt;                              &amp;quot;sql-params&amp;quot;&amp;lt;br&amp;gt;                              &amp;quot;vector&amp;quot;&amp;lt;br&amp;gt;                              &amp;quot;[sql param*]&amp;quot;&amp;lt;br&amp;gt;                              (.getName sql-params-class)&amp;lt;br&amp;gt;                              (pr-str sql-params))] &amp;lt;br&amp;gt;      (throw (IllegalArgumentException. msg))))&amp;lt;br&amp;gt;  (let [special (first sql-params)&amp;lt;br&amp;gt;        sql-is-first (string? special)&amp;lt;br&amp;gt;        options-are-first (map? special)&amp;lt;br&amp;gt;        sql (cond sql-is-first special &amp;lt;br&amp;gt;                  options-are-first (second sql-params))&amp;lt;br&amp;gt;        params (vec (cond sql-is-first (rest sql-params)&amp;lt;br&amp;gt;                          options-are-first (rest (rest sql-params))&amp;lt;br&amp;gt;                          :else (rest sql-params)))&amp;lt;br&amp;gt;        prepare-args (when (map? special) (flatten (seq special)))]&amp;lt;br&amp;gt;    (with-open [^PreparedStatement stmt (if (instance? PreparedStatement special) special (apply prepare-statement (connection) sql prepare-args))]&amp;lt;br&amp;gt;      (set-parameters stmt params)&amp;lt;br&amp;gt;      (with-open [rset (.executeQuery stmt)]&amp;lt;br&amp;gt;        (func (resultset-seq rset))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-query-results*</a>[sql-params func]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jdbc&lt;/i&gt;&lt;b&gt;with-quoted-identifiers&lt;/b&gt; ([q &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates body in the context of a simple quoting naming strategy.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-quoted-identifiers&amp;lt;br&amp;gt;  &amp;quot;Evaluates body in the context of a simple quoting naming strategy.&amp;quot;&amp;lt;br&amp;gt;  [q &amp;amp; body ]&amp;lt;br&amp;gt;  `(binding [*as-str* (partial as-quoted-str ~q)] ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-quoted-identifiers</a>[q & body]</div></div></div><div class="row"><div class="namespace"><h4>clojure.java.jmx</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;-&gt;Bean&lt;/b&gt; ([state-ref])&lt;br&gt; Positional factory function for class clojure.java.jmx.Bean.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype Bean [state-ref]&amp;lt;br&amp;gt;  DynamicMBean&amp;lt;br&amp;gt;  (getMBeanInfo [_]&amp;lt;br&amp;gt;                (MBeanInfo. (.. _ getClass getName)                             ; class name&amp;lt;br&amp;gt;                            &amp;quot;Clojure Dynamic MBean&amp;quot;                             ; description&amp;lt;br&amp;gt;                            (map-&amp;gt;attribute-infos @state-ref)                   ; attributes&amp;lt;br&amp;gt;                            nil                                                 ; constructors&amp;lt;br&amp;gt;                            nil                                                 ; operations&amp;lt;br&amp;gt;                            nil))&amp;lt;br&amp;gt;  (getAttribute [_ attr]&amp;lt;br&amp;gt;                (@state-ref (keyword attr)))&amp;lt;br&amp;gt;  (getAttributes [_ attrs]&amp;lt;br&amp;gt;                 (let [result (AttributeList.)]&amp;lt;br&amp;gt;                   (doseq [attr attrs]&amp;lt;br&amp;gt;                     (.add result (.getAttribute _ attr)))&amp;lt;br&amp;gt;                   result)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Bean</a>[state-ref]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;as-object-name&lt;/b&gt; ([_])&lt;br&gt; &lt;/div&gt;" data-placement="right">as-object-name</a>[_]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;attribute-info&lt;/b&gt; ([object-name attr-name])&lt;br&gt; Get the MBeanAttributeInfo for an attribute.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn attribute-info&amp;lt;br&amp;gt;  &amp;quot;Get the MBeanAttributeInfo for an attribute.&amp;quot;&amp;lt;br&amp;gt;  [object-name attr-name]&amp;lt;br&amp;gt;  (filter #(= (name attr-name) (.getName %))&amp;lt;br&amp;gt;          (.getAttributes (mbean-info object-name))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">attribute-info</a>[object-name attr-name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;attribute-names&lt;/b&gt; ([n])&lt;br&gt; All attribute names available on an MBean.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn attribute-names&amp;lt;br&amp;gt;  &amp;quot;All attribute names available on an MBean.&amp;quot;&amp;lt;br&amp;gt;  [n]&amp;lt;br&amp;gt;  (doall (map #(-&amp;gt; % .getName keyword)&amp;lt;br&amp;gt;              (.getAttributes (mbean-info n)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">attribute-names</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;create-bean&lt;/b&gt; ([state-ref])&lt;br&gt; Expose a reference as a JMX bean. state-ref should be a Clojure&lt;br&gt;   reference (ref, atom, agent) containing a map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn create-bean&amp;lt;br&amp;gt;  &amp;quot;Expose a reference as a JMX bean. state-ref should be a Clojure&amp;lt;br&amp;gt;   reference (ref, atom, agent) containing a map.&amp;quot;&amp;lt;br&amp;gt;  [state-ref]&amp;lt;br&amp;gt;  (Bean. state-ref))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">create-bean</a>[state-ref]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;invoke&lt;/b&gt; ([n op &amp; args])&lt;br&gt; Invoke an operation an an MBean.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn invoke&amp;lt;br&amp;gt;  &amp;quot;Invoke an operation an an MBean.&amp;quot;&amp;lt;br&amp;gt;  [n op &amp;amp; args]&amp;lt;br&amp;gt;  (apply invoke-signature n op (op-param-types n op) args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">invoke</a>[n op & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;invoke-signature&lt;/b&gt; ([n op signature &amp; args])&lt;br&gt; Invoke an operation an an MBean. You must also supply&lt;br&gt;  the signature of the operation. This is useful in cases&lt;br&gt;  where the operation is overloaded. Otherwise you should&lt;br&gt;  use the 'invoke' operation which will determine the&lt;br&gt;  signature for you.&lt;br&gt;&lt;br&gt;  The signature parameter is a sequence of strings that&lt;br&gt;  describes the method parameter types in order.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn invoke-signature&amp;lt;br&amp;gt;  &amp;quot;Invoke an operation an an MBean. You must also supply&amp;lt;br&amp;gt;  the signature of the operation. This is useful in cases&amp;lt;br&amp;gt;  where the operation is overloaded. Otherwise you should&amp;lt;br&amp;gt;  use the 'invoke' operation which will determine the&amp;lt;br&amp;gt;  signature for you.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The signature parameter is a sequence of strings that&amp;lt;br&amp;gt;  describes the method parameter types in order.&amp;quot;&amp;lt;br&amp;gt;  [n op signature &amp;amp; args]&amp;lt;br&amp;gt;  (if ( seq args)&amp;lt;br&amp;gt;    (.invoke *connection* (as-object-name n) (name op)&amp;lt;br&amp;gt;             (into-array Object args)&amp;lt;br&amp;gt;             (into-array String signature))&amp;lt;br&amp;gt;    (.invoke *connection* (as-object-name n) (name op)&amp;lt;br&amp;gt;             nil nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">invoke-signature</a>[n op signature & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;jmx-url&lt;/b&gt; ([] [overrides])&lt;br&gt; Build a JMX URL from options.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn jmx-url&amp;lt;br&amp;gt;  &amp;quot;Build a JMX URL from options.&amp;quot;&amp;lt;br&amp;gt;  ([] (jmx-url {}))&amp;lt;br&amp;gt;  ([overrides]&amp;lt;br&amp;gt;     (let [opts (merge {:host &amp;quot;localhost&amp;quot;, :port &amp;quot;3000&amp;quot;, :jndi-path &amp;quot;jmxrmi&amp;quot;} overrides)]&amp;lt;br&amp;gt;       (format &amp;quot;service:jmx:rmi:///jndi/rmi://%s:%s/%s&amp;quot; (opts :host) (opts :port) (opts :jndi-path)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">jmx-url</a>[] [overrides]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;mbean&lt;/b&gt; ([n])&lt;br&gt; Like clojure.core/bean, but for JMX beans. Returns a read-only map of&lt;br&gt;   a JMX bean's attributes. If an attribute it not supported, value is&lt;br&gt;   set to the exception thrown.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mbean&amp;lt;br&amp;gt;  &amp;quot;Like clojure.core/bean, but for JMX beans. Returns a read-only map of&amp;lt;br&amp;gt;   a JMX bean's attributes. If an attribute it not supported, value is&amp;lt;br&amp;gt;   set to the exception thrown.&amp;quot;&amp;lt;br&amp;gt;  [n]&amp;lt;br&amp;gt;  (into {} (map (fn [attr-name] [(keyword attr-name) (read-supported n attr-name)])&amp;lt;br&amp;gt;                (attribute-names n))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mbean</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;mbean-info&lt;/b&gt; ([n])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mbean-info [n]&amp;lt;br&amp;gt;  (.getMBeanInfo *connection* (as-object-name n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mbean-info</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;mbean-names&lt;/b&gt; ([n])&lt;br&gt; Finds all MBeans matching a name on the current *connection*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mbean-names&amp;lt;br&amp;gt;  &amp;quot;Finds all MBeans matching a name on the current *connection*.&amp;quot;&amp;lt;br&amp;gt;   [n]&amp;lt;br&amp;gt;  (.queryNames *connection* (as-object-name n) nil))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mbean-names</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;objects-&gt;data&lt;/b&gt; ([_])&lt;br&gt; Convert JMX object model into data. Handles CompositeData, TabularData, maps, and atoms.&lt;/div&gt;" data-placement="right">objects->data</a>[_]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;operation-names&lt;/b&gt; ([n])&lt;br&gt; All operation names available on an MBean.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn operation-names&amp;lt;br&amp;gt;  &amp;quot;All operation names available on an MBean.&amp;quot;&amp;lt;br&amp;gt;  [n]&amp;lt;br&amp;gt;  (doall (map #(-&amp;gt; % .getName keyword) (operations n))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">operation-names</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;operations&lt;/b&gt; ([n])&lt;br&gt; All oeprations available on an MBean.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn operations&amp;lt;br&amp;gt;  &amp;quot;All oeprations available on an MBean.&amp;quot;&amp;lt;br&amp;gt;  [n]&amp;lt;br&amp;gt;  (.getOperations (mbean-info n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">operations</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;raw-read&lt;/b&gt; ([n attrs])&lt;br&gt; Read a list of mbean properties. Returns low-level Java object&lt;br&gt;   models for composites, tabulars, etc. Most callers should use&lt;br&gt;   read.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn raw-read&amp;lt;br&amp;gt;  &amp;quot;Read a list of mbean properties. Returns low-level Java object&amp;lt;br&amp;gt;   models for composites, tabulars, etc. Most callers should use&amp;lt;br&amp;gt;   read.&amp;quot;&amp;lt;br&amp;gt;  [n attrs]&amp;lt;br&amp;gt;  (if (sequential? attrs)&amp;lt;br&amp;gt;    (into {}&amp;lt;br&amp;gt;          (map (fn [attr] [(keyword (.getName attr)) (.getValue attr)])&amp;lt;br&amp;gt;               (.getAttributes *connection*&amp;lt;br&amp;gt;                               (as-object-name n)&amp;lt;br&amp;gt;                               (into-array (map name attrs)))))&amp;lt;br&amp;gt;    (.getAttribute *connection* (as-object-name n) (name attrs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">raw-read</a>[n attrs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;readable?&lt;/b&gt; ([n attr])&lt;br&gt; Is attribute readable?&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn readable?&amp;lt;br&amp;gt;  &amp;quot;Is attribute readable?&amp;quot;&amp;lt;br&amp;gt;  [n attr]&amp;lt;br&amp;gt;  (.isReadable (mbean-info n)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">readable?</a>[n attr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;register-mbean&lt;/b&gt; ([mbean mbean-name])&lt;br&gt; Register an mbean with the current *connection*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn register-mbean&amp;lt;br&amp;gt;  &amp;quot;Register an mbean with the current *connection*.&amp;quot;&amp;lt;br&amp;gt;  [mbean mbean-name]&amp;lt;br&amp;gt;  (.registerMBean *connection* mbean (as-object-name mbean-name)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">register-mbean</a>[mbean mbean-name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;with-connection&lt;/b&gt; ([opts &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Execute body with JMX connection specified by opts. opts can also&lt;br&gt;   include an optional :environment key which is passed as the&lt;br&gt;   environment arg to JMXConnectorFactory/connect.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-connection&amp;lt;br&amp;gt;  &amp;quot;Execute body with JMX connection specified by opts. opts can also&amp;lt;br&amp;gt;   include an optional :environment key which is passed as the&amp;lt;br&amp;gt;   environment arg to JMXConnectorFactory/connect.&amp;quot;&amp;lt;br&amp;gt;  [opts &amp;amp; body]&amp;lt;br&amp;gt;  `(let [opts# ~opts&amp;lt;br&amp;gt;         env# (get opts# :environment {})&amp;lt;br&amp;gt;         opts# (dissoc opts# :environment)]&amp;lt;br&amp;gt;     (with-open [connector# (javax.management.remote.JMXConnectorFactory/connect&amp;lt;br&amp;gt;                             (JMXServiceURL. (jmx-url opts#)) env#)]&amp;lt;br&amp;gt;       (binding [*connection* (.getMBeanServerConnection connector#)]&amp;lt;br&amp;gt;         ~@body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-connection</a>[opts & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.jmx&lt;/i&gt;&lt;b&gt;write!&lt;/b&gt; ([n attr value])&lt;br&gt; Write an attribute value.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn write!&amp;lt;br&amp;gt;  &amp;quot;Write an attribute value.&amp;quot;&amp;lt;br&amp;gt;  [n attr value]&amp;lt;br&amp;gt;  (.setAttribute&amp;lt;br&amp;gt;   *connection*&amp;lt;br&amp;gt;   (as-object-name n)&amp;lt;br&amp;gt;   (Attribute. (name attr) value)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">write!</a>[n attr value]</div></div></div><div class="row"><div class="namespace"><h4>clojure.java.shell</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.shell&lt;/i&gt;&lt;b&gt;sh&lt;/b&gt; ([&amp; args])&lt;br&gt; Passes the given strings to Runtime.exec() to launch a sub-process.&lt;br&gt;&lt;br&gt;  Options are&lt;br&gt;&lt;br&gt;  :in      may be given followed by any legal input source for&lt;br&gt;           clojure.java.io/copy, e.g. InputStream, Reader, File, byte[],&lt;br&gt;           or String, to be fed to the sub-process's stdin.&lt;br&gt;  :in-enc  option may be given followed by a String, used as a character&lt;br&gt;           encoding name (for example &quot;UTF-8&quot; or &quot;ISO-8859-1&quot;) to&lt;br&gt;           convert the input string specified by the :in option to the&lt;br&gt;           sub-process's stdin.  Defaults to UTF-8.&lt;br&gt;           If the :in option provides a byte array, then the bytes are passed&lt;br&gt;           unencoded, and this option is ignored.&lt;br&gt;  :out-enc option may be given followed by :bytes or a String. If a&lt;br&gt;           String is given, it will be used as a character encoding&lt;br&gt;           name (for example &quot;UTF-8&quot; or &quot;ISO-8859-1&quot;) to convert&lt;br&gt;           the sub-process's stdout to a String which is returned.&lt;br&gt;           If :bytes is given, the sub-process's stdout will be stored&lt;br&gt;           in a byte array and returned.  Defaults to UTF-8.&lt;br&gt;  :env     override the process env with a map (or the underlying Java&lt;br&gt;           String[] if you are a masochist).&lt;br&gt;  :dir     override the process dir with a String or java.io.File.&lt;br&gt;&lt;br&gt;  You can bind :env or :dir for multiple operations using with-sh-env&lt;br&gt;  and with-sh-dir.&lt;br&gt;&lt;br&gt;  sh returns a map of&lt;br&gt;    :exit =&gt; sub-process's exit code&lt;br&gt;    :out  =&gt; sub-process's stdout (as byte[] or String)&lt;br&gt;    :err  =&gt; sub-process's stderr (String via platform default encoding)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn sh&amp;lt;br&amp;gt;  &amp;quot;Passes the given strings to Runtime.exec() to launch a sub-process.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Options are&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :in      may be given followed by any legal input source for&amp;lt;br&amp;gt;           clojure.java.io/copy, e.g. InputStream, Reader, File, byte[],&amp;lt;br&amp;gt;           or String, to be fed to the sub-process's stdin.&amp;lt;br&amp;gt;  :in-enc  option may be given followed by a String, used as a character&amp;lt;br&amp;gt;           encoding name (for example \&amp;quot;UTF-8\&amp;quot; or \&amp;quot;ISO-8859-1\&amp;quot;) to&amp;lt;br&amp;gt;           convert the input string specified by the :in option to the&amp;lt;br&amp;gt;           sub-process's stdin.  Defaults to UTF-8.&amp;lt;br&amp;gt;           If the :in option provides a byte array, then the bytes are passed&amp;lt;br&amp;gt;           unencoded, and this option is ignored.&amp;lt;br&amp;gt;  :out-enc option may be given followed by :bytes or a String. If a&amp;lt;br&amp;gt;           String is given, it will be used as a character encoding&amp;lt;br&amp;gt;           name (for example \&amp;quot;UTF-8\&amp;quot; or \&amp;quot;ISO-8859-1\&amp;quot;) to convert&amp;lt;br&amp;gt;           the sub-process's stdout to a String which is returned.&amp;lt;br&amp;gt;           If :bytes is given, the sub-process's stdout will be stored&amp;lt;br&amp;gt;           in a byte array and returned.  Defaults to UTF-8.&amp;lt;br&amp;gt;  :env     override the process env with a map (or the underlying Java&amp;lt;br&amp;gt;           String[] if you are a masochist).&amp;lt;br&amp;gt;  :dir     override the process dir with a String or java.io.File.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  You can bind :env or :dir for multiple operations using with-sh-env&amp;lt;br&amp;gt;  and with-sh-dir.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  sh returns a map of&amp;lt;br&amp;gt;    :exit =&amp;gt; sub-process's exit code&amp;lt;br&amp;gt;    :out  =&amp;gt; sub-process's stdout (as byte[] or String)&amp;lt;br&amp;gt;    :err  =&amp;gt; sub-process's stderr (String via platform default encoding)&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  (let [[cmd opts] (parse-args args)&amp;lt;br&amp;gt;        proc (.exec (Runtime/getRuntime) &amp;lt;br&amp;gt;               ^&amp;quot;[Ljava.lang.String;&amp;quot; (into-array cmd)&amp;lt;br&amp;gt;               (as-env-strings (:env opts))&amp;lt;br&amp;gt;               (as-file (:dir opts)))&amp;lt;br&amp;gt;        {:keys [in in-enc out-enc]} opts]&amp;lt;br&amp;gt;    (if in&amp;lt;br&amp;gt;      (future&amp;lt;br&amp;gt;        (with-open [os (.getOutputStream proc)]&amp;lt;br&amp;gt;          (copy in os :encoding in-enc)))&amp;lt;br&amp;gt;      (.close (.getOutputStream proc)))&amp;lt;br&amp;gt;    (with-open [stdout (.getInputStream proc)&amp;lt;br&amp;gt;                stderr (.getErrorStream proc)]&amp;lt;br&amp;gt;      (let [out (future (stream-to-enc stdout out-enc))&amp;lt;br&amp;gt;            err (future (stream-to-string stderr))&amp;lt;br&amp;gt;            exit-code (.waitFor proc)]&amp;lt;br&amp;gt;        {:exit exit-code :out @out :err @err}))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">sh</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.shell&lt;/i&gt;&lt;b&gt;with-sh-dir&lt;/b&gt; ([dir &amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Sets the directory for use with sh, see sh for details.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-sh-dir&amp;lt;br&amp;gt;  &amp;quot;Sets the directory for use with sh, see sh for details.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [dir &amp;amp; forms]&amp;lt;br&amp;gt;  `(binding [*sh-dir* ~dir]&amp;lt;br&amp;gt;     ~@forms))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-sh-dir</a>[dir & forms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.java.shell&lt;/i&gt;&lt;b&gt;with-sh-env&lt;/b&gt; ([env &amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Sets the environment for use with sh, see sh for details.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-sh-env&amp;lt;br&amp;gt;  &amp;quot;Sets the environment for use with sh, see sh for details.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [env &amp;amp; forms]&amp;lt;br&amp;gt;  `(binding [*sh-env* ~env]&amp;lt;br&amp;gt;     ~@forms))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-sh-env</a>[env & forms]</div></div></div><div class="row"><div class="namespace"><h4>clojure.main</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;demunge&lt;/b&gt; ([fn-name])&lt;br&gt; Given a string representation of a fn class,&lt;br&gt;  as in a stack trace element, returns a readable version.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn demunge&amp;lt;br&amp;gt;  &amp;quot;Given a string representation of a fn class,&amp;lt;br&amp;gt;  as in a stack trace element, returns a readable version.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [fn-name]&amp;lt;br&amp;gt;  (re-replace demunge-pattern fn-name demunge-map))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">demunge</a>[fn-name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;load-script&lt;/b&gt; ([path])&lt;br&gt; Loads Clojure source from a file or resource given its path. Paths&lt;br&gt;  beginning with @ or @/ are considered relative to classpath.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn load-script&amp;lt;br&amp;gt;  &amp;quot;Loads Clojure source from a file or resource given its path. Paths&amp;lt;br&amp;gt;  beginning with @ or @/ are considered relative to classpath.&amp;quot;&amp;lt;br&amp;gt;  [^String path]&amp;lt;br&amp;gt;  (if (.startsWith path &amp;quot;@&amp;quot;)&amp;lt;br&amp;gt;    (RT/loadResourceScript&amp;lt;br&amp;gt;     (.substring path (if (.startsWith path &amp;quot;@/&amp;quot;) 2 1)))&amp;lt;br&amp;gt;    (Compiler/loadFile path)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">load-script</a>[path]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;main&lt;/b&gt; ([&amp; args])&lt;br&gt; Usage: java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]&lt;br&gt;&lt;br&gt;  With no options or args, runs an interactive Read-Eval-Print Loop&lt;br&gt;&lt;br&gt;  init options:&lt;br&gt;    -i, --init path     Load a file or resource&lt;br&gt;    -e, --eval string   Evaluate expressions in string; print non-nil values&lt;br&gt;&lt;br&gt;  main options:&lt;br&gt;    -m, --main ns-name  Call the -main function from a namespace with args&lt;br&gt;    -r, --repl          Run a repl&lt;br&gt;    path                Run a script from from a file or resource&lt;br&gt;    -                   Run a script from standard input&lt;br&gt;    -h, -?, --help      Print this help message and exit&lt;br&gt;&lt;br&gt;  operation:&lt;br&gt;&lt;br&gt;    - Establishes thread-local bindings for commonly set!-able vars&lt;br&gt;    - Enters the user namespace&lt;br&gt;    - Binds *command-line-args* to a seq of strings containing command line&lt;br&gt;      args that appear after any main option&lt;br&gt;    - Runs all init options in order&lt;br&gt;    - Calls a -main function or runs a repl or script if requested&lt;br&gt;&lt;br&gt;  The init options may be repeated and mixed freely, but must appear before&lt;br&gt;  any main option. The appearance of any eval option before running a repl&lt;br&gt;  suppresses the usual repl greeting message: &quot;Clojure ~(clojure-version)&quot;.&lt;br&gt;&lt;br&gt;  Paths may be absolute or relative in the filesystem or relative to&lt;br&gt;  classpath. Classpath-relative paths have prefix of @ or @/&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn main&amp;lt;br&amp;gt;  &amp;quot;Usage: java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  With no options or args, runs an interactive Read-Eval-Print Loop&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  init options:&amp;lt;br&amp;gt;    -i, --init path     Load a file or resource&amp;lt;br&amp;gt;    -e, --eval string   Evaluate expressions in string; print non-nil values&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  main options:&amp;lt;br&amp;gt;    -m, --main ns-name  Call the -main function from a namespace with args&amp;lt;br&amp;gt;    -r, --repl          Run a repl&amp;lt;br&amp;gt;    path                Run a script from from a file or resource&amp;lt;br&amp;gt;    -                   Run a script from standard input&amp;lt;br&amp;gt;    -h, -?, --help      Print this help message and exit&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  operation:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    - Establishes thread-local bindings for commonly set!-able vars&amp;lt;br&amp;gt;    - Enters the user namespace&amp;lt;br&amp;gt;    - Binds *command-line-args* to a seq of strings containing command line&amp;lt;br&amp;gt;      args that appear after any main option&amp;lt;br&amp;gt;    - Runs all init options in order&amp;lt;br&amp;gt;    - Calls a -main function or runs a repl or script if requested&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The init options may be repeated and mixed freely, but must appear before&amp;lt;br&amp;gt;  any main option. The appearance of any eval option before running a repl&amp;lt;br&amp;gt;  suppresses the usual repl greeting message: \&amp;quot;Clojure ~(clojure-version)\&amp;quot;.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Paths may be absolute or relative in the filesystem or relative to&amp;lt;br&amp;gt;  classpath. Classpath-relative paths have prefix of @ or @/&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;   (if args&amp;lt;br&amp;gt;     (loop [[opt arg &amp;amp; more :as args] args inits []]&amp;lt;br&amp;gt;       (if (init-dispatch opt)&amp;lt;br&amp;gt;         (recur more (conj inits [opt arg]))&amp;lt;br&amp;gt;         ((main-dispatch opt) args inits)))&amp;lt;br&amp;gt;     (repl-opt nil nil))&amp;lt;br&amp;gt;   (finally &amp;lt;br&amp;gt;     (flush))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">main</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;repl&lt;/b&gt; ([&amp; options])&lt;br&gt; Generic, reusable, read-eval-print loop. By default, reads from *in*,&lt;br&gt;  writes to *out*, and prints exception summaries to *err*. If you use the&lt;br&gt;  default :read hook, *in* must either be an instance of&lt;br&gt;  LineNumberingPushbackReader or duplicate its behavior of both supporting&lt;br&gt;  .unread and collapsing CR, LF, and CRLF into a single \newline. Options&lt;br&gt;  are sequential keyword-value pairs. Available options and their defaults:&lt;br&gt;&lt;br&gt;     - :init, function of no arguments, initialization hook called with&lt;br&gt;       bindings for set!-able vars in place.&lt;br&gt;       default: #()&lt;br&gt;&lt;br&gt;     - :need-prompt, function of no arguments, called before each&lt;br&gt;       read-eval-print except the first, the user will be prompted if it&lt;br&gt;       returns true.&lt;br&gt;       default: (if (instance? LineNumberingPushbackReader *in*)&lt;br&gt;                  #(.atLineStart *in*)&lt;br&gt;                  #(identity true))&lt;br&gt;&lt;br&gt;     - :prompt, function of no arguments, prompts for more input.&lt;br&gt;       default: repl-prompt&lt;br&gt;&lt;br&gt;     - :flush, function of no arguments, flushes output&lt;br&gt;       default: flush&lt;br&gt;&lt;br&gt;     - :read, function of two arguments, reads from *in*:&lt;br&gt;         - returns its first argument to request a fresh prompt&lt;br&gt;           - depending on need-prompt, this may cause the repl to prompt&lt;br&gt;             before reading again&lt;br&gt;         - returns its second argument to request an exit from the repl&lt;br&gt;         - else returns the next object read from the input stream&lt;br&gt;       default: repl-read&lt;br&gt;&lt;br&gt;     - :eval, funtion of one argument, returns the evaluation of its&lt;br&gt;       argument&lt;br&gt;       default: eval&lt;br&gt;&lt;br&gt;     - :print, function of one argument, prints its argument to the output&lt;br&gt;       default: prn&lt;br&gt;&lt;br&gt;     - :caught, function of one argument, a throwable, called when&lt;br&gt;       read, eval, or print throws an exception or error&lt;br&gt;       default: repl-caught&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn repl&amp;lt;br&amp;gt;  &amp;quot;Generic, reusable, read-eval-print loop. By default, reads from *in*,&amp;lt;br&amp;gt;  writes to *out*, and prints exception summaries to *err*. If you use the&amp;lt;br&amp;gt;  default :read hook, *in* must either be an instance of&amp;lt;br&amp;gt;  LineNumberingPushbackReader or duplicate its behavior of both supporting&amp;lt;br&amp;gt;  .unread and collapsing CR, LF, and CRLF into a single \\newline. Options&amp;lt;br&amp;gt;  are sequential keyword-value pairs. Available options and their defaults:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     - :init, function of no arguments, initialization hook called with&amp;lt;br&amp;gt;       bindings for set!-able vars in place.&amp;lt;br&amp;gt;       default: #()&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     - :need-prompt, function of no arguments, called before each&amp;lt;br&amp;gt;       read-eval-print except the first, the user will be prompted if it&amp;lt;br&amp;gt;       returns true.&amp;lt;br&amp;gt;       default: (if (instance? LineNumberingPushbackReader *in*)&amp;lt;br&amp;gt;                  #(.atLineStart *in*)&amp;lt;br&amp;gt;                  #(identity true))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     - :prompt, function of no arguments, prompts for more input.&amp;lt;br&amp;gt;       default: repl-prompt&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     - :flush, function of no arguments, flushes output&amp;lt;br&amp;gt;       default: flush&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     - :read, function of two arguments, reads from *in*:&amp;lt;br&amp;gt;         - returns its first argument to request a fresh prompt&amp;lt;br&amp;gt;           - depending on need-prompt, this may cause the repl to prompt&amp;lt;br&amp;gt;             before reading again&amp;lt;br&amp;gt;         - returns its second argument to request an exit from the repl&amp;lt;br&amp;gt;         - else returns the next object read from the input stream&amp;lt;br&amp;gt;       default: repl-read&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     - :eval, funtion of one argument, returns the evaluation of its&amp;lt;br&amp;gt;       argument&amp;lt;br&amp;gt;       default: eval&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     - :print, function of one argument, prints its argument to the output&amp;lt;br&amp;gt;       default: prn&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     - :caught, function of one argument, a throwable, called when&amp;lt;br&amp;gt;       read, eval, or print throws an exception or error&amp;lt;br&amp;gt;       default: repl-caught&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; options]&amp;lt;br&amp;gt;  (let [cl (.getContextClassLoader (Thread/currentThread))]&amp;lt;br&amp;gt;    (.setContextClassLoader (Thread/currentThread) (clojure.lang.DynamicClassLoader. cl)))&amp;lt;br&amp;gt;  (let [{:keys [init need-prompt prompt flush read eval print caught]&amp;lt;br&amp;gt;         :or {init        #()&amp;lt;br&amp;gt;              need-prompt (if (instance? LineNumberingPushbackReader *in*)&amp;lt;br&amp;gt;                            #(.atLineStart ^LineNumberingPushbackReader *in*)&amp;lt;br&amp;gt;                            #(identity true))&amp;lt;br&amp;gt;              prompt      repl-prompt&amp;lt;br&amp;gt;              flush       flush&amp;lt;br&amp;gt;              read        repl-read&amp;lt;br&amp;gt;              eval        eval&amp;lt;br&amp;gt;              print       prn&amp;lt;br&amp;gt;              caught      repl-caught}}&amp;lt;br&amp;gt;        (apply hash-map options)&amp;lt;br&amp;gt;        request-prompt (Object.)&amp;lt;br&amp;gt;        request-exit (Object.)&amp;lt;br&amp;gt;        read-eval-print&amp;lt;br&amp;gt;        (fn []&amp;lt;br&amp;gt;          (try&amp;lt;br&amp;gt;            (let [read-eval *read-eval*&amp;lt;br&amp;gt;                  input (with-read-known (read request-prompt request-exit))]&amp;lt;br&amp;gt;             (or (#{request-prompt request-exit} input)&amp;lt;br&amp;gt;                 (let [value (binding [*read-eval* read-eval] (eval input))]&amp;lt;br&amp;gt;                   (print value)&amp;lt;br&amp;gt;                   (set! *3 *2)&amp;lt;br&amp;gt;                   (set! *2 *1)&amp;lt;br&amp;gt;                   (set! *1 value))))&amp;lt;br&amp;gt;           (catch Throwable e&amp;lt;br&amp;gt;             (caught e)&amp;lt;br&amp;gt;             (set! *e e))))]&amp;lt;br&amp;gt;    (with-bindings&amp;lt;br&amp;gt;     (try&amp;lt;br&amp;gt;      (init)&amp;lt;br&amp;gt;      (catch Throwable e&amp;lt;br&amp;gt;        (caught e)&amp;lt;br&amp;gt;        (set! *e e)))&amp;lt;br&amp;gt;     (prompt)&amp;lt;br&amp;gt;     (flush)&amp;lt;br&amp;gt;     (loop []&amp;lt;br&amp;gt;       (when-not &amp;lt;br&amp;gt;       	 (try (identical? (read-eval-print) request-exit)&amp;lt;br&amp;gt;	  (catch Throwable e&amp;lt;br&amp;gt;	   (caught e)&amp;lt;br&amp;gt;	   (set! *e e)&amp;lt;br&amp;gt;	   nil))&amp;lt;br&amp;gt;         (when (need-prompt)&amp;lt;br&amp;gt;           (prompt)&amp;lt;br&amp;gt;           (flush))&amp;lt;br&amp;gt;         (recur))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">repl</a>[& options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;repl-caught&lt;/b&gt; ([e])&lt;br&gt; Default :caught hook for repl&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn repl-caught&amp;lt;br&amp;gt;  &amp;quot;Default :caught hook for repl&amp;quot;&amp;lt;br&amp;gt;  [e]&amp;lt;br&amp;gt;  (let [ex (repl-exception e)&amp;lt;br&amp;gt;        tr (.getStackTrace ex)&amp;lt;br&amp;gt;        el (when-not (zero? (count tr)) (aget tr 0))]&amp;lt;br&amp;gt;    (binding [*out* *err*]&amp;lt;br&amp;gt;      (println (str (-&amp;gt; ex class .getSimpleName)&amp;lt;br&amp;gt;                    &amp;quot; &amp;quot; (.getMessage ex) &amp;quot; &amp;quot;&amp;lt;br&amp;gt;                    (when-not (instance? clojure.lang.Compiler$CompilerException ex)&amp;lt;br&amp;gt;                      (str &amp;quot; &amp;quot; (if el (stack-element-str el) &amp;quot;[trace missing]&amp;quot;))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">repl-caught</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;repl-exception&lt;/b&gt; ([throwable])&lt;br&gt; Returns the root cause of throwables&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn repl-exception&amp;lt;br&amp;gt;  &amp;quot;Returns the root cause of throwables&amp;quot;&amp;lt;br&amp;gt;  [throwable]&amp;lt;br&amp;gt;  (root-cause throwable))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">repl-exception</a>[throwable]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;repl-prompt&lt;/b&gt; ([])&lt;br&gt; Default :prompt hook for repl&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn repl-prompt&amp;lt;br&amp;gt;  &amp;quot;Default :prompt hook for repl&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (printf &amp;quot;%s=&amp;gt; &amp;quot; (ns-name *ns*)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">repl-prompt</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;repl-read&lt;/b&gt; ([request-prompt request-exit])&lt;br&gt; Default :read hook for repl. Reads from *in* which must either be an&lt;br&gt;  instance of LineNumberingPushbackReader or duplicate its behavior of both&lt;br&gt;  supporting .unread and collapsing all of CR, LF, and CRLF into a single&lt;br&gt;  \newline. repl-read:&lt;br&gt;    - skips whitespace, then&lt;br&gt;      - returns request-prompt on start of line, or&lt;br&gt;      - returns request-exit on end of stream, or&lt;br&gt;      - reads an object from the input stream, then&lt;br&gt;        - skips the next input character if it's end of line, then&lt;br&gt;        - returns the object.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn repl-read&amp;lt;br&amp;gt;  &amp;quot;Default :read hook for repl. Reads from *in* which must either be an&amp;lt;br&amp;gt;  instance of LineNumberingPushbackReader or duplicate its behavior of both&amp;lt;br&amp;gt;  supporting .unread and collapsing all of CR, LF, and CRLF into a single&amp;lt;br&amp;gt;  \\newline. repl-read:&amp;lt;br&amp;gt;    - skips whitespace, then&amp;lt;br&amp;gt;      - returns request-prompt on start of line, or&amp;lt;br&amp;gt;      - returns request-exit on end of stream, or&amp;lt;br&amp;gt;      - reads an object from the input stream, then&amp;lt;br&amp;gt;        - skips the next input character if it's end of line, then&amp;lt;br&amp;gt;        - returns the object.&amp;quot;&amp;lt;br&amp;gt;  [request-prompt request-exit]&amp;lt;br&amp;gt;  (or ({:line-start request-prompt :stream-end request-exit}&amp;lt;br&amp;gt;       (skip-whitespace *in*))&amp;lt;br&amp;gt;      (let [input (read)]&amp;lt;br&amp;gt;        (skip-if-eol *in*)&amp;lt;br&amp;gt;        input)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">repl-read</a>[request-prompt request-exit]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;root-cause&lt;/b&gt; ([t])&lt;br&gt; Returns the initial cause of an exception or error by peeling off all of&lt;br&gt;  its wrappers&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn root-cause&amp;lt;br&amp;gt;  &amp;quot;Returns the initial cause of an exception or error by peeling off all of&amp;lt;br&amp;gt;  its wrappers&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [^Throwable t]&amp;lt;br&amp;gt;  (loop [cause t]&amp;lt;br&amp;gt;    (if (and (instance? clojure.lang.Compiler$CompilerException cause)&amp;lt;br&amp;gt;             (not= (.source ^clojure.lang.Compiler$CompilerException cause) &amp;quot;NO_SOURCE_FILE&amp;quot;))&amp;lt;br&amp;gt;      cause&amp;lt;br&amp;gt;      (if-let [cause (.getCause cause)]&amp;lt;br&amp;gt;        (recur cause)&amp;lt;br&amp;gt;        cause))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">root-cause</a>[t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;skip-if-eol&lt;/b&gt; ([s])&lt;br&gt; If the next character on stream s is a newline, skips it, otherwise&lt;br&gt;  leaves the stream untouched. Returns :line-start, :stream-end, or :body&lt;br&gt;  to indicate the relative location of the next character on s. The stream&lt;br&gt;  must either be an instance of LineNumberingPushbackReader or duplicate&lt;br&gt;  its behavior of both supporting .unread and collapsing all of CR, LF, and&lt;br&gt;  CRLF to a single \newline.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn skip-if-eol&amp;lt;br&amp;gt;  &amp;quot;If the next character on stream s is a newline, skips it, otherwise&amp;lt;br&amp;gt;  leaves the stream untouched. Returns :line-start, :stream-end, or :body&amp;lt;br&amp;gt;  to indicate the relative location of the next character on s. The stream&amp;lt;br&amp;gt;  must either be an instance of LineNumberingPushbackReader or duplicate&amp;lt;br&amp;gt;  its behavior of both supporting .unread and collapsing all of CR, LF, and&amp;lt;br&amp;gt;  CRLF to a single \\newline.&amp;quot;&amp;lt;br&amp;gt;  [s]&amp;lt;br&amp;gt;  (let [c (.read s)]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;     (= c (int \newline)) :line-start&amp;lt;br&amp;gt;     (= c -1) :stream-end&amp;lt;br&amp;gt;     :else (do (.unread s c) :body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">skip-if-eol</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;skip-whitespace&lt;/b&gt; ([s])&lt;br&gt; Skips whitespace characters on stream s. Returns :line-start, :stream-end,&lt;br&gt;  or :body to indicate the relative location of the next character on s.&lt;br&gt;  Interprets comma as whitespace and semicolon as comment to end of line.&lt;br&gt;  Does not interpret #! as comment to end of line because only one&lt;br&gt;  character of lookahead is available. The stream must either be an&lt;br&gt;  instance of LineNumberingPushbackReader or duplicate its behavior of both&lt;br&gt;  supporting .unread and collapsing all of CR, LF, and CRLF to a single&lt;br&gt;  \newline.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn skip-whitespace&amp;lt;br&amp;gt;  &amp;quot;Skips whitespace characters on stream s. Returns :line-start, :stream-end,&amp;lt;br&amp;gt;  or :body to indicate the relative location of the next character on s.&amp;lt;br&amp;gt;  Interprets comma as whitespace and semicolon as comment to end of line.&amp;lt;br&amp;gt;  Does not interpret #! as comment to end of line because only one&amp;lt;br&amp;gt;  character of lookahead is available. The stream must either be an&amp;lt;br&amp;gt;  instance of LineNumberingPushbackReader or duplicate its behavior of both&amp;lt;br&amp;gt;  supporting .unread and collapsing all of CR, LF, and CRLF to a single&amp;lt;br&amp;gt;  \\newline.&amp;quot;&amp;lt;br&amp;gt;  [s]&amp;lt;br&amp;gt;  (loop [c (.read s)]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;     (= c (int \newline)) :line-start&amp;lt;br&amp;gt;     (= c -1) :stream-end&amp;lt;br&amp;gt;     (= c (int \;)) (do (.readLine s) :line-start)&amp;lt;br&amp;gt;     (or (Character/isWhitespace (char c)) (= c (int \,))) (recur (.read s))&amp;lt;br&amp;gt;     :else (do (.unread s c) :body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">skip-whitespace</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;stack-element-str&lt;/b&gt; ([el])&lt;br&gt; Returns a (possibly unmunged) string representation of a StackTraceElement&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn stack-element-str&amp;lt;br&amp;gt;  &amp;quot;Returns a (possibly unmunged) string representation of a StackTraceElement&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [^StackTraceElement el]&amp;lt;br&amp;gt;  (let [file (.getFileName el)&amp;lt;br&amp;gt;        clojure-fn? (and file (or (.endsWith file &amp;quot;.clj&amp;quot;)&amp;lt;br&amp;gt;                                  (= file &amp;quot;NO_SOURCE_FILE&amp;quot;)))]&amp;lt;br&amp;gt;    (str (if clojure-fn?&amp;lt;br&amp;gt;           (demunge (.getClassName el))&amp;lt;br&amp;gt;           (str (.getClassName el) &amp;quot;.&amp;quot; (.getMethodName el)))&amp;lt;br&amp;gt;         &amp;quot; (&amp;quot; (.getFileName el) &amp;quot;:&amp;quot; (.getLineNumber el) &amp;quot;)&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">stack-element-str</a>[el]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;with-bindings&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Executes body in the context of thread-local bindings for several vars&lt;br&gt;  that often need to be set!: *ns* *warn-on-reflection* *math-context*&lt;br&gt;  *print-meta* *print-length* *print-level* *compile-path*&lt;br&gt;  *command-line-args* *1 *2 *3 *e&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-bindings&amp;lt;br&amp;gt;  &amp;quot;Executes body in the context of thread-local bindings for several vars&amp;lt;br&amp;gt;  that often need to be set!: *ns* *warn-on-reflection* *math-context*&amp;lt;br&amp;gt;  *print-meta* *print-length* *print-level* *compile-path*&amp;lt;br&amp;gt;  *command-line-args* *1 *2 *3 *e&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*ns* *ns*&amp;lt;br&amp;gt;             *warn-on-reflection* *warn-on-reflection*&amp;lt;br&amp;gt;             *math-context* *math-context*&amp;lt;br&amp;gt;             *print-meta* *print-meta*&amp;lt;br&amp;gt;             *print-length* *print-length*&amp;lt;br&amp;gt;             *print-level* *print-level*&amp;lt;br&amp;gt;             *data-readers* *data-readers*&amp;lt;br&amp;gt;             *compile-path* (System/getProperty &amp;quot;clojure.compile.path&amp;quot; &amp;quot;classes&amp;quot;)&amp;lt;br&amp;gt;             *command-line-args* *command-line-args*&amp;lt;br&amp;gt;             *unchecked-math* *unchecked-math*&amp;lt;br&amp;gt;             *assert* *assert*&amp;lt;br&amp;gt;             *1 nil&amp;lt;br&amp;gt;             *2 nil&amp;lt;br&amp;gt;             *3 nil&amp;lt;br&amp;gt;             *e nil]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-bindings</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.main&lt;/i&gt;&lt;b&gt;with-read-known&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates body with *read-eval* set to a &quot;known&quot; value,&lt;br&gt;   i.e. substituting true for :unknown if necessary.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-read-known&amp;lt;br&amp;gt;  &amp;quot;Evaluates body with *read-eval* set to a \&amp;quot;known\&amp;quot; value,&amp;lt;br&amp;gt;   i.e. substituting true for :unknown if necessary.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*read-eval* (if (= :unknown *read-eval*) true *read-eval*)]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-read-known</a>[& body]</div></div></div><div class="row"><div class="namespace"><h4>clojure.math.combinatorics</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.combinatorics&lt;/i&gt;&lt;b&gt;cartesian-product&lt;/b&gt; ([&amp; seqs])&lt;br&gt; All the ways to take one item from each sequence&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cartesian-product&amp;lt;br&amp;gt;  &amp;quot;All the ways to take one item from each sequence&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; seqs]&amp;lt;br&amp;gt;  (let [v-original-seqs (vec seqs)&amp;lt;br&amp;gt;	step&amp;lt;br&amp;gt;	(fn step [v-seqs]&amp;lt;br&amp;gt;	  (let [increment&amp;lt;br&amp;gt;		(fn [v-seqs]&amp;lt;br&amp;gt;		  (loop [i (dec (count v-seqs)), v-seqs v-seqs]&amp;lt;br&amp;gt;		    (if (= i -1) nil&amp;lt;br&amp;gt;			(if-let [rst (next (v-seqs i))]&amp;lt;br&amp;gt;			  (assoc v-seqs i rst)&amp;lt;br&amp;gt;			  (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]&amp;lt;br&amp;gt;	    (when v-seqs&amp;lt;br&amp;gt;	       (cons (map first v-seqs)&amp;lt;br&amp;gt;		     (lazy-seq (step (increment v-seqs)))))))]&amp;lt;br&amp;gt;    (when (every? seq seqs)&amp;lt;br&amp;gt;      (lazy-seq (step v-original-seqs)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cartesian-product</a>[& seqs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.combinatorics&lt;/i&gt;&lt;b&gt;combinations&lt;/b&gt; ([items n])&lt;br&gt; All the unique ways of taking n different elements from items&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn combinations&amp;lt;br&amp;gt;  &amp;quot;All the unique ways of taking n different elements from items&amp;quot;&amp;lt;br&amp;gt;  [items n]      &amp;lt;br&amp;gt;  (let [v-items (vec (reverse items))]&amp;lt;br&amp;gt;    (if (zero? n) (list ())&amp;lt;br&amp;gt;	(let [cnt (count items)]&amp;lt;br&amp;gt;	  (cond (&amp;gt; n cnt) nil&amp;lt;br&amp;gt;		(= n cnt) (list (seq items))&amp;lt;br&amp;gt;		:else&amp;lt;br&amp;gt;		(map #(map v-items %) (index-combinations n cnt)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">combinations</a>[items n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.combinatorics&lt;/i&gt;&lt;b&gt;lex-permutations&lt;/b&gt; ([c])&lt;br&gt; DEPRECATED as a public function.&lt;br&gt;&lt;br&gt;In prior versions of the combinatorics library, there were two similar functions: permutations and lex-permutations.  It was a source of confusion to know which to call.  Now, you can always call permutations.  When appropriate (i.e., when you pass in a sorted sequence of numbers), permutations will automatically call lex-permutations as a speed optimization.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lex-permutations&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED as a public function.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;In prior versions of the combinatorics library, there were two similar functions: permutations and lex-permutations.  It was a source of confusion to know which to call.  Now, you can always call permutations.  When appropriate (i.e., when you pass in a sorted sequence of numbers), permutations will automatically call lex-permutations as a speed optimization.&amp;quot;&amp;lt;br&amp;gt;  {:deprecated &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [c]&amp;lt;br&amp;gt;  (lazy-seq&amp;lt;br&amp;gt;   (let [vec-sorted (vec (sort c))]&amp;lt;br&amp;gt;     (if (zero? (count vec-sorted))&amp;lt;br&amp;gt;       (list [])&amp;lt;br&amp;gt;       (vec-lex-permutations vec-sorted)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lex-permutations</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.combinatorics&lt;/i&gt;&lt;b&gt;permutations&lt;/b&gt; ([items])&lt;br&gt; All the distinct permutations of items, lexicographic by index.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn permutations&amp;lt;br&amp;gt;  &amp;quot;All the distinct permutations of items, lexicographic by index.&amp;quot;&amp;lt;br&amp;gt;  [items]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;   (sorted-numbers? items) (lex-permutations items),&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   (apply distinct? items)&amp;lt;br&amp;gt;   (let [v (vec items)]&amp;lt;br&amp;gt;     (map #(map v %) (lex-permutations (range (count v)))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   :else&amp;lt;br&amp;gt;   (multi-perm items)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">permutations</a>[items]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.combinatorics&lt;/i&gt;&lt;b&gt;selections&lt;/b&gt; ([items n])&lt;br&gt; All the ways of taking n (possibly the same) elements from the sequence of items&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn selections&amp;lt;br&amp;gt;  &amp;quot;All the ways of taking n (possibly the same) elements from the sequence of items&amp;quot;&amp;lt;br&amp;gt;  [items n]&amp;lt;br&amp;gt;  (apply cartesian-product (take n (repeat items))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">selections</a>[items n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.combinatorics&lt;/i&gt;&lt;b&gt;subsets&lt;/b&gt; ([items])&lt;br&gt; All the subsets of items&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subsets&amp;lt;br&amp;gt;  &amp;quot;All the subsets of items&amp;quot;&amp;lt;br&amp;gt;  [items]&amp;lt;br&amp;gt;  (mapcat (fn [n] (combinations items n))&amp;lt;br&amp;gt;	  (range (inc (count items)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subsets</a>[items]</div></div></div><div class="row"><div class="namespace"><h4>clojure.math.numeric-tower</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.numeric-tower&lt;/i&gt;&lt;b&gt;abs&lt;/b&gt; ([n])&lt;br&gt; (abs n) is the absolute value of n&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn abs &amp;quot;(abs n) is the absolute value of n&amp;quot; [n]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;   (not (number? n)) (throw (IllegalArgumentException.&amp;lt;br&amp;gt;			     &amp;quot;abs requires a number&amp;quot;))&amp;lt;br&amp;gt;   (neg? n) (minus n)&amp;lt;br&amp;gt;   :else n))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">abs</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.numeric-tower&lt;/i&gt;&lt;b&gt;ceil&lt;/b&gt; ([n])&lt;br&gt; (ceil n) returns the least integer greater than or equal to n.&lt;br&gt;If n is an exact number, ceil returns an integer, otherwise a double.&lt;/div&gt;" data-placement="right">ceil</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.numeric-tower&lt;/i&gt;&lt;b&gt;exact-integer-sqrt&lt;/b&gt; ([n])&lt;br&gt; (exact-integer-sqrt n) expects a non-negative integer n, and returns [s r] where n = s^2+r and n &lt; (s+1)^2.  In other words, it returns the floor of the square root and the 'remainder'.&lt;br&gt;For example, (exact-integer-sqrt 15) is [3 6] because 15 = 3^2+6.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn exact-integer-sqrt &amp;quot;(exact-integer-sqrt n) expects a non-negative integer n, and returns [s r] where n = s^2+r and n &amp;lt; (s+1)^2.  In other words, it returns the floor of the square root and the 'remainder'.&amp;lt;br&amp;gt;For example, (exact-integer-sqrt 15) is [3 6] because 15 = 3^2+6.&amp;quot;&amp;lt;br&amp;gt;  [n]&amp;lt;br&amp;gt;  (if (or (not (integer? n)) (neg? n))&amp;lt;br&amp;gt;    (throw (IllegalArgumentException. &amp;quot;exact-integer-sqrt requires a non-negative integer&amp;quot;))&amp;lt;br&amp;gt;    (let [isqrt (integer-sqrt n),&amp;lt;br&amp;gt;	  error (minus n (mult isqrt isqrt))]&amp;lt;br&amp;gt;      [isqrt error])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">exact-integer-sqrt</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.numeric-tower&lt;/i&gt;&lt;b&gt;expt&lt;/b&gt; ([base pow])&lt;br&gt; (expt base pow) is base to the pow power.&lt;br&gt;Returns an exact number if the base is an exact number and the power is an integer, otherwise returns a double.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn expt&amp;lt;br&amp;gt;  &amp;quot;(expt base pow) is base to the pow power.&amp;lt;br&amp;gt;Returns an exact number if the base is an exact number and the power is an integer, otherwise returns a double.&amp;quot;&amp;lt;br&amp;gt;  [base pow]&amp;lt;br&amp;gt;  (if (and (not (float? base)) (integer? pow))&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;     (pos? pow) (expt-int base pow)&amp;lt;br&amp;gt;     (zero? pow) 1&amp;lt;br&amp;gt;     :else (/ 1 (expt-int base (minus pow))))&amp;lt;br&amp;gt;    (Math/pow base pow)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">expt</a>[base pow]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.numeric-tower&lt;/i&gt;&lt;b&gt;floor&lt;/b&gt; ([n])&lt;br&gt; (floor n) returns the greatest integer less than or equal to n.&lt;br&gt;If n is an exact number, floor returns an integer, otherwise a double.&lt;/div&gt;" data-placement="right">floor</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.numeric-tower&lt;/i&gt;&lt;b&gt;gcd&lt;/b&gt; ([a b])&lt;br&gt; (gcd a b) returns the greatest common divisor of a and b&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn gcd &amp;quot;(gcd a b) returns the greatest common divisor of a and b&amp;quot; [a b]&amp;lt;br&amp;gt;  (if (or (not (integer? a)) (not (integer? b)))&amp;lt;br&amp;gt;    (throw (IllegalArgumentException. &amp;quot;gcd requires two integers&amp;quot;))  &amp;lt;br&amp;gt;    (loop [a (abs a) b (abs b)]&amp;lt;br&amp;gt;      (if (zero? b) a,&amp;lt;br&amp;gt;	  (recur b (mod a b))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">gcd</a>[a b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.numeric-tower&lt;/i&gt;&lt;b&gt;integer-length&lt;/b&gt; ([n])&lt;br&gt; Length of integer in binary&lt;/div&gt;" data-placement="right">integer-length</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.numeric-tower&lt;/i&gt;&lt;b&gt;lcm&lt;/b&gt; ([a b])&lt;br&gt; (lcm a b) returns the least common multiple of a and b&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lcm&amp;lt;br&amp;gt;  &amp;quot;(lcm a b) returns the least common multiple of a and b&amp;quot;&amp;lt;br&amp;gt;  [a b]&amp;lt;br&amp;gt;  (when (or (not (integer? a)) (not (integer? b)))&amp;lt;br&amp;gt;    (throw (IllegalArgumentException. &amp;quot;lcm requires two integers&amp;quot;)))&amp;lt;br&amp;gt;  (cond (zero? a) 0&amp;lt;br&amp;gt;        (zero? b) 0&amp;lt;br&amp;gt;        :else (abs (mult b (quot a (gcd a b))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lcm</a>[a b]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.numeric-tower&lt;/i&gt;&lt;b&gt;round&lt;/b&gt; ([n])&lt;br&gt; (round n) rounds to the nearest integer.&lt;br&gt;round always returns an integer.  Rounds up for values exactly in between two integers.&lt;/div&gt;" data-placement="right">round</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.numeric-tower&lt;/i&gt;&lt;b&gt;sqrt&lt;/b&gt; ([n])&lt;br&gt; Square root, but returns exact number if possible.&lt;/div&gt;" data-placement="right">sqrt</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.math.numeric-tower&lt;/i&gt;&lt;b&gt;when-available&lt;/b&gt; ([sym &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro when-available&amp;lt;br&amp;gt;  [sym &amp;amp; body]&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;    (when (resolve sym)&amp;lt;br&amp;gt;      (list* 'do body))&amp;lt;br&amp;gt;    (catch ClassNotFoundException _#)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">when-available</a>[sym & body]</div></div></div><div class="row"><div class="namespace"><h4>clojure.pprint</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;cl-format&lt;/b&gt; ([writer format-in &amp; args])&lt;br&gt; An implementation of a Common Lisp compatible format function. cl-format formats its&lt;br&gt;arguments to an output stream or string based on the format control string given. It &lt;br&gt;supports sophisticated formatting of structured data.&lt;br&gt;&lt;br&gt;Writer is an instance of java.io.Writer, true to output to *out* or nil to output &lt;br&gt;to a string, format-in is the format control string and the remaining arguments &lt;br&gt;are the data to be formatted.&lt;br&gt;&lt;br&gt;The format control string is a string to be output with embedded 'format directives' &lt;br&gt;describing how to format the various arguments passed in.&lt;br&gt;&lt;br&gt;If writer is nil, cl-format returns the formatted result string. Otherwise, cl-format &lt;br&gt;returns nil.&lt;br&gt;&lt;br&gt;For example:&lt;br&gt; (let [results [46 38 22]]&lt;br&gt;        (cl-format true &quot;There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%&quot; &lt;br&gt;                   (count results) results))&lt;br&gt;&lt;br&gt;Prints to *out*:&lt;br&gt; There are 3 results: 46, 38, 22&lt;br&gt;&lt;br&gt;Detailed documentation on format control strings is available in the &quot;Common Lisp the &lt;br&gt;Language, 2nd edition&quot;, Chapter 22 (available online at:&lt;br&gt;http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000) &lt;br&gt;and in the Common Lisp HyperSpec at &lt;br&gt;http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cl-format &amp;lt;br&amp;gt;  &amp;quot;An implementation of a Common Lisp compatible format function. cl-format formats its&amp;lt;br&amp;gt;arguments to an output stream or string based on the format control string given. It &amp;lt;br&amp;gt;supports sophisticated formatting of structured data.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;Writer is an instance of java.io.Writer, true to output to *out* or nil to output &amp;lt;br&amp;gt;to a string, format-in is the format control string and the remaining arguments &amp;lt;br&amp;gt;are the data to be formatted.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;The format control string is a string to be output with embedded 'format directives' &amp;lt;br&amp;gt;describing how to format the various arguments passed in.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;If writer is nil, cl-format returns the formatted result string. Otherwise, cl-format &amp;lt;br&amp;gt;returns nil.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;For example:&amp;lt;br&amp;gt; (let [results [46 38 22]]&amp;lt;br&amp;gt;        (cl-format true \&amp;quot;There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\&amp;quot; &amp;lt;br&amp;gt;                   (count results) results))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;Prints to *out*:&amp;lt;br&amp;gt; There are 3 results: 46, 38, 22&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;Detailed documentation on format control strings is available in the \&amp;quot;Common Lisp the &amp;lt;br&amp;gt;Language, 2nd edition\&amp;quot;, Chapter 22 (available online at:&amp;lt;br&amp;gt;http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000) &amp;lt;br&amp;gt;and in the Common Lisp HyperSpec at &amp;lt;br&amp;gt;http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm&amp;lt;br&amp;gt;&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;,&amp;lt;br&amp;gt;   :see-also [[&amp;quot;http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000&amp;quot; &amp;lt;br&amp;gt;               &amp;quot;Common Lisp the Language&amp;quot;]&amp;lt;br&amp;gt;              [&amp;quot;http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm&amp;quot;&amp;lt;br&amp;gt;               &amp;quot;Common Lisp HyperSpec&amp;quot;]]}&amp;lt;br&amp;gt;  [writer format-in &amp;amp; args]&amp;lt;br&amp;gt;  (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)&amp;lt;br&amp;gt;        navigator (init-navigator args)]&amp;lt;br&amp;gt;    (execute-format writer compiled-format navigator)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cl-format</a>[writer format-in & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;code-dispatch&lt;/b&gt; ([object])&lt;br&gt; The pretty print dispatch function for pretty printing Clojure code.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmulti &amp;lt;br&amp;gt;  code-dispatch&amp;lt;br&amp;gt;  &amp;quot;The pretty print dispatch function for pretty printing Clojure code.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot; :arglists '[[object]]} &amp;lt;br&amp;gt;  class)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">code-dispatch</a>[object]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;formatter&lt;/b&gt; ([format-in])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Makes a function which can directly run format-in. The function is&lt;br&gt;fn [stream &amp; args] ... and returns nil unless the stream is nil (meaning &lt;br&gt;output to a string) in which case it returns the resulting string.&lt;br&gt;&lt;br&gt;format-in can be either a control string or a previously compiled format.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro formatter&amp;lt;br&amp;gt;  &amp;quot;Makes a function which can directly run format-in. The function is&amp;lt;br&amp;gt;fn [stream &amp;amp; args] ... and returns nil unless the stream is nil (meaning &amp;lt;br&amp;gt;output to a string) in which case it returns the resulting string.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;format-in can be either a control string or a previously compiled format.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [format-in]&amp;lt;br&amp;gt;  `(let [format-in# ~format-in&amp;lt;br&amp;gt;         my-c-c# (var-get (get (ns-interns (the-ns 'clojure.pprint))&amp;lt;br&amp;gt;                               '~'cached-compile))&amp;lt;br&amp;gt;         my-e-f# (var-get (get (ns-interns (the-ns 'clojure.pprint))&amp;lt;br&amp;gt;                               '~'execute-format))&amp;lt;br&amp;gt;         my-i-n# (var-get (get (ns-interns (the-ns 'clojure.pprint))&amp;lt;br&amp;gt;                               '~'init-navigator))&amp;lt;br&amp;gt;         cf# (if (string? format-in#) (my-c-c# format-in#) format-in#)]&amp;lt;br&amp;gt;     (fn [stream# &amp;amp; args#]&amp;lt;br&amp;gt;       (let [navigator# (my-i-n# args#)]&amp;lt;br&amp;gt;         (my-e-f# stream# cf# navigator#)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">formatter</a>[format-in]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;formatter-out&lt;/b&gt; ([format-in])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Makes a function which can directly run format-in. The function is&lt;br&gt;fn [&amp; args] ... and returns nil. This version of the formatter macro is&lt;br&gt;designed to be used with *out* set to an appropriate Writer. In particular,&lt;br&gt;this is meant to be used as part of a pretty printer dispatch method.&lt;br&gt;&lt;br&gt;format-in can be either a control string or a previously compiled format.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro formatter-out&amp;lt;br&amp;gt;  &amp;quot;Makes a function which can directly run format-in. The function is&amp;lt;br&amp;gt;fn [&amp;amp; args] ... and returns nil. This version of the formatter macro is&amp;lt;br&amp;gt;designed to be used with *out* set to an appropriate Writer. In particular,&amp;lt;br&amp;gt;this is meant to be used as part of a pretty printer dispatch method.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;format-in can be either a control string or a previously compiled format.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [format-in]&amp;lt;br&amp;gt;  `(let [format-in# ~format-in&amp;lt;br&amp;gt;         cf# (if (string? format-in#) (#'clojure.pprint/cached-compile format-in#) format-in#)]&amp;lt;br&amp;gt;     (fn [&amp;amp; args#]&amp;lt;br&amp;gt;       (let [navigator# (#'clojure.pprint/init-navigator args#)]&amp;lt;br&amp;gt;         (#'clojure.pprint/execute-format cf# navigator#)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">formatter-out</a>[format-in]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;fresh-line&lt;/b&gt; ([])&lt;br&gt; Make a newline if *out* is not already at the beginning of the line. If *out* is&lt;br&gt;not a pretty writer (which keeps track of columns), this function always outputs a newline.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fresh-line&amp;lt;br&amp;gt;  &amp;quot;Make a newline if *out* is not already at the beginning of the line. If *out* is&amp;lt;br&amp;gt;not a pretty writer (which keeps track of columns), this function always outputs a newline.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (if (instance? clojure.lang.IDeref *out*)&amp;lt;br&amp;gt;    (if (not (= 0 (get-column (:base @@*out*))))&amp;lt;br&amp;gt;      (prn))&amp;lt;br&amp;gt;    (prn)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fresh-line</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;get-pretty-writer&lt;/b&gt; ([writer])&lt;br&gt; Returns the java.io.Writer passed in wrapped in a pretty writer proxy, unless it's &lt;br&gt;already a pretty writer. Generally, it is unneccesary to call this function, since pprint,&lt;br&gt;write, and cl-format all call it if they need to. However if you want the state to be &lt;br&gt;preserved across calls, you will want to wrap them with this. &lt;br&gt;&lt;br&gt;For example, when you want to generate column-aware output with multiple calls to cl-format, &lt;br&gt;do it like in this example:&lt;br&gt;&lt;br&gt;    (defn print-table [aseq column-width]&lt;br&gt;      (binding [*out* (get-pretty-writer *out*)]&lt;br&gt;        (doseq [row aseq]&lt;br&gt;          (doseq [col row]&lt;br&gt;            (cl-format true &quot;~4D~7,vT&quot; col column-width))&lt;br&gt;          (prn))))&lt;br&gt;&lt;br&gt;Now when you run:&lt;br&gt;&lt;br&gt;    user&gt; (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)&lt;br&gt;&lt;br&gt;It prints a table of squares and cubes for the numbers from 1 to 10:&lt;br&gt;&lt;br&gt;       1      1       1    &lt;br&gt;       2      4       8    &lt;br&gt;       3      9      27    &lt;br&gt;       4     16      64    &lt;br&gt;       5     25     125    &lt;br&gt;       6     36     216    &lt;br&gt;       7     49     343    &lt;br&gt;       8     64     512    &lt;br&gt;       9     81     729    &lt;br&gt;      10    100    1000&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-pretty-writer &amp;lt;br&amp;gt;  &amp;quot;Returns the java.io.Writer passed in wrapped in a pretty writer proxy, unless it's &amp;lt;br&amp;gt;already a pretty writer. Generally, it is unneccesary to call this function, since pprint,&amp;lt;br&amp;gt;write, and cl-format all call it if they need to. However if you want the state to be &amp;lt;br&amp;gt;preserved across calls, you will want to wrap them with this. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;For example, when you want to generate column-aware output with multiple calls to cl-format, &amp;lt;br&amp;gt;do it like in this example:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (defn print-table [aseq column-width]&amp;lt;br&amp;gt;      (binding [*out* (get-pretty-writer *out*)]&amp;lt;br&amp;gt;        (doseq [row aseq]&amp;lt;br&amp;gt;          (doseq [col row]&amp;lt;br&amp;gt;            (cl-format true \&amp;quot;~4D~7,vT\&amp;quot; col column-width))&amp;lt;br&amp;gt;          (prn))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;Now when you run:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    user&amp;gt; (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;It prints a table of squares and cubes for the numbers from 1 to 10:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       1      1       1    &amp;lt;br&amp;gt;       2      4       8    &amp;lt;br&amp;gt;       3      9      27    &amp;lt;br&amp;gt;       4     16      64    &amp;lt;br&amp;gt;       5     25     125    &amp;lt;br&amp;gt;       6     36     216    &amp;lt;br&amp;gt;       7     49     343    &amp;lt;br&amp;gt;       8     64     512    &amp;lt;br&amp;gt;       9     81     729    &amp;lt;br&amp;gt;      10    100    1000&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [writer]&amp;lt;br&amp;gt;  (if (pretty-writer? writer) &amp;lt;br&amp;gt;    writer&amp;lt;br&amp;gt;    (pretty-writer writer *print-right-margin* *print-miser-width*)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-pretty-writer</a>[writer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;pp&lt;/b&gt; ([])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; A convenience macro that pretty prints the last thing output. This is&lt;br&gt;exactly equivalent to (pprint *1).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro pp &amp;lt;br&amp;gt;  &amp;quot;A convenience macro that pretty prints the last thing output. This is&amp;lt;br&amp;gt;exactly equivalent to (pprint *1).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [] `(pprint *1))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pp</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;pprint&lt;/b&gt; ([object] [object writer])&lt;br&gt; Pretty print object to the optional output writer. If the writer is not provided, &lt;br&gt;print the object to the currently bound value of *out*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pprint &amp;lt;br&amp;gt;  &amp;quot;Pretty print object to the optional output writer. If the writer is not provided, &amp;lt;br&amp;gt;print the object to the currently bound value of *out*.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  ([object] (pprint object *out*)) &amp;lt;br&amp;gt;  ([object writer]&amp;lt;br&amp;gt;     (with-pretty-writer writer&amp;lt;br&amp;gt;       (binding [*print-pretty* true]&amp;lt;br&amp;gt;         (binding-map (if (or (not (= *print-base* 10)) *print-radix*) {#'pr pr-with-base} {}) &amp;lt;br&amp;gt;           (write-out object)))&amp;lt;br&amp;gt;       (if (not (= 0 (get-column *out*)))&amp;lt;br&amp;gt;         (prn)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pprint</a>[object] [object writer]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;pprint-indent&lt;/b&gt; ([relative-to n])&lt;br&gt; Create an indent at this point in the pretty printing stream. This defines how &lt;br&gt;following lines are indented. relative-to can be either :block or :current depending &lt;br&gt;whether the indent should be computed relative to the start of the logical block or&lt;br&gt;the current column position. n is an offset. &lt;br&gt;&lt;br&gt;This function is intended for use when writing custom dispatch functions.&lt;br&gt;&lt;br&gt;Output is sent to *out* which must be a pretty printing writer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pprint-indent &amp;lt;br&amp;gt;  &amp;quot;Create an indent at this point in the pretty printing stream. This defines how &amp;lt;br&amp;gt;following lines are indented. relative-to can be either :block or :current depending &amp;lt;br&amp;gt;whether the indent should be computed relative to the start of the logical block or&amp;lt;br&amp;gt;the current column position. n is an offset. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;This function is intended for use when writing custom dispatch functions.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;Output is sent to *out* which must be a pretty printing writer.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [relative-to n] &amp;lt;br&amp;gt;  (check-enumerated-arg relative-to #{:block :current})&amp;lt;br&amp;gt;  (indent *out* relative-to n))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pprint-indent</a>[relative-to n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;pprint-logical-block&lt;/b&gt; ([options* body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Execute the body as a pretty printing logical block with output to *out* which &lt;br&gt;must be a pretty printing writer. When used from pprint or cl-format, this can be &lt;br&gt;assumed. &lt;br&gt;&lt;br&gt;This function is intended for use when writing custom dispatch functions.&lt;br&gt;&lt;br&gt;Before the body, the caller can optionally specify options: :prefix, :per-line-prefix, &lt;br&gt;and :suffix.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro pprint-logical-block &amp;lt;br&amp;gt;  &amp;quot;Execute the body as a pretty printing logical block with output to *out* which &amp;lt;br&amp;gt;must be a pretty printing writer. When used from pprint or cl-format, this can be &amp;lt;br&amp;gt;assumed. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;This function is intended for use when writing custom dispatch functions.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;Before the body, the caller can optionally specify options: :prefix, :per-line-prefix, &amp;lt;br&amp;gt;and :suffix.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;, :arglists '[[options* body]]}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  (let [[options body] (parse-lb-options #{:prefix :per-line-prefix :suffix} args)]&amp;lt;br&amp;gt;    `(do (if (#'clojure.pprint/level-exceeded) &amp;lt;br&amp;gt;           (.write ^java.io.Writer *out* &amp;quot;#&amp;quot;)&amp;lt;br&amp;gt;           (do &amp;lt;br&amp;gt;             (push-thread-bindings {#'clojure.pprint/*current-level*&amp;lt;br&amp;gt;                                    (inc (var-get #'clojure.pprint/*current-level*))&amp;lt;br&amp;gt;                                    #'clojure.pprint/*current-length* 0})&amp;lt;br&amp;gt;             (try  &amp;lt;br&amp;gt;              (#'clojure.pprint/start-block *out*&amp;lt;br&amp;gt;                           ~(:prefix options) ~(:per-line-prefix options) ~(:suffix options))&amp;lt;br&amp;gt;              ~@body&amp;lt;br&amp;gt;              (#'clojure.pprint/end-block *out*)&amp;lt;br&amp;gt;              (finally &amp;lt;br&amp;gt;               (pop-thread-bindings)))))&amp;lt;br&amp;gt;         nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pprint-logical-block</a>[options* body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;pprint-newline&lt;/b&gt; ([kind])&lt;br&gt; Print a conditional newline to a pretty printing stream. kind specifies if the &lt;br&gt;newline is :linear, :miser, :fill, or :mandatory. &lt;br&gt;&lt;br&gt;This function is intended for use when writing custom dispatch functions.&lt;br&gt;&lt;br&gt;Output is sent to *out* which must be a pretty printing writer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pprint-newline&amp;lt;br&amp;gt;  &amp;quot;Print a conditional newline to a pretty printing stream. kind specifies if the &amp;lt;br&amp;gt;newline is :linear, :miser, :fill, or :mandatory. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;This function is intended for use when writing custom dispatch functions.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;Output is sent to *out* which must be a pretty printing writer.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [kind] &amp;lt;br&amp;gt;  (check-enumerated-arg kind #{:linear :miser :fill :mandatory})&amp;lt;br&amp;gt;  (nl *out* kind))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pprint-newline</a>[kind]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;pprint-tab&lt;/b&gt; ([kind colnum colinc])&lt;br&gt; Tab at this point in the pretty printing stream. kind specifies whether the tab&lt;br&gt;is :line, :section, :line-relative, or :section-relative. &lt;br&gt;&lt;br&gt;Colnum and colinc specify the target column and the increment to move the target&lt;br&gt;forward if the output is already past the original target.&lt;br&gt;&lt;br&gt;This function is intended for use when writing custom dispatch functions.&lt;br&gt;&lt;br&gt;Output is sent to *out* which must be a pretty printing writer.&lt;br&gt;&lt;br&gt;THIS FUNCTION IS NOT YET IMPLEMENTED.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pprint-tab &amp;lt;br&amp;gt;  &amp;quot;Tab at this point in the pretty printing stream. kind specifies whether the tab&amp;lt;br&amp;gt;is :line, :section, :line-relative, or :section-relative. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;Colnum and colinc specify the target column and the increment to move the target&amp;lt;br&amp;gt;forward if the output is already past the original target.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;This function is intended for use when writing custom dispatch functions.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;Output is sent to *out* which must be a pretty printing writer.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;THIS FUNCTION IS NOT YET IMPLEMENTED.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [kind colnum colinc] &amp;lt;br&amp;gt;  (check-enumerated-arg kind #{:line :section :line-relative :section-relative})&amp;lt;br&amp;gt;  (throw (UnsupportedOperationException. &amp;quot;pprint-tab is not yet implemented&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pprint-tab</a>[kind colnum colinc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;print-length-loop&lt;/b&gt; ([bindings &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; A version of loop that iterates at most *print-length* times. This is designed &lt;br&gt;for use in pretty-printer dispatch functions.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro print-length-loop&amp;lt;br&amp;gt;  &amp;quot;A version of loop that iterates at most *print-length* times. This is designed &amp;lt;br&amp;gt;for use in pretty-printer dispatch functions.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [bindings &amp;amp; body]&amp;lt;br&amp;gt;  (let [count-var (gensym &amp;quot;length-count&amp;quot;)&amp;lt;br&amp;gt;        mod-body (pll-mod-body count-var body)]&amp;lt;br&amp;gt;    `(loop ~(apply vector count-var 0 bindings)&amp;lt;br&amp;gt;       (if (or (not *print-length*) (&amp;lt; ~count-var *print-length*))&amp;lt;br&amp;gt;         (do ~@mod-body)&amp;lt;br&amp;gt;         (.write ^java.io.Writer *out* &amp;quot;...&amp;quot;)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-length-loop</a>[bindings & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;print-table&lt;/b&gt; ([ks rows] [rows])&lt;br&gt; Alpha - subject to change.&lt;br&gt;   Prints a collection of maps in a textual table. Prints table headings&lt;br&gt;   ks, and then a line of output for each row, corresponding to the keys&lt;br&gt;   in ks. If ks are not specified, use the keys of the first item in rows.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-table&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;   Prints a collection of maps in a textual table. Prints table headings&amp;lt;br&amp;gt;   ks, and then a line of output for each row, corresponding to the keys&amp;lt;br&amp;gt;   in ks. If ks are not specified, use the keys of the first item in rows.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  ([ks rows]&amp;lt;br&amp;gt;     (when (seq rows)&amp;lt;br&amp;gt;       (let [widths (map&amp;lt;br&amp;gt;                     (fn [k]&amp;lt;br&amp;gt;                       (apply max (count (str k)) (map #(count (str (get % k))) rows)))&amp;lt;br&amp;gt;                     ks)&amp;lt;br&amp;gt;             spacers (map #(apply str (repeat % &amp;quot;-&amp;quot;)) widths)&amp;lt;br&amp;gt;             fmts (map #(str &amp;quot;%&amp;quot; % &amp;quot;s&amp;quot;) widths)&amp;lt;br&amp;gt;             fmt-row (fn [leader divider trailer row]&amp;lt;br&amp;gt;                       (str leader&amp;lt;br&amp;gt;                            (apply str (interpose divider&amp;lt;br&amp;gt;                                                  (for [[col fmt] (map vector (map #(get row %) ks) fmts)]&amp;lt;br&amp;gt;                                                    (format fmt (str col)))))&amp;lt;br&amp;gt;                            trailer))]&amp;lt;br&amp;gt;         (println)&amp;lt;br&amp;gt;         (println (fmt-row &amp;quot;| &amp;quot; &amp;quot; | &amp;quot; &amp;quot; |&amp;quot; (zipmap ks ks)))&amp;lt;br&amp;gt;         (println (fmt-row &amp;quot;|-&amp;quot; &amp;quot;-+-&amp;quot; &amp;quot;-|&amp;quot; (zipmap ks spacers)))&amp;lt;br&amp;gt;         (doseq [row rows]&amp;lt;br&amp;gt;           (println (fmt-row &amp;quot;| &amp;quot; &amp;quot; | &amp;quot; &amp;quot; |&amp;quot; row))))))&amp;lt;br&amp;gt;  ([rows] (print-table (keys (first rows)) rows)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-table</a>[ks rows] [rows]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;set-pprint-dispatch&lt;/b&gt; ([function])&lt;br&gt; Set the pretty print dispatch function to a function matching (fn [obj] ...)&lt;br&gt;where obj is the object to pretty print. That function will be called with *out* set&lt;br&gt;to a pretty printing writer to which it should do its printing.&lt;br&gt;&lt;br&gt;For example functions, see simple-dispatch and code-dispatch in &lt;br&gt;clojure.pprint.dispatch.clj.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-pprint-dispatch  &amp;lt;br&amp;gt;  &amp;quot;Set the pretty print dispatch function to a function matching (fn [obj] ...)&amp;lt;br&amp;gt;where obj is the object to pretty print. That function will be called with *out* set&amp;lt;br&amp;gt;to a pretty printing writer to which it should do its printing.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;For example functions, see simple-dispatch and code-dispatch in &amp;lt;br&amp;gt;clojure.pprint.dispatch.clj.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [function]&amp;lt;br&amp;gt;  (let [old-meta (meta #'*print-pprint-dispatch*)]&amp;lt;br&amp;gt;    (alter-var-root #'*print-pprint-dispatch* (constantly function))&amp;lt;br&amp;gt;    (alter-meta! #'*print-pprint-dispatch* (constantly old-meta)))&amp;lt;br&amp;gt;  nil)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-pprint-dispatch</a>[function]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;simple-dispatch&lt;/b&gt; ([object])&lt;br&gt; The pretty print dispatch function for simple data structure format.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmulti &amp;lt;br&amp;gt;  simple-dispatch&amp;lt;br&amp;gt;  &amp;quot;The pretty print dispatch function for simple data structure format.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot; :arglists '[[object]]} &amp;lt;br&amp;gt;  class)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">simple-dispatch</a>[object]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;with-pprint-dispatch&lt;/b&gt; ([function &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Execute body with the pretty print dispatch function bound to function.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-pprint-dispatch &amp;lt;br&amp;gt;  &amp;quot;Execute body with the pretty print dispatch function bound to function.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [function &amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*print-pprint-dispatch* ~function]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-pprint-dispatch</a>[function & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;write&lt;/b&gt; ([object &amp; kw-args])&lt;br&gt; Write an object subject to the current bindings of the printer control variables.&lt;br&gt;Use the kw-args argument to override individual variables for this call (and any &lt;br&gt;recursive calls). Returns the string result if :stream is nil or nil otherwise.&lt;br&gt;&lt;br&gt;The following keyword arguments can be passed with values:&lt;br&gt;  Keyword              Meaning                              Default value&lt;br&gt;  :stream              Writer for output or nil             true (indicates *out*)&lt;br&gt;  :base                Base to use for writing rationals    Current value of *print-base*&lt;br&gt;  :circle*             If true, mark circular structures    Current value of *print-circle*&lt;br&gt;  :length              Maximum elements to show in sublists Current value of *print-length*&lt;br&gt;  :level               Maximum depth                        Current value of *print-level*&lt;br&gt;  :lines*              Maximum lines of output              Current value of *print-lines*&lt;br&gt;  :miser-width         Width to enter miser mode            Current value of *print-miser-width*&lt;br&gt;  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*&lt;br&gt;  :pretty              If true, do pretty printing          Current value of *print-pretty*&lt;br&gt;  :radix               If true, prepend a radix specifier   Current value of *print-radix*&lt;br&gt;  :readably*           If true, print readably              Current value of *print-readably*&lt;br&gt;  :right-margin        The column for the right margin      Current value of *print-right-margin*&lt;br&gt;  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*&lt;br&gt;&lt;br&gt;  * = not yet supported&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn write &amp;lt;br&amp;gt;  &amp;quot;Write an object subject to the current bindings of the printer control variables.&amp;lt;br&amp;gt;Use the kw-args argument to override individual variables for this call (and any &amp;lt;br&amp;gt;recursive calls). Returns the string result if :stream is nil or nil otherwise.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;The following keyword arguments can be passed with values:&amp;lt;br&amp;gt;  Keyword              Meaning                              Default value&amp;lt;br&amp;gt;  :stream              Writer for output or nil             true (indicates *out*)&amp;lt;br&amp;gt;  :base                Base to use for writing rationals    Current value of *print-base*&amp;lt;br&amp;gt;  :circle*             If true, mark circular structures    Current value of *print-circle*&amp;lt;br&amp;gt;  :length              Maximum elements to show in sublists Current value of *print-length*&amp;lt;br&amp;gt;  :level               Maximum depth                        Current value of *print-level*&amp;lt;br&amp;gt;  :lines*              Maximum lines of output              Current value of *print-lines*&amp;lt;br&amp;gt;  :miser-width         Width to enter miser mode            Current value of *print-miser-width*&amp;lt;br&amp;gt;  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*&amp;lt;br&amp;gt;  :pretty              If true, do pretty printing          Current value of *print-pretty*&amp;lt;br&amp;gt;  :radix               If true, prepend a radix specifier   Current value of *print-radix*&amp;lt;br&amp;gt;  :readably*           If true, print readably              Current value of *print-readably*&amp;lt;br&amp;gt;  :right-margin        The column for the right margin      Current value of *print-right-margin*&amp;lt;br&amp;gt;  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  * = not yet supported&amp;lt;br&amp;gt;&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [object &amp;amp; kw-args]&amp;lt;br&amp;gt;  (let [options (merge {:stream true} (apply hash-map kw-args))]&amp;lt;br&amp;gt;    (binding-map (table-ize write-option-table options) &amp;lt;br&amp;gt;      (binding-map (if (or (not (= *print-base* 10)) *print-radix*) {#'pr pr-with-base} {}) &amp;lt;br&amp;gt;        (let [optval (if (contains? options :stream) &amp;lt;br&amp;gt;                       (:stream options)&amp;lt;br&amp;gt;                       true) &amp;lt;br&amp;gt;              base-writer (condp = optval&amp;lt;br&amp;gt;                            nil (java.io.StringWriter.)&amp;lt;br&amp;gt;                            true *out*&amp;lt;br&amp;gt;                            optval)]&amp;lt;br&amp;gt;          (if *print-pretty*&amp;lt;br&amp;gt;            (with-pretty-writer base-writer&amp;lt;br&amp;gt;              (write-out object))&amp;lt;br&amp;gt;            (binding [*out* base-writer]&amp;lt;br&amp;gt;              (pr object)))&amp;lt;br&amp;gt;          (if (nil? optval) &amp;lt;br&amp;gt;            (.toString ^java.io.StringWriter base-writer)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">write</a>[object & kw-args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.pprint&lt;/i&gt;&lt;b&gt;write-out&lt;/b&gt; ([object])&lt;br&gt; Write an object to *out* subject to the current bindings of the printer control &lt;br&gt;variables. Use the kw-args argument to override individual variables for this call (and &lt;br&gt;any recursive calls).&lt;br&gt;&lt;br&gt;*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility&lt;br&gt;of the caller.&lt;br&gt;&lt;br&gt;This method is primarily intended for use by pretty print dispatch functions that &lt;br&gt;already know that the pretty printer will have set up their environment appropriately.&lt;br&gt;Normal library clients should use the standard &quot;write&quot; interface. &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn write-out &amp;lt;br&amp;gt;  &amp;quot;Write an object to *out* subject to the current bindings of the printer control &amp;lt;br&amp;gt;variables. Use the kw-args argument to override individual variables for this call (and &amp;lt;br&amp;gt;any recursive calls).&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility&amp;lt;br&amp;gt;of the caller.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;This method is primarily intended for use by pretty print dispatch functions that &amp;lt;br&amp;gt;already know that the pretty printer will have set up their environment appropriately.&amp;lt;br&amp;gt;Normal library clients should use the standard \&amp;quot;write\&amp;quot; interface. &amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [object]&amp;lt;br&amp;gt;  (let [length-reached (and &amp;lt;br&amp;gt;                        *current-length*&amp;lt;br&amp;gt;                        *print-length*&amp;lt;br&amp;gt;                        (&amp;gt;= *current-length* *print-length*))]&amp;lt;br&amp;gt;    (if-not *print-pretty*&amp;lt;br&amp;gt;      (pr object)&amp;lt;br&amp;gt;      (if length-reached&amp;lt;br&amp;gt;        (print &amp;quot;...&amp;quot;)&amp;lt;br&amp;gt;        (do&amp;lt;br&amp;gt;          (if *current-length* (set! *current-length* (inc *current-length*)))&amp;lt;br&amp;gt;          (*print-pprint-dispatch* object))))&amp;lt;br&amp;gt;    length-reached))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">write-out</a>[object]</div></div></div><div class="row"><div class="namespace"><h4>clojure.reflect</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;-&gt;AsmReflector&lt;/b&gt; ([class-resolver])&lt;br&gt; Positional factory function for class clojure.reflect.AsmReflector.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype AsmReflector [class-resolver]&amp;lt;br&amp;gt;  Reflector&amp;lt;br&amp;gt;  (do-reflect [_ typeref]&amp;lt;br&amp;gt;    (with-open [is (resolve-class class-resolver typeref)]&amp;lt;br&amp;gt;      (let [class-symbol (typesym typeref)&amp;lt;br&amp;gt;            r (ClassReader. is)&amp;lt;br&amp;gt;            result (atom {:bases #{} :flags #{} :members #{}})]&amp;lt;br&amp;gt;        (.accept&amp;lt;br&amp;gt;         r&amp;lt;br&amp;gt;         (reify&amp;lt;br&amp;gt;          ClassVisitor&amp;lt;br&amp;gt;          (visit [_ version access name signature superName interfaces]&amp;lt;br&amp;gt;                 (let [flags (parse-flags access :class)&amp;lt;br&amp;gt;                       ;; ignore java.lang.Object on interfaces to match reflection&amp;lt;br&amp;gt;                       superName (if (and (flags :interface)&amp;lt;br&amp;gt;                                          (= superName &amp;quot;java/lang/Object&amp;quot;))&amp;lt;br&amp;gt;                                   nil&amp;lt;br&amp;gt;                                   superName)&amp;lt;br&amp;gt;                       bases (-&amp;gt;&amp;gt; (cons superName interfaces)&amp;lt;br&amp;gt;                                  (remove nil?)&amp;lt;br&amp;gt;                                  (map internal-name-&amp;gt;class-symbol)&amp;lt;br&amp;gt;                                  (map symbol)&amp;lt;br&amp;gt;                                  (set)&amp;lt;br&amp;gt;                                  (not-empty))]&amp;lt;br&amp;gt;                   (swap! result merge {:bases bases &amp;lt;br&amp;gt;                                        :flags flags})))&amp;lt;br&amp;gt;          (visitSource [_ name debug])&amp;lt;br&amp;gt;          (visitInnerClass [_ name outerName innerName access])&amp;lt;br&amp;gt;          (visitField [_ access name desc signature value]&amp;lt;br&amp;gt;                      (swap! result update-in [:members] (fnil conj #{})&amp;lt;br&amp;gt;                             (Field. (symbol name)&amp;lt;br&amp;gt;                                     (field-descriptor-&amp;gt;class-symbol desc)&amp;lt;br&amp;gt;                                     class-symbol&amp;lt;br&amp;gt;                                     (parse-flags access :field)))&amp;lt;br&amp;gt;                      nil)&amp;lt;br&amp;gt;          (visitMethod [_ access name desc signature exceptions]&amp;lt;br&amp;gt;                       (when-not (= name &amp;quot;&amp;lt;clinit&amp;gt;&amp;quot;)&amp;lt;br&amp;gt;                         (let [constructor? (= name &amp;quot;&amp;lt;init&amp;gt;&amp;quot;)]&amp;lt;br&amp;gt;                           (swap! result update-in [:members] (fnil conj #{})&amp;lt;br&amp;gt;                                  (let [{:keys [parameter-types return-type]} (parse-method-descriptor desc)&amp;lt;br&amp;gt;                                        flags (parse-flags access :method)]&amp;lt;br&amp;gt;                                    (if constructor?&amp;lt;br&amp;gt;                                      (Constructor. class-symbol&amp;lt;br&amp;gt;                                                    class-symbol&amp;lt;br&amp;gt;                                                    parameter-types&amp;lt;br&amp;gt;                                                    (vec (map internal-name-&amp;gt;class-symbol exceptions))&amp;lt;br&amp;gt;                                                    flags)&amp;lt;br&amp;gt;                                      (Method. (symbol name)&amp;lt;br&amp;gt;                                               return-type&amp;lt;br&amp;gt;                                               class-symbol&amp;lt;br&amp;gt;                                               parameter-types&amp;lt;br&amp;gt;                                               (vec (map internal-name-&amp;gt;class-symbol exceptions))&amp;lt;br&amp;gt;                                               flags))))))&amp;lt;br&amp;gt;                       nil)&amp;lt;br&amp;gt;          (visitEnd [_])&amp;lt;br&amp;gt;          ) 0)&amp;lt;br&amp;gt;        @result))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->AsmReflector</a>[class-resolver]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;-&gt;Constructor&lt;/b&gt; ([name declaring-class parameter-types exception-types flags])&lt;br&gt; Positional factory function for class clojure.reflect.Constructor.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Constructor&amp;lt;br&amp;gt;  [name declaring-class parameter-types exception-types flags])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Constructor</a>[name declaring-class parameter-types exception-types flags]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;-&gt;Field&lt;/b&gt; ([name type declaring-class flags])&lt;br&gt; Positional factory function for class clojure.reflect.Field.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Field&amp;lt;br&amp;gt;  [name type declaring-class flags])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Field</a>[name type declaring-class flags]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;-&gt;JavaReflector&lt;/b&gt; ([classloader])&lt;br&gt; Positional factory function for class clojure.reflect.JavaReflector.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype JavaReflector [classloader]&amp;lt;br&amp;gt;  Reflector&amp;lt;br&amp;gt;  (do-reflect [_ typeref]&amp;lt;br&amp;gt;           (let [cls (Class/forName (typename typeref) false classloader)]&amp;lt;br&amp;gt;             {:bases (not-empty (set (map typesym (bases cls))))&amp;lt;br&amp;gt;              :flags (parse-flags (.getModifiers cls) :class)&amp;lt;br&amp;gt;              :members (set/union (declared-fields cls)&amp;lt;br&amp;gt;                                  (declared-methods cls)&amp;lt;br&amp;gt;                                  (declared-constructors cls))})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->JavaReflector</a>[classloader]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;-&gt;Method&lt;/b&gt; ([name return-type declaring-class parameter-types exception-types flags])&lt;br&gt; Positional factory function for class clojure.reflect.Method.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Method&amp;lt;br&amp;gt;  [name return-type declaring-class parameter-types exception-types flags])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->Method</a>[name return-type declaring-class parameter-types exception-types flags]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;do-reflect&lt;/b&gt; ([reflector typeref])&lt;br&gt; &lt;/div&gt;" data-placement="right">do-reflect</a>[reflector typeref]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;map-&gt;Constructor&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.reflect.Constructor, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Constructor&amp;lt;br&amp;gt;  [name declaring-class parameter-types exception-types flags])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Constructor</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;map-&gt;Field&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.reflect.Field, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Field&amp;lt;br&amp;gt;  [name type declaring-class flags])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Field</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;map-&gt;Method&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.reflect.Method, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord Method&amp;lt;br&amp;gt;  [name return-type declaring-class parameter-types exception-types flags])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->Method</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;reflect&lt;/b&gt; ([obj &amp; options])&lt;br&gt; Alpha - subject to change.&lt;br&gt;   Reflect on the type of obj (or obj itself if obj is a class).&lt;br&gt;   Return value and options are the same as for type-reflect. &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reflect&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;   Reflect on the type of obj (or obj itself if obj is a class).&amp;lt;br&amp;gt;   Return value and options are the same as for type-reflect. &amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [obj &amp;amp; options]&amp;lt;br&amp;gt;  (apply type-reflect (if (class? obj) obj (class obj)) options))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reflect</a>[obj & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;resolve-class&lt;/b&gt; ([this name])&lt;br&gt; Given a class name, return that typeref's class bytes as an InputStream.&lt;/div&gt;" data-placement="right">resolve-class</a>[this name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;type-reflect&lt;/b&gt; ([typeref &amp; options])&lt;br&gt; Alpha - subject to change.&lt;br&gt;   Reflect on a typeref, returning a map with :bases, :flags, and&lt;br&gt;  :members. In the discussion below, names are always Clojure symbols.&lt;br&gt;&lt;br&gt;   :bases            a set of names of the type's bases&lt;br&gt;   :flags            a set of keywords naming the boolean attributes&lt;br&gt;                     of the type.&lt;br&gt;   :members          a set of the type's members. Each membrer is a map&lt;br&gt;                     and can be a constructor, method, or field.&lt;br&gt;&lt;br&gt;   Keys common to all members:&lt;br&gt;   :name             name of the type &lt;br&gt;   :declaring-class  name of the declarer&lt;br&gt;   :flags            keyword naming boolean attributes of the member&lt;br&gt;&lt;br&gt;   Keys specific to constructors:&lt;br&gt;   :parameter-types  vector of parameter type names&lt;br&gt;   :exception-types  vector of exception type names&lt;br&gt;&lt;br&gt;   Key specific to methods:&lt;br&gt;   :parameter-types  vector of parameter type names&lt;br&gt;   :exception-types  vector of exception type names&lt;br&gt;   :return-type      return type name&lt;br&gt;&lt;br&gt;   Keys specific to fields:&lt;br&gt;   :type             type name&lt;br&gt;&lt;br&gt;   Options:&lt;br&gt;&lt;br&gt;     :ancestors     in addition to the keys described above, also&lt;br&gt;                    include an :ancestors key with the entire set of&lt;br&gt;                    ancestors, and add all ancestor members to&lt;br&gt;                    :members.&lt;br&gt;     :reflector     implementation to use. Defaults to JavaReflector,&lt;br&gt;                    AsmReflector is also an option.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn type-reflect&amp;lt;br&amp;gt;  &amp;quot;Alpha - subject to change.&amp;lt;br&amp;gt;   Reflect on a typeref, returning a map with :bases, :flags, and&amp;lt;br&amp;gt;  :members. In the discussion below, names are always Clojure symbols.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   :bases            a set of names of the type's bases&amp;lt;br&amp;gt;   :flags            a set of keywords naming the boolean attributes&amp;lt;br&amp;gt;                     of the type.&amp;lt;br&amp;gt;   :members          a set of the type's members. Each membrer is a map&amp;lt;br&amp;gt;                     and can be a constructor, method, or field.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Keys common to all members:&amp;lt;br&amp;gt;   :name             name of the type &amp;lt;br&amp;gt;   :declaring-class  name of the declarer&amp;lt;br&amp;gt;   :flags            keyword naming boolean attributes of the member&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Keys specific to constructors:&amp;lt;br&amp;gt;   :parameter-types  vector of parameter type names&amp;lt;br&amp;gt;   :exception-types  vector of exception type names&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Key specific to methods:&amp;lt;br&amp;gt;   :parameter-types  vector of parameter type names&amp;lt;br&amp;gt;   :exception-types  vector of exception type names&amp;lt;br&amp;gt;   :return-type      return type name&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Keys specific to fields:&amp;lt;br&amp;gt;   :type             type name&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Options:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     :ancestors     in addition to the keys described above, also&amp;lt;br&amp;gt;                    include an :ancestors key with the entire set of&amp;lt;br&amp;gt;                    ancestors, and add all ancestor members to&amp;lt;br&amp;gt;                    :members.&amp;lt;br&amp;gt;     :reflector     implementation to use. Defaults to JavaReflector,&amp;lt;br&amp;gt;                    AsmReflector is also an option.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [typeref &amp;amp; options]&amp;lt;br&amp;gt;  (let [{:keys [ancestors reflector]}&amp;lt;br&amp;gt;        (merge {:reflector default-reflector}&amp;lt;br&amp;gt;               (apply hash-map options))&amp;lt;br&amp;gt;        refl (partial do-reflect reflector)&amp;lt;br&amp;gt;        result (refl typeref)]&amp;lt;br&amp;gt;    ;; could make simpler loop of two args: names an&amp;lt;br&amp;gt;    (if ancestors&amp;lt;br&amp;gt;      (let [make-ancestor-map (fn [names]&amp;lt;br&amp;gt;                            (zipmap names (map refl names)))]&amp;lt;br&amp;gt;        (loop [reflections (make-ancestor-map (:bases result))]&amp;lt;br&amp;gt;          (let [ancestors-visited (set (keys reflections))&amp;lt;br&amp;gt;                ancestors-to-visit (set/difference (set (mapcat :bases (vals reflections)))&amp;lt;br&amp;gt;                                               ancestors-visited)]&amp;lt;br&amp;gt;            (if (seq ancestors-to-visit)&amp;lt;br&amp;gt;              (recur (merge reflections (make-ancestor-map ancestors-to-visit)))&amp;lt;br&amp;gt;              (apply merge-with into result {:ancestors ancestors-visited}&amp;lt;br&amp;gt;                     (map #(select-keys % [:members]) (vals reflections)))))))&amp;lt;br&amp;gt;      result)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">type-reflect</a>[typeref & options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.reflect&lt;/i&gt;&lt;b&gt;typename&lt;/b&gt; ([o])&lt;br&gt; Returns Java name as returned by ASM getClassName, e.g. byte[], java.lang.String[]&lt;/div&gt;" data-placement="right">typename</a>[o]</div></div></div><div class="row"><div class="namespace"><h4>clojure.repl</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;apropos&lt;/b&gt; ([str-or-pattern])&lt;br&gt; Given a regular expression or stringable thing, return a seq of&lt;br&gt;all definitions in all currently-loaded namespaces that match the&lt;br&gt;str-or-pattern.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn apropos&amp;lt;br&amp;gt;  &amp;quot;Given a regular expression or stringable thing, return a seq of&amp;lt;br&amp;gt;all definitions in all currently-loaded namespaces that match the&amp;lt;br&amp;gt;str-or-pattern.&amp;quot;&amp;lt;br&amp;gt;  [str-or-pattern]&amp;lt;br&amp;gt;  (let [matches? (if (instance? java.util.regex.Pattern str-or-pattern)&amp;lt;br&amp;gt;                   #(re-find str-or-pattern (str %))&amp;lt;br&amp;gt;                   #(.contains (str %) (str str-or-pattern)))]&amp;lt;br&amp;gt;    (mapcat (fn [ns]&amp;lt;br&amp;gt;              (filter matches? (keys (ns-publics ns))))&amp;lt;br&amp;gt;            (all-ns))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">apropos</a>[str-or-pattern]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;demunge&lt;/b&gt; ([fn-name])&lt;br&gt; Given a string representation of a fn class,&lt;br&gt;  as in a stack trace element, returns a readable version.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn demunge&amp;lt;br&amp;gt;  &amp;quot;Given a string representation of a fn class,&amp;lt;br&amp;gt;  as in a stack trace element, returns a readable version.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [fn-name]&amp;lt;br&amp;gt;  (re-replace demunge-pattern fn-name demunge-map))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">demunge</a>[fn-name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;dir&lt;/b&gt; ([nsname])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Prints a sorted directory of public vars in a namespace&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro dir&amp;lt;br&amp;gt;  &amp;quot;Prints a sorted directory of public vars in a namespace&amp;quot;&amp;lt;br&amp;gt;  [nsname]&amp;lt;br&amp;gt;  `(doseq [v# (dir-fn '~nsname)]&amp;lt;br&amp;gt;     (println v#)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dir</a>[nsname]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;dir-fn&lt;/b&gt; ([ns])&lt;br&gt; Returns a sorted seq of symbols naming public vars in&lt;br&gt;  a namespace&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dir-fn&amp;lt;br&amp;gt;  &amp;quot;Returns a sorted seq of symbols naming public vars in&amp;lt;br&amp;gt;  a namespace&amp;quot;&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (sort (map first (ns-publics (the-ns ns)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dir-fn</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;doc&lt;/b&gt; ([name])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Prints documentation for a var or special form given its name&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro doc&amp;lt;br&amp;gt;  &amp;quot;Prints documentation for a var or special form given its name&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [name]&amp;lt;br&amp;gt;  (if-let [special-name ('{&amp;amp; fn catch try finally try} name)]&amp;lt;br&amp;gt;    (#'print-doc (#'special-doc special-name))&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;      (special-doc-map name) `(#'print-doc (#'special-doc '~name))&amp;lt;br&amp;gt;      (find-ns name) `(#'print-doc (#'namespace-doc (find-ns '~name)))&amp;lt;br&amp;gt;      (resolve name) `(#'print-doc (meta (var ~name))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">doc</a>[name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;find-doc&lt;/b&gt; ([re-string-or-pattern])&lt;br&gt; Prints documentation for any var whose documentation or name&lt;br&gt; contains a match for re-string-or-pattern&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-doc&amp;lt;br&amp;gt;  &amp;quot;Prints documentation for any var whose documentation or name&amp;lt;br&amp;gt; contains a match for re-string-or-pattern&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [re-string-or-pattern]&amp;lt;br&amp;gt;    (let [re (re-pattern re-string-or-pattern)&amp;lt;br&amp;gt;          ms (concat (mapcat #(sort-by :name (map meta (vals (ns-interns %))))&amp;lt;br&amp;gt;                             (all-ns))&amp;lt;br&amp;gt;                     (map namespace-doc (all-ns))&amp;lt;br&amp;gt;                     (map special-doc (keys special-doc-map)))]&amp;lt;br&amp;gt;      (doseq [m ms&amp;lt;br&amp;gt;              :when (and (:doc m)&amp;lt;br&amp;gt;                         (or (re-find (re-matcher re (:doc m)))&amp;lt;br&amp;gt;                             (re-find (re-matcher re (str (:name m))))))]&amp;lt;br&amp;gt;               (print-doc m))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-doc</a>[re-string-or-pattern]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;pst&lt;/b&gt; ([] [e-or-depth] [e depth])&lt;br&gt; Prints a stack trace of the exception, to the depth requested. If none supplied, uses the root cause of the&lt;br&gt;  most recent repl exception (*e), and a depth of 12.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pst&amp;lt;br&amp;gt;  &amp;quot;Prints a stack trace of the exception, to the depth requested. If none supplied, uses the root cause of the&amp;lt;br&amp;gt;  most recent repl exception (*e), and a depth of 12.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  ([] (pst 12))&amp;lt;br&amp;gt;  ([e-or-depth]&amp;lt;br&amp;gt;     (if (instance? Throwable e-or-depth)&amp;lt;br&amp;gt;       (pst e-or-depth 12)&amp;lt;br&amp;gt;       (when-let [e *e]&amp;lt;br&amp;gt;         (pst (root-cause e) e-or-depth))))&amp;lt;br&amp;gt;  ([^Throwable e depth]&amp;lt;br&amp;gt;     (binding [*out* *err*]&amp;lt;br&amp;gt;       (println (str (-&amp;gt; e class .getSimpleName) &amp;quot; &amp;quot;&amp;lt;br&amp;gt;                     (.getMessage e)&amp;lt;br&amp;gt;                     (when-let [info (ex-data e)] (str &amp;quot; &amp;quot; (pr-str info)))))&amp;lt;br&amp;gt;       (let [st (.getStackTrace e)&amp;lt;br&amp;gt;             cause (.getCause e)]&amp;lt;br&amp;gt;         (doseq [el (take depth&amp;lt;br&amp;gt;                          (remove #(#{&amp;quot;clojure.lang.RestFn&amp;quot; &amp;quot;clojure.lang.AFn&amp;quot;} (.getClassName %))&amp;lt;br&amp;gt;                                  st))]&amp;lt;br&amp;gt;           (println (str \tab (stack-element-str el))))&amp;lt;br&amp;gt;         (when cause&amp;lt;br&amp;gt;           (println &amp;quot;Caused by:&amp;quot;)&amp;lt;br&amp;gt;           (pst cause (min depth&amp;lt;br&amp;gt;                           (+ 2 (- (count (.getStackTrace cause))&amp;lt;br&amp;gt;                                   (count st))))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pst</a>[] [e-or-depth] [e depth]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;root-cause&lt;/b&gt; ([t])&lt;br&gt; Returns the initial cause of an exception or error by peeling off all of&lt;br&gt;  its wrappers&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn root-cause&amp;lt;br&amp;gt;  &amp;quot;Returns the initial cause of an exception or error by peeling off all of&amp;lt;br&amp;gt;  its wrappers&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [^Throwable t]&amp;lt;br&amp;gt;  (loop [cause t]&amp;lt;br&amp;gt;    (if (and (instance? clojure.lang.Compiler$CompilerException cause)&amp;lt;br&amp;gt;             (not= (.source ^clojure.lang.Compiler$CompilerException cause) &amp;quot;NO_SOURCE_FILE&amp;quot;))&amp;lt;br&amp;gt;      cause&amp;lt;br&amp;gt;      (if-let [cause (.getCause cause)]&amp;lt;br&amp;gt;        (recur cause)&amp;lt;br&amp;gt;        cause))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">root-cause</a>[t]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;set-break-handler!&lt;/b&gt; ([] [f])&lt;br&gt; Register INT signal handler.  After calling this, Ctrl-C will cause&lt;br&gt;  the given function f to be called with a single argument, the signal.&lt;br&gt;  Uses thread-stopper if no function given.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-break-handler!&amp;lt;br&amp;gt;  &amp;quot;Register INT signal handler.  After calling this, Ctrl-C will cause&amp;lt;br&amp;gt;  the given function f to be called with a single argument, the signal.&amp;lt;br&amp;gt;  Uses thread-stopper if no function given.&amp;quot;&amp;lt;br&amp;gt;  ([] (set-break-handler! (thread-stopper)))&amp;lt;br&amp;gt;  ([f]&amp;lt;br&amp;gt;   (sun.misc.Signal/handle&amp;lt;br&amp;gt;     (sun.misc.Signal. &amp;quot;INT&amp;quot;)&amp;lt;br&amp;gt;     (proxy [sun.misc.SignalHandler] []&amp;lt;br&amp;gt;       (handle [signal]&amp;lt;br&amp;gt;         (f (str &amp;quot;-- caught signal &amp;quot; signal)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-break-handler!</a>[] [f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;source&lt;/b&gt; ([n])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Prints the source code for the given symbol, if it can find it.&lt;br&gt;  This requires that the symbol resolve to a Var defined in a&lt;br&gt;  namespace for which the .clj is in the classpath.&lt;br&gt;&lt;br&gt;  Example: (source filter)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro source&amp;lt;br&amp;gt;  &amp;quot;Prints the source code for the given symbol, if it can find it.&amp;lt;br&amp;gt;  This requires that the symbol resolve to a Var defined in a&amp;lt;br&amp;gt;  namespace for which the .clj is in the classpath.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Example: (source filter)&amp;quot;&amp;lt;br&amp;gt;  [n]&amp;lt;br&amp;gt;  `(println (or (source-fn '~n) (str &amp;quot;Source not found&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">source</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;source-fn&lt;/b&gt; ([x])&lt;br&gt; Returns a string of the source code for the given symbol, if it can&lt;br&gt;  find it.  This requires that the symbol resolve to a Var defined in&lt;br&gt;  a namespace for which the .clj is in the classpath.  Returns nil if&lt;br&gt;  it can't find the source.  For most REPL usage, 'source' is more&lt;br&gt;  convenient.&lt;br&gt;&lt;br&gt;  Example: (source-fn 'filter)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn source-fn&amp;lt;br&amp;gt;  &amp;quot;Returns a string of the source code for the given symbol, if it can&amp;lt;br&amp;gt;  find it.  This requires that the symbol resolve to a Var defined in&amp;lt;br&amp;gt;  a namespace for which the .clj is in the classpath.  Returns nil if&amp;lt;br&amp;gt;  it can't find the source.  For most REPL usage, 'source' is more&amp;lt;br&amp;gt;  convenient.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Example: (source-fn 'filter)&amp;quot;&amp;lt;br&amp;gt;  [x]&amp;lt;br&amp;gt;  (when-let [v (resolve x)]&amp;lt;br&amp;gt;    (when-let [filepath (:file (meta v))]&amp;lt;br&amp;gt;      (when-let [strm (.getResourceAsStream (RT/baseLoader) filepath)]&amp;lt;br&amp;gt;        (with-open [rdr (LineNumberReader. (InputStreamReader. strm))]&amp;lt;br&amp;gt;          (dotimes [_ (dec (:line (meta v)))] (.readLine rdr))&amp;lt;br&amp;gt;          (let [text (StringBuilder.)&amp;lt;br&amp;gt;                pbr (proxy [PushbackReader] [rdr]&amp;lt;br&amp;gt;                      (read [] (let [i (proxy-super read)]&amp;lt;br&amp;gt;                                 (.append text (char i))&amp;lt;br&amp;gt;                                 i)))]&amp;lt;br&amp;gt;            (read (PushbackReader. pbr))&amp;lt;br&amp;gt;            (str text)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">source-fn</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;stack-element-str&lt;/b&gt; ([el])&lt;br&gt; Returns a (possibly unmunged) string representation of a StackTraceElement&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn stack-element-str&amp;lt;br&amp;gt;  &amp;quot;Returns a (possibly unmunged) string representation of a StackTraceElement&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.3&amp;quot;}&amp;lt;br&amp;gt;  [^StackTraceElement el]&amp;lt;br&amp;gt;  (let [file (.getFileName el)&amp;lt;br&amp;gt;        clojure-fn? (and file (or (.endsWith file &amp;quot;.clj&amp;quot;)&amp;lt;br&amp;gt;                                  (= file &amp;quot;NO_SOURCE_FILE&amp;quot;)))]&amp;lt;br&amp;gt;    (str (if clojure-fn?&amp;lt;br&amp;gt;           (demunge (.getClassName el))&amp;lt;br&amp;gt;           (str (.getClassName el) &amp;quot;.&amp;quot; (.getMethodName el)))&amp;lt;br&amp;gt;         &amp;quot; (&amp;quot; (.getFileName el) &amp;quot;:&amp;quot; (.getLineNumber el) &amp;quot;)&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">stack-element-str</a>[el]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.repl&lt;/i&gt;&lt;b&gt;thread-stopper&lt;/b&gt; ([] [thread])&lt;br&gt; Returns a function that takes one arg and uses that as an exception message&lt;br&gt;  to stop the given thread.  Defaults to the current thread&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn thread-stopper&amp;lt;br&amp;gt;  &amp;quot;Returns a function that takes one arg and uses that as an exception message&amp;lt;br&amp;gt;  to stop the given thread.  Defaults to the current thread&amp;quot;&amp;lt;br&amp;gt;  ([] (thread-stopper (Thread/currentThread)))&amp;lt;br&amp;gt;  ([thread] (fn [msg] (.stop thread (Error. msg)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">thread-stopper</a>[] [thread]</div></div></div><div class="row"><div class="namespace"><h4>clojure.set</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.set&lt;/i&gt;&lt;b&gt;difference&lt;/b&gt; ([s1] [s1 s2] [s1 s2 &amp; sets])&lt;br&gt; Return a set that is the first set without elements of the remaining sets&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn difference&amp;lt;br&amp;gt;  &amp;quot;Return a set that is the first set without elements of the remaining sets&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([s1] s1)&amp;lt;br&amp;gt;  ([s1 s2] &amp;lt;br&amp;gt;     (if (&amp;lt; (count s1) (count s2))&amp;lt;br&amp;gt;       (reduce (fn [result item] &amp;lt;br&amp;gt;                   (if (contains? s2 item) &amp;lt;br&amp;gt;                     (disj result item) &amp;lt;br&amp;gt;                     result))&amp;lt;br&amp;gt;               s1 s1)&amp;lt;br&amp;gt;       (reduce disj s1 s2)))&amp;lt;br&amp;gt;  ([s1 s2 &amp;amp; sets] &amp;lt;br&amp;gt;     (reduce difference s1 (conj sets s2))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">difference</a>[s1] [s1 s2] [s1 s2 & sets]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.set&lt;/i&gt;&lt;b&gt;index&lt;/b&gt; ([xrel ks])&lt;br&gt; Returns a map of the distinct values of ks in the xrel mapped to a&lt;br&gt;  set of the maps in xrel with the corresponding values of ks.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn index&amp;lt;br&amp;gt;  &amp;quot;Returns a map of the distinct values of ks in the xrel mapped to a&amp;lt;br&amp;gt;  set of the maps in xrel with the corresponding values of ks.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [xrel ks]&amp;lt;br&amp;gt;    (reduce&amp;lt;br&amp;gt;     (fn [m x]&amp;lt;br&amp;gt;       (let [ik (select-keys x ks)]&amp;lt;br&amp;gt;         (assoc m ik (conj (get m ik #{}) x))))&amp;lt;br&amp;gt;     {} xrel))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">index</a>[xrel ks]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.set&lt;/i&gt;&lt;b&gt;intersection&lt;/b&gt; ([s1] [s1 s2] [s1 s2 &amp; sets])&lt;br&gt; Return a set that is the intersection of the input sets&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn intersection&amp;lt;br&amp;gt;  &amp;quot;Return a set that is the intersection of the input sets&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([s1] s1)&amp;lt;br&amp;gt;  ([s1 s2]&amp;lt;br&amp;gt;     (if (&amp;lt; (count s2) (count s1))&amp;lt;br&amp;gt;       (recur s2 s1)&amp;lt;br&amp;gt;       (reduce (fn [result item]&amp;lt;br&amp;gt;                   (if (contains? s2 item)&amp;lt;br&amp;gt;		     result&amp;lt;br&amp;gt;                     (disj result item)))&amp;lt;br&amp;gt;	       s1 s1)))&amp;lt;br&amp;gt;  ([s1 s2 &amp;amp; sets] &amp;lt;br&amp;gt;     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]&amp;lt;br&amp;gt;       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">intersection</a>[s1] [s1 s2] [s1 s2 & sets]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.set&lt;/i&gt;&lt;b&gt;join&lt;/b&gt; ([xrel yrel] [xrel yrel km])&lt;br&gt; When passed 2 rels, returns the rel corresponding to the natural&lt;br&gt;  join. When passed an additional keymap, joins on the corresponding&lt;br&gt;  keys.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn join&amp;lt;br&amp;gt;  &amp;quot;When passed 2 rels, returns the rel corresponding to the natural&amp;lt;br&amp;gt;  join. When passed an additional keymap, joins on the corresponding&amp;lt;br&amp;gt;  keys.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([xrel yrel] ;natural join&amp;lt;br&amp;gt;   (if (and (seq xrel) (seq yrel))&amp;lt;br&amp;gt;     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))&amp;lt;br&amp;gt;           [r s] (if (&amp;lt;= (count xrel) (count yrel))&amp;lt;br&amp;gt;                   [xrel yrel]&amp;lt;br&amp;gt;                   [yrel xrel])&amp;lt;br&amp;gt;           idx (index r ks)]&amp;lt;br&amp;gt;       (reduce (fn [ret x]&amp;lt;br&amp;gt;                 (let [found (idx (select-keys x ks))]&amp;lt;br&amp;gt;                   (if found&amp;lt;br&amp;gt;                     (reduce #(conj %1 (merge %2 x)) ret found)&amp;lt;br&amp;gt;                     ret)))&amp;lt;br&amp;gt;               #{} s))&amp;lt;br&amp;gt;     #{}))&amp;lt;br&amp;gt;  ([xrel yrel km] ;arbitrary key mapping&amp;lt;br&amp;gt;   (let [[r s k] (if (&amp;lt;= (count xrel) (count yrel))&amp;lt;br&amp;gt;                   [xrel yrel (map-invert km)]&amp;lt;br&amp;gt;                   [yrel xrel km])&amp;lt;br&amp;gt;         idx (index r (vals k))]&amp;lt;br&amp;gt;     (reduce (fn [ret x]&amp;lt;br&amp;gt;               (let [found (idx (rename-keys (select-keys x (keys k)) k))]&amp;lt;br&amp;gt;                 (if found&amp;lt;br&amp;gt;                   (reduce #(conj %1 (merge %2 x)) ret found)&amp;lt;br&amp;gt;                   ret)))&amp;lt;br&amp;gt;             #{} s))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">join</a>[xrel yrel] [xrel yrel km]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.set&lt;/i&gt;&lt;b&gt;map-invert&lt;/b&gt; ([m])&lt;br&gt; Returns the map with the vals mapped to the keys.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn map-invert&amp;lt;br&amp;gt;  &amp;quot;Returns the map with the vals mapped to the keys.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map-invert</a>[m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.set&lt;/i&gt;&lt;b&gt;project&lt;/b&gt; ([xrel ks])&lt;br&gt; Returns a rel of the elements of xrel with only the keys in ks&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn project&amp;lt;br&amp;gt;  &amp;quot;Returns a rel of the elements of xrel with only the keys in ks&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [xrel ks]&amp;lt;br&amp;gt;  (with-meta (set (map #(select-keys % ks) xrel)) (meta xrel)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">project</a>[xrel ks]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.set&lt;/i&gt;&lt;b&gt;rename&lt;/b&gt; ([xrel kmap])&lt;br&gt; Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rename&amp;lt;br&amp;gt;  &amp;quot;Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [xrel kmap]&amp;lt;br&amp;gt;  (with-meta (set (map #(rename-keys % kmap) xrel)) (meta xrel)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rename</a>[xrel kmap]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.set&lt;/i&gt;&lt;b&gt;rename-keys&lt;/b&gt; ([map kmap])&lt;br&gt; Returns the map with the keys in kmap renamed to the vals in kmap&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rename-keys&amp;lt;br&amp;gt;  &amp;quot;Returns the map with the keys in kmap renamed to the vals in kmap&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [map kmap]&amp;lt;br&amp;gt;    (reduce &amp;lt;br&amp;gt;     (fn [m [old new]]&amp;lt;br&amp;gt;       (if (contains? map old)&amp;lt;br&amp;gt;         (assoc m new (get map old))&amp;lt;br&amp;gt;         m)) &amp;lt;br&amp;gt;     (apply dissoc map (keys kmap)) kmap))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rename-keys</a>[map kmap]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.set&lt;/i&gt;&lt;b&gt;select&lt;/b&gt; ([pred xset])&lt;br&gt; Returns a set of the elements for which pred is true&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn select&amp;lt;br&amp;gt;  &amp;quot;Returns a set of the elements for which pred is true&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [pred xset]&amp;lt;br&amp;gt;    (reduce (fn [s k] (if (pred k) s (disj s k)))&amp;lt;br&amp;gt;            xset xset))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">select</a>[pred xset]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.set&lt;/i&gt;&lt;b&gt;subset?&lt;/b&gt; ([set1 set2])&lt;br&gt; Is set1 a subset of set2?&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn subset? &amp;lt;br&amp;gt;  &amp;quot;Is set1 a subset of set2?&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;,&amp;lt;br&amp;gt;   :tag Boolean}&amp;lt;br&amp;gt;  [set1 set2]&amp;lt;br&amp;gt;  (and (&amp;lt;= (count set1) (count set2))&amp;lt;br&amp;gt;       (every? #(contains? set2 %) set1)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">subset?</a>[set1 set2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.set&lt;/i&gt;&lt;b&gt;superset?&lt;/b&gt; ([set1 set2])&lt;br&gt; Is set1 a superset of set2?&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn superset? &amp;lt;br&amp;gt;  &amp;quot;Is set1 a superset of set2?&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;,&amp;lt;br&amp;gt;   :tag Boolean}&amp;lt;br&amp;gt;  [set1 set2]&amp;lt;br&amp;gt;  (and (&amp;gt;= (count set1) (count set2))&amp;lt;br&amp;gt;       (every? #(contains? set1 %) set2)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">superset?</a>[set1 set2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.set&lt;/i&gt;&lt;b&gt;union&lt;/b&gt; ([] [s1] [s1 s2] [s1 s2 &amp; sets])&lt;br&gt; Return a set that is the union of the input sets&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn union&amp;lt;br&amp;gt;  &amp;quot;Return a set that is the union of the input sets&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([] #{})&amp;lt;br&amp;gt;  ([s1] s1)&amp;lt;br&amp;gt;  ([s1 s2]&amp;lt;br&amp;gt;     (if (&amp;lt; (count s1) (count s2))&amp;lt;br&amp;gt;       (reduce conj s2 s1)&amp;lt;br&amp;gt;       (reduce conj s1 s2)))&amp;lt;br&amp;gt;  ([s1 s2 &amp;amp; sets]&amp;lt;br&amp;gt;     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]&amp;lt;br&amp;gt;       (reduce into (first bubbled-sets) (rest bubbled-sets)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">union</a>[] [s1] [s1 s2] [s1 s2 & sets]</div></div></div><div class="row"><div class="namespace"><h4>clojure.stacktrace</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.stacktrace&lt;/i&gt;&lt;b&gt;e&lt;/b&gt; ([])&lt;br&gt; REPL utility.  Prints a brief stack trace for the root cause of the&lt;br&gt;  most recent exception.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn e&amp;lt;br&amp;gt;  &amp;quot;REPL utility.  Prints a brief stack trace for the root cause of the&amp;lt;br&amp;gt;  most recent exception.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (print-stack-trace (root-cause *e) 8))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">e</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.stacktrace&lt;/i&gt;&lt;b&gt;print-cause-trace&lt;/b&gt; ([tr] [tr n])&lt;br&gt; Like print-stack-trace but prints chained exceptions (causes).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-cause-trace&amp;lt;br&amp;gt;  &amp;quot;Like print-stack-trace but prints chained exceptions (causes).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  ([tr] (print-cause-trace tr nil))&amp;lt;br&amp;gt;  ([tr n]&amp;lt;br&amp;gt;     (print-stack-trace tr n)&amp;lt;br&amp;gt;     (when-let [cause (.getCause tr)]&amp;lt;br&amp;gt;       (print &amp;quot;Caused by: &amp;quot; )&amp;lt;br&amp;gt;       (recur cause n))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-cause-trace</a>[tr] [tr n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.stacktrace&lt;/i&gt;&lt;b&gt;print-stack-trace&lt;/b&gt; ([tr] [tr n])&lt;br&gt; Prints a Clojure-oriented stack trace of tr, a Throwable.&lt;br&gt;  Prints a maximum of n stack frames (default: unlimited).&lt;br&gt;  Does not print chained exceptions (causes).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-stack-trace&amp;lt;br&amp;gt;  &amp;quot;Prints a Clojure-oriented stack trace of tr, a Throwable.&amp;lt;br&amp;gt;  Prints a maximum of n stack frames (default: unlimited).&amp;lt;br&amp;gt;  Does not print chained exceptions (causes).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  ([tr] (print-stack-trace tr nil))&amp;lt;br&amp;gt;  ([tr n]&amp;lt;br&amp;gt;     (let [st (.getStackTrace tr)]&amp;lt;br&amp;gt;       (print-throwable tr)&amp;lt;br&amp;gt;       (newline)&amp;lt;br&amp;gt;       (print &amp;quot; at &amp;quot;) &amp;lt;br&amp;gt;       (print-trace-element (first st))&amp;lt;br&amp;gt;       (newline)&amp;lt;br&amp;gt;       (doseq [e (if (nil? n)&amp;lt;br&amp;gt;		   (rest st)&amp;lt;br&amp;gt;		   (take (dec n) (rest st)))]&amp;lt;br&amp;gt;	 (print &amp;quot;    &amp;quot;)&amp;lt;br&amp;gt;	 (print-trace-element e)&amp;lt;br&amp;gt;	 (newline)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-stack-trace</a>[tr] [tr n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.stacktrace&lt;/i&gt;&lt;b&gt;print-throwable&lt;/b&gt; ([tr])&lt;br&gt; Prints the class and message of a Throwable.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-throwable&amp;lt;br&amp;gt;  &amp;quot;Prints the class and message of a Throwable.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [tr]&amp;lt;br&amp;gt;  (printf &amp;quot;%s: %s&amp;quot; (.getName (class tr)) (.getMessage tr)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-throwable</a>[tr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.stacktrace&lt;/i&gt;&lt;b&gt;print-trace-element&lt;/b&gt; ([e])&lt;br&gt; Prints a Clojure-oriented view of one element in a stack trace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-trace-element&amp;lt;br&amp;gt;  &amp;quot;Prints a Clojure-oriented view of one element in a stack trace.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [e]&amp;lt;br&amp;gt;  (let [class (.getClassName e)&amp;lt;br&amp;gt;	method (.getMethodName e)] &amp;lt;br&amp;gt;    (let [match (re-matches #&amp;quot;^([A-Za-z0-9_.-]+)\$(\w+)__\d+$&amp;quot; (str class))]&amp;lt;br&amp;gt;      (if (and match (= &amp;quot;invoke&amp;quot; method))&amp;lt;br&amp;gt;	(apply printf &amp;quot;%s/%s&amp;quot; (rest match))&amp;lt;br&amp;gt;	(printf &amp;quot;%s.%s&amp;quot; class method))))&amp;lt;br&amp;gt;  (printf &amp;quot; (%s:%d)&amp;quot; (or (.getFileName e) &amp;quot;&amp;quot;) (.getLineNumber e)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-trace-element</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.stacktrace&lt;/i&gt;&lt;b&gt;root-cause&lt;/b&gt; ([tr])&lt;br&gt; Returns the last 'cause' Throwable in a chain of Throwables.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn root-cause&amp;lt;br&amp;gt;  &amp;quot;Returns the last 'cause' Throwable in a chain of Throwables.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [tr]&amp;lt;br&amp;gt;  (if-let [cause (.getCause tr)]&amp;lt;br&amp;gt;    (recur cause)&amp;lt;br&amp;gt;    tr))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">root-cause</a>[tr]</div></div></div><div class="row"><div class="namespace"><h4>clojure.string</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;blank?&lt;/b&gt; ([s])&lt;br&gt; True if s is nil, empty, or contains only whitespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn blank?&amp;lt;br&amp;gt;  &amp;quot;True if s is nil, empty, or contains only whitespace.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s]&amp;lt;br&amp;gt;  (if s&amp;lt;br&amp;gt;    (loop [index (int 0)]&amp;lt;br&amp;gt;      (if (= (.length s) index)&amp;lt;br&amp;gt;        true&amp;lt;br&amp;gt;        (if (Character/isWhitespace (.charAt s index))&amp;lt;br&amp;gt;          (recur (inc index))&amp;lt;br&amp;gt;          false)))&amp;lt;br&amp;gt;    true))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">blank?</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;capitalize&lt;/b&gt; ([s])&lt;br&gt; Converts first character of the string to upper-case, all other&lt;br&gt;  characters to lower-case.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String capitalize&amp;lt;br&amp;gt;  &amp;quot;Converts first character of the string to upper-case, all other&amp;lt;br&amp;gt;  characters to lower-case.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s]&amp;lt;br&amp;gt;  (let [s (.toString s)]&amp;lt;br&amp;gt;    (if (&amp;lt; (count s) 2)&amp;lt;br&amp;gt;      (.toUpperCase s)&amp;lt;br&amp;gt;      (str (.toUpperCase (subs s 0 1))&amp;lt;br&amp;gt;           (.toLowerCase (subs s 1))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">capitalize</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;escape&lt;/b&gt; ([s cmap])&lt;br&gt; Return a new string, using cmap to escape each character ch&lt;br&gt;   from s as follows:&lt;br&gt;   &lt;br&gt;   If (cmap ch) is nil, append ch to the new string.&lt;br&gt;   If (cmap ch) is non-nil, append (str (cmap ch)) instead.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String escape&amp;lt;br&amp;gt;  &amp;quot;Return a new string, using cmap to escape each character ch&amp;lt;br&amp;gt;   from s as follows:&amp;lt;br&amp;gt;   &amp;lt;br&amp;gt;   If (cmap ch) is nil, append ch to the new string.&amp;lt;br&amp;gt;   If (cmap ch) is non-nil, append (str (cmap ch)) instead.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s cmap]&amp;lt;br&amp;gt;  (loop [index (int 0)&amp;lt;br&amp;gt;         buffer (StringBuilder. (.length s))]&amp;lt;br&amp;gt;    (if (= (.length s) index)&amp;lt;br&amp;gt;      (.toString buffer)&amp;lt;br&amp;gt;      (let [ch (.charAt s index)]&amp;lt;br&amp;gt;        (if-let [replacement (cmap ch)]&amp;lt;br&amp;gt;          (.append buffer replacement)&amp;lt;br&amp;gt;          (.append buffer ch))&amp;lt;br&amp;gt;        (recur (inc index) buffer)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">escape</a>[s cmap]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;join&lt;/b&gt; ([coll] [separator coll])&lt;br&gt; Returns a string of all elements in coll, as returned by (seq coll),&lt;br&gt;   separated by an optional separator.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String join&amp;lt;br&amp;gt;  &amp;quot;Returns a string of all elements in coll, as returned by (seq coll),&amp;lt;br&amp;gt;   separated by an optional separator.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  ([coll]&amp;lt;br&amp;gt;     (apply str coll))&amp;lt;br&amp;gt;  ([separator coll]&amp;lt;br&amp;gt;     (loop [sb (StringBuilder. (str (first coll)))&amp;lt;br&amp;gt;            more (next coll)&amp;lt;br&amp;gt;            sep (str separator)]&amp;lt;br&amp;gt;       (if more&amp;lt;br&amp;gt;         (recur (-&amp;gt; sb (.append sep) (.append (str (first more))))&amp;lt;br&amp;gt;                (next more)&amp;lt;br&amp;gt;                sep)&amp;lt;br&amp;gt;         (str sb)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">join</a>[coll] [separator coll]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;lower-case&lt;/b&gt; ([s])&lt;br&gt; Converts string to all lower-case.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String lower-case&amp;lt;br&amp;gt;  &amp;quot;Converts string to all lower-case.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s]&amp;lt;br&amp;gt;  (.. s toString toLowerCase))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lower-case</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;re-quote-replacement&lt;/b&gt; ([replacement])&lt;br&gt; Given a replacement string that you wish to be a literal&lt;br&gt;   replacement for a pattern match in replace or replace-first, do the&lt;br&gt;   necessary escaping of special characters in the replacement.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String re-quote-replacement&amp;lt;br&amp;gt;  &amp;quot;Given a replacement string that you wish to be a literal&amp;lt;br&amp;gt;   replacement for a pattern match in replace or replace-first, do the&amp;lt;br&amp;gt;   necessary escaping of special characters in the replacement.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.5&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence replacement]&amp;lt;br&amp;gt;  (Matcher/quoteReplacement (.toString ^CharSequence replacement)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">re-quote-replacement</a>[replacement]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;replace&lt;/b&gt; ([s match replacement])&lt;br&gt; Replaces all instance of match with replacement in s.&lt;br&gt;&lt;br&gt;   match/replacement can be:&lt;br&gt;&lt;br&gt;   string / string&lt;br&gt;   char / char&lt;br&gt;   pattern / (string or function of match).&lt;br&gt;&lt;br&gt;   See also replace-first.&lt;br&gt;&lt;br&gt;   The replacement is literal (i.e. none of its characters are treated&lt;br&gt;   specially) for all cases above except pattern / string.&lt;br&gt;&lt;br&gt;   For pattern / string, $1, $2, etc. in the replacement string are&lt;br&gt;   substituted with the string that matched the corresponding&lt;br&gt;   parenthesized group in the pattern.  If you wish your replacement&lt;br&gt;   string r to be used literally, use (re-quote-replacement r) as the&lt;br&gt;   replacement argument.  See also documentation for&lt;br&gt;   java.util.regex.Matcher's appendReplacement method.&lt;br&gt;&lt;br&gt;   Example:&lt;br&gt;   (clojure.string/replace &quot;Almost Pig Latin&quot; #&quot;\b(\w)(\w+)\b&quot; &quot;$2$1ay&quot;)&lt;br&gt;   -&gt; &quot;lmostAay igPay atinLay&quot;&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String replace&amp;lt;br&amp;gt;  &amp;quot;Replaces all instance of match with replacement in s.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   match/replacement can be:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   string / string&amp;lt;br&amp;gt;   char / char&amp;lt;br&amp;gt;   pattern / (string or function of match).&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   See also replace-first.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   The replacement is literal (i.e. none of its characters are treated&amp;lt;br&amp;gt;   specially) for all cases above except pattern / string.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   For pattern / string, $1, $2, etc. in the replacement string are&amp;lt;br&amp;gt;   substituted with the string that matched the corresponding&amp;lt;br&amp;gt;   parenthesized group in the pattern.  If you wish your replacement&amp;lt;br&amp;gt;   string r to be used literally, use (re-quote-replacement r) as the&amp;lt;br&amp;gt;   replacement argument.  See also documentation for&amp;lt;br&amp;gt;   java.util.regex.Matcher's appendReplacement method.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Example:&amp;lt;br&amp;gt;   (clojure.string/replace \&amp;quot;Almost Pig Latin\&amp;quot; #\&amp;quot;\\b(\\w)(\\w+)\\b\&amp;quot; \&amp;quot;$2$1ay\&amp;quot;)&amp;lt;br&amp;gt;   -&amp;gt; \&amp;quot;lmostAay igPay atinLay\&amp;quot;&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s match replacement]&amp;lt;br&amp;gt;  (let [s (.toString s)]&amp;lt;br&amp;gt;    (cond &amp;lt;br&amp;gt;     (instance? Character match) (.replace s ^Character match ^Character replacement)&amp;lt;br&amp;gt;     (instance? CharSequence match) (.replace s ^CharSequence match ^CharSequence replacement)&amp;lt;br&amp;gt;     (instance? Pattern match) (if (instance? CharSequence replacement)&amp;lt;br&amp;gt;                                 (.replaceAll (re-matcher ^Pattern match s)&amp;lt;br&amp;gt;                                              (.toString ^CharSequence replacement))&amp;lt;br&amp;gt;                                 (replace-by s match replacement))&amp;lt;br&amp;gt;     :else (throw (IllegalArgumentException. (str &amp;quot;Invalid match arg: &amp;quot; match))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">replace</a>[s match replacement]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;replace-first&lt;/b&gt; ([s match replacement])&lt;br&gt; Replaces the first instance of match with replacement in s.&lt;br&gt;&lt;br&gt;   match/replacement can be:&lt;br&gt;&lt;br&gt;   char / char&lt;br&gt;   string / string&lt;br&gt;   pattern / (string or function of match).&lt;br&gt;&lt;br&gt;   See also replace.&lt;br&gt;&lt;br&gt;   The replacement is literal (i.e. none of its characters are treated&lt;br&gt;   specially) for all cases above except pattern / string.&lt;br&gt;&lt;br&gt;   For pattern / string, $1, $2, etc. in the replacement string are&lt;br&gt;   substituted with the string that matched the corresponding&lt;br&gt;   parenthesized group in the pattern.  If you wish your replacement&lt;br&gt;   string r to be used literally, use (re-quote-replacement r) as the&lt;br&gt;   replacement argument.  See also documentation for&lt;br&gt;   java.util.regex.Matcher's appendReplacement method.&lt;br&gt;&lt;br&gt;   Example:&lt;br&gt;   (clojure.string/replace-first &quot;swap first two words&quot;&lt;br&gt;                                 #&quot;(\w+)(\s+)(\w+)&quot; &quot;$3$2$1&quot;)&lt;br&gt;   -&gt; &quot;first swap two words&quot;&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String replace-first&amp;lt;br&amp;gt;  &amp;quot;Replaces the first instance of match with replacement in s.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   match/replacement can be:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   char / char&amp;lt;br&amp;gt;   string / string&amp;lt;br&amp;gt;   pattern / (string or function of match).&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   See also replace.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   The replacement is literal (i.e. none of its characters are treated&amp;lt;br&amp;gt;   specially) for all cases above except pattern / string.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   For pattern / string, $1, $2, etc. in the replacement string are&amp;lt;br&amp;gt;   substituted with the string that matched the corresponding&amp;lt;br&amp;gt;   parenthesized group in the pattern.  If you wish your replacement&amp;lt;br&amp;gt;   string r to be used literally, use (re-quote-replacement r) as the&amp;lt;br&amp;gt;   replacement argument.  See also documentation for&amp;lt;br&amp;gt;   java.util.regex.Matcher's appendReplacement method.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Example:&amp;lt;br&amp;gt;   (clojure.string/replace-first \&amp;quot;swap first two words\&amp;quot;&amp;lt;br&amp;gt;                                 #\&amp;quot;(\\w+)(\\s+)(\\w+)\&amp;quot; \&amp;quot;$3$2$1\&amp;quot;)&amp;lt;br&amp;gt;   -&amp;gt; \&amp;quot;first swap two words\&amp;quot;&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s match replacement]&amp;lt;br&amp;gt;  (let [s (.toString s)]&amp;lt;br&amp;gt;    (cond&amp;lt;br&amp;gt;     (instance? Character match)&amp;lt;br&amp;gt;     (replace-first-char s match replacement)&amp;lt;br&amp;gt;     (instance? CharSequence match)&amp;lt;br&amp;gt;     (replace-first-str s (.toString ^CharSequence match)&amp;lt;br&amp;gt;                        (.toString ^CharSequence replacement))&amp;lt;br&amp;gt;     (instance? Pattern match)&amp;lt;br&amp;gt;     (if (instance? CharSequence replacement)&amp;lt;br&amp;gt;       (.replaceFirst (re-matcher ^Pattern match s)&amp;lt;br&amp;gt;                      (.toString ^CharSequence replacement))&amp;lt;br&amp;gt;       (replace-first-by s match replacement))&amp;lt;br&amp;gt;     :else (throw (IllegalArgumentException. (str &amp;quot;Invalid match arg: &amp;quot; match))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">replace-first</a>[s match replacement]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;reverse&lt;/b&gt; ([s])&lt;br&gt; Returns s with its characters reversed.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String reverse&amp;lt;br&amp;gt;  &amp;quot;Returns s with its characters reversed.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s]&amp;lt;br&amp;gt;  (.toString (.reverse (StringBuilder. s))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reverse</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;split&lt;/b&gt; ([s re] [s re limit])&lt;br&gt; Splits string on a regular expression.  Optional argument limit is&lt;br&gt;  the maximum number of splits. Not lazy. Returns vector of the splits.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn split&amp;lt;br&amp;gt;  &amp;quot;Splits string on a regular expression.  Optional argument limit is&amp;lt;br&amp;gt;  the maximum number of splits. Not lazy. Returns vector of the splits.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  ([^CharSequence s ^Pattern re]&amp;lt;br&amp;gt;     (LazilyPersistentVector/createOwning (.split re s)))&amp;lt;br&amp;gt;  ([ ^CharSequence s ^Pattern re limit]&amp;lt;br&amp;gt;     (LazilyPersistentVector/createOwning (.split re s limit))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">split</a>[s re] [s re limit]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;split-lines&lt;/b&gt; ([s])&lt;br&gt; Splits s on \n or \r\n.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn split-lines&amp;lt;br&amp;gt;  &amp;quot;Splits s on \\n or \\r\\n.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s]&amp;lt;br&amp;gt;  (split s #&amp;quot;\r?\n&amp;quot;))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">split-lines</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;trim&lt;/b&gt; ([s])&lt;br&gt; Removes whitespace from both ends of string.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String trim&amp;lt;br&amp;gt;  &amp;quot;Removes whitespace from both ends of string.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s]&amp;lt;br&amp;gt;  (.. s toString trim))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trim</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;trim-newline&lt;/b&gt; ([s])&lt;br&gt; Removes all trailing newline \n or return \r characters from&lt;br&gt;  string.  Similar to Perl's chomp.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String trim-newline&amp;lt;br&amp;gt;  &amp;quot;Removes all trailing newline \\n or return \\r characters from&amp;lt;br&amp;gt;  string.  Similar to Perl's chomp.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s]&amp;lt;br&amp;gt;  (loop [index (.length s)]&amp;lt;br&amp;gt;    (if (zero? index)&amp;lt;br&amp;gt;      &amp;quot;&amp;quot;&amp;lt;br&amp;gt;      (let [ch (.charAt s (dec index))]&amp;lt;br&amp;gt;        (if (or (= ch \newline) (= ch \return))&amp;lt;br&amp;gt;          (recur (dec index))&amp;lt;br&amp;gt;          (.. s (subSequence 0 index) toString))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trim-newline</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;triml&lt;/b&gt; ([s])&lt;br&gt; Removes whitespace from the left side of string.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String triml&amp;lt;br&amp;gt;  &amp;quot;Removes whitespace from the left side of string.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s]&amp;lt;br&amp;gt;  (loop [index (int 0)]&amp;lt;br&amp;gt;    (if (= (.length s) index)&amp;lt;br&amp;gt;      &amp;quot;&amp;quot;&amp;lt;br&amp;gt;      (if (Character/isWhitespace (.charAt s index))&amp;lt;br&amp;gt;        (recur (inc index))&amp;lt;br&amp;gt;        (.. s (subSequence index (.length s)) toString)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">triml</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;trimr&lt;/b&gt; ([s])&lt;br&gt; Removes whitespace from the right side of string.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String trimr&amp;lt;br&amp;gt;  &amp;quot;Removes whitespace from the right side of string.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s]&amp;lt;br&amp;gt;  (loop [index (.length s)]&amp;lt;br&amp;gt;    (if (zero? index)&amp;lt;br&amp;gt;      &amp;quot;&amp;quot;&amp;lt;br&amp;gt;      (if (Character/isWhitespace (.charAt s (dec index)))&amp;lt;br&amp;gt;        (recur (dec index))&amp;lt;br&amp;gt;        (.. s (subSequence 0 index) toString)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trimr</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.string&lt;/i&gt;&lt;b&gt;upper-case&lt;/b&gt; ([s])&lt;br&gt; Converts string to all upper-case.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String upper-case&amp;lt;br&amp;gt;  &amp;quot;Converts string to all upper-case.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [^CharSequence s]&amp;lt;br&amp;gt;  (.. s toString toUpperCase))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">upper-case</a>[s]</div></div></div><div class="row"><div class="namespace"><h4>clojure.template</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.template&lt;/i&gt;&lt;b&gt;apply-template&lt;/b&gt; ([argv expr values])&lt;br&gt; For use in macros.  argv is an argument list, as in defn.  expr is&lt;br&gt;  a quoted expression using the symbols in argv.  values is a sequence&lt;br&gt;  of values to be used for the arguments.&lt;br&gt;&lt;br&gt;  apply-template will recursively replace argument symbols in expr&lt;br&gt;  with their corresponding values, returning a modified expr.&lt;br&gt;&lt;br&gt;  Example: (apply-template '[x] '(+ x x) '[2])&lt;br&gt;           ;=&gt; (+ 2 2)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn apply-template&amp;lt;br&amp;gt;  &amp;quot;For use in macros.  argv is an argument list, as in defn.  expr is&amp;lt;br&amp;gt;  a quoted expression using the symbols in argv.  values is a sequence&amp;lt;br&amp;gt;  of values to be used for the arguments.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  apply-template will recursively replace argument symbols in expr&amp;lt;br&amp;gt;  with their corresponding values, returning a modified expr.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Example: (apply-template '[x] '(+ x x) '[2])&amp;lt;br&amp;gt;           ;=&amp;gt; (+ 2 2)&amp;quot;&amp;lt;br&amp;gt;  [argv expr values]&amp;lt;br&amp;gt;  (assert (vector? argv))&amp;lt;br&amp;gt;  (assert (every? symbol? argv))&amp;lt;br&amp;gt;  (walk/prewalk-replace (zipmap argv values) expr))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">apply-template</a>[argv expr values]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.template&lt;/i&gt;&lt;b&gt;do-template&lt;/b&gt; ([argv expr &amp; values])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Repeatedly copies expr (in a do block) for each group of arguments&lt;br&gt;  in values.  values are automatically partitioned by the number of&lt;br&gt;  arguments in argv, an argument vector as in defn.&lt;br&gt;&lt;br&gt;  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))&lt;br&gt;           ;=&gt; (do (+ 4 2) (+ 5 3))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro do-template&amp;lt;br&amp;gt;  &amp;quot;Repeatedly copies expr (in a do block) for each group of arguments&amp;lt;br&amp;gt;  in values.  values are automatically partitioned by the number of&amp;lt;br&amp;gt;  arguments in argv, an argument vector as in defn.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))&amp;lt;br&amp;gt;           ;=&amp;gt; (do (+ 4 2) (+ 5 3))&amp;quot;&amp;lt;br&amp;gt;  [argv expr &amp;amp; values]&amp;lt;br&amp;gt;  (let [c (count argv)]&amp;lt;br&amp;gt;    `(do ~@(map (fn [a] (apply-template argv expr a)) &amp;lt;br&amp;gt;                (partition c values)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">do-template</a>[argv expr & values]</div></div></div><div class="row"><div class="namespace"><h4>clojure.test</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;are&lt;/b&gt; ([argv expr &amp; args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Checks multiple assertions with a template expression.&lt;br&gt;  See clojure.template/do-template for an explanation of&lt;br&gt;  templates.&lt;br&gt;&lt;br&gt;  Example: (are [x y] (= x y)  &lt;br&gt;                2 (+ 1 1)&lt;br&gt;                4 (* 2 2))&lt;br&gt;  Expands to: &lt;br&gt;           (do (is (= 2 (+ 1 1)))&lt;br&gt;               (is (= 4 (* 2 2))))&lt;br&gt;&lt;br&gt;  Note: This breaks some reporting features, such as line numbers.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro are&amp;lt;br&amp;gt;  &amp;quot;Checks multiple assertions with a template expression.&amp;lt;br&amp;gt;  See clojure.template/do-template for an explanation of&amp;lt;br&amp;gt;  templates.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Example: (are [x y] (= x y)  &amp;lt;br&amp;gt;                2 (+ 1 1)&amp;lt;br&amp;gt;                4 (* 2 2))&amp;lt;br&amp;gt;  Expands to: &amp;lt;br&amp;gt;           (do (is (= 2 (+ 1 1)))&amp;lt;br&amp;gt;               (is (= 4 (* 2 2))))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Note: This breaks some reporting features, such as line numbers.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [argv expr &amp;amp; args]&amp;lt;br&amp;gt;  (if (or&amp;lt;br&amp;gt;       ;; (are [] true) is meaningless but ok&amp;lt;br&amp;gt;       (and (empty? argv) (empty? args))&amp;lt;br&amp;gt;       ;; Catch wrong number of args&amp;lt;br&amp;gt;       (and (pos? (count argv))&amp;lt;br&amp;gt;            (pos? (count args))&amp;lt;br&amp;gt;            (zero? (mod (count args) (count argv)))))&amp;lt;br&amp;gt;    `(temp/do-template ~argv (is ~expr) ~@args)&amp;lt;br&amp;gt;    (throw (IllegalArgumentException. &amp;quot;The number of args doesn't match are's argv.&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">are</a>[argv expr & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;assert-any&lt;/b&gt; ([msg form])&lt;br&gt; Returns generic assertion code for any test, including macros, Java&lt;br&gt;  method calls, or isolated symbols.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn assert-any&amp;lt;br&amp;gt;  &amp;quot;Returns generic assertion code for any test, including macros, Java&amp;lt;br&amp;gt;  method calls, or isolated symbols.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [msg form]&amp;lt;br&amp;gt;  `(let [value# ~form]&amp;lt;br&amp;gt;     (if value#&amp;lt;br&amp;gt;       (do-report {:type :pass, :message ~msg,&amp;lt;br&amp;gt;                :expected '~form, :actual value#})&amp;lt;br&amp;gt;       (do-report {:type :fail, :message ~msg,&amp;lt;br&amp;gt;                :expected '~form, :actual value#}))&amp;lt;br&amp;gt;     value#))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">assert-any</a>[msg form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;assert-predicate&lt;/b&gt; ([msg form])&lt;br&gt; Returns generic assertion code for any functional predicate.  The&lt;br&gt;  'expected' argument to 'report' will contains the original form, the&lt;br&gt;  'actual' argument will contain the form with all its sub-forms&lt;br&gt;  evaluated.  If the predicate returns false, the 'actual' form will&lt;br&gt;  be wrapped in (not...).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn assert-predicate&amp;lt;br&amp;gt;  &amp;quot;Returns generic assertion code for any functional predicate.  The&amp;lt;br&amp;gt;  'expected' argument to 'report' will contains the original form, the&amp;lt;br&amp;gt;  'actual' argument will contain the form with all its sub-forms&amp;lt;br&amp;gt;  evaluated.  If the predicate returns false, the 'actual' form will&amp;lt;br&amp;gt;  be wrapped in (not...).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [msg form]&amp;lt;br&amp;gt;  (let [args (rest form)&amp;lt;br&amp;gt;        pred (first form)]&amp;lt;br&amp;gt;    `(let [values# (list ~@args)&amp;lt;br&amp;gt;           result# (apply ~pred values#)]&amp;lt;br&amp;gt;       (if result#&amp;lt;br&amp;gt;         (do-report {:type :pass, :message ~msg,&amp;lt;br&amp;gt;                  :expected '~form, :actual (cons ~pred values#)})&amp;lt;br&amp;gt;         (do-report {:type :fail, :message ~msg,&amp;lt;br&amp;gt;                  :expected '~form, :actual (list '~'not (cons '~pred values#))}))&amp;lt;br&amp;gt;       result#)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">assert-predicate</a>[msg form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;compose-fixtures&lt;/b&gt; ([f1 f2])&lt;br&gt; Composes two fixture functions, creating a new fixture function&lt;br&gt;  that combines their behavior.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn compose-fixtures&amp;lt;br&amp;gt;  &amp;quot;Composes two fixture functions, creating a new fixture function&amp;lt;br&amp;gt;  that combines their behavior.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [f1 f2]&amp;lt;br&amp;gt;  (fn [g] (f1 (fn [] (f2 g)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">compose-fixtures</a>[f1 f2]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;deftest&lt;/b&gt; ([name &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Defines a test function with no arguments.  Test functions may call&lt;br&gt;  other tests, so tests may be composed.  If you compose tests, you&lt;br&gt;  should also define a function named test-ns-hook; run-tests will&lt;br&gt;  call test-ns-hook instead of testing all vars.&lt;br&gt;&lt;br&gt;  Note: Actually, the test body goes in the :test metadata on the var,&lt;br&gt;  and the real function (the value of the var) calls test-var on&lt;br&gt;  itself.&lt;br&gt;&lt;br&gt;  When *load-tests* is false, deftest is ignored.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro deftest&amp;lt;br&amp;gt;  &amp;quot;Defines a test function with no arguments.  Test functions may call&amp;lt;br&amp;gt;  other tests, so tests may be composed.  If you compose tests, you&amp;lt;br&amp;gt;  should also define a function named test-ns-hook; run-tests will&amp;lt;br&amp;gt;  call test-ns-hook instead of testing all vars.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Note: Actually, the test body goes in the :test metadata on the var,&amp;lt;br&amp;gt;  and the real function (the value of the var) calls test-var on&amp;lt;br&amp;gt;  itself.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  When *load-tests* is false, deftest is ignored.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [name &amp;amp; body]&amp;lt;br&amp;gt;  (when *load-tests*&amp;lt;br&amp;gt;    `(def ~(vary-meta name assoc :test `(fn [] ~@body))&amp;lt;br&amp;gt;          (fn [] (test-var (var ~name))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">deftest</a>[name & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;deftest-&lt;/b&gt; ([name &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Like deftest but creates a private var.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro deftest-&amp;lt;br&amp;gt;  &amp;quot;Like deftest but creates a private var.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [name &amp;amp; body]&amp;lt;br&amp;gt;  (when *load-tests*&amp;lt;br&amp;gt;    `(def ~(vary-meta name assoc :test `(fn [] ~@body) :private true)&amp;lt;br&amp;gt;          (fn [] (test-var (var ~name))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">deftest-</a>[name & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;do-report&lt;/b&gt; ([m])&lt;br&gt; Add file and line information to a test result and call report.&lt;br&gt;   If you are writing a custom assert-expr method, call this function&lt;br&gt;   to pass test results to report.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn do-report&amp;lt;br&amp;gt;  &amp;quot;Add file and line information to a test result and call report.&amp;lt;br&amp;gt;   If you are writing a custom assert-expr method, call this function&amp;lt;br&amp;gt;   to pass test results to report.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [m]&amp;lt;br&amp;gt;  (report&amp;lt;br&amp;gt;   (case&amp;lt;br&amp;gt;    (:type m)&amp;lt;br&amp;gt;    :fail (merge (file-and-line (new java.lang.Throwable) 1) m)&amp;lt;br&amp;gt;    :error (merge (file-and-line (:actual m) 0) m) &amp;lt;br&amp;gt;    m)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">do-report</a>[m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;file-position&lt;/b&gt; ([n])&lt;br&gt; Returns a vector [filename line-number] for the nth call up the&lt;br&gt;  stack.&lt;br&gt;&lt;br&gt;  Deprecated in 1.2: The information needed for test reporting is&lt;br&gt;  now on :file and :line keys in the result map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn file-position&amp;lt;br&amp;gt;  &amp;quot;Returns a vector [filename line-number] for the nth call up the&amp;lt;br&amp;gt;  stack.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Deprecated in 1.2: The information needed for test reporting is&amp;lt;br&amp;gt;  now on :file and :line keys in the result map.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;&amp;lt;br&amp;gt;   :deprecated &amp;quot;1.2&amp;quot;}&amp;lt;br&amp;gt;  [n]&amp;lt;br&amp;gt;  (let [^StackTraceElement s (nth (.getStackTrace (new java.lang.Throwable)) n)]&amp;lt;br&amp;gt;    [(.getFileName s) (.getLineNumber s)]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">file-position</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;function?&lt;/b&gt; ([x])&lt;br&gt; Returns true if argument is a function or a symbol that resolves to&lt;br&gt;  a function (not a macro).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn function?&amp;lt;br&amp;gt;  &amp;quot;Returns true if argument is a function or a symbol that resolves to&amp;lt;br&amp;gt;  a function (not a macro).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [x]&amp;lt;br&amp;gt;  (if (symbol? x)&amp;lt;br&amp;gt;    (when-let [v (resolve x)]&amp;lt;br&amp;gt;      (when-let [value (get-possibly-unbound-var v)]&amp;lt;br&amp;gt;        (and (fn? value)&amp;lt;br&amp;gt;             (not (:macro (meta v))))))&amp;lt;br&amp;gt;    (fn? x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">function?</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;get-possibly-unbound-var&lt;/b&gt; ([v])&lt;br&gt; Like var-get but returns nil if the var is unbound.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-possibly-unbound-var&amp;lt;br&amp;gt;  &amp;quot;Like var-get but returns nil if the var is unbound.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [v]&amp;lt;br&amp;gt;  (try (var-get v)&amp;lt;br&amp;gt;       (catch IllegalStateException e&amp;lt;br&amp;gt;         nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-possibly-unbound-var</a>[v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;inc-report-counter&lt;/b&gt; ([name])&lt;br&gt; Increments the named counter in *report-counters*, a ref to a map.&lt;br&gt;  Does nothing if *report-counters* is nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn inc-report-counter&amp;lt;br&amp;gt;  &amp;quot;Increments the named counter in *report-counters*, a ref to a map.&amp;lt;br&amp;gt;  Does nothing if *report-counters* is nil.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [name]&amp;lt;br&amp;gt;  (when *report-counters*&amp;lt;br&amp;gt;    (dosync (commute *report-counters* assoc name&amp;lt;br&amp;gt;                     (inc (or (*report-counters* name) 0))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">inc-report-counter</a>[name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;is&lt;/b&gt; ([form] [form msg])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Generic assertion macro.  'form' is any predicate test.&lt;br&gt;  'msg' is an optional message to attach to the assertion.&lt;br&gt;  &lt;br&gt;  Example: (is (= 4 (+ 2 2)) &quot;Two plus two should be 4&quot;)&lt;br&gt;&lt;br&gt;  Special forms:&lt;br&gt;&lt;br&gt;  (is (thrown? c body)) checks that an instance of c is thrown from&lt;br&gt;  body, fails if not; then returns the thing thrown.&lt;br&gt;&lt;br&gt;  (is (thrown-with-msg? c re body)) checks that an instance of c is&lt;br&gt;  thrown AND that the message on the exception matches (with&lt;br&gt;  re-find) the regular expression re.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro is&amp;lt;br&amp;gt;  &amp;quot;Generic assertion macro.  'form' is any predicate test.&amp;lt;br&amp;gt;  'msg' is an optional message to attach to the assertion.&amp;lt;br&amp;gt;  &amp;lt;br&amp;gt;  Example: (is (= 4 (+ 2 2)) \&amp;quot;Two plus two should be 4\&amp;quot;)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Special forms:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (is (thrown? c body)) checks that an instance of c is thrown from&amp;lt;br&amp;gt;  body, fails if not; then returns the thing thrown.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (is (thrown-with-msg? c re body)) checks that an instance of c is&amp;lt;br&amp;gt;  thrown AND that the message on the exception matches (with&amp;lt;br&amp;gt;  re-find) the regular expression re.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;} &amp;lt;br&amp;gt;  ([form] `(is ~form nil))&amp;lt;br&amp;gt;  ([form msg] `(try-expr ~msg ~form)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">is</a>[form] [form msg]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;join-fixtures&lt;/b&gt; ([fixtures])&lt;br&gt; Composes a collection of fixtures, in order.  Always returns a valid&lt;br&gt;  fixture function, even if the collection is empty.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn join-fixtures&amp;lt;br&amp;gt;  &amp;quot;Composes a collection of fixtures, in order.  Always returns a valid&amp;lt;br&amp;gt;  fixture function, even if the collection is empty.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [fixtures]&amp;lt;br&amp;gt;  (reduce compose-fixtures default-fixture fixtures))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">join-fixtures</a>[fixtures]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;run-all-tests&lt;/b&gt; ([] [re])&lt;br&gt; Runs all tests in all namespaces; prints results.&lt;br&gt;  Optional argument is a regular expression; only namespaces with&lt;br&gt;  names matching the regular expression (with re-matches) will be&lt;br&gt;  tested.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn run-all-tests&amp;lt;br&amp;gt;  &amp;quot;Runs all tests in all namespaces; prints results.&amp;lt;br&amp;gt;  Optional argument is a regular expression; only namespaces with&amp;lt;br&amp;gt;  names matching the regular expression (with re-matches) will be&amp;lt;br&amp;gt;  tested.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  ([] (apply run-tests (all-ns)))&amp;lt;br&amp;gt;  ([re] (apply run-tests (filter #(re-matches re (name (ns-name %))) (all-ns)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-all-tests</a>[] [re]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;run-tests&lt;/b&gt; ([] [&amp; namespaces])&lt;br&gt; Runs all tests in the given namespaces; prints results.&lt;br&gt;  Defaults to current namespace if none given.  Returns a map&lt;br&gt;  summarizing test results.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn run-tests&amp;lt;br&amp;gt;  &amp;quot;Runs all tests in the given namespaces; prints results.&amp;lt;br&amp;gt;  Defaults to current namespace if none given.  Returns a map&amp;lt;br&amp;gt;  summarizing test results.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  ([] (run-tests *ns*))&amp;lt;br&amp;gt;  ([&amp;amp; namespaces]&amp;lt;br&amp;gt;     (let [summary (assoc (apply merge-with + (map test-ns namespaces))&amp;lt;br&amp;gt;                     :type :summary)]&amp;lt;br&amp;gt;       (do-report summary)&amp;lt;br&amp;gt;       summary)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-tests</a>[] [& namespaces]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;set-test&lt;/b&gt; ([name &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Experimental.&lt;br&gt;  Sets :test metadata of the named var to a fn with the given body.&lt;br&gt;  The var must already exist.  Does not modify the value of the var.&lt;br&gt;&lt;br&gt;  When *load-tests* is false, set-test is ignored.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro set-test&amp;lt;br&amp;gt;  &amp;quot;Experimental.&amp;lt;br&amp;gt;  Sets :test metadata of the named var to a fn with the given body.&amp;lt;br&amp;gt;  The var must already exist.  Does not modify the value of the var.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  When *load-tests* is false, set-test is ignored.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [name &amp;amp; body]&amp;lt;br&amp;gt;  (when *load-tests*&amp;lt;br&amp;gt;    `(alter-meta! (var ~name) assoc :test (fn [] ~@body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-test</a>[name & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;successful?&lt;/b&gt; ([summary])&lt;br&gt; Returns true if the given test summary indicates all tests&lt;br&gt;  were successful, false otherwise.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn successful?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the given test summary indicates all tests&amp;lt;br&amp;gt;  were successful, false otherwise.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [summary]&amp;lt;br&amp;gt;  (and (zero? (:fail summary 0))&amp;lt;br&amp;gt;       (zero? (:error summary 0))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">successful?</a>[summary]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;test-all-vars&lt;/b&gt; ([ns])&lt;br&gt; Calls test-var on every var interned in the namespace, with fixtures.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn test-all-vars&amp;lt;br&amp;gt;  &amp;quot;Calls test-var on every var interned in the namespace, with fixtures.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (let [once-fixture-fn (join-fixtures (::once-fixtures (meta ns)))&amp;lt;br&amp;gt;        each-fixture-fn (join-fixtures (::each-fixtures (meta ns)))]&amp;lt;br&amp;gt;    (once-fixture-fn&amp;lt;br&amp;gt;     (fn []&amp;lt;br&amp;gt;       (doseq [v (vals (ns-interns ns))]&amp;lt;br&amp;gt;         (when (:test (meta v))&amp;lt;br&amp;gt;           (each-fixture-fn (fn [] (test-var v)))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">test-all-vars</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;test-ns&lt;/b&gt; ([ns])&lt;br&gt; If the namespace defines a function named test-ns-hook, calls that.&lt;br&gt;  Otherwise, calls test-all-vars on the namespace.  'ns' is a&lt;br&gt;  namespace object or a symbol.&lt;br&gt;&lt;br&gt;  Internally binds *report-counters* to a ref initialized to&lt;br&gt;  *inital-report-counters*.  Returns the final, dereferenced state of&lt;br&gt;  *report-counters*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn test-ns&amp;lt;br&amp;gt;  &amp;quot;If the namespace defines a function named test-ns-hook, calls that.&amp;lt;br&amp;gt;  Otherwise, calls test-all-vars on the namespace.  'ns' is a&amp;lt;br&amp;gt;  namespace object or a symbol.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Internally binds *report-counters* to a ref initialized to&amp;lt;br&amp;gt;  *inital-report-counters*.  Returns the final, dereferenced state of&amp;lt;br&amp;gt;  *report-counters*.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (binding [*report-counters* (ref *initial-report-counters*)]&amp;lt;br&amp;gt;    (let [ns-obj (the-ns ns)]&amp;lt;br&amp;gt;      (do-report {:type :begin-test-ns, :ns ns-obj})&amp;lt;br&amp;gt;      ;; If the namespace has a test-ns-hook function, call that:&amp;lt;br&amp;gt;      (if-let [v (find-var (symbol (str (ns-name ns-obj)) &amp;quot;test-ns-hook&amp;quot;))]&amp;lt;br&amp;gt;	((var-get v))&amp;lt;br&amp;gt;        ;; Otherwise, just test every var in the namespace.&amp;lt;br&amp;gt;        (test-all-vars ns-obj))&amp;lt;br&amp;gt;      (do-report {:type :end-test-ns, :ns ns-obj}))&amp;lt;br&amp;gt;    @*report-counters*))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">test-ns</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;test-var&lt;/b&gt; ([v])&lt;br&gt; If v has a function in its :test metadata, calls that function,&lt;br&gt;  with *testing-vars* bound to (conj *testing-vars* v).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn test-var&amp;lt;br&amp;gt;  &amp;quot;If v has a function in its :test metadata, calls that function,&amp;lt;br&amp;gt;  with *testing-vars* bound to (conj *testing-vars* v).&amp;quot;&amp;lt;br&amp;gt;  {:dynamic true, :added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [v]&amp;lt;br&amp;gt;  (when-let [t (:test (meta v))]&amp;lt;br&amp;gt;    (binding [*testing-vars* (conj *testing-vars* v)]&amp;lt;br&amp;gt;      (do-report {:type :begin-test-var, :var v})&amp;lt;br&amp;gt;      (inc-report-counter :test)&amp;lt;br&amp;gt;      (try (t)&amp;lt;br&amp;gt;           (catch Throwable e&amp;lt;br&amp;gt;             (do-report {:type :error, :message &amp;quot;Uncaught exception, not in assertion.&amp;quot;&amp;lt;br&amp;gt;                      :expected nil, :actual e})))&amp;lt;br&amp;gt;      (do-report {:type :end-test-var, :var v}))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">test-var</a>[v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;testing&lt;/b&gt; ([string &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Adds a new string to the list of testing contexts.  May be nested,&lt;br&gt;  but must occur inside a test function (deftest).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro testing&amp;lt;br&amp;gt;  &amp;quot;Adds a new string to the list of testing contexts.  May be nested,&amp;lt;br&amp;gt;  but must occur inside a test function (deftest).&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [string &amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*testing-contexts* (conj *testing-contexts* ~string)]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">testing</a>[string & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;testing-contexts-str&lt;/b&gt; ([])&lt;br&gt; Returns a string representation of the current test context. Joins&lt;br&gt;  strings in *testing-contexts* with spaces.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn testing-contexts-str&amp;lt;br&amp;gt;  &amp;quot;Returns a string representation of the current test context. Joins&amp;lt;br&amp;gt;  strings in *testing-contexts* with spaces.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (apply str (interpose &amp;quot; &amp;quot; (reverse *testing-contexts*))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">testing-contexts-str</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;testing-vars-str&lt;/b&gt; ([m])&lt;br&gt; Returns a string representation of the current test.  Renders names&lt;br&gt;  in *testing-vars* as a list, then the source file and line of&lt;br&gt;  current assertion.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn testing-vars-str&amp;lt;br&amp;gt;  &amp;quot;Returns a string representation of the current test.  Renders names&amp;lt;br&amp;gt;  in *testing-vars* as a list, then the source file and line of&amp;lt;br&amp;gt;  current assertion.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [m]&amp;lt;br&amp;gt;  (let [{:keys [file line]} m]&amp;lt;br&amp;gt;    (str&amp;lt;br&amp;gt;     ;; Uncomment to include namespace in failure report:&amp;lt;br&amp;gt;     ;;(ns-name (:ns (meta (first *testing-vars*)))) &amp;quot;/ &amp;quot;&amp;lt;br&amp;gt;     (reverse (map #(:name (meta %)) *testing-vars*))&amp;lt;br&amp;gt;     &amp;quot; (&amp;quot; file &amp;quot;:&amp;quot; line &amp;quot;)&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">testing-vars-str</a>[m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;try-expr&lt;/b&gt; ([msg form])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Used by the 'is' macro to catch unexpected exceptions.&lt;br&gt;  You don't call this.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro try-expr&amp;lt;br&amp;gt;  &amp;quot;Used by the 'is' macro to catch unexpected exceptions.&amp;lt;br&amp;gt;  You don't call this.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [msg form]&amp;lt;br&amp;gt;  `(try ~(assert-expr msg form)&amp;lt;br&amp;gt;        (catch Throwable t#&amp;lt;br&amp;gt;          (do-report {:type :error, :message ~msg,&amp;lt;br&amp;gt;                      :expected '~form, :actual t#}))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">try-expr</a>[msg form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;with-test&lt;/b&gt; ([definition &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Takes any definition form (that returns a Var) as the first argument.&lt;br&gt;  Remaining body goes in the :test metadata function for that Var.&lt;br&gt;&lt;br&gt;  When *load-tests* is false, only evaluates the definition, ignoring&lt;br&gt;  the tests.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-test&amp;lt;br&amp;gt;  &amp;quot;Takes any definition form (that returns a Var) as the first argument.&amp;lt;br&amp;gt;  Remaining body goes in the :test metadata function for that Var.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  When *load-tests* is false, only evaluates the definition, ignoring&amp;lt;br&amp;gt;  the tests.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [definition &amp;amp; body]&amp;lt;br&amp;gt;  (if *load-tests*&amp;lt;br&amp;gt;    `(doto ~definition (alter-meta! assoc :test (fn [] ~@body)))&amp;lt;br&amp;gt;    definition))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-test</a>[definition & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test&lt;/i&gt;&lt;b&gt;with-test-out&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Runs body with *out* bound to the value of *test-out*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-test-out&amp;lt;br&amp;gt;  &amp;quot;Runs body with *out* bound to the value of *test-out*.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*out* *test-out*]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-test-out</a>[& body]</div></div></div><div class="row"><div class="namespace"><h4>clojure.test.generative</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative&lt;/i&gt;&lt;b&gt;defspec&lt;/b&gt; ([name fn-to-test args &amp; validator-body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Defines a function named name that expects args. The defined&lt;br&gt;   function binds '%' to the result of calling fn-to-test with args,&lt;br&gt;   and runs validator-body forms (if any), which have access to both&lt;br&gt;   args and %. The defined function.&lt;br&gt;&lt;br&gt;   Args must have type hints (i.e. :tag metdata), which are&lt;br&gt;   interpreted as instructions for generating test input&lt;br&gt;   data. Unquoted names in type hints are resolved in the&lt;br&gt;   c.t.g.generators namespace, which has generator functions for&lt;br&gt;   common Clojure data types. For example, the following argument list&lt;br&gt;   declares that 'seed' is an int, and that 'iters' is an int in the&lt;br&gt;   uniform distribution from 1 to 100:&lt;br&gt;&lt;br&gt;       [^int seed ^{:tag (uniform 1 100)} iters]&lt;br&gt;&lt;br&gt;   Backquoted names in an argument list are resolved in the current&lt;br&gt;   namespace, allowing arbitrary generators, e.g.&lt;br&gt;&lt;br&gt;       [^{:tag `scary-word} word]&lt;br&gt;&lt;br&gt;   The function c.t.g.runner/run-iter takes a var naming a test, and runs&lt;br&gt;   a single test iteration, generating inputs based on the arg type hints.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defspec&amp;lt;br&amp;gt;  &amp;quot;Defines a function named name that expects args. The defined&amp;lt;br&amp;gt;   function binds '%' to the result of calling fn-to-test with args,&amp;lt;br&amp;gt;   and runs validator-body forms (if any), which have access to both&amp;lt;br&amp;gt;   args and %. The defined function.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Args must have type hints (i.e. :tag metdata), which are&amp;lt;br&amp;gt;   interpreted as instructions for generating test input&amp;lt;br&amp;gt;   data. Unquoted names in type hints are resolved in the&amp;lt;br&amp;gt;   c.t.g.generators namespace, which has generator functions for&amp;lt;br&amp;gt;   common Clojure data types. For example, the following argument list&amp;lt;br&amp;gt;   declares that 'seed' is an int, and that 'iters' is an int in the&amp;lt;br&amp;gt;   uniform distribution from 1 to 100:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       [^int seed ^{:tag (uniform 1 100)} iters]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Backquoted names in an argument list are resolved in the current&amp;lt;br&amp;gt;   namespace, allowing arbitrary generators, e.g.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       [^{:tag `scary-word} word]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   The function c.t.g.runner/run-iter takes a var naming a test, and runs&amp;lt;br&amp;gt;   a single test iteration, generating inputs based on the arg type hints.&amp;quot;&amp;lt;br&amp;gt;  [name fn-to-test args &amp;amp; validator-body]&amp;lt;br&amp;gt;  (when-let [missing-tags (-&amp;gt;&amp;gt; (map #(list % (-&amp;gt; % meta :tag)) args)&amp;lt;br&amp;gt;                               (filter (fn [[_ tag]] (nil? tag)))&amp;lt;br&amp;gt;                               seq)]&amp;lt;br&amp;gt;    (throw (IllegalArgumentException. (str &amp;quot;Missing tags for &amp;quot; (seq (map first missing-tags)) &amp;quot; in &amp;quot; name))))&amp;lt;br&amp;gt;  `(defn ~(with-meta name (assoc (meta name)&amp;lt;br&amp;gt;                            ::type :defspec&amp;lt;br&amp;gt;                            ::arg-fns (into [] (map #(-&amp;gt; % meta :tag tag-&amp;gt;gen eval)  args))))&amp;lt;br&amp;gt;     ~(into [] (map (fn [a#] (with-meta a# (dissoc (meta a#) :tag))) args))&amp;lt;br&amp;gt;     (let [~'% (apply ~fn-to-test ~args)]&amp;lt;br&amp;gt;       ~@validator-body&amp;lt;br&amp;gt;       ~'%)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defspec</a>[name fn-to-test args & validator-body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative&lt;/i&gt;&lt;b&gt;fail&lt;/b&gt; ([&amp; args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro fail&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(do&amp;lt;br&amp;gt;     (runner/failed!)&amp;lt;br&amp;gt;     ~(with-meta `(event/report-context :assert/fail&amp;lt;br&amp;gt;                                        :level :warn&amp;lt;br&amp;gt;                                        ~@args)&amp;lt;br&amp;gt;        (meta &amp;amp;form))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fail</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative&lt;/i&gt;&lt;b&gt;is&lt;/b&gt; ([v] [v msg])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Assert that v is true, otherwise fail the current generative&lt;br&gt;   test (with optional msg).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro is&amp;lt;br&amp;gt;  &amp;quot;Assert that v is true, otherwise fail the current generative&amp;lt;br&amp;gt;   test (with optional msg).&amp;quot;&amp;lt;br&amp;gt;  ([v] (with-meta `(is ~v nil) (meta &amp;amp;form)))&amp;lt;br&amp;gt;  ([v msg]&amp;lt;br&amp;gt;     `(let [~'actual ~v ~'expected '~v]&amp;lt;br&amp;gt;        (if ~'actual&amp;lt;br&amp;gt;          (do&amp;lt;br&amp;gt;            (event/report :assert/pass :level :debug)&amp;lt;br&amp;gt;            ~'actual)&amp;lt;br&amp;gt;          ~(with-meta&amp;lt;br&amp;gt;             `(fail ~@(when msg `[:message ~msg]))&amp;lt;br&amp;gt;             (meta &amp;amp;form))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">is</a>[v] [v msg]</div></div></div><div class="row"><div class="namespace"><h4>clojure.test.generative.config</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.config&lt;/i&gt;&lt;b&gt;config&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn config&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (reduce&amp;lt;br&amp;gt;   (fn [m [prop path coerce default]]&amp;lt;br&amp;gt;     (let [val (System/getProperty prop)]&amp;lt;br&amp;gt;       (if (seq val)&amp;lt;br&amp;gt;         (assoc-in m path (coerce val))&amp;lt;br&amp;gt;         (assoc-in m path default))))&amp;lt;br&amp;gt;   {}&amp;lt;br&amp;gt;   config-mapping))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">config</a>[]</div></div></div><div class="row"><div class="namespace"><h4>clojure.test.generative.event</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;add-handler&lt;/b&gt; ([f])&lt;br&gt; Add a handler. Idempotent&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-handler&amp;lt;br&amp;gt;  &amp;quot;Add a handler. Idempotent&amp;quot;&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (swap!&amp;lt;br&amp;gt;   handlers&amp;lt;br&amp;gt;   (fn [v f]&amp;lt;br&amp;gt;     (if (some #{f} v)&amp;lt;br&amp;gt;       v&amp;lt;br&amp;gt;       (conj v f)))&amp;lt;br&amp;gt;   f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-handler</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;assocnn&lt;/b&gt; ([m k v] [m k v &amp; kvs])&lt;br&gt; Assoc but drop nils&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn assocnn&amp;lt;br&amp;gt;  &amp;quot;Assoc but drop nils&amp;quot;&amp;lt;br&amp;gt;  ([m k v] (if (nil? v) m (assoc m k v)))&amp;lt;br&amp;gt;  ([m k v &amp;amp; kvs] (let [ret (assocnn m k v)]&amp;lt;br&amp;gt;                   (if kvs&amp;lt;br&amp;gt;                     (recur ret (first kvs) (second kvs) (nnext kvs))&amp;lt;br&amp;gt;                     ret))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">assocnn</a>[m k v] [m k v & kvs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;create&lt;/b&gt; ([&amp; args])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn create&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  (let [t (Thread/currentThread)&amp;lt;br&amp;gt;        event (apply assocnn&amp;lt;br&amp;gt;                     {:tstamp (System/currentTimeMillis)&amp;lt;br&amp;gt;                      :thread (.getId t)&amp;lt;br&amp;gt;                      :thread/name (.getName t)&amp;lt;br&amp;gt;                      :pid pid&amp;lt;br&amp;gt;                      :level :info}&amp;lt;br&amp;gt;                     args)]&amp;lt;br&amp;gt;    (assert (keyword? (:type event)) event)&amp;lt;br&amp;gt;    event))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">create</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;fqname&lt;/b&gt; ([_])&lt;br&gt; &lt;/div&gt;" data-placement="right">fqname</a>[_]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;install-default-handlers&lt;/b&gt; ([])&lt;br&gt; Installs handler functions, a comma-delimited list of fn names, from&lt;br&gt;   clojure.test.generative.event.handlers. If none are specified, install&lt;br&gt;   c.t.g.io/console-reporter&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn install-default-handlers&amp;lt;br&amp;gt;  &amp;quot;Installs handler functions, a comma-delimited list of fn names, from&amp;lt;br&amp;gt;   clojure.test.generative.event.handlers. If none are specified, install&amp;lt;br&amp;gt;   c.t.g.io/console-reporter&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (reset! handlers [])&amp;lt;br&amp;gt;  (doseq [handler (:handlers (config/config))]&amp;lt;br&amp;gt;    (add-handler (load-var-val (symbol handler)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">install-default-handlers</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;level-enabled?&lt;/b&gt; ([event-level enable-level])&lt;br&gt; Is the event-level enabled?&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn level-enabled?&amp;lt;br&amp;gt;  &amp;quot;Is the event-level enabled?&amp;quot;&amp;lt;br&amp;gt;  [event-level enable-level]&amp;lt;br&amp;gt;  (case enable-level&amp;lt;br&amp;gt;        :error (case event-level (:error) true false)&amp;lt;br&amp;gt;        :warn (case event-level (:error :warn) true false)&amp;lt;br&amp;gt;        :info (case event-level (:error :warn :info) true false)&amp;lt;br&amp;gt;        :debug true))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">level-enabled?</a>[event-level enable-level]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;load-var-val&lt;/b&gt; ([fqname])&lt;br&gt; Load and return the value of a var&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn load-var-val&amp;lt;br&amp;gt;  &amp;quot;Load and return the value of a var&amp;quot;&amp;lt;br&amp;gt;  [fqname]&amp;lt;br&amp;gt;  (when-let [ns (namespace fqname)]&amp;lt;br&amp;gt;    (require (symbol ns)))&amp;lt;br&amp;gt;  (if-let [v (resolve fqname)]&amp;lt;br&amp;gt;    @v&amp;lt;br&amp;gt;    (throw (IllegalArgumentException. (str &amp;quot;No var named &amp;quot; fqname)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">load-var-val</a>[fqname]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;local-bindings&lt;/b&gt; ([env])&lt;br&gt; Produces a map of the names of local bindings to their values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn local-bindings&amp;lt;br&amp;gt;  &amp;quot;Produces a map of the names of local bindings to their values.&amp;quot;&amp;lt;br&amp;gt;  [env]&amp;lt;br&amp;gt;  (let [symbols (map key env)]&amp;lt;br&amp;gt;    (zipmap (map (fn [sym] `(quote ~sym)) symbols) symbols)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">local-bindings</a>[env]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;remove-handler&lt;/b&gt; ([f])&lt;br&gt; Remove a handler. Idempotent&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove-handler&amp;lt;br&amp;gt;  &amp;quot;Remove a handler. Idempotent&amp;quot;&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (swap!&amp;lt;br&amp;gt;   handlers&amp;lt;br&amp;gt;   (fn [v f]&amp;lt;br&amp;gt;     (into (empty v) (remove #{f} v)))&amp;lt;br&amp;gt;   f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove-handler</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;report&lt;/b&gt; ([type &amp; args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro report&amp;lt;br&amp;gt;  [type &amp;amp; args]&amp;lt;br&amp;gt;  (assert (even? (count args)) args)&amp;lt;br&amp;gt;  `(report-fn (create ~@args :type ~type)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">report</a>[type & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;report-context&lt;/b&gt; ([type &amp; args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Report event with contextual ns, file, line, bindings.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro report-context&amp;lt;br&amp;gt;  &amp;quot;Report event with contextual ns, file, line, bindings.&amp;quot;&amp;lt;br&amp;gt;  [type &amp;amp; args]&amp;lt;br&amp;gt;  (assert (even? (count args)) args)&amp;lt;br&amp;gt;  `(report-fn&amp;lt;br&amp;gt;    (create :locals ~(local-bindings &amp;amp;env)&amp;lt;br&amp;gt;            :file ~*file*&amp;lt;br&amp;gt;            :line ~(:line (meta &amp;amp;form))&amp;lt;br&amp;gt;            ~@args&amp;lt;br&amp;gt;            :type ~type)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">report-context</a>[type & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;report-fn&lt;/b&gt; ([event])&lt;br&gt; Call the installed handlers for an event, or io/pprint if no handlers&lt;br&gt;   installed.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn report-fn&amp;lt;br&amp;gt;  &amp;quot;Call the installed handlers for an event, or io/pprint if no handlers&amp;lt;br&amp;gt;   installed.&amp;quot;&amp;lt;br&amp;gt;  [event]&amp;lt;br&amp;gt;  (if-let [hs (seq @handlers)]&amp;lt;br&amp;gt;    (doseq [h hs]&amp;lt;br&amp;gt;      (h event))&amp;lt;br&amp;gt;    (io/pprint event)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">report-fn</a>[event]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.event&lt;/i&gt;&lt;b&gt;with-handler&lt;/b&gt; ([handler &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Run with handler temporarily installed.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-handler&amp;lt;br&amp;gt;  &amp;quot;Run with handler temporarily installed.&amp;quot;&amp;lt;br&amp;gt;  [handler &amp;amp; body]&amp;lt;br&amp;gt;  `(let [h# ~handler]&amp;lt;br&amp;gt;     (add-handler h#)&amp;lt;br&amp;gt;     (try&amp;lt;br&amp;gt;      ~@body&amp;lt;br&amp;gt;      (finally&amp;lt;br&amp;gt;       (remove-handler h#)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-handler</a>[handler & body]</div></div></div><div class="row"><div class="namespace"><h4>clojure.test.generative.io</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.io&lt;/i&gt;&lt;b&gt;await&lt;/b&gt; ([])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn await&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  &amp;quot;Wait for everything sent to the serializer&amp;quot;&amp;lt;br&amp;gt;  (send-off serializer (fn [_]))&amp;lt;br&amp;gt;  (clojure.core/await serializer))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">await</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.io&lt;/i&gt;&lt;b&gt;pr-str&lt;/b&gt; ([s])&lt;br&gt; Print with event print settings&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn pr-str&amp;lt;br&amp;gt;  &amp;quot;Print with event print settings&amp;quot;&amp;lt;br&amp;gt;  [s]&amp;lt;br&amp;gt;  (binding [*print-length* event-print-length&amp;lt;br&amp;gt;            *print-level* event-print-level]&amp;lt;br&amp;gt;    (clojure.core/pr-str s)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pr-str</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.io&lt;/i&gt;&lt;b&gt;serialized&lt;/b&gt; ([f] [f agt])&lt;br&gt; Returns a function that calls f for side effects, async,&lt;br&gt;   serialized by an agent&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn serialized&amp;lt;br&amp;gt;  &amp;quot;Returns a function that calls f for side effects, async,&amp;lt;br&amp;gt;   serialized by an agent&amp;quot;&amp;lt;br&amp;gt;  ([f] (serialized f serializer))&amp;lt;br&amp;gt;  ([f agt]&amp;lt;br&amp;gt;     (fn [&amp;amp; args]&amp;lt;br&amp;gt;       (send-off agt&amp;lt;br&amp;gt;                 (fn [_]&amp;lt;br&amp;gt;                   (try&amp;lt;br&amp;gt;                    (apply f args)&amp;lt;br&amp;gt;                    (catch Throwable t&amp;lt;br&amp;gt;                      (.printStackTrace t)))&amp;lt;br&amp;gt;                   nil))&amp;lt;br&amp;gt;       nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">serialized</a>[f] [f agt]</div></div></div><div class="row"><div class="namespace"><h4>clojure.test.generative.runner</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;-main&lt;/b&gt; ([&amp; dirs])&lt;br&gt; Command line entry point, runs all tests in dirs using clojure.test and&lt;br&gt;   test.generative. Calls System.exit!&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -main&amp;lt;br&amp;gt;  &amp;quot;Command line entry point, runs all tests in dirs using clojure.test and&amp;lt;br&amp;gt;   test.generative. Calls System.exit!&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; dirs]&amp;lt;br&amp;gt;  (if (seq dirs)&amp;lt;br&amp;gt;    (try&amp;lt;br&amp;gt;     (let [results (apply test-dirs dirs)&amp;lt;br&amp;gt;           failed? (boolean (some failed? (vals results)))]&amp;lt;br&amp;gt;       (doseq [[k v] results]&amp;lt;br&amp;gt;         (println (str &amp;quot;\nFramework &amp;quot; k))&amp;lt;br&amp;gt;         (println v))&amp;lt;br&amp;gt;       (when failed?&amp;lt;br&amp;gt;         (binding [*out* *err*]&amp;lt;br&amp;gt;           (println &amp;quot;\n*** Some tests failed ***\n&amp;quot;)))&amp;lt;br&amp;gt;       (System/exit (if failed? 1 0)))&amp;lt;br&amp;gt;     (catch Throwable t&amp;lt;br&amp;gt;       (.printStackTrace t)&amp;lt;br&amp;gt;       (System/exit -1))&amp;lt;br&amp;gt;     (finally&amp;lt;br&amp;gt;      (shutdown-agents)))&amp;lt;br&amp;gt;    (do&amp;lt;br&amp;gt;      (println &amp;quot;Specify at least one directory with tests&amp;quot;)&amp;lt;br&amp;gt;      (System/exit -1))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-main</a>[& dirs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;ct-adapter&lt;/b&gt; ([m])&lt;br&gt; Adapt clojure.test event model to fire c.t.g events.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ct-adapter&amp;lt;br&amp;gt;  &amp;quot;Adapt clojure.test event model to fire c.t.g events.&amp;quot;&amp;lt;br&amp;gt;  [m]&amp;lt;br&amp;gt;  (when-let [e (ctevent-&amp;gt;event m)]&amp;lt;br&amp;gt;    (event/report-fn e)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ct-adapter</a>[m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;failed!&lt;/b&gt; ([])&lt;br&gt; Tell the runner that a test failed&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn failed!&amp;lt;br&amp;gt;  &amp;quot;Tell the runner that a test failed&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (when *failed*&amp;lt;br&amp;gt;    (deliver *failed* :failed)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">failed!</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;failed?&lt;/b&gt; ([result])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn failed?&amp;lt;br&amp;gt;  [result]&amp;lt;br&amp;gt;  (or (:assert/fail result)&amp;lt;br&amp;gt;      (:test/fail result)&amp;lt;br&amp;gt;      (:error result)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">failed?</a>[result]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;find-vars-in-dirs&lt;/b&gt; ([&amp; dirs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-vars-in-dirs&amp;lt;br&amp;gt;  [&amp;amp; dirs]&amp;lt;br&amp;gt;  (let [nses (mapcat #(ns/find-namespaces-in-dir (java.io.File. ^String %)) dirs)]&amp;lt;br&amp;gt;    (doseq [ns nses] (require ns))&amp;lt;br&amp;gt;    (apply find-vars-in-namespaces nses)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-vars-in-dirs</a>[& dirs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;find-vars-in-namespaces&lt;/b&gt; ([&amp; nses])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-vars-in-namespaces&amp;lt;br&amp;gt;  [&amp;amp; nses]&amp;lt;br&amp;gt;  (when nses&amp;lt;br&amp;gt;    (reduce (fn [v ns] (into v (vals (ns-interns ns)))) [] nses)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-vars-in-namespaces</a>[& nses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;has-clojure-test-tests?&lt;/b&gt; ([ns])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn has-clojure-test-tests?&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (or (contains? (ns-interns ns) 'test-ns-hook)&amp;lt;br&amp;gt;      (some (comp :test meta) (vals (ns-interns ns)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">has-clojure-test-tests?</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;run-all-tests&lt;/b&gt; ([nses threads msec])&lt;br&gt; Run generative tests and clojure.test tests&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn run-all-tests&amp;lt;br&amp;gt;  &amp;quot;Run generative tests and clojure.test tests&amp;quot;&amp;lt;br&amp;gt;  [nses threads msec]&amp;lt;br&amp;gt;  (binding [ctest/report ct-adapter]&amp;lt;br&amp;gt;    (let [run-with-counts&amp;lt;br&amp;gt;          (fn [lib f]&amp;lt;br&amp;gt;            (let [event-counts (atom {})&amp;lt;br&amp;gt;                  event-counter #(when-not (contains? (:tags %) :begin)&amp;lt;br&amp;gt;                                   (when-let [type (:type %)]&amp;lt;br&amp;gt;                                     (swap! event-counts update-in [type] (fnil inc 0))))]&amp;lt;br&amp;gt;              (event/report :test/library :name lib)&amp;lt;br&amp;gt;              (event/with-handler event-counter (f))&amp;lt;br&amp;gt;              @event-counts))&amp;lt;br&amp;gt;          ct-results (run-with-counts 'clojure.test&amp;lt;br&amp;gt;                       #(when-let [ctnses (seq (filter has-clojure-test-tests? nses))]&amp;lt;br&amp;gt;                          (apply ctest/run-tests ctnses)))&amp;lt;br&amp;gt;          ctg-results (run-with-counts 'clojure.test.generative&amp;lt;br&amp;gt;                        #(run-generative-tests nses threads msec))]&amp;lt;br&amp;gt;      (io/await)&amp;lt;br&amp;gt;      {'clojure.test ct-results&amp;lt;br&amp;gt;       'clojure.test.generative ctg-results})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-all-tests</a>[nses threads msec]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;run-batch&lt;/b&gt; ([tests nthreads test-msec])&lt;br&gt; Run a batch of fs on nthreads each. Call each f repeatedly&lt;br&gt;   for up to test-msec&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn run-batch&amp;lt;br&amp;gt;  &amp;quot;Run a batch of fs on nthreads each. Call each f repeatedly&amp;lt;br&amp;gt;   for up to test-msec&amp;quot;&amp;lt;br&amp;gt;  [tests nthreads test-msec]&amp;lt;br&amp;gt;  (when (seq tests)&amp;lt;br&amp;gt;    (doseq [test tests]&amp;lt;br&amp;gt;      (run-for test nthreads test-msec))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-batch</a>[tests nthreads test-msec]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;run-for&lt;/b&gt; ([test nthreads msec])&lt;br&gt; Run f (presumably for side effects) repeatedly on n threads,&lt;br&gt;   until msec has passed or somebody signals *failed*&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn run-for&amp;lt;br&amp;gt;  &amp;quot;Run f (presumably for side effects) repeatedly on n threads,&amp;lt;br&amp;gt;   until msec has passed or somebody signals *failed*&amp;quot;&amp;lt;br&amp;gt;  [test nthreads msec]&amp;lt;br&amp;gt;  (let [start (System/currentTimeMillis)&amp;lt;br&amp;gt;        futs (doall&amp;lt;br&amp;gt;              (map&amp;lt;br&amp;gt;               #(future&amp;lt;br&amp;gt;                 (try&amp;lt;br&amp;gt;                  (let [seed (+ % 42)&amp;lt;br&amp;gt;                        name (:name test)&amp;lt;br&amp;gt;                        f (:fn test)]&amp;lt;br&amp;gt;                    (binding [gen/*rnd* (java.util.Random. seed)&amp;lt;br&amp;gt;                              *failed* (promise)]&amp;lt;br&amp;gt;                      (event/report :test/test :tags #{:begin} :test/seed seed :name name)&amp;lt;br&amp;gt;                      (loop [iter 0&amp;lt;br&amp;gt;                             [input &amp;amp; more] ((:inputs test))]&amp;lt;br&amp;gt;                        (let [now (System/currentTimeMillis)&amp;lt;br&amp;gt;                              failed? (realized? *failed*)]&amp;lt;br&amp;gt;                          (if input&amp;lt;br&amp;gt;                            (let [result (run-iter name f input)]&amp;lt;br&amp;gt;                              (if (and (&amp;lt; now (+ start msec))&amp;lt;br&amp;gt;                                       (not failed?))&amp;lt;br&amp;gt;                                (recur (inc iter) more)&amp;lt;br&amp;gt;                                (event/report :test/test&amp;lt;br&amp;gt;                                              :msec (- now start)&amp;lt;br&amp;gt;                                              :count (inc iter)&amp;lt;br&amp;gt;                                              :tags #{:end}&amp;lt;br&amp;gt;                                              :test/result (if failed? :test/fail :test/pass)&amp;lt;br&amp;gt;                                              :level (if failed? :warn :info)&amp;lt;br&amp;gt;                                              :name name)))&amp;lt;br&amp;gt;                            (event/report :test/test&amp;lt;br&amp;gt;                                          :msec (- now start)&amp;lt;br&amp;gt;                                          :count iter&amp;lt;br&amp;gt;                                          :tags #{:end :test/inputs-exhausted}&amp;lt;br&amp;gt;                                          :test/result (if failed? :test/fail :test/pass)&amp;lt;br&amp;gt;                                          :level (if failed? :warn :info)&amp;lt;br&amp;gt;                                          :name name))))))&amp;lt;br&amp;gt;                  (catch Throwable t&amp;lt;br&amp;gt;                    (event/report :error :level :error :exception t :name name))))&amp;lt;br&amp;gt;               (range nthreads)))]&amp;lt;br&amp;gt;    (doseq [f futs] @f)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-for</a>[test nthreads msec]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;run-generative-tests&lt;/b&gt; ([nses nthreads msec])&lt;br&gt; Run generative tests.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn run-generative-tests&amp;lt;br&amp;gt;  &amp;quot;Run generative tests.&amp;quot;&amp;lt;br&amp;gt;  [nses nthreads msec]&amp;lt;br&amp;gt;  (let [c (count (-&amp;gt;&amp;gt; (apply find-vars-in-namespaces nses)&amp;lt;br&amp;gt;                      (mapcat tests)))]&amp;lt;br&amp;gt;    (when-not (zero? c)&amp;lt;br&amp;gt;      (let [test-msec (quot msec c)]&amp;lt;br&amp;gt;        (doseq [ns nses]&amp;lt;br&amp;gt;          (when-let [fs (-&amp;gt;&amp;gt; (find-vars-in-namespaces ns)&amp;lt;br&amp;gt;                             (mapcat tests)&amp;lt;br&amp;gt;                             seq)]&amp;lt;br&amp;gt;            (event/report :test/group&amp;lt;br&amp;gt;                          :name ns&amp;lt;br&amp;gt;                          :tags #{:begin}&amp;lt;br&amp;gt;                          :test/threads nthreads&amp;lt;br&amp;gt;                          :test/count (count fs))&amp;lt;br&amp;gt;            (try&amp;lt;br&amp;gt;             (run-batch&amp;lt;br&amp;gt;              fs&amp;lt;br&amp;gt;              nthreads&amp;lt;br&amp;gt;              test-msec)&amp;lt;br&amp;gt;             (finally&amp;lt;br&amp;gt;              (event/report :test/group :tags #{:end} :test/threads nthreads :test/count (count fs))))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-generative-tests</a>[nses nthreads msec]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;run-iter&lt;/b&gt; ([name f input])&lt;br&gt; Run a single test iteration&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn run-iter&amp;lt;br&amp;gt;  &amp;quot;Run a single test iteration&amp;quot;&amp;lt;br&amp;gt;  [name f input]&amp;lt;br&amp;gt;  (event/report :test/iter :level :debug :name name :args input :tags #{:begin})&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;   (let [result (apply f input)]&amp;lt;br&amp;gt;     (when-not (realized? *failed*)&amp;lt;br&amp;gt;       (event/report :test/iter :level :debug :name name :return result :tags #{:end})))&amp;lt;br&amp;gt;   (catch Throwable t&amp;lt;br&amp;gt;     (deliver *failed* :error)&amp;lt;br&amp;gt;     (event/report :error :name name :exception t))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-iter</a>[name f input]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;save&lt;/b&gt; ([e])&lt;br&gt; Save results at info level or higher, using store.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn save&amp;lt;br&amp;gt;  &amp;quot;Save results at info level or higher, using store.&amp;quot;&amp;lt;br&amp;gt;  [e]&amp;lt;br&amp;gt;  (when (event/level-enabled? (:level e) :info)&amp;lt;br&amp;gt;    (store e)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">save</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;test-dirs&lt;/b&gt; ([&amp; dirs])&lt;br&gt; Runs tests in dirs, returning a map of test lib keyword&lt;br&gt;   to summary data&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn test-dirs&amp;lt;br&amp;gt;  &amp;quot;Runs tests in dirs, returning a map of test lib keyword&amp;lt;br&amp;gt;   to summary data&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; dirs]&amp;lt;br&amp;gt;  (let [nses (mapcat #(ns/find-namespaces-in-dir (java.io.File. ^String %)) dirs)&amp;lt;br&amp;gt;        conf (config/config)]&amp;lt;br&amp;gt;    (doseq [ns nses] (require ns))&amp;lt;br&amp;gt;    (event/install-default-handlers)&amp;lt;br&amp;gt;    (run-all-tests nses (:threads conf) (:msec conf))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">test-dirs</a>[& dirs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.test.generative.runner&lt;/i&gt;&lt;b&gt;tests&lt;/b&gt; ([_])&lt;br&gt; Returns a collection of generative tests, where a test is a map with&lt;br&gt;      :name     ns-qualified symbol&lt;br&gt;      :fn       fn to test&lt;br&gt;      :inputs   fn returning a (possibly infinite!) sequence of inputs&lt;br&gt;&lt;br&gt;   All input generation should use and gen/*rnd*&lt;br&gt;   if a source of pseudo-randomness is needed.&lt;/div&gt;" data-placement="right">tests</a>[_]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.analyzer</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;analysis-&gt;map&lt;/b&gt; ([aobj env])&lt;br&gt; Recursively converts the output of the Compiler's analysis to a map&lt;/div&gt;" data-placement="right">analysis->map</a>[aobj env]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;analyze-form&lt;/b&gt; ([form])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-form [form]&amp;lt;br&amp;gt;  (analyze-form-in-ns (ns-name *ns*) form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-form</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;analyze-form-in-ns&lt;/b&gt; ([nsym form])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-form-in-ns [nsym form]&amp;lt;br&amp;gt;  (analyze-one {:ns {:name nsym} :context :eval}&amp;lt;br&amp;gt;               form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-form-in-ns</a>[nsym form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;analyze-ns&lt;/b&gt; ([source-nsym] [rdr source-path source-nsym])&lt;br&gt; Takes a LineNumberingPushbackReader and a namespace symbol.&lt;br&gt;  Returns a vector of maps, with keys :op, :env. If expressions&lt;br&gt;  have children, will have :children entry.&lt;br&gt;&lt;br&gt;  eg. (analyze-path (pb-reader-for-ns 'my.ns) 'my-ns 'my-ns)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-ns&amp;lt;br&amp;gt;  &amp;quot;Takes a LineNumberingPushbackReader and a namespace symbol.&amp;lt;br&amp;gt;  Returns a vector of maps, with keys :op, :env. If expressions&amp;lt;br&amp;gt;  have children, will have :children entry.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  eg. (analyze-path (pb-reader-for-ns 'my.ns) 'my-ns 'my-ns)&amp;quot;&amp;lt;br&amp;gt;  ([source-nsym] (analyze-ns (pb-reader-for-ns source-nsym) source-nsym source-nsym))&amp;lt;br&amp;gt;  ([rdr source-path source-nsym]&amp;lt;br&amp;gt;   (let [eof (reify)&amp;lt;br&amp;gt;         ^LineNumberingPushbackReader &amp;lt;br&amp;gt;         pushback-reader (if (instance? LineNumberingPushbackReader rdr)&amp;lt;br&amp;gt;                           rdr&amp;lt;br&amp;gt;                           (LineNumberingPushbackReader. rdr))]&amp;lt;br&amp;gt;     (do&amp;lt;br&amp;gt;       (push-thread-bindings (thrd-bindings source-path source-nsym pushback-reader))&amp;lt;br&amp;gt;       (try&amp;lt;br&amp;gt;         (let [eof (reify)]&amp;lt;br&amp;gt;           (loop [form (read pushback-reader nil eof)&amp;lt;br&amp;gt;                  out []]&amp;lt;br&amp;gt;             (if (identical? form eof)&amp;lt;br&amp;gt;               out&amp;lt;br&amp;gt;               ;; FIXME shouldn't be source-nsym here&amp;lt;br&amp;gt;               (let [env {:ns {:name (-&amp;gt; @RT/CURRENT_NS str symbol)} :locals {}}&amp;lt;br&amp;gt;                     expr-ast (Compiler/analyze (keyword-&amp;gt;Context :eval) form)&amp;lt;br&amp;gt;                     m (analysis-&amp;gt;map expr-ast env)&amp;lt;br&amp;gt;                     _ (method-accessor Compiler$Expr 'eval expr-ast [])]&amp;lt;br&amp;gt;                 (recur (read pushback-reader nil eof) (conj out m))))))&amp;lt;br&amp;gt;         (finally&amp;lt;br&amp;gt;           (pop-thread-bindings)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-ns</a>[source-nsym] [rdr source-path source-nsym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;analyze-one&lt;/b&gt; ([env form])&lt;br&gt; Analyze a single form&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn analyze-one&amp;lt;br&amp;gt;  &amp;quot;Analyze a single form&amp;quot;&amp;lt;br&amp;gt;  [env form]&amp;lt;br&amp;gt;  (analyze* env form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">analyze-one</a>[env form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;ast&lt;/b&gt; ([form])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Returns the abstract syntax tree representation of the given form,&lt;br&gt;  evaluated in the current namespace&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ast &amp;lt;br&amp;gt;  &amp;quot;Returns the abstract syntax tree representation of the given form,&amp;lt;br&amp;gt;  evaluated in the current namespace&amp;quot;&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  `(analyze-form '~form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ast</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;ast-in-ns&lt;/b&gt; ([nsym form])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Returns the abstract syntax tree representation of the given form,&lt;br&gt;  evaluated in the given namespace&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ast-in-ns&amp;lt;br&amp;gt;  &amp;quot;Returns the abstract syntax tree representation of the given form,&amp;lt;br&amp;gt;  evaluated in the given namespace&amp;quot;&amp;lt;br&amp;gt;  [nsym form]&amp;lt;br&amp;gt;  `(analyze-form-in-ns '~nsym '~form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ast-in-ns</a>[nsym form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;field&lt;/b&gt; ([class-obj field] [class-obj field obj])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Call a private field, must be known at compile time. Throws an error&lt;br&gt;  if field is already publicly accessible.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro field &amp;lt;br&amp;gt;  &amp;quot;Call a private field, must be known at compile time. Throws an error&amp;lt;br&amp;gt;  if field is already publicly accessible.&amp;quot;&amp;lt;br&amp;gt;  ([class-obj field] `(field ~class-obj ~field nil))&amp;lt;br&amp;gt;  ([class-obj field obj]&amp;lt;br&amp;gt;   (let [{class-flags :flags :keys [members]} (reflect/reflect (resolve class-obj))&amp;lt;br&amp;gt;         {field-flags :flags} (some #(and (= (:name %) field) %) members)]&amp;lt;br&amp;gt;     (assert field-flags&amp;lt;br&amp;gt;             (str &amp;quot;Class &amp;quot; (resolve class-obj) &amp;quot; does not have field &amp;quot; field))&amp;lt;br&amp;gt;     (assert (not (and (:public class-flags)&amp;lt;br&amp;gt;                       (:public field-flags)))&amp;lt;br&amp;gt;             (str &amp;quot;Class &amp;quot; (resolve class-obj) &amp;quot; and field &amp;quot; field &amp;quot; is already public&amp;quot;)))&amp;lt;br&amp;gt;   `(field-accessor ~class-obj '~field ~obj)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">field</a>[class-obj field] [class-obj field obj]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;forms-seq&lt;/b&gt; ([rdr])&lt;br&gt; Lazy seq of forms in a Clojure or ClojureScript file.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn forms-seq&amp;lt;br&amp;gt;  &amp;quot;Lazy seq of forms in a Clojure or ClojureScript file.&amp;quot;&amp;lt;br&amp;gt;  [^java.io.PushbackReader rdr]&amp;lt;br&amp;gt;  (let [eof (reify)]&amp;lt;br&amp;gt;    (lazy-seq&amp;lt;br&amp;gt;      (let [form (read rdr nil eof)]&amp;lt;br&amp;gt;        (when-not (identical? form eof)&amp;lt;br&amp;gt;          (lazy-seq (cons form (forms-seq rdr))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">forms-seq</a>[rdr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;keyword-&gt;Context&lt;/b&gt; ([k])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn keyword-&amp;gt;Context [k]&amp;lt;br&amp;gt;  (case k&amp;lt;br&amp;gt;    :statement Compiler$C/STATEMENT&amp;lt;br&amp;gt;    :expression Compiler$C/EXPRESSION&amp;lt;br&amp;gt;    :return Compiler$C/RETURN&amp;lt;br&amp;gt;    :eval Compiler$C/EVAL))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">keyword->Context</a>[k]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;literal-dispatch&lt;/b&gt; ([disp-class op-keyword])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro literal-dispatch [disp-class op-keyword]&amp;lt;br&amp;gt;  `(extend-protocol AnalysisToMap&amp;lt;br&amp;gt;     ~disp-class&amp;lt;br&amp;gt;     (~'analysis-&amp;gt;map&amp;lt;br&amp;gt;       [expr# env#]&amp;lt;br&amp;gt;       (let []&amp;lt;br&amp;gt;         (merge&amp;lt;br&amp;gt;           {:op ~op-keyword&amp;lt;br&amp;gt;            :env env#&amp;lt;br&amp;gt;            :val (.eval expr#)}&amp;lt;br&amp;gt;           (when @JAVA-OBJ&amp;lt;br&amp;gt;             {:Expr-obj expr#}))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">literal-dispatch</a>[disp-class op-keyword]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;pb-reader-for-ns&lt;/b&gt; ([ns-sym])&lt;br&gt; Returns a LineNumberingPushbackReader for namespace ns-sym&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^LineNumberingPushbackReader&amp;lt;br&amp;gt;  pb-reader-for-ns&amp;lt;br&amp;gt;  &amp;quot;Returns a LineNumberingPushbackReader for namespace ns-sym&amp;quot;&amp;lt;br&amp;gt;  [ns-sym]&amp;lt;br&amp;gt;  (let [uri (uri-for-ns ns-sym)]&amp;lt;br&amp;gt;    (LineNumberingPushbackReader. (io/reader uri))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">pb-reader-for-ns</a>[ns-sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer&lt;/i&gt;&lt;b&gt;uri-for-ns&lt;/b&gt; ([ns-sym])&lt;br&gt; Returns a URI representing the namespace&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn uri-for-ns &amp;lt;br&amp;gt;  &amp;quot;Returns a URI representing the namespace&amp;quot;&amp;lt;br&amp;gt;  [ns-sym]&amp;lt;br&amp;gt;  (let [source-path (-&amp;gt; (name ns-sym)&amp;lt;br&amp;gt;                      (string/replace &amp;quot;.&amp;quot; &amp;quot;/&amp;quot;)&amp;lt;br&amp;gt;                      (string/replace &amp;quot;-&amp;quot; &amp;quot;_&amp;quot;)&amp;lt;br&amp;gt;                      (str &amp;quot;.clj&amp;quot;))]&amp;lt;br&amp;gt;    (io/resource source-path)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">uri-for-ns</a>[ns-sym]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.analyzer.emit-form</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.emit-form&lt;/i&gt;&lt;b&gt;derive-emit-default&lt;/b&gt; ([tag])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn derive-emit-default [tag]&amp;lt;br&amp;gt;  (derive tag emit-default))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">derive-emit-default</a>[tag]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.emit-form&lt;/i&gt;&lt;b&gt;emit-form&lt;/b&gt; ([expr])&lt;br&gt; Return the form represented by the given AST.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-form &amp;lt;br&amp;gt;  &amp;quot;Return the form represented by the given AST.&amp;quot;&amp;lt;br&amp;gt;  [expr]&amp;lt;br&amp;gt;  (map-&amp;gt;form expr ::emit-default))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-form</a>[expr]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.analyzer.fold</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.fold&lt;/i&gt;&lt;b&gt;add-default-fold-case&lt;/b&gt; ([ty fld-fn])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro add-default-fold-case [ty fld-fn]&amp;lt;br&amp;gt;  `(add-fold-case fold-expr-default ~ty ~fld-fn))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-default-fold-case</a>[ty fld-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.fold&lt;/i&gt;&lt;b&gt;add-fold-case&lt;/b&gt; ([mode op fld-fn])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro add-fold-case [mode op fld-fn]&amp;lt;br&amp;gt;  `(defmethod fold-expr [~mode ~op]&amp;lt;br&amp;gt;     [mode# options# expr#]&amp;lt;br&amp;gt;     (let [~'[expr-rec]&amp;lt;br&amp;gt;           (map #(or (% options#)&amp;lt;br&amp;gt;                     (partial fold-expr mode# options#))&amp;lt;br&amp;gt;                [:expr-rec])&amp;lt;br&amp;gt;           ~'map-expr-rec #(if % (map ~'expr-rec %) %)&amp;lt;br&amp;gt;           ~'if-expr-rec #(if % (~'expr-rec %) %)&amp;lt;br&amp;gt;           fld-fn# ~fld-fn]&amp;lt;br&amp;gt;       (fld-fn# expr# options#))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-fold-case</a>[mode op fld-fn]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.fold&lt;/i&gt;&lt;b&gt;derive-default-fold&lt;/b&gt; ([tag])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn derive-default-fold [tag]&amp;lt;br&amp;gt;  (derive tag fold-expr-default))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">derive-default-fold</a>[tag]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.fold&lt;/i&gt;&lt;b&gt;return-first&lt;/b&gt; ([a &amp; _])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn return-first [a &amp;amp; _] a)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">return-first</a>[a & _]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.analyzer.hygienic</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.hygienic&lt;/i&gt;&lt;b&gt;add-scope&lt;/b&gt; ([scope sym hy-sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-scope [scope sym hy-sym]&amp;lt;br&amp;gt;  {:pre [sym hy-sym scope]}&amp;lt;br&amp;gt;  (assoc scope sym hy-sym))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-scope</a>[scope sym hy-sym]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.hygienic&lt;/i&gt;&lt;b&gt;ast-hy&lt;/b&gt; ([expr])&lt;br&gt; Perform hygienic transformation on an AST&lt;br&gt;&lt;br&gt;  eg. (-&gt; (ast ...) ast-hy)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ast-hy &amp;lt;br&amp;gt;  &amp;quot;Perform hygienic transformation on an AST&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  eg. (-&amp;gt; (ast ...) ast-hy)&amp;quot;&amp;lt;br&amp;gt;  [expr]&amp;lt;br&amp;gt;  (hygienic-ast expr {}))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ast-hy</a>[expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.hygienic&lt;/i&gt;&lt;b&gt;emit-hy&lt;/b&gt; ([expr])&lt;br&gt; Emit an already-hygienic AST as a form.&lt;br&gt;&lt;br&gt;  eg. (-&gt; (ast ...) ast-hy emit-hy)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-hy &amp;lt;br&amp;gt;  &amp;quot;Emit an already-hygienic AST as a form.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  eg. (-&amp;gt; (ast ...) ast-hy emit-hy)&amp;quot;&amp;lt;br&amp;gt;  [expr]&amp;lt;br&amp;gt;  (map-&amp;gt;form expr hygienic-emit))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-hy</a>[expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.hygienic&lt;/i&gt;&lt;b&gt;hygienic-ast&lt;/b&gt; ([expr scope])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hygienic-ast [expr scope]&amp;lt;br&amp;gt;  (assert expr)&amp;lt;br&amp;gt;  (assert scope)&amp;lt;br&amp;gt;  (fold-expr ::hygienic&amp;lt;br&amp;gt;    {:expr-rec #(hygienic-ast % scope)&amp;lt;br&amp;gt;     :locals {::scope scope}}&amp;lt;br&amp;gt;    expr))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hygienic-ast</a>[expr scope]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.hygienic&lt;/i&gt;&lt;b&gt;hygienic-lbs&lt;/b&gt; ([lbs scope])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hygienic-lbs [lbs scope]&amp;lt;br&amp;gt;  (reduce (fn [[hy-lbs scope] {:keys [sym] :as local-binding}]&amp;lt;br&amp;gt;            {:pre [(vector? hy-lbs)]}&amp;lt;br&amp;gt;            (let [hy-local-binding (hygienic-local-binding local-binding scope true)&amp;lt;br&amp;gt;                  hy-sym (hsym-key hy-local-binding)&amp;lt;br&amp;gt;                  new-scope (add-scope scope sym hy-sym)]&amp;lt;br&amp;gt;              [(conj hy-lbs hy-local-binding) new-scope]))&amp;lt;br&amp;gt;          [[] scope] lbs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hygienic-lbs</a>[lbs scope]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.hygienic&lt;/i&gt;&lt;b&gt;hygienic-local-binding&lt;/b&gt; ([{:keys [op init sym], :as local-binding} scope new-sym?])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hygienic-local-binding [{:keys [op init sym] :as local-binding} scope new-sym?]&amp;lt;br&amp;gt;  {:pre [(= :local-binding op)]}&amp;lt;br&amp;gt;  (let [hy-init (when init&amp;lt;br&amp;gt;                  (hygienic-ast init scope))&amp;lt;br&amp;gt;        hy-sym (if new-sym?&amp;lt;br&amp;gt;                 (hygienic-sym scope sym)&amp;lt;br&amp;gt;                 (scope sym))&amp;lt;br&amp;gt;        _ (assert hy-sym (str &amp;quot;Local &amp;quot; sym &amp;quot; not in scope.&amp;quot;))]&amp;lt;br&amp;gt;    (assoc local-binding&amp;lt;br&amp;gt;           :init hy-init&amp;lt;br&amp;gt;           hsym-key hy-sym)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hygienic-local-binding</a>[{:keys [op init sym], :as local-binding} scope new-sym?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.hygienic&lt;/i&gt;&lt;b&gt;hygienic-name&lt;/b&gt; ([name scope])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hygienic-name [name scope]&amp;lt;br&amp;gt;  (let [hy-name (when name&amp;lt;br&amp;gt;                  (hygienic-sym scope name))&amp;lt;br&amp;gt;        new-scope (if hy-name&amp;lt;br&amp;gt;                    (add-scope scope name hy-name)&amp;lt;br&amp;gt;                    scope)]&amp;lt;br&amp;gt;    [hy-name new-scope]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hygienic-name</a>[name scope]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.hygienic&lt;/i&gt;&lt;b&gt;hygienic-sym&lt;/b&gt; ([scope sym])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn hygienic-sym [scope sym]&amp;lt;br&amp;gt;  ;only generate unique when shadowing&amp;lt;br&amp;gt;  (if (scope sym)&amp;lt;br&amp;gt;    (gensym sym)&amp;lt;br&amp;gt;    sym))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">hygienic-sym</a>[scope sym]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.analyzer.util</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.util&lt;/i&gt;&lt;b&gt;expr-seq&lt;/b&gt; ([expr])&lt;br&gt; Given an expression, returns a lazy sequence of the expressions&lt;br&gt;  followed by its children (in a depth first manner)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn expr-seq&amp;lt;br&amp;gt;  &amp;quot;Given an expression, returns a lazy sequence of the expressions&amp;lt;br&amp;gt;  followed by its children (in a depth first manner)&amp;quot;&amp;lt;br&amp;gt;  [expr]&amp;lt;br&amp;gt;  (tree-seq :children&amp;lt;br&amp;gt;            :children&amp;lt;br&amp;gt;            expr))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">expr-seq</a>[expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.analyzer.util&lt;/i&gt;&lt;b&gt;print-expr&lt;/b&gt; ([expr &amp; exclusions])&lt;br&gt; Pretty-prints expr, excluding supplied keys.&lt;br&gt;  Example: (print-expr expr :children :env)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn print-expr&amp;lt;br&amp;gt;  &amp;quot;Pretty-prints expr, excluding supplied keys.&amp;lt;br&amp;gt;  Example: (print-expr expr :children :env)&amp;quot;&amp;lt;br&amp;gt;  [expr &amp;amp; exclusions]&amp;lt;br&amp;gt;  (pp/pprint (apply dissoc-rec expr exclusions)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">print-expr</a>[expr & exclusions]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.cli</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.cli&lt;/i&gt;&lt;b&gt;cli&lt;/b&gt; ([args &amp; specs])&lt;br&gt; Parse the provided args using the given specs. Specs are vectors&lt;br&gt;  describing a command line argument. For example:&lt;br&gt;&lt;br&gt;  [&quot;-p&quot; &quot;--port&quot; &quot;Port to listen on&quot; :default 3000 :parse-fn #(Integer/parseInt %)]&lt;br&gt;&lt;br&gt;  First provide the switches (from least to most specific), then a doc&lt;br&gt;  string, and pairs of options.&lt;br&gt;&lt;br&gt;  Valid options are :default, :parse-fn, and :flag. See&lt;br&gt;  https://github.com/clojure/tools.cli/blob/master/README.md for more&lt;br&gt;  detailed examples.&lt;br&gt;&lt;br&gt;  Returns a vector containing a map of the parsed arguments, a vector&lt;br&gt;  of extra arguments that did not match known switches, and a&lt;br&gt;  documentation banner to provide usage instructions.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cli&amp;lt;br&amp;gt;  &amp;quot;Parse the provided args using the given specs. Specs are vectors&amp;lt;br&amp;gt;  describing a command line argument. For example:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  [\&amp;quot;-p\&amp;quot; \&amp;quot;--port\&amp;quot; \&amp;quot;Port to listen on\&amp;quot; :default 3000 :parse-fn #(Integer/parseInt %)]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  First provide the switches (from least to most specific), then a doc&amp;lt;br&amp;gt;  string, and pairs of options.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Valid options are :default, :parse-fn, and :flag. See&amp;lt;br&amp;gt;  https://github.com/clojure/tools.cli/blob/master/README.md for more&amp;lt;br&amp;gt;  detailed examples.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Returns a vector containing a map of the parsed arguments, a vector&amp;lt;br&amp;gt;  of extra arguments that did not match known switches, and a&amp;lt;br&amp;gt;  documentation banner to provide usage instructions.&amp;quot;&amp;lt;br&amp;gt;  [args &amp;amp; specs]&amp;lt;br&amp;gt;  (let [specs (map generate-spec specs)]&amp;lt;br&amp;gt;    (let [[options extra-args] (apply-specs specs args)&amp;lt;br&amp;gt;          banner  (with-out-str (banner-for specs))]&amp;lt;br&amp;gt;      [options extra-args banner])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cli</a>[args & specs]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.logging</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;debug&lt;/b&gt; ([message &amp; more] [throwable message &amp; more])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Debug level logging using print-style args.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro debug&amp;lt;br&amp;gt;  &amp;quot;Debug level logging using print-style args.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([message &amp;amp; more] [throwable message &amp;amp; more])}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(logp :debug ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">debug</a>[message & more] [throwable message & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;debugf&lt;/b&gt; ([fmt &amp; fmt-args] [throwable fmt &amp; fmt-args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Debug level logging using format.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro debugf&amp;lt;br&amp;gt;  &amp;quot;Debug level logging using format.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([fmt &amp;amp; fmt-args] [throwable fmt &amp;amp; fmt-args])}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(logf :debug ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">debugf</a>[fmt & fmt-args] [throwable fmt & fmt-args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;enabled?&lt;/b&gt; ([level] [level logger-ns])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Returns true if the specific logging level is enabled.  Use of this macro&lt;br&gt;  should only be necessary if one needs to execute alternate code paths beyond&lt;br&gt;  whether the log should be written to.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro enabled?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the specific logging level is enabled.  Use of this macro&amp;lt;br&amp;gt;  should only be necessary if one needs to execute alternate code paths beyond&amp;lt;br&amp;gt;  whether the log should be written to.&amp;quot;&amp;lt;br&amp;gt;  ([level]&amp;lt;br&amp;gt;    `(enabled? ~level ~*ns*))&amp;lt;br&amp;gt;  ([level logger-ns]&amp;lt;br&amp;gt;    `(impl/enabled? (impl/get-logger *logger-factory* ~logger-ns) ~level)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">enabled?</a>[level] [level logger-ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;error&lt;/b&gt; ([message &amp; more] [throwable message &amp; more])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Error level logging using print-style args.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro error&amp;lt;br&amp;gt;  &amp;quot;Error level logging using print-style args.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([message &amp;amp; more] [throwable message &amp;amp; more])}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(logp :error ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">error</a>[message & more] [throwable message & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;errorf&lt;/b&gt; ([fmt &amp; fmt-args] [throwable fmt &amp; fmt-args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Error level logging using format.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro errorf&amp;lt;br&amp;gt;  &amp;quot;Error level logging using format.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([fmt &amp;amp; fmt-args] [throwable fmt &amp;amp; fmt-args])}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(logf :error ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">errorf</a>[fmt & fmt-args] [throwable fmt & fmt-args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;fatal&lt;/b&gt; ([message &amp; more] [throwable message &amp; more])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Fatal level logging using print-style args.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro fatal&amp;lt;br&amp;gt;  &amp;quot;Fatal level logging using print-style args.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([message &amp;amp; more] [throwable message &amp;amp; more])}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(logp :fatal ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fatal</a>[message & more] [throwable message & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;fatalf&lt;/b&gt; ([fmt &amp; fmt-args] [throwable fmt &amp; fmt-args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Fatal level logging using format.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro fatalf&amp;lt;br&amp;gt;  &amp;quot;Fatal level logging using format.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([fmt &amp;amp; fmt-args] [throwable fmt &amp;amp; fmt-args])}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(logf :fatal ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fatalf</a>[fmt & fmt-args] [throwable fmt & fmt-args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;info&lt;/b&gt; ([message &amp; more] [throwable message &amp; more])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Info level logging using print-style args.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro info&amp;lt;br&amp;gt;  &amp;quot;Info level logging using print-style args.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([message &amp;amp; more] [throwable message &amp;amp; more])}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(logp :info ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">info</a>[message & more] [throwable message & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;infof&lt;/b&gt; ([fmt &amp; fmt-args] [throwable fmt &amp; fmt-args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Info level logging using format.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro infof&amp;lt;br&amp;gt;  &amp;quot;Info level logging using format.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([fmt &amp;amp; fmt-args] [throwable fmt &amp;amp; fmt-args])}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(logf :info ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">infof</a>[fmt & fmt-args] [throwable fmt & fmt-args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;log&lt;/b&gt; ([level message] [level throwable message] [logger-ns level throwable message] [logger-factory logger-ns level throwable message])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates and logs a message only if the specified level is enabled. See log*&lt;br&gt;  for more details.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro log&amp;lt;br&amp;gt;  &amp;quot;Evaluates and logs a message only if the specified level is enabled. See log*&amp;lt;br&amp;gt;  for more details.&amp;quot;&amp;lt;br&amp;gt;  ([level message]&amp;lt;br&amp;gt;    `(log ~level nil ~message))&amp;lt;br&amp;gt;  ([level throwable message]&amp;lt;br&amp;gt;    `(log ~*ns* ~level ~throwable ~message))&amp;lt;br&amp;gt;  ([logger-ns level throwable message]&amp;lt;br&amp;gt;    `(log *logger-factory* ~logger-ns ~level ~throwable ~message))&amp;lt;br&amp;gt;  ([logger-factory logger-ns level throwable message]&amp;lt;br&amp;gt;    `(let [logger# (impl/get-logger ~logger-factory ~logger-ns)]&amp;lt;br&amp;gt;       (if (impl/enabled? logger# ~level)&amp;lt;br&amp;gt;         (log* logger# ~level ~throwable ~message)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">log</a>[level message] [level throwable message] [logger-ns level throwable message] [logger-factory logger-ns level throwable message]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;log*&lt;/b&gt; ([logger level throwable message])&lt;br&gt; Attempts to log a message, either directly or via an agent; does not check if&lt;br&gt;  the level is enabled.&lt;br&gt;&lt;br&gt;  For performance reasons, an agent will only be used when invoked within a&lt;br&gt;  running transaction, and only for logging levels specified by&lt;br&gt;  *tx-agent-levels*. This allows those entries to only be written once the&lt;br&gt;  transaction commits, and are discarded if it is retried or aborted.  As&lt;br&gt;  corollary, other levels (e.g., :debug, :error) will be written even from&lt;br&gt;  failed transactions though at the cost of repeat messages during retries.&lt;br&gt;&lt;br&gt;  One can override the above by setting *force* to :direct or :agent; all&lt;br&gt;  subsequent writes will be direct or via an agent, respectively.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn log*&amp;lt;br&amp;gt;  &amp;quot;Attempts to log a message, either directly or via an agent; does not check if&amp;lt;br&amp;gt;  the level is enabled.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  For performance reasons, an agent will only be used when invoked within a&amp;lt;br&amp;gt;  running transaction, and only for logging levels specified by&amp;lt;br&amp;gt;  *tx-agent-levels*. This allows those entries to only be written once the&amp;lt;br&amp;gt;  transaction commits, and are discarded if it is retried or aborted.  As&amp;lt;br&amp;gt;  corollary, other levels (e.g., :debug, :error) will be written even from&amp;lt;br&amp;gt;  failed transactions though at the cost of repeat messages during retries.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  One can override the above by setting *force* to :direct or :agent; all&amp;lt;br&amp;gt;  subsequent writes will be direct or via an agent, respectively.&amp;quot;&amp;lt;br&amp;gt;  [logger level throwable message]&amp;lt;br&amp;gt;  (if (cond&amp;lt;br&amp;gt;        (nil? *force*) (and (clojure.lang.LockingTransaction/isRunning)&amp;lt;br&amp;gt;                            (*tx-agent-levels* level))&amp;lt;br&amp;gt;        (= *force* :agent)  true&amp;lt;br&amp;gt;        (= *force* :direct) false)&amp;lt;br&amp;gt;    (send-off *logging-agent*&amp;lt;br&amp;gt;      (fn [_#] (impl/write! logger level throwable message)))&amp;lt;br&amp;gt;    (impl/write! logger level throwable message)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">log*</a>[logger level throwable message]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;log-capture!&lt;/b&gt; ([logger-ns] [logger-ns out-level err-level])&lt;br&gt; Captures System.out and System.err, piping all writes of those streams to&lt;br&gt;    the log. If unspecified, levels default to :info and :error, respectively.&lt;br&gt;    The specified logger-ns value will be used to namespace all log entries.&lt;br&gt;&lt;br&gt;    Note: use with-logs to redirect output of *out* or *err*.&lt;br&gt;&lt;br&gt;    Warning: if the logging implementation is configured to output to System.out&lt;br&gt;    (as is the default with java.util.logging) then using this function will&lt;br&gt;    result in StackOverflowException when writing to the log.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;  (defn log-capture!&amp;lt;br&amp;gt;    &amp;quot;Captures System.out and System.err, piping all writes of those streams to&amp;lt;br&amp;gt;    the log. If unspecified, levels default to :info and :error, respectively.&amp;lt;br&amp;gt;    The specified logger-ns value will be used to namespace all log entries.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    Note: use with-logs to redirect output of *out* or *err*.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    Warning: if the logging implementation is configured to output to System.out&amp;lt;br&amp;gt;    (as is the default with java.util.logging) then using this function will&amp;lt;br&amp;gt;    result in StackOverflowException when writing to the log.&amp;quot;&amp;lt;br&amp;gt;    ; Implementation Notes:&amp;lt;br&amp;gt;    ; - only set orig when nil to preserve original out/err&amp;lt;br&amp;gt;    ; - no enabled? check before making streams since that may change later&amp;lt;br&amp;gt;    ([logger-ns]&amp;lt;br&amp;gt;      (log-capture! logger-ns :info :error))&amp;lt;br&amp;gt;    ([logger-ns out-level err-level]&amp;lt;br&amp;gt;      (locking monitor&amp;lt;br&amp;gt;        (compare-and-set! orig nil [System/out System/err])&amp;lt;br&amp;gt;        (System/setOut  (log-stream out-level logger-ns))&amp;lt;br&amp;gt;        (System/setErr (log-stream err-level logger-ns)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">log-capture!</a>[logger-ns] [logger-ns out-level err-level]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;log-stream&lt;/b&gt; ([level logger-ns])&lt;br&gt; Creates a PrintStream that will output to the log at the specified level.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn log-stream&amp;lt;br&amp;gt;  &amp;quot;Creates a PrintStream that will output to the log at the specified level.&amp;quot;&amp;lt;br&amp;gt;  [level logger-ns]&amp;lt;br&amp;gt;  (let [logger (impl/get-logger *logger-factory* logger-ns)]&amp;lt;br&amp;gt;    (java.io.PrintStream.&amp;lt;br&amp;gt;      (proxy [java.io.ByteArrayOutputStream] []&amp;lt;br&amp;gt;        (flush []&amp;lt;br&amp;gt;          ; deal with reflection in proxy-super&amp;lt;br&amp;gt;          (let [^java.io.ByteArrayOutputStream this this]&amp;lt;br&amp;gt;            (proxy-super flush)&amp;lt;br&amp;gt;            (let [message (.trim (.toString this))]&amp;lt;br&amp;gt;              (proxy-super reset)&amp;lt;br&amp;gt;              (if (&amp;gt; (.length message) 0)&amp;lt;br&amp;gt;                (log* logger level nil message))))))&amp;lt;br&amp;gt;      true)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">log-stream</a>[level logger-ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;log-uncapture!&lt;/b&gt; ([])&lt;br&gt; Restores System.out and System.err to their original values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;  (defn log-uncapture!&amp;lt;br&amp;gt;    &amp;quot;Restores System.out and System.err to their original values.&amp;quot;&amp;lt;br&amp;gt;    []&amp;lt;br&amp;gt;    (locking monitor&amp;lt;br&amp;gt;      (when-let [[out err :as v] @orig]&amp;lt;br&amp;gt;        (swap! orig (constantly nil))&amp;lt;br&amp;gt;        (System/setOut out)&amp;lt;br&amp;gt;        (System/setErr err))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">log-uncapture!</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;logf&lt;/b&gt; ([level fmt &amp; fmt-args] [level throwable fmt &amp; fmt-args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Logs a message using a format string and args. Can optionally take a&lt;br&gt;  throwable as its second arg. See level-specific macros, e.g., debugf.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro logf&amp;lt;br&amp;gt;  &amp;quot;Logs a message using a format string and args. Can optionally take a&amp;lt;br&amp;gt;  throwable as its second arg. See level-specific macros, e.g., debugf.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([level fmt &amp;amp; fmt-args] [level throwable fmt &amp;amp; fmt-args])}&amp;lt;br&amp;gt;  [level x &amp;amp; more]&amp;lt;br&amp;gt;  (if (or (instance? String x) (nil? more)) ; optimize for common case&amp;lt;br&amp;gt;    `(log ~level (format ~x ~@more))&amp;lt;br&amp;gt;    `(let [logger# (impl/get-logger *logger-factory* ~*ns*)]&amp;lt;br&amp;gt;       (if (impl/enabled? logger# ~level)&amp;lt;br&amp;gt;         (let [x# ~x]&amp;lt;br&amp;gt;           (if (instance? Throwable x#) ; type check only when enabled&amp;lt;br&amp;gt;             (log* logger# ~level x# (format ~@more))&amp;lt;br&amp;gt;             (log* logger# ~level nil (format x# ~@more))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">logf</a>[level fmt & fmt-args] [level throwable fmt & fmt-args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;logp&lt;/b&gt; ([level message &amp; more] [level throwable message &amp; more])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Logs a message using print style args. Can optionally take a throwable as its&lt;br&gt;  second arg. See level-specific macros, e.g., debug.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro logp&amp;lt;br&amp;gt;  &amp;quot;Logs a message using print style args. Can optionally take a throwable as its&amp;lt;br&amp;gt;  second arg. See level-specific macros, e.g., debug.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([level message &amp;amp; more] [level throwable message &amp;amp; more])}&amp;lt;br&amp;gt;  [level x &amp;amp; more]&amp;lt;br&amp;gt;  (if (or (instance? String x) (nil? more)) ; optimize for common case&amp;lt;br&amp;gt;    `(log ~level (print-str ~x ~@more))&amp;lt;br&amp;gt;    `(let [logger# (impl/get-logger *logger-factory* ~*ns*)]&amp;lt;br&amp;gt;       (if (impl/enabled? logger# ~level)&amp;lt;br&amp;gt;         (let [x# ~x]&amp;lt;br&amp;gt;           (if (instance? Throwable x#) ; type check only when enabled&amp;lt;br&amp;gt;             (log* logger# ~level x# (print-str ~@more))&amp;lt;br&amp;gt;             (log* logger# ~level nil (print-str x# ~@more))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">logp</a>[level message & more] [level throwable message & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;spy&lt;/b&gt; ([expr] [level expr])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates expr and may write the form and its result to the log. Returns the&lt;br&gt;  result of expr. Defaults to :debug log level.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro spy&amp;lt;br&amp;gt;  &amp;quot;Evaluates expr and may write the form and its result to the log. Returns the&amp;lt;br&amp;gt;  result of expr. Defaults to :debug log level.&amp;quot;&amp;lt;br&amp;gt;  ([expr]&amp;lt;br&amp;gt;    `(spy :debug ~expr))&amp;lt;br&amp;gt;  ([level expr]&amp;lt;br&amp;gt;    `(let [a# ~expr]&amp;lt;br&amp;gt;       (log ~level&amp;lt;br&amp;gt;         (let [s# (with-out-str&amp;lt;br&amp;gt;                    (with-pprint-dispatch code-dispatch ; need a better way&amp;lt;br&amp;gt;                      (pprint '~expr)&amp;lt;br&amp;gt;                      (print &amp;quot;=&amp;gt; &amp;quot;)&amp;lt;br&amp;gt;                      (pprint a#)))]&amp;lt;br&amp;gt;           (trim-newline s#)))&amp;lt;br&amp;gt;       a#)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">spy</a>[expr] [level expr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;trace&lt;/b&gt; ([message &amp; more] [throwable message &amp; more])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Trace level logging using print-style args.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro trace&amp;lt;br&amp;gt;  &amp;quot;Trace level logging using print-style args.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([message &amp;amp; more] [throwable message &amp;amp; more])}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(logp :trace ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace</a>[message & more] [throwable message & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;tracef&lt;/b&gt; ([fmt &amp; fmt-args] [throwable fmt &amp; fmt-args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Trace level logging using format.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro tracef&amp;lt;br&amp;gt;  &amp;quot;Trace level logging using format.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([fmt &amp;amp; fmt-args] [throwable fmt &amp;amp; fmt-args])}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(logf :trace ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tracef</a>[fmt & fmt-args] [throwable fmt & fmt-args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;warn&lt;/b&gt; ([message &amp; more] [throwable message &amp; more])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Warn level logging using print-style args.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro warn&amp;lt;br&amp;gt;  &amp;quot;Warn level logging using print-style args.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([message &amp;amp; more] [throwable message &amp;amp; more])}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(logp :warn ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">warn</a>[message & more] [throwable message & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;warnf&lt;/b&gt; ([fmt &amp; fmt-args] [throwable fmt &amp; fmt-args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Warn level logging using format.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro warnf&amp;lt;br&amp;gt;  &amp;quot;Warn level logging using format.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([fmt &amp;amp; fmt-args] [throwable fmt &amp;amp; fmt-args])}&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  `(logf :warn ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">warnf</a>[fmt & fmt-args] [throwable fmt & fmt-args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging&lt;/i&gt;&lt;b&gt;with-logs&lt;/b&gt; ([logger-ns &amp; body] [[logger-ns out-level err-level] &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Evaluates exprs in a context in which *out* and *err* write to the log. The&lt;br&gt;  specified logger-ns value will be used to namespace all log entries.&lt;br&gt;&lt;br&gt;  By default *out* and *err* write to :info and :error, respectively.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-logs&amp;lt;br&amp;gt;  &amp;quot;Evaluates exprs in a context in which *out* and *err* write to the log. The&amp;lt;br&amp;gt;  specified logger-ns value will be used to namespace all log entries.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  By default *out* and *err* write to :info and :error, respectively.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([logger-ns &amp;amp; body]&amp;lt;br&amp;gt;               [[logger-ns out-level err-level] &amp;amp; body])}&amp;lt;br&amp;gt;  [arg &amp;amp; body]&amp;lt;br&amp;gt;  ; Implementation Notes:&amp;lt;br&amp;gt;  ; - no enabled? check before making writers since that may change later&amp;lt;br&amp;gt;  (let [[logger-ns out-level err-level] (if (vector? arg)&amp;lt;br&amp;gt;                                       arg&amp;lt;br&amp;gt;                                       [arg :info :error])]&amp;lt;br&amp;gt;    (if (and logger-ns (seq body))&amp;lt;br&amp;gt;      `(binding [*out* (java.io.OutputStreamWriter.&amp;lt;br&amp;gt;                         (log-stream ~out-level ~logger-ns))&amp;lt;br&amp;gt;                 *err* (java.io.OutputStreamWriter.&amp;lt;br&amp;gt;                         (log-stream ~err-level ~logger-ns))]&amp;lt;br&amp;gt;         ~@body))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-logs</a>[logger-ns & body] [[logger-ns out-level err-level] & body]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.logging.impl</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging.impl&lt;/i&gt;&lt;b&gt;cl-factory&lt;/b&gt; ([])&lt;br&gt; Returns a Commons Logging-based implementation of the LoggerFactory protocol, or&lt;br&gt;  nil if not available.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn cl-factory&amp;lt;br&amp;gt;  &amp;quot;Returns a Commons Logging-based implementation of the LoggerFactory protocol, or&amp;lt;br&amp;gt;  nil if not available.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;    (Class/forName &amp;quot;org.apache.commons.logging.Log&amp;quot;)&amp;lt;br&amp;gt;    (eval&amp;lt;br&amp;gt;      `(do&amp;lt;br&amp;gt;         (extend org.apache.commons.logging.Log&amp;lt;br&amp;gt;           Logger&amp;lt;br&amp;gt;           {:enabled?&amp;lt;br&amp;gt;            (fn [^org.apache.commons.logging.Log logger# level#]&amp;lt;br&amp;gt;              (condp = level#&amp;lt;br&amp;gt;                :trace (.isTraceEnabled logger#)&amp;lt;br&amp;gt;                :debug (.isDebugEnabled logger#)&amp;lt;br&amp;gt;                :info  (.isInfoEnabled  logger#)&amp;lt;br&amp;gt;                :warn  (.isWarnEnabled  logger#)&amp;lt;br&amp;gt;                :error (.isErrorEnabled logger#)&amp;lt;br&amp;gt;                :fatal (.isFatalEnabled logger#)&amp;lt;br&amp;gt;                (throw (IllegalArgumentException. (str level#)))))&amp;lt;br&amp;gt;            :write!&amp;lt;br&amp;gt;            (fn [^org.apache.commons.logging.Log logger# level# e# msg#]&amp;lt;br&amp;gt;              (if e#&amp;lt;br&amp;gt;                (condp = level#&amp;lt;br&amp;gt;                  :trace (.trace logger# msg# e#)&amp;lt;br&amp;gt;                  :debug (.debug logger# msg# e#)&amp;lt;br&amp;gt;                  :info  (.info  logger# msg# e#)&amp;lt;br&amp;gt;                  :warn  (.warn  logger# msg# e#)&amp;lt;br&amp;gt;                  :error (.error logger# msg# e#)&amp;lt;br&amp;gt;                  :fatal (.fatal logger# msg# e#)&amp;lt;br&amp;gt;                  (throw (IllegalArgumentException. (str level#))))&amp;lt;br&amp;gt;                (condp = level#&amp;lt;br&amp;gt;                  :trace (.trace logger# msg#)&amp;lt;br&amp;gt;                  :debug (.debug logger# msg#)&amp;lt;br&amp;gt;                  :info  (.info  logger# msg#)&amp;lt;br&amp;gt;                  :warn  (.warn  logger# msg#)&amp;lt;br&amp;gt;                  :error (.error logger# msg#)&amp;lt;br&amp;gt;                  :fatal (.fatal logger# msg#)&amp;lt;br&amp;gt;                  (throw (IllegalArgumentException. (str level#))))))})&amp;lt;br&amp;gt;         (reify LoggerFactory&amp;lt;br&amp;gt;           (name [_#]&amp;lt;br&amp;gt;             &amp;quot;org.apache.commons.logging&amp;quot;)&amp;lt;br&amp;gt;           (get-logger [_# logger-ns#]&amp;lt;br&amp;gt;             (org.apache.commons.logging.LogFactory/getLog (str logger-ns#))))))&amp;lt;br&amp;gt;    (catch Exception e nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">cl-factory</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging.impl&lt;/i&gt;&lt;b&gt;enabled?&lt;/b&gt; ([logger level])&lt;br&gt; Check if a particular level is enabled for the given Logger.&lt;/div&gt;" data-placement="right">enabled?</a>[logger level]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging.impl&lt;/i&gt;&lt;b&gt;find-factory&lt;/b&gt; ([])&lt;br&gt; Returns the first non-nil value from slf4j-factory, cl-factory,&lt;br&gt;   log4j-factory, and jul-factory.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-factory&amp;lt;br&amp;gt;  &amp;quot;Returns the first non-nil value from slf4j-factory, cl-factory,&amp;lt;br&amp;gt;   log4j-factory, and jul-factory.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (or (slf4j-factory)&amp;lt;br&amp;gt;      (cl-factory)&amp;lt;br&amp;gt;      (log4j-factory)&amp;lt;br&amp;gt;      (jul-factory)&amp;lt;br&amp;gt;      (throw ; this should never happen in 1.5+&amp;lt;br&amp;gt;        (RuntimeException.&amp;lt;br&amp;gt;          &amp;quot;Valid logging implementation could not be found.&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-factory</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging.impl&lt;/i&gt;&lt;b&gt;get-logger&lt;/b&gt; ([factory logger-ns])&lt;br&gt; Returns an implementation-specific Logger by namespace.&lt;/div&gt;" data-placement="right">get-logger</a>[factory logger-ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging.impl&lt;/i&gt;&lt;b&gt;jul-factory&lt;/b&gt; ([])&lt;br&gt; Returns a java.util.logging-based implementation of the LoggerFactory protocol,&lt;br&gt;  or nil if not available.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn jul-factory&amp;lt;br&amp;gt;  &amp;quot;Returns a java.util.logging-based implementation of the LoggerFactory protocol,&amp;lt;br&amp;gt;  or nil if not available.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;    (Class/forName &amp;quot;java.util.logging.Logger&amp;quot;)&amp;lt;br&amp;gt;    (eval&amp;lt;br&amp;gt;      `(let [levels# {:trace java.util.logging.Level/FINEST&amp;lt;br&amp;gt;                      :debug java.util.logging.Level/FINE&amp;lt;br&amp;gt;                      :info  java.util.logging.Level/INFO&amp;lt;br&amp;gt;                      :warn  java.util.logging.Level/WARNING&amp;lt;br&amp;gt;                      :error java.util.logging.Level/SEVERE&amp;lt;br&amp;gt;                      :fatal java.util.logging.Level/SEVERE}]&amp;lt;br&amp;gt;         (extend java.util.logging.Logger&amp;lt;br&amp;gt;           Logger&amp;lt;br&amp;gt;           {:enabled?&amp;lt;br&amp;gt;            (fn [^java.util.logging.Logger logger# level#]&amp;lt;br&amp;gt;              (.isLoggable logger#&amp;lt;br&amp;gt;                (or&amp;lt;br&amp;gt;                  (levels# level#)&amp;lt;br&amp;gt;                  (throw (IllegalArgumentException. (str level#))))))&amp;lt;br&amp;gt;            :write!&amp;lt;br&amp;gt;            (fn [^java.util.logging.Logger logger# level# ^Throwable e# msg#]&amp;lt;br&amp;gt;              (let [^java.util.logging.Level level#&amp;lt;br&amp;gt;                    (or&amp;lt;br&amp;gt;                      (levels# level#)&amp;lt;br&amp;gt;                      (throw (IllegalArgumentException. (str level#))))&amp;lt;br&amp;gt;                    ^String msg# (str msg#)]&amp;lt;br&amp;gt;                (if e#&amp;lt;br&amp;gt;                  (.log logger# level# msg# e#)&amp;lt;br&amp;gt;                  (.log logger# level# msg#))))})&amp;lt;br&amp;gt;         (reify LoggerFactory&amp;lt;br&amp;gt;           (name [_#]&amp;lt;br&amp;gt;             &amp;quot;java.util.logging&amp;quot;)&amp;lt;br&amp;gt;           (get-logger [_# logger-ns#]&amp;lt;br&amp;gt;             (java.util.logging.Logger/getLogger (str logger-ns#))))))&amp;lt;br&amp;gt;    (catch Exception e nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">jul-factory</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging.impl&lt;/i&gt;&lt;b&gt;log4j-factory&lt;/b&gt; ([])&lt;br&gt; Returns a Log4j-based implementation of the LoggerFactory protocol, or nil if&lt;br&gt;  not available.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn log4j-factory&amp;lt;br&amp;gt;  &amp;quot;Returns a Log4j-based implementation of the LoggerFactory protocol, or nil if&amp;lt;br&amp;gt;  not available.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;    (Class/forName &amp;quot;org.apache.log4j.Logger&amp;quot;)&amp;lt;br&amp;gt;    (eval&amp;lt;br&amp;gt;      `(let [levels# {:trace org.apache.log4j.Level/TRACE&amp;lt;br&amp;gt;                      :debug org.apache.log4j.Level/DEBUG&amp;lt;br&amp;gt;                      :info  org.apache.log4j.Level/INFO&amp;lt;br&amp;gt;                      :warn  org.apache.log4j.Level/WARN&amp;lt;br&amp;gt;                      :error org.apache.log4j.Level/ERROR&amp;lt;br&amp;gt;                      :fatal org.apache.log4j.Level/FATAL}]&amp;lt;br&amp;gt;         (extend org.apache.log4j.Logger&amp;lt;br&amp;gt;           Logger&amp;lt;br&amp;gt;           {:enabled?&amp;lt;br&amp;gt;            (fn [^org.apache.log4j.Logger logger# level#]&amp;lt;br&amp;gt;              (.isEnabledFor logger#&amp;lt;br&amp;gt;                 (or&amp;lt;br&amp;gt;                   (levels# level#)&amp;lt;br&amp;gt;                   (throw (IllegalArgumentException. (str level#))))))&amp;lt;br&amp;gt;            :write!&amp;lt;br&amp;gt;            (fn [^org.apache.log4j.Logger logger# level# e# msg#]&amp;lt;br&amp;gt;              (let [level# (or&amp;lt;br&amp;gt;                             (levels# level#)&amp;lt;br&amp;gt;                             (throw (IllegalArgumentException. (str level#))))]&amp;lt;br&amp;gt;                (if e#&amp;lt;br&amp;gt;                  (.log logger# level# msg# e#)&amp;lt;br&amp;gt;                  (.log logger# level# msg#))))})&amp;lt;br&amp;gt;         (reify LoggerFactory&amp;lt;br&amp;gt;           (name [_#]&amp;lt;br&amp;gt;             &amp;quot;org.apache.log4j&amp;quot;)&amp;lt;br&amp;gt;           (get-logger [_# logger-ns#]&amp;lt;br&amp;gt;             (org.apache.log4j.Logger/getLogger ^String (str logger-ns#))))))&amp;lt;br&amp;gt;    (catch Exception e nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">log4j-factory</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging.impl&lt;/i&gt;&lt;b&gt;name&lt;/b&gt; ([factory])&lt;br&gt; Returns some text identifying the underlying implementation.&lt;/div&gt;" data-placement="right">name</a>[factory]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging.impl&lt;/i&gt;&lt;b&gt;slf4j-factory&lt;/b&gt; ([])&lt;br&gt; Returns a SLF4J-based implementation of the LoggerFactory protocol, or nil if&lt;br&gt;  not available.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn slf4j-factory&amp;lt;br&amp;gt;  &amp;quot;Returns a SLF4J-based implementation of the LoggerFactory protocol, or nil if&amp;lt;br&amp;gt;  not available.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;    (Class/forName &amp;quot;org.slf4j.Logger&amp;quot;)&amp;lt;br&amp;gt;    (eval&amp;lt;br&amp;gt;      `(do&amp;lt;br&amp;gt;        (extend org.slf4j.Logger&amp;lt;br&amp;gt;          Logger&amp;lt;br&amp;gt;          {:enabled?&amp;lt;br&amp;gt;           (fn [^org.slf4j.Logger logger# level#]&amp;lt;br&amp;gt;             (condp = level#&amp;lt;br&amp;gt;               :trace (.isTraceEnabled logger#)&amp;lt;br&amp;gt;               :debug (.isDebugEnabled logger#)&amp;lt;br&amp;gt;               :info  (.isInfoEnabled  logger#)&amp;lt;br&amp;gt;               :warn  (.isWarnEnabled  logger#)&amp;lt;br&amp;gt;               :error (.isErrorEnabled logger#)&amp;lt;br&amp;gt;               :fatal (.isErrorEnabled logger#)&amp;lt;br&amp;gt;               (throw (IllegalArgumentException. (str level#)))))&amp;lt;br&amp;gt;           :write!&amp;lt;br&amp;gt;           (fn [^org.slf4j.Logger logger# level# ^Throwable e# msg#]&amp;lt;br&amp;gt;             (let [^String msg# (str msg#)]&amp;lt;br&amp;gt;               (if e#&amp;lt;br&amp;gt;                 (condp = level#&amp;lt;br&amp;gt;                   :trace (.trace logger# msg# e#)&amp;lt;br&amp;gt;                   :debug (.debug logger# msg# e#)&amp;lt;br&amp;gt;                   :info  (.info  logger# msg# e#)&amp;lt;br&amp;gt;                   :warn  (.warn  logger# msg# e#)&amp;lt;br&amp;gt;                   :error (.error logger# msg# e#)&amp;lt;br&amp;gt;                   :fatal (.error logger# msg# e#)&amp;lt;br&amp;gt;                   (throw (IllegalArgumentException. (str level#))))&amp;lt;br&amp;gt;                 (condp = level#&amp;lt;br&amp;gt;                   :trace (.trace logger# msg#)&amp;lt;br&amp;gt;                   :debug (.debug logger# msg#)&amp;lt;br&amp;gt;                   :info  (.info  logger# msg#)&amp;lt;br&amp;gt;                   :warn  (.warn  logger# msg#)&amp;lt;br&amp;gt;                   :error (.error logger# msg#)&amp;lt;br&amp;gt;                   :fatal (.error logger# msg#)&amp;lt;br&amp;gt;                   (throw (IllegalArgumentException. (str level#)))))))})&amp;lt;br&amp;gt;        (reify LoggerFactory&amp;lt;br&amp;gt;          (name [_#]&amp;lt;br&amp;gt;            &amp;quot;org.slf4j&amp;quot;)&amp;lt;br&amp;gt;          (get-logger [_# logger-ns#]&amp;lt;br&amp;gt;            (org.slf4j.LoggerFactory/getLogger ^String (str logger-ns#))))))&amp;lt;br&amp;gt;    (catch Exception e nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">slf4j-factory</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.logging.impl&lt;/i&gt;&lt;b&gt;write!&lt;/b&gt; ([logger level throwable message])&lt;br&gt; Writes a log message to the given Logger.&lt;/div&gt;" data-placement="right">write!</a>[logger level throwable message]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.macro</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.macro&lt;/i&gt;&lt;b&gt;defsymbolmacro&lt;/b&gt; ([symbol expansion])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a symbol macro. Because symbol macros are not part of&lt;br&gt;   Clojure's built-in macro expansion system, they can be used only&lt;br&gt;   inside a with-symbol-macros form.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defsymbolmacro&amp;lt;br&amp;gt;  &amp;quot;Define a symbol macro. Because symbol macros are not part of&amp;lt;br&amp;gt;   Clojure's built-in macro expansion system, they can be used only&amp;lt;br&amp;gt;   inside a with-symbol-macros form.&amp;quot;&amp;lt;br&amp;gt;  [symbol expansion]&amp;lt;br&amp;gt;  (let [meta-map (if (meta symbol) (meta symbol) {})&amp;lt;br&amp;gt;        meta-map (assoc meta-map :symbol-macro true)]&amp;lt;br&amp;gt;  `(def ~(with-meta symbol meta-map) (quote ~expansion))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defsymbolmacro</a>[symbol expansion]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.macro&lt;/i&gt;&lt;b&gt;deftemplate&lt;/b&gt; ([name params &amp; forms])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a macro that expands into forms after replacing the&lt;br&gt;   symbols in params (a vector) by the corresponding parameters&lt;br&gt;   given in the macro call.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro deftemplate&amp;lt;br&amp;gt;  &amp;quot;Define a macro that expands into forms after replacing the&amp;lt;br&amp;gt;   symbols in params (a vector) by the corresponding parameters&amp;lt;br&amp;gt;   given in the macro call.&amp;quot;&amp;lt;br&amp;gt;  [name params &amp;amp; forms]&amp;lt;br&amp;gt;  (let [param-map (for [p params] (list (list 'quote p) (gensym)))&amp;lt;br&amp;gt;        template-params (vec (map second param-map))&amp;lt;br&amp;gt;        param-map (vec (apply concat param-map))&amp;lt;br&amp;gt;        expansion (list 'list (list 'quote `symbol-macrolet) param-map&amp;lt;br&amp;gt;                        (list 'quote (cons 'do forms)))]&amp;lt;br&amp;gt;    `(defmacro ~name ~template-params ~expansion)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">deftemplate</a>[name params & forms]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.macro&lt;/i&gt;&lt;b&gt;macrolet&lt;/b&gt; ([fn-bindings &amp; exprs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define local macros that are used in the expansion of exprs. The&lt;br&gt;   syntax is the same as for letfn forms.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro macrolet&amp;lt;br&amp;gt;  &amp;quot;Define local macros that are used in the expansion of exprs. The&amp;lt;br&amp;gt;   syntax is the same as for letfn forms.&amp;quot;&amp;lt;br&amp;gt;  [fn-bindings &amp;amp; exprs]&amp;lt;br&amp;gt;  (let [names      (map first fn-bindings)&amp;lt;br&amp;gt;        name-map   (into {} (map (fn [n] [(list 'quote n) n]) names))&amp;lt;br&amp;gt;        macro-map  (eval `(letfn ~fn-bindings ~name-map))]&amp;lt;br&amp;gt;    (binding [macro-fns     (merge macro-fns macro-map)&amp;lt;br&amp;gt;              macro-symbols (apply dissoc macro-symbols names)]&amp;lt;br&amp;gt;      `(do ~@(doall (map expand-all exprs))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">macrolet</a>[fn-bindings & exprs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.macro&lt;/i&gt;&lt;b&gt;mexpand&lt;/b&gt; ([form])&lt;br&gt; Like clojure.core/macroexpand, but takes into account symbol macros.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mexpand&amp;lt;br&amp;gt;  &amp;quot;Like clojure.core/macroexpand, but takes into account symbol macros.&amp;quot;&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (binding [macro-fns {}&amp;lt;br&amp;gt;            macro-symbols {}&amp;lt;br&amp;gt;            protected-symbols #{}]&amp;lt;br&amp;gt;    (expand form)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mexpand</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.macro&lt;/i&gt;&lt;b&gt;mexpand-1&lt;/b&gt; ([form])&lt;br&gt; Like clojure.core/macroexpand-1, but takes into account symbol macros.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mexpand-1&amp;lt;br&amp;gt;  &amp;quot;Like clojure.core/macroexpand-1, but takes into account symbol macros.&amp;quot;&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (binding [macro-fns {}&amp;lt;br&amp;gt;            macro-symbols {}&amp;lt;br&amp;gt;            protected-symbols #{}]&amp;lt;br&amp;gt;    (expand-1 form)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mexpand-1</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.macro&lt;/i&gt;&lt;b&gt;mexpand-all&lt;/b&gt; ([form])&lt;br&gt; Perform a full recursive macro expansion of a form.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn mexpand-all&amp;lt;br&amp;gt;  &amp;quot;Perform a full recursive macro expansion of a form.&amp;quot;&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (binding [macro-fns {}&amp;lt;br&amp;gt;            macro-symbols {}&amp;lt;br&amp;gt;            protected-symbols #{}]&amp;lt;br&amp;gt;    (expand-all form)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">mexpand-all</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.macro&lt;/i&gt;&lt;b&gt;name-with-attributes&lt;/b&gt; ([name macro-args])&lt;br&gt; To be used in macro definitions.&lt;br&gt;   Handles optional docstrings and attribute maps for a name to be defined&lt;br&gt;   in a list of macro arguments. If the first macro argument is a string,&lt;br&gt;   it is added as a docstring to name and removed from the macro argument&lt;br&gt;   list. If afterwards the first macro argument is a map, its entries are&lt;br&gt;   added to the name's metadata map and the map is removed from the&lt;br&gt;   macro argument list. The return value is a vector containing the name&lt;br&gt;   with its extended metadata map and the list of unprocessed macro&lt;br&gt;   arguments.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn name-with-attributes&amp;lt;br&amp;gt;  &amp;quot;To be used in macro definitions.&amp;lt;br&amp;gt;   Handles optional docstrings and attribute maps for a name to be defined&amp;lt;br&amp;gt;   in a list of macro arguments. If the first macro argument is a string,&amp;lt;br&amp;gt;   it is added as a docstring to name and removed from the macro argument&amp;lt;br&amp;gt;   list. If afterwards the first macro argument is a map, its entries are&amp;lt;br&amp;gt;   added to the name's metadata map and the map is removed from the&amp;lt;br&amp;gt;   macro argument list. The return value is a vector containing the name&amp;lt;br&amp;gt;   with its extended metadata map and the list of unprocessed macro&amp;lt;br&amp;gt;   arguments.&amp;quot;&amp;lt;br&amp;gt;  [name macro-args]&amp;lt;br&amp;gt;  (let [[docstring macro-args] (if (string? (first macro-args))&amp;lt;br&amp;gt;                                 [(first macro-args) (next macro-args)]&amp;lt;br&amp;gt;                                 [nil macro-args])&amp;lt;br&amp;gt;    [attr macro-args]          (if (map? (first macro-args))&amp;lt;br&amp;gt;                                 [(first macro-args) (next macro-args)]&amp;lt;br&amp;gt;                                 [{} macro-args])&amp;lt;br&amp;gt;    attr                       (if docstring&amp;lt;br&amp;gt;                                 (assoc attr :doc docstring)&amp;lt;br&amp;gt;                                 attr)&amp;lt;br&amp;gt;    attr                       (if (meta name)&amp;lt;br&amp;gt;                                 (conj (meta name) attr)&amp;lt;br&amp;gt;                                 attr)]&amp;lt;br&amp;gt;    [(with-meta name attr) macro-args]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">name-with-attributes</a>[name macro-args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.macro&lt;/i&gt;&lt;b&gt;symbol-macrolet&lt;/b&gt; ([symbol-bindings &amp; exprs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define local symbol macros that are used in the expansion of exprs.&lt;br&gt;   The syntax is the same as for let forms.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro symbol-macrolet&amp;lt;br&amp;gt;  &amp;quot;Define local symbol macros that are used in the expansion of exprs.&amp;lt;br&amp;gt;   The syntax is the same as for let forms.&amp;quot;&amp;lt;br&amp;gt;  [symbol-bindings &amp;amp; exprs]&amp;lt;br&amp;gt;  (let [symbol-map (into {} (map vec (partition 2 symbol-bindings)))&amp;lt;br&amp;gt;        names      (keys symbol-map)]&amp;lt;br&amp;gt;    (binding [macro-fns     (apply dissoc macro-fns names)&amp;lt;br&amp;gt;              macro-symbols (merge macro-symbols symbol-map)]&amp;lt;br&amp;gt;      `(do ~@(doall (map expand-all exprs))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">symbol-macrolet</a>[symbol-bindings & exprs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.macro&lt;/i&gt;&lt;b&gt;with-symbol-macros&lt;/b&gt; ([&amp; exprs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Fully expand exprs, including symbol macros.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-symbol-macros&amp;lt;br&amp;gt;  &amp;quot;Fully expand exprs, including symbol macros.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; exprs]&amp;lt;br&amp;gt;  `(do ~@(doall (map expand-all exprs))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-symbol-macros</a>[& exprs]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.namespace</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;clojure-source-file?&lt;/b&gt; ([file])&lt;br&gt; DEPRECATED; trivial to implement locally&lt;br&gt;&lt;br&gt;  Returns true if file is a normal file with a .clj extension.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn clojure-source-file?&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; trivial to implement locally&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Returns true if file is a normal file with a .clj extension.&amp;quot;&amp;lt;br&amp;gt;  [^File file]&amp;lt;br&amp;gt;  (and (.isFile file)&amp;lt;br&amp;gt;       (.endsWith (.getName file) &amp;quot;.clj&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">clojure-source-file?</a>[file]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;clojure-sources-in-jar&lt;/b&gt; ([jar-file])&lt;br&gt; DEPRECATED; moved to clojure.tools.namespace.find&lt;br&gt;&lt;br&gt;  Returns a sequence of filenames ending in .clj found in the JAR file.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn clojure-sources-in-jar&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; moved to clojure.tools.namespace.find&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Returns a sequence of filenames ending in .clj found in the JAR file.&amp;quot;&amp;lt;br&amp;gt;  [^JarFile jar-file]&amp;lt;br&amp;gt;  (filter #(.endsWith ^String % &amp;quot;.clj&amp;quot;) (filenames-in-jar jar-file)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">clojure-sources-in-jar</a>[jar-file]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;comment?&lt;/b&gt; ([form])&lt;br&gt; DEPRECATED; moved to clojure.tools.namespace.parse&lt;br&gt;&lt;br&gt;  Returns true if form is a (comment ...)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn comment?&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; moved to clojure.tools.namespace.parse&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Returns true if form is a (comment ...)&amp;quot;&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (and (list? form) (= 'comment (first form))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">comment?</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;find-clojure-sources-in-dir&lt;/b&gt; ([dir])&lt;br&gt; DEPRECATED; moved to clojure.tools.namespace.find&lt;br&gt;&lt;br&gt;  Searches recursively under dir for Clojure source files (.clj).&lt;br&gt;  Returns a sequence of File objects, in breadth-first sort order.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-clojure-sources-in-dir&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; moved to clojure.tools.namespace.find&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Searches recursively under dir for Clojure source files (.clj).&amp;lt;br&amp;gt;  Returns a sequence of File objects, in breadth-first sort order.&amp;quot;&amp;lt;br&amp;gt;  [^File dir]&amp;lt;br&amp;gt;  ;; Use sort by absolute path to get breadth-first search.&amp;lt;br&amp;gt;  (sort-by #(.getAbsolutePath ^File %)&amp;lt;br&amp;gt;           (filter clojure-source-file? (file-seq dir))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-clojure-sources-in-dir</a>[dir]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;find-namespaces-in-dir&lt;/b&gt; ([dir])&lt;br&gt; DEPRECATED; moved to clojure.tools.namespace.find&lt;br&gt;&lt;br&gt;  Searches dir recursively for (ns ...) declarations in Clojure&lt;br&gt;  source files; returns the symbol names of the declared namespaces.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-namespaces-in-dir&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; moved to clojure.tools.namespace.find&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Searches dir recursively for (ns ...) declarations in Clojure&amp;lt;br&amp;gt;  source files; returns the symbol names of the declared namespaces.&amp;quot;&amp;lt;br&amp;gt;  [^File dir]&amp;lt;br&amp;gt;  (map second (find-ns-decls-in-dir dir)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-namespaces-in-dir</a>[dir]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;find-namespaces-in-jarfile&lt;/b&gt; ([jarfile])&lt;br&gt; DEPRECATED; moved to clojure.tools.namespace.find&lt;br&gt;&lt;br&gt;  Searches the JAR file for Clojure source files containing (ns ...)&lt;br&gt;  declarations.  Returns a sequence of the symbol names of the&lt;br&gt;  declared namespaces.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-namespaces-in-jarfile&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; moved to clojure.tools.namespace.find&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Searches the JAR file for Clojure source files containing (ns ...)&amp;lt;br&amp;gt;  declarations.  Returns a sequence of the symbol names of the&amp;lt;br&amp;gt;  declared namespaces.&amp;quot;&amp;lt;br&amp;gt;  [^JarFile jarfile]&amp;lt;br&amp;gt;  (map second (find-ns-decls-in-jarfile jarfile)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-namespaces-in-jarfile</a>[jarfile]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;find-namespaces-on-classpath&lt;/b&gt; ([])&lt;br&gt; DEPRECATED; use clojure.tools.namespace.find/find-namespaces&lt;br&gt;  and clojure.java.classpath/classpath from&lt;br&gt;  http://github.com/clojure/java.classpath&lt;br&gt;&lt;br&gt;  Searches CLASSPATH (both directories and JAR files) for Clojure&lt;br&gt;  source files containing (ns ...) declarations.  Returns a sequence&lt;br&gt;  of the symbol names of the declared namespaces.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-namespaces-on-classpath&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; use clojure.tools.namespace.find/find-namespaces&amp;lt;br&amp;gt;  and clojure.java.classpath/classpath from&amp;lt;br&amp;gt;  http://github.com/clojure/java.classpath&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Searches CLASSPATH (both directories and JAR files) for Clojure&amp;lt;br&amp;gt;  source files containing (ns ...) declarations.  Returns a sequence&amp;lt;br&amp;gt;  of the symbol names of the declared namespaces.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (map second (find-ns-decls-on-classpath)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-namespaces-on-classpath</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;find-ns-decls-in-dir&lt;/b&gt; ([dir])&lt;br&gt; DEPRECATED; moved to clojure.tools.namespace.find&lt;br&gt;&lt;br&gt;  Searches dir recursively for (ns ...) declarations in Clojure&lt;br&gt;  source files; returns the unevaluated ns declarations.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-ns-decls-in-dir&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; moved to clojure.tools.namespace.find&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Searches dir recursively for (ns ...) declarations in Clojure&amp;lt;br&amp;gt;  source files; returns the unevaluated ns declarations.&amp;quot;&amp;lt;br&amp;gt;  [^File dir]&amp;lt;br&amp;gt;  (filter identity (map read-file-ns-decl (find-clojure-sources-in-dir dir))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-ns-decls-in-dir</a>[dir]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;find-ns-decls-in-jarfile&lt;/b&gt; ([jarfile])&lt;br&gt; DEPRECATED; moved to clojure.tools.namespace.find&lt;br&gt;&lt;br&gt;  Searches the JAR file for Clojure source files containing (ns ...)&lt;br&gt;  declarations; returns the unevaluated ns declarations.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-ns-decls-in-jarfile&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; moved to clojure.tools.namespace.find&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Searches the JAR file for Clojure source files containing (ns ...)&amp;lt;br&amp;gt;  declarations; returns the unevaluated ns declarations.&amp;quot;&amp;lt;br&amp;gt;  [^JarFile jarfile]&amp;lt;br&amp;gt;  (filter identity&amp;lt;br&amp;gt;          (map #(read-ns-decl-from-jarfile-entry jarfile %)&amp;lt;br&amp;gt;               (clojure-sources-in-jar jarfile))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-ns-decls-in-jarfile</a>[jarfile]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;find-ns-decls-on-classpath&lt;/b&gt; ([])&lt;br&gt; DEPRECATED; use clojure.tools.namespace.find/find-ns-decls&lt;br&gt;  and clojure.java.classpath/classpath from&lt;br&gt;  http://github.com/clojure/java.classpath&lt;br&gt;&lt;br&gt;  Searches CLASSPATH (both directories and JAR files) for Clojure&lt;br&gt;  source files containing (ns ...) declarations. Returns a sequence of&lt;br&gt;  the unevaluated ns declaration forms.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-ns-decls-on-classpath&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; use clojure.tools.namespace.find/find-ns-decls&amp;lt;br&amp;gt;  and clojure.java.classpath/classpath from&amp;lt;br&amp;gt;  http://github.com/clojure/java.classpath&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Searches CLASSPATH (both directories and JAR files) for Clojure&amp;lt;br&amp;gt;  source files containing (ns ...) declarations. Returns a sequence of&amp;lt;br&amp;gt;  the unevaluated ns declaration forms.&amp;quot; []&amp;lt;br&amp;gt;  (concat&amp;lt;br&amp;gt;   (mapcat find-ns-decls-in-dir (classpath-directories))&amp;lt;br&amp;gt;   (mapcat find-ns-decls-in-jarfile (classpath-jarfiles))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-ns-decls-on-classpath</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;ns-decl?&lt;/b&gt; ([form])&lt;br&gt; DEPRECATED; moved to clojure.tools.namespace.parse&lt;br&gt;&lt;br&gt;  Returns true if form is a (ns ...) declaration.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-decl?&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; moved to clojure.tools.namespace.parse&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Returns true if form is a (ns ...) declaration.&amp;quot;&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (and (list? form) (= 'ns (first form))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-decl?</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;read-file-ns-decl&lt;/b&gt; ([file])&lt;br&gt; DEPRECATED; moved to clojure.tools.namespace.file&lt;br&gt;&lt;br&gt;  Attempts to read a (ns ...) declaration from file, and returns the&lt;br&gt;  unevaluated form.  Returns nil if read fails, or if the first form&lt;br&gt;  is not a ns declaration.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-file-ns-decl&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; moved to clojure.tools.namespace.file&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Attempts to read a (ns ...) declaration from file, and returns the&amp;lt;br&amp;gt;  unevaluated form.  Returns nil if read fails, or if the first form&amp;lt;br&amp;gt;  is not a ns declaration.&amp;quot;&amp;lt;br&amp;gt;  [^File file]&amp;lt;br&amp;gt;  (with-open [rdr (PushbackReader. (BufferedReader. (FileReader. file)))]&amp;lt;br&amp;gt;    (read-ns-decl rdr)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-file-ns-decl</a>[file]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;read-ns-decl&lt;/b&gt; ([rdr])&lt;br&gt; DEPRECATED; moved to clojure.tools.namespace.parse&lt;br&gt;&lt;br&gt;  Attempts to read a (ns ...) declaration from rdr, and returns the&lt;br&gt;  unevaluated form.  Returns nil if read fails or if a ns declaration&lt;br&gt;  cannot be found.  The ns declaration must be the first Clojure form&lt;br&gt;  in the file, except for (comment ...)  forms.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-ns-decl&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; moved to clojure.tools.namespace.parse&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Attempts to read a (ns ...) declaration from rdr, and returns the&amp;lt;br&amp;gt;  unevaluated form.  Returns nil if read fails or if a ns declaration&amp;lt;br&amp;gt;  cannot be found.  The ns declaration must be the first Clojure form&amp;lt;br&amp;gt;  in the file, except for (comment ...)  forms.&amp;quot;&amp;lt;br&amp;gt;  [^PushbackReader rdr]&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;   (loop [] (let [form (doto (read rdr) str)]&amp;lt;br&amp;gt;              (cond&amp;lt;br&amp;gt;               (ns-decl? form) form&amp;lt;br&amp;gt;               (comment? form) (recur)&amp;lt;br&amp;gt;               :else nil)))&amp;lt;br&amp;gt;       (catch Exception e nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-ns-decl</a>[rdr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace&lt;/i&gt;&lt;b&gt;read-ns-decl-from-jarfile-entry&lt;/b&gt; ([jarfile entry-name])&lt;br&gt; DEPRECATED; moved to clojure.tools.namespace.find&lt;br&gt;&lt;br&gt;  Attempts to read a (ns ...) declaration from the named entry in the&lt;br&gt;  JAR file, and returns the unevaluated form.  Returns nil if the read&lt;br&gt;  fails, or if the first form is not a ns declaration.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-ns-decl-from-jarfile-entry&amp;lt;br&amp;gt;  &amp;quot;DEPRECATED; moved to clojure.tools.namespace.find&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Attempts to read a (ns ...) declaration from the named entry in the&amp;lt;br&amp;gt;  JAR file, and returns the unevaluated form.  Returns nil if the read&amp;lt;br&amp;gt;  fails, or if the first form is not a ns declaration.&amp;quot;&amp;lt;br&amp;gt;  [^JarFile jarfile ^String entry-name]&amp;lt;br&amp;gt;  (with-open [rdr (PushbackReader.&amp;lt;br&amp;gt;                   (BufferedReader.&amp;lt;br&amp;gt;                    (InputStreamReader.&amp;lt;br&amp;gt;                     (.getInputStream jarfile (.getEntry jarfile entry-name)))))]&amp;lt;br&amp;gt;    (read-ns-decl rdr)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-ns-decl-from-jarfile-entry</a>[jarfile entry-name]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.namespace.dependency</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;-&gt;MapDependencyGraph&lt;/b&gt; ([dependencies dependents])&lt;br&gt; Positional factory function for class clojure.tools.namespace.dependency.MapDependencyGraph.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord MapDependencyGraph [dependencies dependents]&amp;lt;br&amp;gt;  DependencyGraph&amp;lt;br&amp;gt;  (immediate-dependencies [graph node]&amp;lt;br&amp;gt;    (get dependencies node #{}))&amp;lt;br&amp;gt;  (immediate-dependents [graph node]&amp;lt;br&amp;gt;    (get dependents node #{}))&amp;lt;br&amp;gt;  (transitive-dependencies [graph node]&amp;lt;br&amp;gt;    (transitive dependencies node))&amp;lt;br&amp;gt;  (transitive-dependents [graph node]&amp;lt;br&amp;gt;    (transitive dependents node))&amp;lt;br&amp;gt;  (nodes [graph]&amp;lt;br&amp;gt;    (clojure.set/union (set (keys dependencies))&amp;lt;br&amp;gt;                       (set (keys dependents))))&amp;lt;br&amp;gt;  DependencyGraphUpdate&amp;lt;br&amp;gt;  (depend [graph node dep]&amp;lt;br&amp;gt;    (when (depends? graph dep node)&amp;lt;br&amp;gt;      (let [^String msg (binding [*print-length* 10]&amp;lt;br&amp;gt;                          (str &amp;quot;Circular dependency between &amp;quot;&amp;lt;br&amp;gt;                               (pr-str node) &amp;quot; and &amp;quot; (pr-str dep)))]&amp;lt;br&amp;gt;        (throw (Exception. msg))))&amp;lt;br&amp;gt;    (MapDependencyGraph.&amp;lt;br&amp;gt;     (update-in dependencies [node] set-conj dep)&amp;lt;br&amp;gt;     (update-in dependents [dep] set-conj node)))&amp;lt;br&amp;gt;  (remove-edge [graph node dep]&amp;lt;br&amp;gt;    (MapDependencyGraph.&amp;lt;br&amp;gt;     (update-in dependencies [node] disj dep)&amp;lt;br&amp;gt;     (update-in dependents [dep] disj node)))&amp;lt;br&amp;gt;  (remove-all [graph node]&amp;lt;br&amp;gt;    (MapDependencyGraph.&amp;lt;br&amp;gt;     (remove-from-map dependencies node)&amp;lt;br&amp;gt;     (remove-from-map dependents node)))&amp;lt;br&amp;gt;  (remove-node [graph node]&amp;lt;br&amp;gt;    (MapDependencyGraph.&amp;lt;br&amp;gt;     (dissoc dependencies node)&amp;lt;br&amp;gt;     dependents)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->MapDependencyGraph</a>[dependencies dependents]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;depend&lt;/b&gt; ([graph node dep])&lt;br&gt; Returns a new graph with a dependency from node to dep (&quot;node depends&lt;br&gt;    on dep&quot;). Forbids circular dependencies.&lt;/div&gt;" data-placement="right">depend</a>[graph node dep]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;dependent?&lt;/b&gt; ([graph x y])&lt;br&gt; True if y is a dependent of x.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dependent?&amp;lt;br&amp;gt;  &amp;quot;True if y is a dependent of x.&amp;quot;&amp;lt;br&amp;gt;  [graph x y]&amp;lt;br&amp;gt;  (contains? (transitive-dependents graph x) y))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dependent?</a>[graph x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;depends?&lt;/b&gt; ([graph x y])&lt;br&gt; True if x is directly or transitively dependent on y.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn depends?&amp;lt;br&amp;gt;  &amp;quot;True if x is directly or transitively dependent on y.&amp;quot;&amp;lt;br&amp;gt;  [graph x y]&amp;lt;br&amp;gt;  (contains? (transitive-dependencies graph x) y))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">depends?</a>[graph x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;graph&lt;/b&gt; ([])&lt;br&gt; Returns a new, empty, dependency graph.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn graph &amp;quot;Returns a new, empty, dependency graph.&amp;quot; []&amp;lt;br&amp;gt;  (-&amp;gt;MapDependencyGraph {} {}))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">graph</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;immediate-dependencies&lt;/b&gt; ([graph node])&lt;br&gt; Returns the set of immediate dependencies of node.&lt;/div&gt;" data-placement="right">immediate-dependencies</a>[graph node]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;immediate-dependents&lt;/b&gt; ([graph node])&lt;br&gt; Returns the set of immediate dependents of node.&lt;/div&gt;" data-placement="right">immediate-dependents</a>[graph node]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;map-&gt;MapDependencyGraph&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clojure.tools.namespace.dependency.MapDependencyGraph, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord MapDependencyGraph [dependencies dependents]&amp;lt;br&amp;gt;  DependencyGraph&amp;lt;br&amp;gt;  (immediate-dependencies [graph node]&amp;lt;br&amp;gt;    (get dependencies node #{}))&amp;lt;br&amp;gt;  (immediate-dependents [graph node]&amp;lt;br&amp;gt;    (get dependents node #{}))&amp;lt;br&amp;gt;  (transitive-dependencies [graph node]&amp;lt;br&amp;gt;    (transitive dependencies node))&amp;lt;br&amp;gt;  (transitive-dependents [graph node]&amp;lt;br&amp;gt;    (transitive dependents node))&amp;lt;br&amp;gt;  (nodes [graph]&amp;lt;br&amp;gt;    (clojure.set/union (set (keys dependencies))&amp;lt;br&amp;gt;                       (set (keys dependents))))&amp;lt;br&amp;gt;  DependencyGraphUpdate&amp;lt;br&amp;gt;  (depend [graph node dep]&amp;lt;br&amp;gt;    (when (depends? graph dep node)&amp;lt;br&amp;gt;      (let [^String msg (binding [*print-length* 10]&amp;lt;br&amp;gt;                          (str &amp;quot;Circular dependency between &amp;quot;&amp;lt;br&amp;gt;                               (pr-str node) &amp;quot; and &amp;quot; (pr-str dep)))]&amp;lt;br&amp;gt;        (throw (Exception. msg))))&amp;lt;br&amp;gt;    (MapDependencyGraph.&amp;lt;br&amp;gt;     (update-in dependencies [node] set-conj dep)&amp;lt;br&amp;gt;     (update-in dependents [dep] set-conj node)))&amp;lt;br&amp;gt;  (remove-edge [graph node dep]&amp;lt;br&amp;gt;    (MapDependencyGraph.&amp;lt;br&amp;gt;     (update-in dependencies [node] disj dep)&amp;lt;br&amp;gt;     (update-in dependents [dep] disj node)))&amp;lt;br&amp;gt;  (remove-all [graph node]&amp;lt;br&amp;gt;    (MapDependencyGraph.&amp;lt;br&amp;gt;     (remove-from-map dependencies node)&amp;lt;br&amp;gt;     (remove-from-map dependents node)))&amp;lt;br&amp;gt;  (remove-node [graph node]&amp;lt;br&amp;gt;    (MapDependencyGraph.&amp;lt;br&amp;gt;     (dissoc dependencies node)&amp;lt;br&amp;gt;     dependents)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->MapDependencyGraph</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;nodes&lt;/b&gt; ([graph])&lt;br&gt; Returns the set of all nodes in graph.&lt;/div&gt;" data-placement="right">nodes</a>[graph]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;remove-all&lt;/b&gt; ([graph node])&lt;br&gt; Returns a new dependency graph with all references to node removed.&lt;/div&gt;" data-placement="right">remove-all</a>[graph node]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;remove-edge&lt;/b&gt; ([graph node dep])&lt;br&gt; Returns a new graph with the dependency from node to dep removed.&lt;/div&gt;" data-placement="right">remove-edge</a>[graph node dep]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;remove-node&lt;/b&gt; ([graph node])&lt;br&gt; Removes the node from the dependency graph without removing it as a&lt;br&gt;    dependency of other nodes. That is, removes all outgoing edges from&lt;br&gt;    node.&lt;/div&gt;" data-placement="right">remove-node</a>[graph node]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;topo-comparator&lt;/b&gt; ([graph])&lt;br&gt; Returns a comparator fn which produces a topological sort based on&lt;br&gt;  the dependencies in graph. Nodes not present in the graph will sort&lt;br&gt;  after nodes in the graph.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn topo-comparator&amp;lt;br&amp;gt;  &amp;quot;Returns a comparator fn which produces a topological sort based on&amp;lt;br&amp;gt;  the dependencies in graph. Nodes not present in the graph will sort&amp;lt;br&amp;gt;  after nodes in the graph.&amp;quot;&amp;lt;br&amp;gt;  [graph]&amp;lt;br&amp;gt;  (let [pos (zipmap (topo-sort graph) (range))]&amp;lt;br&amp;gt;    (fn [a b]&amp;lt;br&amp;gt;      (compare (get pos a Long/MAX_VALUE)&amp;lt;br&amp;gt;               (get pos b Long/MAX_VALUE)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">topo-comparator</a>[graph]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;topo-sort&lt;/b&gt; ([graph])&lt;br&gt; Returns a topologically-sorted list of nodes in graph.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn topo-sort&amp;lt;br&amp;gt;  &amp;quot;Returns a topologically-sorted list of nodes in graph.&amp;quot;&amp;lt;br&amp;gt;  [graph]&amp;lt;br&amp;gt;  (loop [sorted ()&amp;lt;br&amp;gt;         g graph&amp;lt;br&amp;gt;         todo (set (filter #(empty? (immediate-dependents graph %))&amp;lt;br&amp;gt;                           (nodes graph)))]&amp;lt;br&amp;gt;    (if (empty? todo)&amp;lt;br&amp;gt;      sorted&amp;lt;br&amp;gt;      (let [[node &amp;amp; more] (seq todo)&amp;lt;br&amp;gt;            deps (immediate-dependencies g node)&amp;lt;br&amp;gt;            [add g'] (loop [deps deps&amp;lt;br&amp;gt;                            g g&amp;lt;br&amp;gt;                            add #{}]&amp;lt;br&amp;gt;                       (if (seq deps)&amp;lt;br&amp;gt;                         (let [d (first deps)&amp;lt;br&amp;gt;                               g' (remove-edge g node d)]&amp;lt;br&amp;gt;                           (if (empty? (immediate-dependents g' d))&amp;lt;br&amp;gt;                             (recur (rest deps) g' (conj add d))&amp;lt;br&amp;gt;                             (recur (rest deps) g' add)))&amp;lt;br&amp;gt;                         [add g]))]&amp;lt;br&amp;gt;        (recur (cons node sorted)&amp;lt;br&amp;gt;               (remove-node g' node)&amp;lt;br&amp;gt;               (clojure.set/union (set more) (set add)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">topo-sort</a>[graph]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;transitive-dependencies&lt;/b&gt; ([graph node])&lt;br&gt; Returns the set of all things which node depends on, directly or&lt;br&gt;    transitively.&lt;/div&gt;" data-placement="right">transitive-dependencies</a>[graph node]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.dependency&lt;/i&gt;&lt;b&gt;transitive-dependents&lt;/b&gt; ([graph node])&lt;br&gt; Returns the set of all things which depend upon node, directly or&lt;br&gt;    transitively.&lt;/div&gt;" data-placement="right">transitive-dependents</a>[graph node]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.namespace.file</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.file&lt;/i&gt;&lt;b&gt;add-files&lt;/b&gt; ([tracker files])&lt;br&gt; Reads ns declarations from files; returns an updated dependency&lt;br&gt;  tracker with those files added.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add-files&amp;lt;br&amp;gt;  &amp;quot;Reads ns declarations from files; returns an updated dependency&amp;lt;br&amp;gt;  tracker with those files added.&amp;quot;&amp;lt;br&amp;gt;  [tracker files]&amp;lt;br&amp;gt;  (let [{:keys [depmap filemap]} (files-and-deps files)]&amp;lt;br&amp;gt;    (-&amp;gt; tracker&amp;lt;br&amp;gt;        (track/add depmap)&amp;lt;br&amp;gt;        (update-in [::filemap] (fnil merge {}) filemap))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add-files</a>[tracker files]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.file&lt;/i&gt;&lt;b&gt;clojure-file?&lt;/b&gt; ([file])&lt;br&gt; Returns true if the java.io.File represents a normal Clojure source&lt;br&gt;  file.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn clojure-file?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the java.io.File represents a normal Clojure source&amp;lt;br&amp;gt;  file.&amp;quot;&amp;lt;br&amp;gt;  [^java.io.File file]&amp;lt;br&amp;gt;  (and (.isFile file)&amp;lt;br&amp;gt;       (.endsWith (.getName file) &amp;quot;.clj&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">clojure-file?</a>[file]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.file&lt;/i&gt;&lt;b&gt;read-file-ns-decl&lt;/b&gt; ([file])&lt;br&gt; Attempts to read a (ns ...) declaration from file, and returns the&lt;br&gt;  unevaluated form.  Returns nil if read fails, or if the first form&lt;br&gt;  is not a ns declaration.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-file-ns-decl&amp;lt;br&amp;gt;  &amp;quot;Attempts to read a (ns ...) declaration from file, and returns the&amp;lt;br&amp;gt;  unevaluated form.  Returns nil if read fails, or if the first form&amp;lt;br&amp;gt;  is not a ns declaration.&amp;quot;&amp;lt;br&amp;gt;  [file]&amp;lt;br&amp;gt;  (with-open [rdr (PushbackReader. (io/reader file))]&amp;lt;br&amp;gt;    (parse/read-ns-decl rdr)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-file-ns-decl</a>[file]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.file&lt;/i&gt;&lt;b&gt;remove-files&lt;/b&gt; ([tracker files])&lt;br&gt; Returns an updated dependency tracker with files removed. The files&lt;br&gt;  must have been previously added with add-files.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove-files&amp;lt;br&amp;gt;  &amp;quot;Returns an updated dependency tracker with files removed. The files&amp;lt;br&amp;gt;  must have been previously added with add-files.&amp;quot;&amp;lt;br&amp;gt;  [tracker files]&amp;lt;br&amp;gt;  (-&amp;gt; tracker&amp;lt;br&amp;gt;      (track/remove (keep (::filemap tracker {}) files))&amp;lt;br&amp;gt;      (update-in [::filemap] #(apply dissoc % files))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove-files</a>[tracker files]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.namespace.find</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.find&lt;/i&gt;&lt;b&gt;clojure-sources-in-jar&lt;/b&gt; ([jar-file])&lt;br&gt; Returns a sequence of filenames ending in .clj found in the JAR file.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn clojure-sources-in-jar&amp;lt;br&amp;gt;  &amp;quot;Returns a sequence of filenames ending in .clj found in the JAR file.&amp;quot;&amp;lt;br&amp;gt;  [^JarFile jar-file]&amp;lt;br&amp;gt;  (filter #(.endsWith ^String % &amp;quot;.clj&amp;quot;) (filenames-in-jar jar-file)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">clojure-sources-in-jar</a>[jar-file]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.find&lt;/i&gt;&lt;b&gt;find-clojure-sources-in-dir&lt;/b&gt; ([dir])&lt;br&gt; Searches recursively under dir for Clojure source files (.clj).&lt;br&gt;  Returns a sequence of File objects, in breadth-first sort order.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-clojure-sources-in-dir&amp;lt;br&amp;gt;  &amp;quot;Searches recursively under dir for Clojure source files (.clj).&amp;lt;br&amp;gt;  Returns a sequence of File objects, in breadth-first sort order.&amp;quot;&amp;lt;br&amp;gt;  [^File dir]&amp;lt;br&amp;gt;  ;; Use sort by absolute path to get breadth-first search.&amp;lt;br&amp;gt;  (sort-by #(.getAbsolutePath ^File %)&amp;lt;br&amp;gt;           (filter file/clojure-file? (file-seq dir))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-clojure-sources-in-dir</a>[dir]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.find&lt;/i&gt;&lt;b&gt;find-namespaces&lt;/b&gt; ([files])&lt;br&gt; Searches a sequence of java.io.File objects (both directories and&lt;br&gt;  JAR files) for .clj source files containing (ns...) declarations.&lt;br&gt;  Returns a sequence of the symbol names of the declared&lt;br&gt;  namespaces. Use with clojure.java.classpath to search Clojure's&lt;br&gt;  classpath.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-namespaces&amp;lt;br&amp;gt;  &amp;quot;Searches a sequence of java.io.File objects (both directories and&amp;lt;br&amp;gt;  JAR files) for .clj source files containing (ns...) declarations.&amp;lt;br&amp;gt;  Returns a sequence of the symbol names of the declared&amp;lt;br&amp;gt;  namespaces. Use with clojure.java.classpath to search Clojure's&amp;lt;br&amp;gt;  classpath.&amp;quot;&amp;lt;br&amp;gt;  [files]&amp;lt;br&amp;gt;  (map second (find-ns-decls files)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-namespaces</a>[files]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.find&lt;/i&gt;&lt;b&gt;find-namespaces-in-dir&lt;/b&gt; ([dir])&lt;br&gt; Searches dir recursively for (ns ...) declarations in Clojure&lt;br&gt;  source files; returns the symbol names of the declared namespaces.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-namespaces-in-dir&amp;lt;br&amp;gt;  &amp;quot;Searches dir recursively for (ns ...) declarations in Clojure&amp;lt;br&amp;gt;  source files; returns the symbol names of the declared namespaces.&amp;quot;&amp;lt;br&amp;gt;  [^File dir]&amp;lt;br&amp;gt;  (map second (find-ns-decls-in-dir dir)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-namespaces-in-dir</a>[dir]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.find&lt;/i&gt;&lt;b&gt;find-namespaces-in-jarfile&lt;/b&gt; ([jarfile])&lt;br&gt; Searches the JAR file for Clojure source files containing (ns ...)&lt;br&gt;  declarations.  Returns a sequence of the symbol names of the&lt;br&gt;  declared namespaces.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-namespaces-in-jarfile&amp;lt;br&amp;gt;  &amp;quot;Searches the JAR file for Clojure source files containing (ns ...)&amp;lt;br&amp;gt;  declarations.  Returns a sequence of the symbol names of the&amp;lt;br&amp;gt;  declared namespaces.&amp;quot;&amp;lt;br&amp;gt;  [^JarFile jarfile]&amp;lt;br&amp;gt;  (map second (find-ns-decls-in-jarfile jarfile)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-namespaces-in-jarfile</a>[jarfile]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.find&lt;/i&gt;&lt;b&gt;find-ns-decls&lt;/b&gt; ([files])&lt;br&gt; Searches a sequence of java.io.File objects (both directories and&lt;br&gt;  JAR files) for .clj source files containing (ns...) declarations.&lt;br&gt;  Returns a sequence of the unevaluated ns declaration forms. Use with&lt;br&gt;  clojure.java.classpath to search Clojure's classpath.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-ns-decls&amp;lt;br&amp;gt;  &amp;quot;Searches a sequence of java.io.File objects (both directories and&amp;lt;br&amp;gt;  JAR files) for .clj source files containing (ns...) declarations.&amp;lt;br&amp;gt;  Returns a sequence of the unevaluated ns declaration forms. Use with&amp;lt;br&amp;gt;  clojure.java.classpath to search Clojure's classpath.&amp;quot;&amp;lt;br&amp;gt;  [files]&amp;lt;br&amp;gt;  (concat&amp;lt;br&amp;gt;   (mapcat find-ns-decls-in-dir (filter #(.isDirectory ^File %) files))&amp;lt;br&amp;gt;   (mapcat find-ns-decls-in-jarfile (jar-files files))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-ns-decls</a>[files]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.find&lt;/i&gt;&lt;b&gt;find-ns-decls-in-dir&lt;/b&gt; ([dir])&lt;br&gt; Searches dir recursively for (ns ...) declarations in Clojure&lt;br&gt;  source files; returns the unevaluated ns declarations.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-ns-decls-in-dir&amp;lt;br&amp;gt;  &amp;quot;Searches dir recursively for (ns ...) declarations in Clojure&amp;lt;br&amp;gt;  source files; returns the unevaluated ns declarations.&amp;quot;&amp;lt;br&amp;gt;  [^File dir]&amp;lt;br&amp;gt;  (keep file/read-file-ns-decl (find-clojure-sources-in-dir dir)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-ns-decls-in-dir</a>[dir]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.find&lt;/i&gt;&lt;b&gt;find-ns-decls-in-jarfile&lt;/b&gt; ([jarfile])&lt;br&gt; Searches the JAR file for Clojure source files containing (ns ...)&lt;br&gt;  declarations; returns the unevaluated ns declarations.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn find-ns-decls-in-jarfile&amp;lt;br&amp;gt;  &amp;quot;Searches the JAR file for Clojure source files containing (ns ...)&amp;lt;br&amp;gt;  declarations; returns the unevaluated ns declarations.&amp;quot;&amp;lt;br&amp;gt;  [^JarFile jarfile]&amp;lt;br&amp;gt;  (filter identity&amp;lt;br&amp;gt;          (map #(read-ns-decl-from-jarfile-entry jarfile %)&amp;lt;br&amp;gt;               (clojure-sources-in-jar jarfile))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">find-ns-decls-in-jarfile</a>[jarfile]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.find&lt;/i&gt;&lt;b&gt;read-ns-decl-from-jarfile-entry&lt;/b&gt; ([jarfile entry-name])&lt;br&gt; Attempts to read a (ns ...) declaration from the named entry in the&lt;br&gt;  JAR file, and returns the unevaluated form.  Returns nil if the read&lt;br&gt;  fails, or if the first form is not a ns declaration.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-ns-decl-from-jarfile-entry&amp;lt;br&amp;gt;  &amp;quot;Attempts to read a (ns ...) declaration from the named entry in the&amp;lt;br&amp;gt;  JAR file, and returns the unevaluated form.  Returns nil if the read&amp;lt;br&amp;gt;  fails, or if the first form is not a ns declaration.&amp;quot;&amp;lt;br&amp;gt;  [^JarFile jarfile ^String entry-name]&amp;lt;br&amp;gt;  (with-open [rdr (PushbackReader.&amp;lt;br&amp;gt;                   (io/reader&amp;lt;br&amp;gt;                    (.getInputStream jarfile (.getEntry jarfile entry-name))))]&amp;lt;br&amp;gt;    (parse/read-ns-decl rdr)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-ns-decl-from-jarfile-entry</a>[jarfile entry-name]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.namespace.parse</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.parse&lt;/i&gt;&lt;b&gt;comment?&lt;/b&gt; ([form])&lt;br&gt; Returns true if form is a (comment ...)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn comment?&amp;lt;br&amp;gt;  &amp;quot;Returns true if form is a (comment ...)&amp;quot;&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (and (list? form) (= 'comment (first form))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">comment?</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.parse&lt;/i&gt;&lt;b&gt;deps-from-ns-decl&lt;/b&gt; ([decl])&lt;br&gt; Given an (ns...) declaration form (unevaluated), returns a set of&lt;br&gt;  symbols naming the dependencies of that namespace.  Handles :use and&lt;br&gt;  :require clauses but not :load.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn deps-from-ns-decl&amp;lt;br&amp;gt;  &amp;quot;Given an (ns...) declaration form (unevaluated), returns a set of&amp;lt;br&amp;gt;  symbols naming the dependencies of that namespace.  Handles :use and&amp;lt;br&amp;gt;  :require clauses but not :load.&amp;quot;&amp;lt;br&amp;gt;  [decl]&amp;lt;br&amp;gt;  (apply set/union (map deps-from-ns-form decl)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">deps-from-ns-decl</a>[decl]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.parse&lt;/i&gt;&lt;b&gt;ns-decl?&lt;/b&gt; ([form])&lt;br&gt; Returns true if form is a (ns ...) declaration.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-decl?&amp;lt;br&amp;gt;  &amp;quot;Returns true if form is a (ns ...) declaration.&amp;quot;&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (and (list? form) (= 'ns (first form))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-decl?</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.parse&lt;/i&gt;&lt;b&gt;read-ns-decl&lt;/b&gt; ([rdr])&lt;br&gt; Attempts to read a (ns ...) declaration from a&lt;br&gt;  java.io.PushbackReader, and returns the unevaluated form. Returns&lt;br&gt;  nil if read fails or if a ns declaration cannot be found. The ns&lt;br&gt;  declaration must be the first Clojure form in the file, except for&lt;br&gt;  (comment ...) forms.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-ns-decl&amp;lt;br&amp;gt;  &amp;quot;Attempts to read a (ns ...) declaration from a&amp;lt;br&amp;gt;  java.io.PushbackReader, and returns the unevaluated form. Returns&amp;lt;br&amp;gt;  nil if read fails or if a ns declaration cannot be found. The ns&amp;lt;br&amp;gt;  declaration must be the first Clojure form in the file, except for&amp;lt;br&amp;gt;  (comment ...) forms.&amp;quot;&amp;lt;br&amp;gt;  [rdr]&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;   (loop [] (let [form (doto (read rdr) str)]&amp;lt;br&amp;gt;              (cond&amp;lt;br&amp;gt;               (ns-decl? form) form&amp;lt;br&amp;gt;               (comment? form) (recur)&amp;lt;br&amp;gt;               :else nil)))&amp;lt;br&amp;gt;       (catch Exception e nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-ns-decl</a>[rdr]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.namespace.track</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.track&lt;/i&gt;&lt;b&gt;add&lt;/b&gt; ([tracker depmap])&lt;br&gt; Returns an updated dependency tracker with new/updated namespaces.&lt;br&gt;&lt;br&gt;  Depmap is a map describing the new or modified namespaces. Keys in&lt;br&gt;  the map are namespace names (symbols). Values in the map are sets of&lt;br&gt;  symbols naming the birect dependencies of each namespace. For&lt;br&gt;  example, assuming these ns declarations:&lt;br&gt;&lt;br&gt;      (ns alpha (:require beta))&lt;br&gt;      (ns beta (:require gamma delta))&lt;br&gt;&lt;br&gt;  the depmap would look like this:&lt;br&gt;&lt;br&gt;      {alpha #{beta}&lt;br&gt;       beta  #{gamma delta}}&lt;br&gt;&lt;br&gt;  After adding new/updated namespaces, the dependency tracker will&lt;br&gt;  have two lists associated with the following keys:&lt;br&gt;&lt;br&gt;      :clojure.tools.namespace.track/unload&lt;br&gt;          is the list of namespaces that need to be removed&lt;br&gt;&lt;br&gt;      :clojure.tools.namespace.track/load&lt;br&gt;          is the list of namespaces that need to be reloaded&lt;br&gt;&lt;br&gt;  To reload namespaces in the correct order, first remove/unload all&lt;br&gt;  namespaces in the 'unload' list, then (re)load all namespaces in the&lt;br&gt;  'load' list. The clojure.tools.namespace.reload namespace has&lt;br&gt;  functions to do this.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn add&amp;lt;br&amp;gt;  &amp;quot;Returns an updated dependency tracker with new/updated namespaces.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Depmap is a map describing the new or modified namespaces. Keys in&amp;lt;br&amp;gt;  the map are namespace names (symbols). Values in the map are sets of&amp;lt;br&amp;gt;  symbols naming the birect dependencies of each namespace. For&amp;lt;br&amp;gt;  example, assuming these ns declarations:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      (ns alpha (:require beta))&amp;lt;br&amp;gt;      (ns beta (:require gamma delta))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  the depmap would look like this:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      {alpha #{beta}&amp;lt;br&amp;gt;       beta  #{gamma delta}}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  After adding new/updated namespaces, the dependency tracker will&amp;lt;br&amp;gt;  have two lists associated with the following keys:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      :clojure.tools.namespace.track/unload&amp;lt;br&amp;gt;          is the list of namespaces that need to be removed&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      :clojure.tools.namespace.track/load&amp;lt;br&amp;gt;          is the list of namespaces that need to be reloaded&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  To reload namespaces in the correct order, first remove/unload all&amp;lt;br&amp;gt;  namespaces in the 'unload' list, then (re)load all namespaces in the&amp;lt;br&amp;gt;  'load' list. The clojure.tools.namespace.reload namespace has&amp;lt;br&amp;gt;  functions to do this.&amp;quot;&amp;lt;br&amp;gt;  [tracker depmap]&amp;lt;br&amp;gt;  (let [{load ::load&amp;lt;br&amp;gt;         unload ::unload&amp;lt;br&amp;gt;         deps ::deps&amp;lt;br&amp;gt;         :or {load (), unload (), deps (dep/graph)}} tracker&amp;lt;br&amp;gt;        new-deps (update-deps deps depmap)&amp;lt;br&amp;gt;        changed (affected-namespaces new-deps (keys depmap))]&amp;lt;br&amp;gt;    (assoc tracker&amp;lt;br&amp;gt;      ::deps new-deps&amp;lt;br&amp;gt;      ::unload (distinct&amp;lt;br&amp;gt;               (concat (reverse (sort (dep/topo-comparator deps) changed))&amp;lt;br&amp;gt;                       unload))&amp;lt;br&amp;gt;      ::load (distinct&amp;lt;br&amp;gt;             (concat (sort (dep/topo-comparator new-deps) changed)&amp;lt;br&amp;gt;                     load)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">add</a>[tracker depmap]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.track&lt;/i&gt;&lt;b&gt;remove&lt;/b&gt; ([tracker names])&lt;br&gt; Returns an updated dependency tracker from which the namespaces&lt;br&gt;  (symbols) have been removed. The ::unload and ::load lists are&lt;br&gt;  populated as with 'add'.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove&amp;lt;br&amp;gt;  &amp;quot;Returns an updated dependency tracker from which the namespaces&amp;lt;br&amp;gt;  (symbols) have been removed. The ::unload and ::load lists are&amp;lt;br&amp;gt;  populated as with 'add'.&amp;quot;&amp;lt;br&amp;gt;  [tracker names]&amp;lt;br&amp;gt;  (let [{load ::load&amp;lt;br&amp;gt;         unload ::unload&amp;lt;br&amp;gt;         deps ::deps&amp;lt;br&amp;gt;         :or {load (), unload (), deps (dep/graph)}} tracker&amp;lt;br&amp;gt;        known (set (dep/nodes deps))&amp;lt;br&amp;gt;        removed-names (filter known names)&amp;lt;br&amp;gt;        new-deps (remove-deps deps removed-names)&amp;lt;br&amp;gt;        changed (affected-namespaces deps removed-names)]&amp;lt;br&amp;gt;    (assoc tracker&amp;lt;br&amp;gt;      ::deps new-deps&amp;lt;br&amp;gt;      ::unload (distinct&amp;lt;br&amp;gt;                (concat (reverse (sort (dep/topo-comparator deps) changed))&amp;lt;br&amp;gt;                        unload))&amp;lt;br&amp;gt;      ::load (distinct&amp;lt;br&amp;gt;              (filter (complement (set removed-names))&amp;lt;br&amp;gt;                      (concat (sort (dep/topo-comparator new-deps) changed)&amp;lt;br&amp;gt;                              load))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove</a>[tracker names]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.namespace.track&lt;/i&gt;&lt;b&gt;tracker&lt;/b&gt; ([])&lt;br&gt; Returns a new, empty dependency tracker&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tracker&amp;lt;br&amp;gt;  &amp;quot;Returns a new, empty dependency tracker&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  {})&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tracker</a>[]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.nrepl</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl&lt;/i&gt;&lt;b&gt;client&lt;/b&gt; ([transport response-timeout])&lt;br&gt; Returns a fn of zero and one argument, both of which return the current head of a single&lt;br&gt;   response-seq being read off of the given client-side transport.  The one-arg arity will&lt;br&gt;   send a given message on the transport before returning the seq.&lt;br&gt;&lt;br&gt;   Most REPL interactions are best performed via `message` and `client-session` on top of&lt;br&gt;   a client fn returned from this fn.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn client&amp;lt;br&amp;gt;  &amp;quot;Returns a fn of zero and one argument, both of which return the current head of a single&amp;lt;br&amp;gt;   response-seq being read off of the given client-side transport.  The one-arg arity will&amp;lt;br&amp;gt;   send a given message on the transport before returning the seq.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Most REPL interactions are best performed via `message` and `client-session` on top of&amp;lt;br&amp;gt;   a client fn returned from this fn.&amp;quot;&amp;lt;br&amp;gt;  [transport response-timeout]&amp;lt;br&amp;gt;  (let [latest-head (atom nil)&amp;lt;br&amp;gt;        update #(swap! latest-head&amp;lt;br&amp;gt;                       (fn [[timestamp seq :as head] now]&amp;lt;br&amp;gt;                         (if (&amp;lt; timestamp now)&amp;lt;br&amp;gt;                           [now %]&amp;lt;br&amp;gt;                           head))&amp;lt;br&amp;gt;                       ; nanoTime appropriate here; looking to maintain ordering, not actual timestamps&amp;lt;br&amp;gt;                       (System/nanoTime))&amp;lt;br&amp;gt;        tracking-seq (fn tracking-seq [responses]&amp;lt;br&amp;gt;                       (lazy-seq&amp;lt;br&amp;gt;                         (if (seq responses)&amp;lt;br&amp;gt;                           (let [rst (tracking-seq (rest responses))]&amp;lt;br&amp;gt;                             (update rst)&amp;lt;br&amp;gt;                             (cons (first responses) rst))&amp;lt;br&amp;gt;                           (do (update nil) nil))))&amp;lt;br&amp;gt;        restart #(let [head (-&amp;gt; transport&amp;lt;br&amp;gt;                              (response-seq response-timeout)&amp;lt;br&amp;gt;                              tracking-seq)]&amp;lt;br&amp;gt;                   (reset! latest-head [0 head])&amp;lt;br&amp;gt;                   head)]&amp;lt;br&amp;gt;    ^{::transport transport ::timeout response-timeout}&amp;lt;br&amp;gt;    (fn this&amp;lt;br&amp;gt;      ([] (or (second @latest-head)&amp;lt;br&amp;gt;              (restart)))&amp;lt;br&amp;gt;      ([msg]&amp;lt;br&amp;gt;        (transport/send transport msg)&amp;lt;br&amp;gt;        (this)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">client</a>[transport response-timeout]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl&lt;/i&gt;&lt;b&gt;client-session&lt;/b&gt; ([client &amp; {:keys [session clone]}])&lt;br&gt; Returns a function of one argument.  Accepts a message that is sent via the&lt;br&gt;   client provided with a fixed :session id added to it.  Returns the&lt;br&gt;   head of the client's response seq, filtered to include only&lt;br&gt;   messages related to the :session id that will terminate when the session is&lt;br&gt;   closed.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn client-session&amp;lt;br&amp;gt;  &amp;quot;Returns a function of one argument.  Accepts a message that is sent via the&amp;lt;br&amp;gt;   client provided with a fixed :session id added to it.  Returns the&amp;lt;br&amp;gt;   head of the client's response seq, filtered to include only&amp;lt;br&amp;gt;   messages related to the :session id that will terminate when the session is&amp;lt;br&amp;gt;   closed.&amp;quot;&amp;lt;br&amp;gt;  [client &amp;amp; {:keys [session clone]}]&amp;lt;br&amp;gt;  (let [session (or session (apply new-session client (when clone [:clone clone])))]&amp;lt;br&amp;gt;    (delimited-transport-seq client #{&amp;quot;session-closed&amp;quot;} {:session session})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">client-session</a>[client & {:keys [session clone]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl&lt;/i&gt;&lt;b&gt;code&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Expands into a string consisting of the macro's body's forms&lt;br&gt;   (literally, no interpolation/quasiquoting of locals or other&lt;br&gt;   references), suitable for use in an :eval message, e.g.:&lt;br&gt;&lt;br&gt;   {:op :eval, :code (code (+ 1 1) (slurp &quot;foo.txt&quot;))}&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro code&amp;lt;br&amp;gt;  &amp;quot;Expands into a string consisting of the macro's body's forms&amp;lt;br&amp;gt;   (literally, no interpolation/quasiquoting of locals or other&amp;lt;br&amp;gt;   references), suitable for use in an :eval message, e.g.:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   {:op :eval, :code (code (+ 1 1) (slurp \&amp;quot;foo.txt\&amp;quot;))}&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;  (apply code* body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">code</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl&lt;/i&gt;&lt;b&gt;code*&lt;/b&gt; ([&amp; expressions])&lt;br&gt; Returns a single string containing the pr-str'd representations&lt;br&gt;   of the given expressions.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn code*&amp;lt;br&amp;gt;  &amp;quot;Returns a single string containing the pr-str'd representations&amp;lt;br&amp;gt;   of the given expressions.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; expressions]&amp;lt;br&amp;gt;  (apply str (map pr-str expressions)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">code*</a>[& expressions]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl&lt;/i&gt;&lt;b&gt;combine-responses&lt;/b&gt; ([responses])&lt;br&gt; Combines the provided seq of response messages into a single response map.&lt;br&gt;&lt;br&gt;   Certain message slots are combined in special ways:&lt;br&gt;&lt;br&gt;     - only the last :ns is retained&lt;br&gt;     - :value is accumulated into an ordered collection&lt;br&gt;     - :status and :session are accumulated into a set&lt;br&gt;     - string values (associated with e.g. :out and :err) are concatenated&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn combine-responses&amp;lt;br&amp;gt;  &amp;quot;Combines the provided seq of response messages into a single response map.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Certain message slots are combined in special ways:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;     - only the last :ns is retained&amp;lt;br&amp;gt;     - :value is accumulated into an ordered collection&amp;lt;br&amp;gt;     - :status and :session are accumulated into a set&amp;lt;br&amp;gt;     - string values (associated with e.g. :out and :err) are concatenated&amp;quot;&amp;lt;br&amp;gt;  [responses]&amp;lt;br&amp;gt;  (reduce&amp;lt;br&amp;gt;    (fn [m [k v]]&amp;lt;br&amp;gt;      (case k&amp;lt;br&amp;gt;        (:id :ns) (assoc m k v)&amp;lt;br&amp;gt;        :value (update-in m [k] (fnil conj []) v)&amp;lt;br&amp;gt;        :status (update-in m [k] (fnil into #{}) v)&amp;lt;br&amp;gt;        :session (update-in m [k] (fnil conj #{}) v)&amp;lt;br&amp;gt;        (if (string? v)&amp;lt;br&amp;gt;          (update-in m [k] #(str % v))&amp;lt;br&amp;gt;          (assoc m k v))))            &amp;lt;br&amp;gt;    {} (apply concat responses)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">combine-responses</a>[responses]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl&lt;/i&gt;&lt;b&gt;connect&lt;/b&gt; ([&amp; {:keys [port host transport-fn], :or {transport-fn transport/bencode, host &quot;localhost&quot;}}])&lt;br&gt; Connects to a socket-based REPL at the given host (defaults to localhost) and port,&lt;br&gt;   returning the Transport (by default clojure.tools.nrepl.transport/bencode)&lt;br&gt;   for that connection.&lt;br&gt;&lt;br&gt;   Transports are most easily used with `client`, `client-session`, and&lt;br&gt;   `message`, depending on the semantics desired.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn connect&amp;lt;br&amp;gt;  &amp;quot;Connects to a socket-based REPL at the given host (defaults to localhost) and port,&amp;lt;br&amp;gt;   returning the Transport (by default clojure.tools.nrepl.transport/bencode)&amp;lt;br&amp;gt;   for that connection.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Transports are most easily used with `client`, `client-session`, and&amp;lt;br&amp;gt;   `message`, depending on the semantics desired.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; {:keys [port host transport-fn] :or {transport-fn transport/bencode&amp;lt;br&amp;gt;                                          host &amp;quot;localhost&amp;quot;}}]&amp;lt;br&amp;gt;  {:pre [transport-fn port]}&amp;lt;br&amp;gt;  (transport-fn (java.net.Socket. ^String host (int port))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">connect</a>[& {:keys [port host transport-fn], :or {transport-fn transport/bencode, host "localhost"}}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl&lt;/i&gt;&lt;b&gt;message&lt;/b&gt; ([client {:keys [id], :as msg, :or {id (uuid)}}])&lt;br&gt; Sends a message via [client] with a fixed message :id added to it.&lt;br&gt;   Returns the head of the client's response seq, filtered to include only&lt;br&gt;   messages related to the message :id that will terminate upon receipt of a&lt;br&gt;   &quot;done&quot; :status.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn message&amp;lt;br&amp;gt;  &amp;quot;Sends a message via [client] with a fixed message :id added to it.&amp;lt;br&amp;gt;   Returns the head of the client's response seq, filtered to include only&amp;lt;br&amp;gt;   messages related to the message :id that will terminate upon receipt of a&amp;lt;br&amp;gt;   \&amp;quot;done\&amp;quot; :status.&amp;quot;&amp;lt;br&amp;gt;  [client {:keys [id] :as msg :or {id (uuid)}}]&amp;lt;br&amp;gt;  (let [f (delimited-transport-seq client #{&amp;quot;done&amp;quot;} {:id id})]&amp;lt;br&amp;gt;    (f (assoc msg :id id))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">message</a>[client {:keys [id], :as msg, :or {id (uuid)}}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl&lt;/i&gt;&lt;b&gt;new-session&lt;/b&gt; ([client &amp; {:keys [clone]}])&lt;br&gt; Provokes the creation and retention of a new session, optionally as a clone&lt;br&gt;   of an existing retained session, the id of which must be provided as a :clone&lt;br&gt;   kwarg.  Returns the new session's id.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn new-session&amp;lt;br&amp;gt;  &amp;quot;Provokes the creation and retention of a new session, optionally as a clone&amp;lt;br&amp;gt;   of an existing retained session, the id of which must be provided as a :clone&amp;lt;br&amp;gt;   kwarg.  Returns the new session's id.&amp;quot;&amp;lt;br&amp;gt;  [client &amp;amp; {:keys [clone]}]&amp;lt;br&amp;gt;  (let [resp (first (message client (merge {:op &amp;quot;clone&amp;quot;} (when clone {:session clone}))))]&amp;lt;br&amp;gt;    (or (:new-session resp)&amp;lt;br&amp;gt;        (throw (IllegalStateException.&amp;lt;br&amp;gt;                 (str &amp;quot;Could not open new session; :clone response: &amp;quot; resp))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">new-session</a>[client & {:keys [clone]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl&lt;/i&gt;&lt;b&gt;read-response-value&lt;/b&gt; ([{:keys [value], :as msg}])&lt;br&gt; Returns the provided response message, replacing its :value string with&lt;br&gt;   the result of (read)ing it.  Returns the message unchanged if the :value&lt;br&gt;   slot is empty or not a string.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-response-value&amp;lt;br&amp;gt;  &amp;quot;Returns the provided response message, replacing its :value string with&amp;lt;br&amp;gt;   the result of (read)ing it.  Returns the message unchanged if the :value&amp;lt;br&amp;gt;   slot is empty or not a string.&amp;quot;&amp;lt;br&amp;gt;  [{:keys [value] :as msg}]&amp;lt;br&amp;gt;  (if-not (string? value)&amp;lt;br&amp;gt;    msg&amp;lt;br&amp;gt;    (try&amp;lt;br&amp;gt;      (assoc msg :value (read-string value))&amp;lt;br&amp;gt;      (catch Exception e&amp;lt;br&amp;gt;        (throw (IllegalStateException. (str &amp;quot;Could not read response value: &amp;quot; value) e))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-response-value</a>[{:keys [value], :as msg}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl&lt;/i&gt;&lt;b&gt;response-seq&lt;/b&gt; ([transport] [transport timeout])&lt;br&gt; Returns a lazy seq of messages received via the given Transport.&lt;br&gt;   Called with no further arguments, will block waiting for each message.&lt;br&gt;   The seq will end only when the underlying Transport is closed (i.e.&lt;br&gt;   returns nil from `recv`) or if a message takes longer than `timeout`&lt;br&gt;   millis to arrive.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn response-seq&amp;lt;br&amp;gt;  &amp;quot;Returns a lazy seq of messages received via the given Transport.&amp;lt;br&amp;gt;   Called with no further arguments, will block waiting for each message.&amp;lt;br&amp;gt;   The seq will end only when the underlying Transport is closed (i.e.&amp;lt;br&amp;gt;   returns nil from `recv`) or if a message takes longer than `timeout`&amp;lt;br&amp;gt;   millis to arrive.&amp;quot;&amp;lt;br&amp;gt;  ([transport] (response-seq transport Long/MAX_VALUE))&amp;lt;br&amp;gt;  ([transport timeout]&amp;lt;br&amp;gt;    (take-while identity (repeatedly #(transport/recv transport timeout)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">response-seq</a>[transport] [transport timeout]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl&lt;/i&gt;&lt;b&gt;response-values&lt;/b&gt; ([responses])&lt;br&gt; Given a seq of responses (as from response-seq or returned from any function returned&lt;br&gt;   by client or client-session), returns a seq of values read from :value slots found&lt;br&gt;   therein.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn response-values&amp;lt;br&amp;gt;  &amp;quot;Given a seq of responses (as from response-seq or returned from any function returned&amp;lt;br&amp;gt;   by client or client-session), returns a seq of values read from :value slots found&amp;lt;br&amp;gt;   therein.&amp;quot;&amp;lt;br&amp;gt;  [responses]&amp;lt;br&amp;gt;  (-&amp;gt;&amp;gt; responses&amp;lt;br&amp;gt;    (map read-response-value)&amp;lt;br&amp;gt;    combine-responses&amp;lt;br&amp;gt;    :value))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">response-values</a>[responses]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.nrepl.bencode</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.bencode&lt;/i&gt;&lt;b&gt;read-bencode&lt;/b&gt; ([input])&lt;br&gt; Read bencode token from the input stream.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-bencode&amp;lt;br&amp;gt;  &amp;quot;Read bencode token from the input stream.&amp;quot;&amp;lt;br&amp;gt;  [input]&amp;lt;br&amp;gt;  (let [token (read-token input)]&amp;lt;br&amp;gt;    (case token&amp;lt;br&amp;gt;      :integer (read-integer input)&amp;lt;br&amp;gt;      :list    (read-list input)&amp;lt;br&amp;gt;      :map     (read-map input)&amp;lt;br&amp;gt;      token)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-bencode</a>[input]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.bencode&lt;/i&gt;&lt;b&gt;read-netstring&lt;/b&gt; ([input])&lt;br&gt; Reads a classic netstring from inputan InputStream. Returns the&lt;br&gt;  contained binary data as byte array.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn #^&amp;quot;[B&amp;quot; read-netstring&amp;lt;br&amp;gt;  &amp;quot;Reads a classic netstring from inputan InputStream. Returns the&amp;lt;br&amp;gt;  contained binary data as byte array.&amp;quot;&amp;lt;br&amp;gt;  [input]&amp;lt;br&amp;gt;  (let [content (read-netstring* input)]&amp;lt;br&amp;gt;    (when (not= (read-byte input) comma)&amp;lt;br&amp;gt;      (throw (IOException. &amp;quot;Invalid netstring. ',' expected.&amp;quot;)))&amp;lt;br&amp;gt;    content))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-netstring</a>[input]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.bencode&lt;/i&gt;&lt;b&gt;write-netstring&lt;/b&gt; ([output content])&lt;br&gt; Write the given binary data to the output stream in form of a classic&lt;br&gt;  netstring.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn write-netstring&amp;lt;br&amp;gt;  &amp;quot;Write the given binary data to the output stream in form of a classic&amp;lt;br&amp;gt;  netstring.&amp;quot;&amp;lt;br&amp;gt;  [#^OutputStream output content]&amp;lt;br&amp;gt;  (doto output&amp;lt;br&amp;gt;    (write-netstring* content)&amp;lt;br&amp;gt;    (.write (int comma))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">write-netstring</a>[output content]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.nrepl.misc</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.misc&lt;/i&gt;&lt;b&gt;log&lt;/b&gt; ([&amp; args])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;  (defmacro log [&amp;amp; args] `(clojure.tools.logging/error ~@args))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">log</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.misc&lt;/i&gt;&lt;b&gt;response-for&lt;/b&gt; ([{:keys [session id]} &amp; response-data])&lt;br&gt; Returns a map containing the :session and :id from the &quot;request&quot; `msg`&lt;br&gt;   as well as all entries specified in `response-data`, which can be one&lt;br&gt;   or more maps (which will be merged), *or* key-value pairs.&lt;br&gt;&lt;br&gt;   (response-for msg :status :done :value &quot;5&quot;)&lt;br&gt;   (response-for msg {:status :interrupted})&lt;br&gt;&lt;br&gt;   The :session value in `msg` may be any Clojure reference type (to accommodate&lt;br&gt;   likely implementations of sessions) that has an :id slot in its metadata,&lt;br&gt;   or a string.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn response-for&amp;lt;br&amp;gt;  &amp;quot;Returns a map containing the :session and :id from the \&amp;quot;request\&amp;quot; `msg`&amp;lt;br&amp;gt;   as well as all entries specified in `response-data`, which can be one&amp;lt;br&amp;gt;   or more maps (which will be merged), *or* key-value pairs.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   (response-for msg :status :done :value \&amp;quot;5\&amp;quot;)&amp;lt;br&amp;gt;   (response-for msg {:status :interrupted})&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   The :session value in `msg` may be any Clojure reference type (to accommodate&amp;lt;br&amp;gt;   likely implementations of sessions) that has an :id slot in its metadata,&amp;lt;br&amp;gt;   or a string.&amp;quot;&amp;lt;br&amp;gt;  [{:keys [session id]} &amp;amp; response-data]&amp;lt;br&amp;gt;  {:pre [(seq response-data)]}&amp;lt;br&amp;gt;  (let [{:keys [status] :as response} (if (map? (first response-data))&amp;lt;br&amp;gt;                                        (reduce merge response-data)&amp;lt;br&amp;gt;                                        (apply hash-map response-data))&amp;lt;br&amp;gt;        response (if (not status)&amp;lt;br&amp;gt;                   response&amp;lt;br&amp;gt;                   (assoc response :status (if (coll? status)&amp;lt;br&amp;gt;                                             status&amp;lt;br&amp;gt;                                             #{status})))&amp;lt;br&amp;gt;        basis (merge (when id {:id id})&amp;lt;br&amp;gt;                     ; AReference should make this suitable for any session implementation?&amp;lt;br&amp;gt;                     (when session {:session (if (instance? clojure.lang.AReference session)&amp;lt;br&amp;gt;                                               (-&amp;gt; session meta :id)&amp;lt;br&amp;gt;                                               session)}))]&amp;lt;br&amp;gt;    (merge basis response)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">response-for</a>[{:keys [session id]} & response-data]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.misc&lt;/i&gt;&lt;b&gt;returning&lt;/b&gt; ([x &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Executes `body`, returning `x`.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro returning&amp;lt;br&amp;gt;  &amp;quot;Executes `body`, returning `x`.&amp;quot;&amp;lt;br&amp;gt;  [x &amp;amp; body]&amp;lt;br&amp;gt;  `(let [x# ~x] ~@body x#))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">returning</a>[x & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.misc&lt;/i&gt;&lt;b&gt;uuid&lt;/b&gt; ([])&lt;br&gt; Returns a new UUID string.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn uuid&amp;lt;br&amp;gt;  &amp;quot;Returns a new UUID string.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (str (java.util.UUID/randomUUID)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">uuid</a>[]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.nrepl.transport</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.transport&lt;/i&gt;&lt;b&gt;-&gt;FnTransport&lt;/b&gt; ([recv-fn send-fn close])&lt;br&gt; Positional factory function for class clojure.tools.nrepl.transport.FnTransport.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype FnTransport [recv-fn send-fn close]&amp;lt;br&amp;gt;  Transport&amp;lt;br&amp;gt;  ;; TODO this keywordization/stringification has no business being in FnTransport&amp;lt;br&amp;gt;  (send [this msg] (-&amp;gt; msg clojure.walk/stringify-keys send-fn) this)&amp;lt;br&amp;gt;  (recv [this] (.recv this Long/MAX_VALUE))&amp;lt;br&amp;gt;  (recv [this timeout] (clojure.walk/keywordize-keys (recv-fn timeout)))&amp;lt;br&amp;gt;  java.io.Closeable&amp;lt;br&amp;gt;  (close [this] (close)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->FnTransport</a>[recv-fn send-fn close]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.transport&lt;/i&gt;&lt;b&gt;-&gt;QueueTransport&lt;/b&gt; ([in out])&lt;br&gt; Positional factory function for class clojure.tools.nrepl.transport.QueueTransport.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype QueueTransport [^BlockingQueue in ^BlockingQueue out]&amp;lt;br&amp;gt;  clojure.tools.nrepl.transport.Transport&amp;lt;br&amp;gt;  (send [this msg] (.put out msg) this)&amp;lt;br&amp;gt;  (recv [this] (.take in))&amp;lt;br&amp;gt;  (recv [this timeout] (.poll in timeout TimeUnit/MILLISECONDS)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->QueueTransport</a>[in out]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.transport&lt;/i&gt;&lt;b&gt;bencode&lt;/b&gt; ([s] [in out &amp; [s]])&lt;br&gt; Returns a Transport implementation that serializes messages&lt;br&gt;   over the given Socket or InputStream/OutputStream using bencode.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn bencode&amp;lt;br&amp;gt;  &amp;quot;Returns a Transport implementation that serializes messages&amp;lt;br&amp;gt;   over the given Socket or InputStream/OutputStream using bencode.&amp;quot;&amp;lt;br&amp;gt;  ([^Socket s] (bencode s s s))&amp;lt;br&amp;gt;  ([in out &amp;amp; [^Socket s]]&amp;lt;br&amp;gt;    (let [in (PushbackInputStream. (io/input-stream in))&amp;lt;br&amp;gt;          out (io/output-stream out)]&amp;lt;br&amp;gt;      (fn-transport&amp;lt;br&amp;gt;        #(let [payload (rethrow-on-disconnection s (be/read-bencode in))&amp;lt;br&amp;gt;               unencoded (&amp;lt;bytes (payload &amp;quot;-unencoded&amp;quot;))&amp;lt;br&amp;gt;               to-decode (apply dissoc payload &amp;quot;-unencoded&amp;quot; unencoded)]&amp;lt;br&amp;gt;           (merge (dissoc payload &amp;quot;-unencoded&amp;quot;)&amp;lt;br&amp;gt;                  (when unencoded {&amp;quot;-unencoded&amp;quot; unencoded})&amp;lt;br&amp;gt;                  (&amp;lt;bytes to-decode)))&amp;lt;br&amp;gt;        #(rethrow-on-disconnection s&amp;lt;br&amp;gt;           (locking out&amp;lt;br&amp;gt;             (doto out&amp;lt;br&amp;gt;               (be/write-bencode %)&amp;lt;br&amp;gt;               .flush)))&amp;lt;br&amp;gt;        (fn []&amp;lt;br&amp;gt;          (.close in)&amp;lt;br&amp;gt;          (.close out)&amp;lt;br&amp;gt;          (when s (.close s)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">bencode</a>[s] [in out & [s]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.transport&lt;/i&gt;&lt;b&gt;fn-transport&lt;/b&gt; ([read write] [read write close])&lt;br&gt; Returns a Transport implementation that delegates its functionality&lt;br&gt;   to the 2 or 3 functions provided.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn fn-transport&amp;lt;br&amp;gt;  &amp;quot;Returns a Transport implementation that delegates its functionality&amp;lt;br&amp;gt;   to the 2 or 3 functions provided.&amp;quot;&amp;lt;br&amp;gt;  ([read write] (fn-transport read write nil))&amp;lt;br&amp;gt;  ([read write close]&amp;lt;br&amp;gt;    (let [read-queue (SynchronousQueue.)]&amp;lt;br&amp;gt;      (future (try&amp;lt;br&amp;gt;                (while true&amp;lt;br&amp;gt;                  (.put read-queue (read)))&amp;lt;br&amp;gt;                (catch Throwable t&amp;lt;br&amp;gt;                  (.put read-queue t))))&amp;lt;br&amp;gt;      (FnTransport.&amp;lt;br&amp;gt;        (let [failure (atom nil)]&amp;lt;br&amp;gt;          #(if @failure&amp;lt;br&amp;gt;             (throw @failure)&amp;lt;br&amp;gt;             (let [msg (.poll read-queue % TimeUnit/MILLISECONDS)]&amp;lt;br&amp;gt;               (if (instance? Throwable msg)&amp;lt;br&amp;gt;                 (do (reset! failure msg) (throw msg))&amp;lt;br&amp;gt;                 msg))))&amp;lt;br&amp;gt;        write&amp;lt;br&amp;gt;        close))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">fn-transport</a>[read write] [read write close]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.transport&lt;/i&gt;&lt;b&gt;piped-transports&lt;/b&gt; ([])&lt;br&gt; Returns a pair of Transports that read from and write to each other.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn piped-transports&amp;lt;br&amp;gt;  &amp;quot;Returns a pair of Transports that read from and write to each other.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (let [a (LinkedBlockingQueue.)&amp;lt;br&amp;gt;        b (LinkedBlockingQueue.)]&amp;lt;br&amp;gt;    [(QueueTransport. a b) (QueueTransport. b a)]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">piped-transports</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.transport&lt;/i&gt;&lt;b&gt;recv&lt;/b&gt; ([this] [this timeout])&lt;br&gt; Reads and returns the next message received.  Will block.&lt;br&gt;     Should return nil the a message is not available after `timeout`&lt;br&gt;     ms or if the underlying channel has been closed.&lt;/div&gt;" data-placement="right">recv</a>[this] [this timeout]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.transport&lt;/i&gt;&lt;b&gt;send&lt;/b&gt; ([this msg])&lt;br&gt; Sends msg. Implementations should return the transport.&lt;/div&gt;" data-placement="right">send</a>[this msg]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.transport&lt;/i&gt;&lt;b&gt;tty&lt;/b&gt; ([s] [in out &amp; [s]])&lt;br&gt; Returns a Transport implementation suitable for serving an nREPL backend&lt;br&gt;   via simple in/out readers, as with a tty or telnet connection.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tty&amp;lt;br&amp;gt;  &amp;quot;Returns a Transport implementation suitable for serving an nREPL backend&amp;lt;br&amp;gt;   via simple in/out readers, as with a tty or telnet connection.&amp;quot;&amp;lt;br&amp;gt;  ([^Socket s] (tty s s s))&amp;lt;br&amp;gt;  ([in out &amp;amp; [^Socket s]]&amp;lt;br&amp;gt;    (let [r (PushbackReader. (io/reader in))&amp;lt;br&amp;gt;          w (io/writer out)&amp;lt;br&amp;gt;          cns (atom &amp;quot;user&amp;quot;)&amp;lt;br&amp;gt;          prompt (fn [newline?]&amp;lt;br&amp;gt;                   (when newline? (.write w (int \newline)))&amp;lt;br&amp;gt;                   (.write w (str @cns &amp;quot;=&amp;gt; &amp;quot;)))&amp;lt;br&amp;gt;          session-id (atom nil)&amp;lt;br&amp;gt;          read-msg #(let [code (read r)]&amp;lt;br&amp;gt;                      (merge {:op &amp;quot;eval&amp;quot; :code [code] :ns @cns :id (str &amp;quot;eval&amp;quot; (uuid))}&amp;lt;br&amp;gt;                             (when @session-id {:session @session-id})))&amp;lt;br&amp;gt;          read-seq (atom (cons {:op &amp;quot;clone&amp;quot;} (repeatedly read-msg)))&amp;lt;br&amp;gt;          write (fn [{:strs [out err value status ns new-session id] :as msg}]&amp;lt;br&amp;gt;                  (when new-session (reset! session-id new-session))&amp;lt;br&amp;gt;                  (when ns (reset! cns ns))&amp;lt;br&amp;gt;                  (doseq [^String x [out err value] :when x]&amp;lt;br&amp;gt;                    (.write w x))&amp;lt;br&amp;gt;                  (when (and (= status #{:done}) id (.startsWith ^String id &amp;quot;eval&amp;quot;))&amp;lt;br&amp;gt;                    (prompt true))&amp;lt;br&amp;gt;                  (.flush w))&amp;lt;br&amp;gt;          read #(let [head (promise)]&amp;lt;br&amp;gt;                  (swap! read-seq (fn [s]&amp;lt;br&amp;gt;                                     (deliver head (first s))&amp;lt;br&amp;gt;                                     (rest s)))&amp;lt;br&amp;gt;                  @head)]&amp;lt;br&amp;gt;      (fn-transport read write&amp;lt;br&amp;gt;        (when s&amp;lt;br&amp;gt;          (swap! read-seq (partial cons {:session @session-id :op &amp;quot;close&amp;quot;}))&amp;lt;br&amp;gt;          #(.close s))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tty</a>[s] [in out & [s]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.nrepl.transport&lt;/i&gt;&lt;b&gt;tty-greeting&lt;/b&gt; ([transport])&lt;br&gt; A greeting fn usable with clojure.tools.nrepl.server/start-server,&lt;br&gt;   meant to be used in conjunction with Transports returned by the&lt;br&gt;   `tty` function.&lt;br&gt;&lt;br&gt;   Usually, Clojure-aware client-side tooling would provide this upon connecting&lt;br&gt;   to the server, but telnet et al. isn't that.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn tty-greeting&amp;lt;br&amp;gt;  &amp;quot;A greeting fn usable with clojure.tools.nrepl.server/start-server,&amp;lt;br&amp;gt;   meant to be used in conjunction with Transports returned by the&amp;lt;br&amp;gt;   `tty` function.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Usually, Clojure-aware client-side tooling would provide this upon connecting&amp;lt;br&amp;gt;   to the server, but telnet et al. isn't that.&amp;quot;&amp;lt;br&amp;gt;  [transport]&amp;lt;br&amp;gt;  (send transport {:out (str &amp;quot;;; Clojure &amp;quot; (clojure-version)&amp;lt;br&amp;gt;                             \newline &amp;quot;user=&amp;gt; &amp;quot;)}))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">tty-greeting</a>[transport]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.reader</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader&lt;/i&gt;&lt;b&gt;read&lt;/b&gt; ([] [reader] [reader eof-error? sentinel] [reader eof-error? sentinel recursive?])&lt;br&gt; Reads the first object from an IPushbackReader or a java.io.PushbackReader.&lt;br&gt;   Returns the object read. If EOF, throws if eof-error? is true.&lt;br&gt;   Otherwise returns sentinel. If no stream is providen, *in* will be used.&lt;br&gt;&lt;br&gt;   ***WARNING***&lt;br&gt;   Note that read can execute code (controlled by *read-eval*),&lt;br&gt;   and as such should be used only with trusted sources.&lt;br&gt;&lt;br&gt;   To read data structures only, use clojure.tools.reader.edn/read&lt;br&gt;&lt;br&gt;   Note that the function signature of clojure.tools.reader/read and&lt;br&gt;   clojure.tools.reader.edn/read is not the same for eof-handling&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read&amp;lt;br&amp;gt;  &amp;quot;Reads the first object from an IPushbackReader or a java.io.PushbackReader.&amp;lt;br&amp;gt;   Returns the object read. If EOF, throws if eof-error? is true.&amp;lt;br&amp;gt;   Otherwise returns sentinel. If no stream is providen, *in* will be used.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   ***WARNING***&amp;lt;br&amp;gt;   Note that read can execute code (controlled by *read-eval*),&amp;lt;br&amp;gt;   and as such should be used only with trusted sources.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   To read data structures only, use clojure.tools.reader.edn/read&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Note that the function signature of clojure.tools.reader/read and&amp;lt;br&amp;gt;   clojure.tools.reader.edn/read is not the same for eof-handling&amp;quot;&amp;lt;br&amp;gt;  ([] (read *in*))&amp;lt;br&amp;gt;  ([reader] (read reader true nil))&amp;lt;br&amp;gt;  ([reader eof-error? sentinel] (read reader eof-error? sentinel false))&amp;lt;br&amp;gt;  ([reader eof-error? sentinel recursive?]&amp;lt;br&amp;gt;     (when (= :unknown *read-eval*)&amp;lt;br&amp;gt;       (reader-error &amp;quot;Reading disallowed - *read-eval* bound to :unknown&amp;quot;))&amp;lt;br&amp;gt;     (try&amp;lt;br&amp;gt;       (let [ch (read-char reader)]&amp;lt;br&amp;gt;         (cond&amp;lt;br&amp;gt;          (whitespace? ch) (read reader eof-error? sentinel recursive?)&amp;lt;br&amp;gt;          (nil? ch) (if eof-error? (reader-error reader &amp;quot;EOF&amp;quot;) sentinel)&amp;lt;br&amp;gt;          (number-literal? reader ch) (read-number reader ch)&amp;lt;br&amp;gt;          (comment-prefix? ch) (read (read-comment reader ch) eof-error? sentinel recursive?)&amp;lt;br&amp;gt;          :else (let [f (macros ch)]&amp;lt;br&amp;gt;                  (if f&amp;lt;br&amp;gt;                    (let [res (f reader ch)]&amp;lt;br&amp;gt;                      (if (identical? res reader)&amp;lt;br&amp;gt;                        (read reader eof-error? sentinel recursive?)&amp;lt;br&amp;gt;                        res))&amp;lt;br&amp;gt;                    (read-symbol reader ch)))))&amp;lt;br&amp;gt;       (catch Exception e&amp;lt;br&amp;gt;         (if (ex-info? e)&amp;lt;br&amp;gt;           (throw e)&amp;lt;br&amp;gt;           (throw (ex-info (.getMessage e)&amp;lt;br&amp;gt;                           (merge {:type :reader-exception}&amp;lt;br&amp;gt;                                  (if (indexing-reader? reader)&amp;lt;br&amp;gt;                                    {:line (get-line-number reader)&amp;lt;br&amp;gt;                                     :column (get-column-number reader)}))&amp;lt;br&amp;gt;                           e)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read</a>[] [reader] [reader eof-error? sentinel] [reader eof-error? sentinel recursive?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader&lt;/i&gt;&lt;b&gt;read-string&lt;/b&gt; ([s])&lt;br&gt; Reads one object from the string s.&lt;br&gt;   Returns nil when s is nil or empty.&lt;br&gt;&lt;br&gt;   ***WARNING***&lt;br&gt;   Note that read-string can execute code (controlled by *read-eval*),&lt;br&gt;   and as such should be used only with trusted sources.&lt;br&gt;&lt;br&gt;   To read data structures only, use clojure.tools.reader.edn/read-string&lt;br&gt;&lt;br&gt;   Note that the function signature of clojure.tools.reader/read-string and&lt;br&gt;   clojure.tools.reader.edn/read-string is not the same for eof-handling&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-string&amp;lt;br&amp;gt;  &amp;quot;Reads one object from the string s.&amp;lt;br&amp;gt;   Returns nil when s is nil or empty.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   ***WARNING***&amp;lt;br&amp;gt;   Note that read-string can execute code (controlled by *read-eval*),&amp;lt;br&amp;gt;   and as such should be used only with trusted sources.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   To read data structures only, use clojure.tools.reader.edn/read-string&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   Note that the function signature of clojure.tools.reader/read-string and&amp;lt;br&amp;gt;   clojure.tools.reader.edn/read-string is not the same for eof-handling&amp;quot;&amp;lt;br&amp;gt;  [s]&amp;lt;br&amp;gt;  (when (and s (not (identical? s &amp;quot;&amp;quot;)))&amp;lt;br&amp;gt;    (read (string-push-back-reader s) true nil false)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-string</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader&lt;/i&gt;&lt;b&gt;syntax-quote&lt;/b&gt; ([form])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro syntax-quote [form]&amp;lt;br&amp;gt;  &amp;quot;Macro equivalent to the syntax-quote reader macro (`).&amp;quot;&amp;lt;br&amp;gt;  (binding [gensym-env {}]&amp;lt;br&amp;gt;    (syntax-quote* form)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">syntax-quote</a>[form]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.reader.default-data-readers</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.default-data-readers&lt;/i&gt;&lt;b&gt;default-uuid-reader&lt;/b&gt; ([form])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn default-uuid-reader [form]&amp;lt;br&amp;gt;  {:pre [(string? form)]}&amp;lt;br&amp;gt;  (java.util.UUID/fromString form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">default-uuid-reader</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.default-data-readers&lt;/i&gt;&lt;b&gt;validated&lt;/b&gt; ([new-instance])&lt;br&gt; Return a function which constructs and instant by calling constructor&lt;br&gt;after first validating that those arguments are in range and otherwise&lt;br&gt;plausible. The resulting function will throw an exception if called&lt;br&gt;with invalid arguments.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn validated&amp;lt;br&amp;gt;  &amp;quot;Return a function which constructs and instant by calling constructor&amp;lt;br&amp;gt;after first validating that those arguments are in range and otherwise&amp;lt;br&amp;gt;plausible. The resulting function will throw an exception if called&amp;lt;br&amp;gt;with invalid arguments.&amp;quot;&amp;lt;br&amp;gt;  [new-instance]&amp;lt;br&amp;gt;  (fn [years months days hours minutes seconds nanoseconds&amp;lt;br&amp;gt;       offset-sign offset-hours offset-minutes]&amp;lt;br&amp;gt;    (verify (&amp;lt;= 1 months 12))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 1 days (days-in-month months (leap-year? years))))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 0 hours 23))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 0 minutes 59))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 0 seconds (if (= minutes 59) 60 59)))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 0 nanoseconds 999999999))&amp;lt;br&amp;gt;    (verify (&amp;lt;= -1 offset-sign 1))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 0 offset-hours 23))&amp;lt;br&amp;gt;    (verify (&amp;lt;= 0 offset-minutes 59))&amp;lt;br&amp;gt;    (new-instance years months days hours minutes seconds nanoseconds&amp;lt;br&amp;gt;                  offset-sign offset-hours offset-minutes)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">validated</a>[new-instance]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.reader.impl.ExceptionInfo</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.ExceptionInfo&lt;/i&gt;&lt;b&gt;-getData&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -getData [this]&amp;lt;br&amp;gt;  (.data this))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-getData</a>[this]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.ExceptionInfo&lt;/i&gt;&lt;b&gt;-init&lt;/b&gt; ([s data] [s data throwable])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -init&amp;lt;br&amp;gt;  ([s data]&amp;lt;br&amp;gt;     [[s] data])&amp;lt;br&amp;gt;  ([s data throwable]&amp;lt;br&amp;gt;     [[s throwable] data]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-init</a>[s data] [s data throwable]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.ExceptionInfo&lt;/i&gt;&lt;b&gt;-toString&lt;/b&gt; ([this])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn -toString [this]&amp;lt;br&amp;gt;  (str &amp;quot;clojure.toold.reader.ExceptionInfo: &amp;quot; (.getMessage this) &amp;quot; &amp;quot; (str (.data this))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">-toString</a>[this]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.reader.impl.commons</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.commons&lt;/i&gt;&lt;b&gt;match-number&lt;/b&gt; ([s])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn match-number [^String s]&amp;lt;br&amp;gt;  (let [int-matcher (.matcher int-pattern s)]&amp;lt;br&amp;gt;    (if (.matches int-matcher)&amp;lt;br&amp;gt;      (match-int int-matcher)&amp;lt;br&amp;gt;      (let [float-matcher (.matcher float-pattern s)]&amp;lt;br&amp;gt;        (if (.matches float-matcher)&amp;lt;br&amp;gt;          (match-float s float-matcher)&amp;lt;br&amp;gt;          (let [ratio-matcher (.matcher ratio-pattern s)]&amp;lt;br&amp;gt;            (when (.matches ratio-matcher)&amp;lt;br&amp;gt;              (match-ratio ratio-matcher))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">match-number</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.commons&lt;/i&gt;&lt;b&gt;number-literal?&lt;/b&gt; ([reader initch])&lt;br&gt; Checks whether the reader is at the start of a number literal&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn number-literal?&amp;lt;br&amp;gt;  &amp;quot;Checks whether the reader is at the start of a number literal&amp;quot;&amp;lt;br&amp;gt;  [reader initch]&amp;lt;br&amp;gt;  (or (numeric? initch)&amp;lt;br&amp;gt;      (and (or (identical? \+ initch) (identical?  \- initch))&amp;lt;br&amp;gt;           (numeric? (peek-char reader)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">number-literal?</a>[reader initch]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.commons&lt;/i&gt;&lt;b&gt;parse-symbol&lt;/b&gt; ([token])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-symbol [^String token]&amp;lt;br&amp;gt;  (when-not (identical? &amp;quot;&amp;quot; token)&amp;lt;br&amp;gt;    (let [ns-idx (.indexOf token &amp;quot;/&amp;quot;)]&amp;lt;br&amp;gt;      (if-let [ns (and (pos? ns-idx)&amp;lt;br&amp;gt;                       (subs token 0 ns-idx))]&amp;lt;br&amp;gt;        (let [ns-idx (inc ns-idx)]&amp;lt;br&amp;gt;          (when-not (== ns-idx (count token))&amp;lt;br&amp;gt;            (let [sym (subs token ns-idx)]&amp;lt;br&amp;gt;              (when (and (not (numeric? (nth sym 0)))&amp;lt;br&amp;gt;                         (not (identical? &amp;quot;&amp;quot; sym))&amp;lt;br&amp;gt;                         (or (= sym &amp;quot;/&amp;quot;)&amp;lt;br&amp;gt;                             (== -1 (.indexOf sym &amp;quot;/&amp;quot;))))&amp;lt;br&amp;gt;                [ns sym]))))&amp;lt;br&amp;gt;        [nil token]))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-symbol</a>[token]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.commons&lt;/i&gt;&lt;b&gt;read-comment&lt;/b&gt; ([rdr &amp; _])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-comment&amp;lt;br&amp;gt;  [rdr &amp;amp; _]&amp;lt;br&amp;gt;  (skip-line rdr _))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-comment</a>[rdr & _]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.commons&lt;/i&gt;&lt;b&gt;read-past&lt;/b&gt; ([pred rdr])&lt;br&gt; Read until first character that doesn't match pred, returning&lt;br&gt;   char.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-past&amp;lt;br&amp;gt;  &amp;quot;Read until first character that doesn't match pred, returning&amp;lt;br&amp;gt;   char.&amp;quot;&amp;lt;br&amp;gt;  [pred rdr]&amp;lt;br&amp;gt;  (loop [ch (read-char rdr)]&amp;lt;br&amp;gt;    (if (pred ch)&amp;lt;br&amp;gt;      (recur (read-char rdr))&amp;lt;br&amp;gt;      ch)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-past</a>[pred rdr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.commons&lt;/i&gt;&lt;b&gt;read-regex&lt;/b&gt; ([rdr ch])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-regex&amp;lt;br&amp;gt;  [rdr ch]&amp;lt;br&amp;gt;  (let [sb (StringBuilder.)]&amp;lt;br&amp;gt;    (loop [ch (read-char rdr)]&amp;lt;br&amp;gt;      (if (identical? \&amp;quot; ch)&amp;lt;br&amp;gt;        (Pattern/compile (str sb))&amp;lt;br&amp;gt;        (if (nil? ch)&amp;lt;br&amp;gt;          (reader-error rdr &amp;quot;EOF while reading regex&amp;quot;)&amp;lt;br&amp;gt;          (do&amp;lt;br&amp;gt;            (.append sb ch )&amp;lt;br&amp;gt;            (when (identical? \\ ch)&amp;lt;br&amp;gt;              (let [ch (read-char rdr)]&amp;lt;br&amp;gt;                (if (nil? ch)&amp;lt;br&amp;gt;                  (reader-error rdr &amp;quot;EOF while reading regex&amp;quot;))&amp;lt;br&amp;gt;                (.append sb ch)))&amp;lt;br&amp;gt;            (recur (read-char rdr))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-regex</a>[rdr ch]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.commons&lt;/i&gt;&lt;b&gt;skip-line&lt;/b&gt; ([reader _])&lt;br&gt; Advances the reader to the end of a line. Returns the reader&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn skip-line&amp;lt;br&amp;gt;  &amp;quot;Advances the reader to the end of a line. Returns the reader&amp;quot;&amp;lt;br&amp;gt;  [reader _]&amp;lt;br&amp;gt;  (loop []&amp;lt;br&amp;gt;    (when-not (newline? (read-char reader))&amp;lt;br&amp;gt;      (recur)))&amp;lt;br&amp;gt;  reader)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">skip-line</a>[reader _]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.commons&lt;/i&gt;&lt;b&gt;throwing-reader&lt;/b&gt; ([msg])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn throwing-reader&amp;lt;br&amp;gt;  [msg]&amp;lt;br&amp;gt;  (fn [rdr &amp;amp; _]&amp;lt;br&amp;gt;    (reader-error rdr msg)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">throwing-reader</a>[msg]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.reader.impl.utils</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.utils&lt;/i&gt;&lt;b&gt;char&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn char [x]&amp;lt;br&amp;gt;  (when x&amp;lt;br&amp;gt;    (clojure.core/char x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">char</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.utils&lt;/i&gt;&lt;b&gt;comment-prefix?&lt;/b&gt; ([ch])&lt;br&gt; Checks whether the character begins a comment.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn comment-prefix?&amp;lt;br&amp;gt;  &amp;quot;Checks whether the character begins a comment.&amp;quot;&amp;lt;br&amp;gt;  [ch]&amp;lt;br&amp;gt;  (identical? \;  ch))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">comment-prefix?</a>[ch]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.utils&lt;/i&gt;&lt;b&gt;desugar-meta&lt;/b&gt; ([f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn desugar-meta&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;    (keyword? f) {f true}&amp;lt;br&amp;gt;    (symbol? f)  {:tag f}&amp;lt;br&amp;gt;    (string? f)  {:tag f}&amp;lt;br&amp;gt;    :else        f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">desugar-meta</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.utils&lt;/i&gt;&lt;b&gt;ex-info?&lt;/b&gt; ([ex])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(compile-if (= 3 (:minor *clojure-version*))&amp;lt;br&amp;gt;  (do&amp;lt;br&amp;gt;    (defn ex-info&amp;lt;br&amp;gt;      ([msg map]&amp;lt;br&amp;gt;         (clojure.tools.reader.impl.ExceptionInfo. msg map))&amp;lt;br&amp;gt;      ([msg map cause]&amp;lt;br&amp;gt;         (clojure.tools.reader.impl.ExceptionInfo. msg map cause)))&amp;lt;br&amp;gt;    (defn ex-data&amp;lt;br&amp;gt;      [ex]&amp;lt;br&amp;gt;      (.getData ex))&amp;lt;br&amp;gt;    (defn ex-info? [ex]&amp;lt;br&amp;gt;      (instance? clojure.tools.reader.impl.ExceptionInfo ex)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (defn ex-info? [ex]&amp;lt;br&amp;gt;    (instance? clojure.lang.ExceptionInfo ex)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ex-info?</a>[ex]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.utils&lt;/i&gt;&lt;b&gt;newline?&lt;/b&gt; ([c])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn newline? [c]&amp;lt;br&amp;gt;  &amp;quot;Checks whether the character is a newline&amp;quot;&amp;lt;br&amp;gt;  (or (identical? \newline c)&amp;lt;br&amp;gt;      (nil? c)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">newline?</a>[c]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.utils&lt;/i&gt;&lt;b&gt;numeric?&lt;/b&gt; ([ch])&lt;br&gt; Checks whether a given character is numeric&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn numeric?&amp;lt;br&amp;gt;  &amp;quot;Checks whether a given character is numeric&amp;quot;&amp;lt;br&amp;gt;  [^Character ch]&amp;lt;br&amp;gt;  (when ch&amp;lt;br&amp;gt;    (Character/isDigit ch)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">numeric?</a>[ch]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.impl.utils&lt;/i&gt;&lt;b&gt;whitespace?&lt;/b&gt; ([ch])&lt;br&gt; Checks whether a given character is whitespace&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn whitespace?&amp;lt;br&amp;gt;  &amp;quot;Checks whether a given character is whitespace&amp;quot;&amp;lt;br&amp;gt;  [ch]&amp;lt;br&amp;gt;  (when ch&amp;lt;br&amp;gt;    (or (Character/isWhitespace ^Character ch)&amp;lt;br&amp;gt;        (identical? \,  ch))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">whitespace?</a>[ch]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.reader.reader-types</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;-&gt;IndexingPushbackReader&lt;/b&gt; ([rdr line column line-start? prev])&lt;br&gt; Positional factory function for class clojure.tools.reader.reader_types.IndexingPushbackReader.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype IndexingPushbackReader&amp;lt;br&amp;gt;    [rdr ^:unsynchronized-mutable line ^:unsynchronized-mutable column&amp;lt;br&amp;gt;     ^:unsynchronized-mutable line-start? ^:unsynchronized-mutable prev]&amp;lt;br&amp;gt;  Reader&amp;lt;br&amp;gt;  (read-char [reader]&amp;lt;br&amp;gt;    (when-let [ch (read-char rdr)]&amp;lt;br&amp;gt;      (let [ch (normalize-newline rdr ch)]&amp;lt;br&amp;gt;        (set! prev line-start?)&amp;lt;br&amp;gt;        (set! line-start? (newline? ch))&amp;lt;br&amp;gt;        (when line-start?&amp;lt;br&amp;gt;          (set! column 0)&amp;lt;br&amp;gt;          (update! line inc))&amp;lt;br&amp;gt;        (update! column inc)&amp;lt;br&amp;gt;        ch)))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  (peek-char [reader]&amp;lt;br&amp;gt;    (peek-char rdr))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IPushbackReader&amp;lt;br&amp;gt;  (unread [reader ch]&amp;lt;br&amp;gt;    (when line-start? (update! line dec))&amp;lt;br&amp;gt;    (set! line-start? prev)&amp;lt;br&amp;gt;    (update! column dec)&amp;lt;br&amp;gt;    (unread rdr ch))&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  IndexingReader&amp;lt;br&amp;gt;  (get-line-number [reader] (int (inc line)))&amp;lt;br&amp;gt;  (get-column-number [reader] (int column)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->IndexingPushbackReader</a>[rdr line column line-start? prev]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;-&gt;InputStreamReader&lt;/b&gt; ([is buf])&lt;br&gt; Positional factory function for class clojure.tools.reader.reader_types.InputStreamReader.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype InputStreamReader [^InputStream is ^:unsynchronized-mutable ^&amp;quot;[B&amp;quot; buf]&amp;lt;br&amp;gt;  Reader&amp;lt;br&amp;gt;  (read-char [reader]&amp;lt;br&amp;gt;    (if buf&amp;lt;br&amp;gt;      (let [c (aget buf 0)]&amp;lt;br&amp;gt;        (set! buf nil)&amp;lt;br&amp;gt;        (char c))&amp;lt;br&amp;gt;      (let [c (.read is)]&amp;lt;br&amp;gt;        (when (&amp;gt;= c 0)&amp;lt;br&amp;gt;          (char c)))))&amp;lt;br&amp;gt;  (peek-char [reader]&amp;lt;br&amp;gt;    (when-not buf&amp;lt;br&amp;gt;      (set! buf (byte-array 1))&amp;lt;br&amp;gt;      (when (== -1 (.read is buf))&amp;lt;br&amp;gt;        (set! buf nil)))&amp;lt;br&amp;gt;    (when buf&amp;lt;br&amp;gt;      (char (aget buf 0)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->InputStreamReader</a>[is buf]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;-&gt;PushbackReader&lt;/b&gt; ([rdr buf buf-len buf-pos])&lt;br&gt; Positional factory function for class clojure.tools.reader.reader_types.PushbackReader.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype PushbackReader&amp;lt;br&amp;gt;    [rdr ^&amp;quot;[Ljava.lang.Object;&amp;quot; buf buf-len ^:unsynchronized-mutable buf-pos]&amp;lt;br&amp;gt;  Reader&amp;lt;br&amp;gt;  (read-char [reader]&amp;lt;br&amp;gt;    (char&amp;lt;br&amp;gt;     (if (&amp;lt; buf-pos buf-len)&amp;lt;br&amp;gt;       (let [r (aget buf buf-pos)]&amp;lt;br&amp;gt;         (update! buf-pos inc)&amp;lt;br&amp;gt;         r)&amp;lt;br&amp;gt;       (read-char rdr))))&amp;lt;br&amp;gt;  (peek-char [reader]&amp;lt;br&amp;gt;    (char&amp;lt;br&amp;gt;     (if (&amp;lt; buf-pos buf-len)&amp;lt;br&amp;gt;       (aget buf buf-pos)&amp;lt;br&amp;gt;       (peek-char rdr))))&amp;lt;br&amp;gt;  IPushbackReader&amp;lt;br&amp;gt;  (unread [reader ch]&amp;lt;br&amp;gt;    (when ch&amp;lt;br&amp;gt;      (if (zero? buf-pos) (throw (RuntimeException. &amp;quot;Pushback buffer is full&amp;quot;)))&amp;lt;br&amp;gt;      (update! buf-pos dec)&amp;lt;br&amp;gt;      (aset buf buf-pos ch))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->PushbackReader</a>[rdr buf buf-len buf-pos]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;-&gt;StringReader&lt;/b&gt; ([s s-len s-pos])&lt;br&gt; Positional factory function for class clojure.tools.reader.reader_types.StringReader.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype StringReader&amp;lt;br&amp;gt;    [^String s s-len ^:unsynchronized-mutable s-pos]&amp;lt;br&amp;gt;  Reader&amp;lt;br&amp;gt;  (read-char [reader]&amp;lt;br&amp;gt;    (when (&amp;gt; s-len s-pos)&amp;lt;br&amp;gt;      (let [r (nth s s-pos)]&amp;lt;br&amp;gt;        (update! s-pos inc)&amp;lt;br&amp;gt;        r)))&amp;lt;br&amp;gt;  (peek-char [reader]&amp;lt;br&amp;gt;    (when (&amp;gt; s-len s-pos)&amp;lt;br&amp;gt;      (nth s s-pos))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->StringReader</a>[s s-len s-pos]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;get-column-number&lt;/b&gt; ([reader])&lt;br&gt; Returns the line number of the next character to be read from the stream&lt;/div&gt;" data-placement="right">get-column-number</a>[reader]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;get-line-number&lt;/b&gt; ([reader])&lt;br&gt; Returns the line number of the next character to be read from the stream&lt;/div&gt;" data-placement="right">get-line-number</a>[reader]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;indexing-push-back-reader&lt;/b&gt; ([s-or-rdr] [s-or-rdr buf-len])&lt;br&gt; Creates an IndexingPushbackReader from a given string or Reader&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn indexing-push-back-reader&amp;lt;br&amp;gt;  &amp;quot;Creates an IndexingPushbackReader from a given string or Reader&amp;quot;&amp;lt;br&amp;gt;  ([s-or-rdr]&amp;lt;br&amp;gt;     (indexing-push-back-reader s-or-rdr 1))&amp;lt;br&amp;gt;  ([s-or-rdr buf-len]&amp;lt;br&amp;gt;     (IndexingPushbackReader.&amp;lt;br&amp;gt;      (if (string? s-or-rdr) (string-push-back-reader s-or-rdr buf-len) s-or-rdr) 0 1 true nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">indexing-push-back-reader</a>[s-or-rdr] [s-or-rdr buf-len]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;indexing-reader?&lt;/b&gt; ([rdr])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn indexing-reader? [rdr]&amp;lt;br&amp;gt;  &amp;quot;Returns true if the reader satisfies IndexingReader&amp;quot;&amp;lt;br&amp;gt;  (or (instance? clojure.tools.reader.reader_types.IndexingReader rdr)&amp;lt;br&amp;gt;      (instance? LineNumberingPushbackReader rdr)&amp;lt;br&amp;gt;      (and (not (instance? clojure.tools.reader.reader_types.PushbackReader rdr))&amp;lt;br&amp;gt;           (not (instance? clojure.tools.reader.reader_types.StringReader rdr))&amp;lt;br&amp;gt;           (not (instance? clojure.tools.reader.reader_types.InputStreamReader rdr))&amp;lt;br&amp;gt;           (get (:impls IndexingReader) (class rdr)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">indexing-reader?</a>[rdr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;input-stream-push-back-reader&lt;/b&gt; ([is] [is buf-len])&lt;br&gt; Creates a PushbackReader from a given InputString&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn input-stream-push-back-reader&amp;lt;br&amp;gt;  &amp;quot;Creates a PushbackReader from a given InputString&amp;quot;&amp;lt;br&amp;gt;  ([is]&amp;lt;br&amp;gt;     (input-stream-push-back-reader is 1))&amp;lt;br&amp;gt;  ([^InputStream is buf-len]&amp;lt;br&amp;gt;     (PushbackReader. (input-stream-reader is) (object-array buf-len) buf-len buf-len)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">input-stream-push-back-reader</a>[is] [is buf-len]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;input-stream-reader&lt;/b&gt; ([is])&lt;br&gt; Creates an InputStreamReader from an InputString&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn input-stream-reader&amp;lt;br&amp;gt;  &amp;quot;Creates an InputStreamReader from an InputString&amp;quot;&amp;lt;br&amp;gt;  [is]&amp;lt;br&amp;gt;  (InputStreamReader. is nil))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">input-stream-reader</a>[is]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;peek-char&lt;/b&gt; ([reader])&lt;br&gt; Returns the next char from the Reader without removing it from the reader stream&lt;/div&gt;" data-placement="right">peek-char</a>[reader]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;read-char&lt;/b&gt; ([reader])&lt;br&gt; Returns the next char from the Reader, nil if the end of stream has been reached&lt;/div&gt;" data-placement="right">read-char</a>[reader]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;read-line&lt;/b&gt; ([] [rdr])&lt;br&gt; Reads a line from the reader or from *in* if no reader is specified&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn read-line&amp;lt;br&amp;gt;  &amp;quot;Reads a line from the reader or from *in* if no reader is specified&amp;quot;&amp;lt;br&amp;gt;  ([] (read-line *in*))&amp;lt;br&amp;gt;  ([rdr]&amp;lt;br&amp;gt;     (if (or (instance? LineNumberingPushbackReader rdr)&amp;lt;br&amp;gt;             (instance? BufferedReader rdr))&amp;lt;br&amp;gt;       (clojure.core/read-line rdr)&amp;lt;br&amp;gt;       (loop [c (read-char rdr) s (StringBuilder.)]&amp;lt;br&amp;gt;         (if (newline? c)&amp;lt;br&amp;gt;           (str s)&amp;lt;br&amp;gt;           (recur (read-char rdr) (.append s c)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">read-line</a>[] [rdr]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;reader-error&lt;/b&gt; ([rdr &amp; msg])&lt;br&gt; Throws an ExceptionInfo with the given message.&lt;br&gt;   If rdr is an IndexingReader, additional information about column and line number is provided&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reader-error&amp;lt;br&amp;gt;  &amp;quot;Throws an ExceptionInfo with the given message.&amp;lt;br&amp;gt;   If rdr is an IndexingReader, additional information about column and line number is provided&amp;quot;&amp;lt;br&amp;gt;  [rdr &amp;amp; msg]&amp;lt;br&amp;gt;  (throw (ex-info (apply str msg)&amp;lt;br&amp;gt;                  (merge {:type :reader-exception}&amp;lt;br&amp;gt;                         (when (indexing-reader? rdr)&amp;lt;br&amp;gt;                           {:line (get-line-number rdr)&amp;lt;br&amp;gt;                            :column (get-column-number rdr)})))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reader-error</a>[rdr & msg]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;string-push-back-reader&lt;/b&gt; ([s] [s buf-len])&lt;br&gt; Creates a PushbackReader from a given string&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn string-push-back-reader&amp;lt;br&amp;gt;  &amp;quot;Creates a PushbackReader from a given string&amp;quot;&amp;lt;br&amp;gt;  ([s]&amp;lt;br&amp;gt;     (string-push-back-reader s 1))&amp;lt;br&amp;gt;  ([^String s buf-len]&amp;lt;br&amp;gt;     (PushbackReader. (string-reader s) (object-array buf-len) buf-len buf-len)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">string-push-back-reader</a>[s] [s buf-len]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;string-reader&lt;/b&gt; ([s])&lt;br&gt; Creates a StringReader from a given string&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn string-reader&amp;lt;br&amp;gt;  &amp;quot;Creates a StringReader from a given string&amp;quot;&amp;lt;br&amp;gt;  ([^String s]&amp;lt;br&amp;gt;     (StringReader. s (count s) 0)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">string-reader</a>[s]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.reader.reader-types&lt;/i&gt;&lt;b&gt;unread&lt;/b&gt; ([reader ch])&lt;br&gt; Pushes back a single character on to the stream&lt;/div&gt;" data-placement="right">unread</a>[reader ch]</div></div></div><div class="row"><div class="namespace"><h4>clojure.tools.trace</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;deftrace&lt;/b&gt; ([name &amp; definition])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Use in place of defn; traces each call/return of this fn, including&lt;br&gt;   arguments. Nested calls to deftrace'd functions will print a&lt;br&gt;   tree-like structure.&lt;br&gt;   The first argument of the form definition can be a doc string&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro deftrace&amp;lt;br&amp;gt;  &amp;quot;Use in place of defn; traces each call/return of this fn, including&amp;lt;br&amp;gt;   arguments. Nested calls to deftrace'd functions will print a&amp;lt;br&amp;gt;   tree-like structure.&amp;lt;br&amp;gt;   The first argument of the form definition can be a doc string&amp;quot;&amp;lt;br&amp;gt;  [name &amp;amp; definition]&amp;lt;br&amp;gt;  (let [doc-string (if (string? (first definition)) (first definition) &amp;quot;&amp;quot;)&amp;lt;br&amp;gt;        fn-form  (if (string? (first definition)) (rest definition) definition)]&amp;lt;br&amp;gt;    `(do&amp;lt;br&amp;gt;       (def ~name)&amp;lt;br&amp;gt;       (let [f# (fn ~@fn-form)]&amp;lt;br&amp;gt;         (defn ~name ~doc-string [&amp;amp; args#]&amp;lt;br&amp;gt;           (trace-fn-call '~name f# args#))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">deftrace</a>[name & definition]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;dotrace&lt;/b&gt; ([fnames &amp; exprs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Given a sequence of function identifiers, evaluate the body&lt;br&gt;expressions in an environment in which the identifiers are bound to&lt;br&gt;the traced functions. Does not work on inlined functions,&lt;br&gt;such as clojure.core/+&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro dotrace&amp;lt;br&amp;gt;  &amp;quot;Given a sequence of function identifiers, evaluate the body&amp;lt;br&amp;gt;expressions in an environment in which the identifiers are bound to&amp;lt;br&amp;gt;the traced functions. Does not work on inlined functions,&amp;lt;br&amp;gt;such as clojure.core/+&amp;quot;&amp;lt;br&amp;gt;  [fnames &amp;amp; exprs]&amp;lt;br&amp;gt;  `(binding [~@(interleave fnames&amp;lt;br&amp;gt;                           (for [fname fnames]&amp;lt;br&amp;gt;                             `(let [f# @(var ~fname)]&amp;lt;br&amp;gt;                                (fn [&amp;amp; args#]&amp;lt;br&amp;gt;                                  (trace-fn-call '~fname f# args#)))))]&amp;lt;br&amp;gt;     ~@exprs))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dotrace</a>[fnames & exprs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;trace&lt;/b&gt; ([value] [name value])&lt;br&gt; Sends name (optional) and value to the tracer function, then&lt;br&gt;returns value. May be wrapped around any expression without&lt;br&gt;affecting the result.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn trace&amp;lt;br&amp;gt;  &amp;quot;Sends name (optional) and value to the tracer function, then&amp;lt;br&amp;gt;returns value. May be wrapped around any expression without&amp;lt;br&amp;gt;affecting the result.&amp;quot;&amp;lt;br&amp;gt;  ([value] (trace nil value))&amp;lt;br&amp;gt;  ([name value]&amp;lt;br&amp;gt;     (tracer name (pr-str value))&amp;lt;br&amp;gt;     value))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace</a>[value] [name value]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;trace-compose-exception&lt;/b&gt; ([exception message])&lt;br&gt; Re-create a new exception with a composed message from the given exception&lt;br&gt;   and the message to be added. The exception stack trace is kept at a minimum.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^{:skip-wiki true} trace-compose-exception &amp;lt;br&amp;gt;  &amp;quot;Re-create a new exception with a composed message from the given exception&amp;lt;br&amp;gt;   and the message to be added. The exception stack trace is kept at a minimum.&amp;quot;&amp;lt;br&amp;gt;  [^Exception exception ^String message]&amp;lt;br&amp;gt;  (let [klass  (class exception) &amp;lt;br&amp;gt;        previous-msg (.getMessage exception)&amp;lt;br&amp;gt;        composed-msg(str previous-msg (if-not (.endsWith previous-msg &amp;quot;\n&amp;quot;) &amp;quot;\n&amp;quot;) message (if-not (.endsWith message &amp;quot;\n&amp;quot;) &amp;quot;\n&amp;quot;))&amp;lt;br&amp;gt;        ctor (.getConstructor klass (into-array [java.lang.String]))&amp;lt;br&amp;gt;        new-exception ^Exception (cast klass (.newInstance ctor (into-array String [composed-msg])))&amp;lt;br&amp;gt;        new-stack-trace (into-array java.lang.StackTraceElement [(aget (.getStackTrace exception) 0)])&amp;lt;br&amp;gt;        _ (.setStackTrace new-exception new-stack-trace)]&amp;lt;br&amp;gt;     new-exception))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-compose-exception</a>[exception message]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;trace-fn-call&lt;/b&gt; ([name f args])&lt;br&gt; Traces a single call to a function f with args. 'name' is the&lt;br&gt;symbol name of the function.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^{:skip-wiki true} trace-fn-call&amp;lt;br&amp;gt;  &amp;quot;Traces a single call to a function f with args. 'name' is the&amp;lt;br&amp;gt;symbol name of the function.&amp;quot;&amp;lt;br&amp;gt;  [name f args]&amp;lt;br&amp;gt;  (let [id (gensym &amp;quot;t&amp;quot;)]&amp;lt;br&amp;gt;    (tracer id (str (trace-indent) (pr-str (cons name args))))&amp;lt;br&amp;gt;    (let [value (binding [*trace-depth* (inc *trace-depth*)]&amp;lt;br&amp;gt;                  (apply f args))]&amp;lt;br&amp;gt;      (tracer id (str (trace-indent) &amp;quot;=&amp;gt; &amp;quot; (pr-str value)))&amp;lt;br&amp;gt;      value)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-fn-call</a>[name f args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;trace-form&lt;/b&gt; ([form])&lt;br&gt; Trace the given form avoiding try catch when recur is present in the form.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^{:skip-wiki true} trace-form&amp;lt;br&amp;gt;  &amp;quot;Trace the given form avoiding try catch when recur is present in the form.&amp;quot;&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (if (recurs? form)&amp;lt;br&amp;gt;    (trace-form* form)&amp;lt;br&amp;gt;    `(try&amp;lt;br&amp;gt;       ~(trace-form* form)&amp;lt;br&amp;gt;       (catch Exception e#&amp;lt;br&amp;gt;         (throw (trace-compose-exception e# (format &amp;quot;  Form failed: %s&amp;quot; (with-out-str (pprint '~form)))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-form</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;trace-forms&lt;/b&gt; ([&amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Trace all the forms in the given body. Returns any underlying uncaught exceptions that may make the forms fail.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro trace-forms&amp;lt;br&amp;gt;  &amp;quot;Trace all the forms in the given body. Returns any underlying uncaught exceptions that may make the forms fail.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; body]&amp;lt;br&amp;gt;  `(do&amp;lt;br&amp;gt;     ~@(map trace-form body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-forms</a>[& body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;trace-ns&lt;/b&gt; ([ns])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Trace all fns in the given name space.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro trace-ns&amp;lt;br&amp;gt;  &amp;quot;Trace all fns in the given name space.&amp;quot;&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  `(trace-ns* ~ns))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-ns</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;trace-ns*&lt;/b&gt; ([ns])&lt;br&gt; Replaces each function from the given namespace with a version wrapped&lt;br&gt;  in a tracing call. Can be undone with untrace-ns. ns should be a namespace&lt;br&gt;  object or a symbol.&lt;br&gt;&lt;br&gt;  No-op for clojure.core and clojure.tools.trace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^{:skip-wiki true} trace-ns*&amp;lt;br&amp;gt;  &amp;quot;Replaces each function from the given namespace with a version wrapped&amp;lt;br&amp;gt;  in a tracing call. Can be undone with untrace-ns. ns should be a namespace&amp;lt;br&amp;gt;  object or a symbol.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  No-op for clojure.core and clojure.tools.trace.&amp;quot;&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (let [ns (the-ns ns)]&amp;lt;br&amp;gt;    (when-not ('#{clojure.core clojure.tools.trace} (.name ns))&amp;lt;br&amp;gt;      (let [ns-fns (-&amp;gt;&amp;gt; ns ns-interns vals)]&amp;lt;br&amp;gt;        (doseq [f ns-fns]&amp;lt;br&amp;gt;          (trace-var* f))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-ns*</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;trace-var*&lt;/b&gt; ([ns s] [v])&lt;br&gt; If the specified Var holds an IFn and is not marked as a macro, its&lt;br&gt;  contents is replaced with a version wrapped in a tracing call;&lt;br&gt;  otherwise nothing happens. Can be undone with untrace-var.&lt;br&gt;&lt;br&gt;  In the unary case, v should be a Var object or a symbol to be&lt;br&gt;  resolved in the current namespace.&lt;br&gt;&lt;br&gt;  In the binary case, ns should be a namespace object or a symbol&lt;br&gt;  naming a namespace and s a symbol to be resolved in that namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^{:skip-wiki true} trace-var*&amp;lt;br&amp;gt;  &amp;quot;If the specified Var holds an IFn and is not marked as a macro, its&amp;lt;br&amp;gt;  contents is replaced with a version wrapped in a tracing call;&amp;lt;br&amp;gt;  otherwise nothing happens. Can be undone with untrace-var.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  In the unary case, v should be a Var object or a symbol to be&amp;lt;br&amp;gt;  resolved in the current namespace.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  In the binary case, ns should be a namespace object or a symbol&amp;lt;br&amp;gt;  naming a namespace and s a symbol to be resolved in that namespace.&amp;quot;&amp;lt;br&amp;gt;  ([ns s]&amp;lt;br&amp;gt;     (trace-var* (ns-resolve ns s)))&amp;lt;br&amp;gt;  ([v]&amp;lt;br&amp;gt;     (let [^clojure.lang.Var v (if (var? v) v (resolve v))&amp;lt;br&amp;gt;           ns (.ns v)&amp;lt;br&amp;gt;           s  (.sym v)]&amp;lt;br&amp;gt;       (if (and (ifn? @v) (-&amp;gt; v meta :macro not))&amp;lt;br&amp;gt;         (let [f @v&amp;lt;br&amp;gt;               vname (symbol (str ns &amp;quot;/&amp;quot; s))]&amp;lt;br&amp;gt;           (doto v&amp;lt;br&amp;gt;             (alter-var-root #(fn tracing-wrapper [&amp;amp; args]&amp;lt;br&amp;gt;                                (trace-fn-call vname % args)))&amp;lt;br&amp;gt;             (alter-meta! assoc ::traced f)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-var*</a>[ns s] [v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;trace-vars&lt;/b&gt; ([&amp; vs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Trace each of the specified Vars.&lt;br&gt;  The arguments may be Var objects or symbols to be resolved in the current&lt;br&gt;  namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro trace-vars&amp;lt;br&amp;gt;  &amp;quot;Trace each of the specified Vars.&amp;lt;br&amp;gt;  The arguments may be Var objects or symbols to be resolved in the current&amp;lt;br&amp;gt;  namespace.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; vs]&amp;lt;br&amp;gt;  `(do ~@(for [x vs] `(trace-var* (quote ~x)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">trace-vars</a>[& vs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;traceable?&lt;/b&gt; ([v])&lt;br&gt; Returns true if the given var can be traced, false otherwise&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn traceable?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the given var can be traced, false otherwise&amp;quot;&amp;lt;br&amp;gt;  [v]&amp;lt;br&amp;gt;  (let [^clojure.lang.Var v (if (var? v) v (resolve v))]&amp;lt;br&amp;gt;    (and (ifn? @v) (-&amp;gt; v meta :macro not))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">traceable?</a>[v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;traced?&lt;/b&gt; ([v])&lt;br&gt; Returns true if the given var is currently traced, false otherwise&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn traced?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the given var is currently traced, false otherwise&amp;quot;&amp;lt;br&amp;gt;  [v]&amp;lt;br&amp;gt;  (let [^clojure.lang.Var v (if (var? v) v (resolve v))]&amp;lt;br&amp;gt;    (-&amp;gt; v meta ::traced nil? not)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">traced?</a>[v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;untrace-ns&lt;/b&gt; ([ns])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Untrace all fns in the given name space.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro untrace-ns&amp;lt;br&amp;gt;  &amp;quot;Untrace all fns in the given name space.&amp;quot;&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  `(untrace-ns* ~ns))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">untrace-ns</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;untrace-ns*&lt;/b&gt; ([ns])&lt;br&gt; Reverses the effect of trace-var / trace-vars / trace-ns for the&lt;br&gt;  Vars in the given namespace, replacing each traced function from the&lt;br&gt;  given namespace with the original, untraced version.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^{:skip-wiki true} untrace-ns*&amp;lt;br&amp;gt;  &amp;quot;Reverses the effect of trace-var / trace-vars / trace-ns for the&amp;lt;br&amp;gt;  Vars in the given namespace, replacing each traced function from the&amp;lt;br&amp;gt;  given namespace with the original, untraced version.&amp;quot;&amp;lt;br&amp;gt;  [ns]&amp;lt;br&amp;gt;  (let [ns-fns (-&amp;gt;&amp;gt; ns the-ns ns-interns vals)]&amp;lt;br&amp;gt;    (doseq [f ns-fns]&amp;lt;br&amp;gt;          (untrace-var* f))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">untrace-ns*</a>[ns]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;untrace-var*&lt;/b&gt; ([ns s] [v])&lt;br&gt; Reverses the effect of trace-var / trace-vars / trace-ns for the&lt;br&gt;  given Var, replacing the traced function with the original, untraced&lt;br&gt;  version. No-op for non-traced Vars.&lt;br&gt;&lt;br&gt;  Argument types are the same as those for trace-var.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^{:skip-wiki true} untrace-var*&amp;lt;br&amp;gt;  &amp;quot;Reverses the effect of trace-var / trace-vars / trace-ns for the&amp;lt;br&amp;gt;  given Var, replacing the traced function with the original, untraced&amp;lt;br&amp;gt;  version. No-op for non-traced Vars.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Argument types are the same as those for trace-var.&amp;quot;&amp;lt;br&amp;gt;  ([ns s]&amp;lt;br&amp;gt;     (untrace-var* (ns-resolve ns s)))&amp;lt;br&amp;gt;  ([v]&amp;lt;br&amp;gt;     (let [^clojure.lang.Var v (if (var? v) v (resolve v))&amp;lt;br&amp;gt;           ns (.ns v)&amp;lt;br&amp;gt;           s  (.sym v)&amp;lt;br&amp;gt;           f  ((meta v) ::traced)]&amp;lt;br&amp;gt;       (when f&amp;lt;br&amp;gt;         (doto v&amp;lt;br&amp;gt;           (alter-var-root (constantly ((meta v) ::traced)))&amp;lt;br&amp;gt;           (alter-meta! dissoc ::traced))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">untrace-var*</a>[ns s] [v]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.tools.trace&lt;/i&gt;&lt;b&gt;untrace-vars&lt;/b&gt; ([&amp; vs])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Untrace each of the specified Vars.&lt;br&gt;  Reverses the effect of trace-var / trace-vars / trace-ns for each&lt;br&gt;  of the arguments, replacing the traced functions with the original,&lt;br&gt;  untraced versions.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro untrace-vars&amp;lt;br&amp;gt;  &amp;quot;Untrace each of the specified Vars.&amp;lt;br&amp;gt;  Reverses the effect of trace-var / trace-vars / trace-ns for each&amp;lt;br&amp;gt;  of the arguments, replacing the traced functions with the original,&amp;lt;br&amp;gt;  untraced versions.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; vs]&amp;lt;br&amp;gt; `(do ~@(for [x vs] `(untrace-var* (quote ~x)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">untrace-vars</a>[& vs]</div></div></div><div class="row"><div class="namespace"><h4>clojure.uuid</h4></div></div><div class="row"><div class="namespace"><h4>clojure.walk</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.walk&lt;/i&gt;&lt;b&gt;keywordize-keys&lt;/b&gt; ([m])&lt;br&gt; Recursively transforms all map keys from strings to keywords.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn keywordize-keys&amp;lt;br&amp;gt;  &amp;quot;Recursively transforms all map keys from strings to keywords.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [m]&amp;lt;br&amp;gt;  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]&amp;lt;br&amp;gt;    ;; only apply to maps&amp;lt;br&amp;gt;    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">keywordize-keys</a>[m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.walk&lt;/i&gt;&lt;b&gt;macroexpand-all&lt;/b&gt; ([form])&lt;br&gt; Recursively performs all possible macroexpansions in form.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn macroexpand-all&amp;lt;br&amp;gt;  &amp;quot;Recursively performs all possible macroexpansions in form.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (prewalk (fn [x] (if (seq? x) (macroexpand x) x)) form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">macroexpand-all</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.walk&lt;/i&gt;&lt;b&gt;postwalk&lt;/b&gt; ([f form])&lt;br&gt; Performs a depth-first, post-order traversal of form.  Calls f on&lt;br&gt;  each sub-form, uses f's return value in place of the original.&lt;br&gt;  Recognizes all Clojure data structures. Consumes seqs as with doall.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn postwalk&amp;lt;br&amp;gt;  &amp;quot;Performs a depth-first, post-order traversal of form.  Calls f on&amp;lt;br&amp;gt;  each sub-form, uses f's return value in place of the original.&amp;lt;br&amp;gt;  Recognizes all Clojure data structures. Consumes seqs as with doall.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [f form]&amp;lt;br&amp;gt;  (walk (partial postwalk f) f form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">postwalk</a>[f form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.walk&lt;/i&gt;&lt;b&gt;postwalk-demo&lt;/b&gt; ([form])&lt;br&gt; Demonstrates the behavior of postwalk by printing each form as it is&lt;br&gt;  walked.  Returns form.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn postwalk-demo&amp;lt;br&amp;gt;  &amp;quot;Demonstrates the behavior of postwalk by printing each form as it is&amp;lt;br&amp;gt;  walked.  Returns form.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (postwalk (fn [x] (print &amp;quot;Walked: &amp;quot;) (prn x) x) form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">postwalk-demo</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.walk&lt;/i&gt;&lt;b&gt;postwalk-replace&lt;/b&gt; ([smap form])&lt;br&gt; Recursively transforms form by replacing keys in smap with their&lt;br&gt;  values.  Like clojure/replace but works on any data structure.  Does&lt;br&gt;  replacement at the leaves of the tree first.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn postwalk-replace&amp;lt;br&amp;gt;  &amp;quot;Recursively transforms form by replacing keys in smap with their&amp;lt;br&amp;gt;  values.  Like clojure/replace but works on any data structure.  Does&amp;lt;br&amp;gt;  replacement at the leaves of the tree first.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [smap form]&amp;lt;br&amp;gt;  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">postwalk-replace</a>[smap form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.walk&lt;/i&gt;&lt;b&gt;prewalk&lt;/b&gt; ([f form])&lt;br&gt; Like postwalk, but does pre-order traversal.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn prewalk&amp;lt;br&amp;gt;  &amp;quot;Like postwalk, but does pre-order traversal.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [f form]&amp;lt;br&amp;gt;  (walk (partial prewalk f) identity (f form)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">prewalk</a>[f form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.walk&lt;/i&gt;&lt;b&gt;prewalk-demo&lt;/b&gt; ([form])&lt;br&gt; Demonstrates the behavior of prewalk by printing each form as it is&lt;br&gt;  walked.  Returns form.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn prewalk-demo&amp;lt;br&amp;gt;  &amp;quot;Demonstrates the behavior of prewalk by printing each form as it is&amp;lt;br&amp;gt;  walked.  Returns form.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [form]&amp;lt;br&amp;gt;  (prewalk (fn [x] (print &amp;quot;Walked: &amp;quot;) (prn x) x) form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">prewalk-demo</a>[form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.walk&lt;/i&gt;&lt;b&gt;prewalk-replace&lt;/b&gt; ([smap form])&lt;br&gt; Recursively transforms form by replacing keys in smap with their&lt;br&gt;  values.  Like clojure/replace but works on any data structure.  Does&lt;br&gt;  replacement at the root of the tree first.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn prewalk-replace&amp;lt;br&amp;gt;  &amp;quot;Recursively transforms form by replacing keys in smap with their&amp;lt;br&amp;gt;  values.  Like clojure/replace but works on any data structure.  Does&amp;lt;br&amp;gt;  replacement at the root of the tree first.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [smap form]&amp;lt;br&amp;gt;  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">prewalk-replace</a>[smap form]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.walk&lt;/i&gt;&lt;b&gt;stringify-keys&lt;/b&gt; ([m])&lt;br&gt; Recursively transforms all map keys from keywords to strings.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn stringify-keys&amp;lt;br&amp;gt;  &amp;quot;Recursively transforms all map keys from keywords to strings.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [m]&amp;lt;br&amp;gt;  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]&amp;lt;br&amp;gt;    ;; only apply to maps&amp;lt;br&amp;gt;    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">stringify-keys</a>[m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.walk&lt;/i&gt;&lt;b&gt;walk&lt;/b&gt; ([inner outer form])&lt;br&gt; Traverses form, an arbitrary data structure.  inner and outer are&lt;br&gt;  functions.  Applies inner to each element of form, building up a&lt;br&gt;  data structure of the same type, then applies outer to the result.&lt;br&gt;  Recognizes all Clojure data structures. Consumes seqs as with doall.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn walk&amp;lt;br&amp;gt;  &amp;quot;Traverses form, an arbitrary data structure.  inner and outer are&amp;lt;br&amp;gt;  functions.  Applies inner to each element of form, building up a&amp;lt;br&amp;gt;  data structure of the same type, then applies outer to the result.&amp;lt;br&amp;gt;  Recognizes all Clojure data structures. Consumes seqs as with doall.&amp;quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  {:added &amp;quot;1.1&amp;quot;}&amp;lt;br&amp;gt;  [inner outer form]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;   (list? form) (outer (apply list (map inner form)))&amp;lt;br&amp;gt;   (instance? clojure.lang.IMapEntry form) (outer (vec (map inner form)))&amp;lt;br&amp;gt;   (seq? form) (outer (doall (map inner form)))&amp;lt;br&amp;gt;   (coll? form) (outer (into (empty form) (map inner form)))&amp;lt;br&amp;gt;   :else (outer form)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">walk</a>[inner outer form]</div></div></div><div class="row"><div class="namespace"><h4>clojure.xml</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.xml&lt;/i&gt;&lt;b&gt;emit&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit [x]&amp;lt;br&amp;gt;  (println &amp;quot;&amp;lt;?xml version='1.0' encoding='UTF-8'?&amp;gt;&amp;quot;)&amp;lt;br&amp;gt;  (emit-element x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.xml&lt;/i&gt;&lt;b&gt;emit-element&lt;/b&gt; ([e])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn emit-element [e]&amp;lt;br&amp;gt;  (if (instance? String e)&amp;lt;br&amp;gt;    (println e)&amp;lt;br&amp;gt;    (do&amp;lt;br&amp;gt;      (print (str &amp;quot;&amp;lt;&amp;quot; (name (:tag e))))&amp;lt;br&amp;gt;      (when (:attrs e)&amp;lt;br&amp;gt;	(doseq [attr (:attrs e)]&amp;lt;br&amp;gt;	  (print (str &amp;quot; &amp;quot; (name (key attr)) &amp;quot;='&amp;quot; (val attr)&amp;quot;'&amp;quot;))))&amp;lt;br&amp;gt;      (if (:content e)&amp;lt;br&amp;gt;	(do&amp;lt;br&amp;gt;	  (println &amp;quot;&amp;gt;&amp;quot;)&amp;lt;br&amp;gt;	  (doseq [c (:content e)]&amp;lt;br&amp;gt;	    (emit-element c))&amp;lt;br&amp;gt;	  (println (str &amp;quot;&amp;lt;/&amp;quot; (name (:tag e)) &amp;quot;&amp;gt;&amp;quot;)))&amp;lt;br&amp;gt;	(println &amp;quot;/&amp;gt;&amp;quot;)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">emit-element</a>[e]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.xml&lt;/i&gt;&lt;b&gt;parse&lt;/b&gt; ([s] [s startparse])&lt;br&gt; Parses and loads the source s, which can be a File, InputStream or&lt;br&gt;  String naming a URI. Returns a tree of the xml/element struct-map,&lt;br&gt;  which has the keys :tag, :attrs, and :content. and accessor fns tag,&lt;br&gt;  attrs, and content. Other parsers can be supplied by passing&lt;br&gt;  startparse, a fn taking a source and a ContentHandler and returning&lt;br&gt;  a parser&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse&amp;lt;br&amp;gt;  &amp;quot;Parses and loads the source s, which can be a File, InputStream or&amp;lt;br&amp;gt;  String naming a URI. Returns a tree of the xml/element struct-map,&amp;lt;br&amp;gt;  which has the keys :tag, :attrs, and :content. and accessor fns tag,&amp;lt;br&amp;gt;  attrs, and content. Other parsers can be supplied by passing&amp;lt;br&amp;gt;  startparse, a fn taking a source and a ContentHandler and returning&amp;lt;br&amp;gt;  a parser&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  ([s] (parse s startparse-sax))&amp;lt;br&amp;gt;  ([s startparse]&amp;lt;br&amp;gt;    (binding [*stack* nil&amp;lt;br&amp;gt;              *current* (struct element)&amp;lt;br&amp;gt;              *state* :between&amp;lt;br&amp;gt;              *sb* nil]&amp;lt;br&amp;gt;      (startparse s content-handler)&amp;lt;br&amp;gt;      ((:content *current*) 0))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse</a>[s] [s startparse]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.xml&lt;/i&gt;&lt;b&gt;startparse-sax&lt;/b&gt; ([s ch])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn startparse-sax [s ch]&amp;lt;br&amp;gt;  (.. SAXParserFactory (newInstance) (newSAXParser) (parse s ch)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">startparse-sax</a>[s ch]</div></div></div><div class="row"><div class="namespace"><h4>clojure.zip</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;append-child&lt;/b&gt; ([loc item])&lt;br&gt; Inserts the item as the rightmost child of the node at this loc,&lt;br&gt;  without moving&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn append-child&amp;lt;br&amp;gt;  &amp;quot;Inserts the item as the rightmost child of the node at this loc,&amp;lt;br&amp;gt;  without moving&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc item]&amp;lt;br&amp;gt;    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">append-child</a>[loc item]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;branch?&lt;/b&gt; ([loc])&lt;br&gt; Returns true if the node at loc is a branch&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn branch?&amp;lt;br&amp;gt;  &amp;quot;Returns true if the node at loc is a branch&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    ((:zip/branch? (meta loc)) (node loc)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">branch?</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;children&lt;/b&gt; ([loc])&lt;br&gt; Returns a seq of the children of node at loc, which must be a branch&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn children&amp;lt;br&amp;gt;  &amp;quot;Returns a seq of the children of node at loc, which must be a branch&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (if (branch? loc)&amp;lt;br&amp;gt;      ((:zip/children (meta loc)) (node loc))&amp;lt;br&amp;gt;      (throw (Exception. &amp;quot;called children on a leaf node&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">children</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;down&lt;/b&gt; ([loc])&lt;br&gt; Returns the loc of the leftmost child of the node at this loc, or&lt;br&gt;  nil if no children&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn down&amp;lt;br&amp;gt;  &amp;quot;Returns the loc of the leftmost child of the node at this loc, or&amp;lt;br&amp;gt;  nil if no children&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (when (branch? loc)&amp;lt;br&amp;gt;      (let [[node path] loc&amp;lt;br&amp;gt;            [c &amp;amp; cnext :as cs] (children loc)]&amp;lt;br&amp;gt;        (when cs&amp;lt;br&amp;gt;          (with-meta [c {:l [] &amp;lt;br&amp;gt;                         :pnodes (if path (conj (:pnodes path) node) [node]) &amp;lt;br&amp;gt;                         :ppath path &amp;lt;br&amp;gt;                         :r cnext}] (meta loc))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">down</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;edit&lt;/b&gt; ([loc f &amp; args])&lt;br&gt; Replaces the node at this loc with the value of (f node args)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn edit&amp;lt;br&amp;gt;  &amp;quot;Replaces the node at this loc with the value of (f node args)&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc f &amp;amp; args]&amp;lt;br&amp;gt;    (replace loc (apply f (node loc) args)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">edit</a>[loc f & args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;end?&lt;/b&gt; ([loc])&lt;br&gt; Returns true if loc represents the end of a depth-first walk&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn end?&amp;lt;br&amp;gt;  &amp;quot;Returns true if loc represents the end of a depth-first walk&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (= :end (loc 1)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">end?</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;insert-child&lt;/b&gt; ([loc item])&lt;br&gt; Inserts the item as the leftmost child of the node at this loc,&lt;br&gt;  without moving&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn insert-child&amp;lt;br&amp;gt;  &amp;quot;Inserts the item as the leftmost child of the node at this loc,&amp;lt;br&amp;gt;  without moving&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc item]&amp;lt;br&amp;gt;    (replace loc (make-node loc (node loc) (cons item (children loc)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">insert-child</a>[loc item]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;insert-left&lt;/b&gt; ([loc item])&lt;br&gt; Inserts the item as the left sibling of the node at this loc,&lt;br&gt; without moving&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn insert-left&amp;lt;br&amp;gt;  &amp;quot;Inserts the item as the left sibling of the node at this loc,&amp;lt;br&amp;gt; without moving&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc item]&amp;lt;br&amp;gt;    (let [[node {l :l :as path}] loc]&amp;lt;br&amp;gt;      (if (nil? path)&amp;lt;br&amp;gt;        (throw (new Exception &amp;quot;Insert at top&amp;quot;))&amp;lt;br&amp;gt;        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">insert-left</a>[loc item]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;insert-right&lt;/b&gt; ([loc item])&lt;br&gt; Inserts the item as the right sibling of the node at this loc,&lt;br&gt;  without moving&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn insert-right&amp;lt;br&amp;gt;  &amp;quot;Inserts the item as the right sibling of the node at this loc,&amp;lt;br&amp;gt;  without moving&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc item]&amp;lt;br&amp;gt;    (let [[node {r :r :as path}] loc]&amp;lt;br&amp;gt;      (if (nil? path)&amp;lt;br&amp;gt;        (throw (new Exception &amp;quot;Insert at top&amp;quot;))&amp;lt;br&amp;gt;        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">insert-right</a>[loc item]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;left&lt;/b&gt; ([loc])&lt;br&gt; Returns the loc of the left sibling of the node at this loc, or nil&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn left&amp;lt;br&amp;gt;  &amp;quot;Returns the loc of the left sibling of the node at this loc, or nil&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (let [[node {l :l r :r :as path}] loc]&amp;lt;br&amp;gt;      (when (and path (seq l))&amp;lt;br&amp;gt;        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">left</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;leftmost&lt;/b&gt; ([loc])&lt;br&gt; Returns the loc of the leftmost sibling of the node at this loc, or self&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn leftmost&amp;lt;br&amp;gt;  &amp;quot;Returns the loc of the leftmost sibling of the node at this loc, or self&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (let [[node {l :l r :r :as path}] loc]&amp;lt;br&amp;gt;      (if (and path (seq l))&amp;lt;br&amp;gt;        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))&amp;lt;br&amp;gt;        loc)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">leftmost</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;lefts&lt;/b&gt; ([loc])&lt;br&gt; Returns a seq of the left siblings of this loc&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn lefts&amp;lt;br&amp;gt;  &amp;quot;Returns a seq of the left siblings of this loc&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (seq (:l (loc 1))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">lefts</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;make-node&lt;/b&gt; ([loc node children])&lt;br&gt; Returns a new branch node, given an existing node and new&lt;br&gt;  children. The loc is only used to supply the constructor.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-node&amp;lt;br&amp;gt;  &amp;quot;Returns a new branch node, given an existing node and new&amp;lt;br&amp;gt;  children. The loc is only used to supply the constructor.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc node children]&amp;lt;br&amp;gt;    ((:zip/make-node (meta loc)) node children))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-node</a>[loc node children]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;next&lt;/b&gt; ([loc])&lt;br&gt; Moves to the next loc in the hierarchy, depth-first. When reaching&lt;br&gt;  the end, returns a distinguished loc detectable via end?. If already&lt;br&gt;  at the end, stays there.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn next&amp;lt;br&amp;gt;  &amp;quot;Moves to the next loc in the hierarchy, depth-first. When reaching&amp;lt;br&amp;gt;  the end, returns a distinguished loc detectable via end?. If already&amp;lt;br&amp;gt;  at the end, stays there.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (if (= :end (loc 1))&amp;lt;br&amp;gt;      loc&amp;lt;br&amp;gt;      (or &amp;lt;br&amp;gt;       (and (branch? loc) (down loc))&amp;lt;br&amp;gt;       (right loc)&amp;lt;br&amp;gt;       (loop [p loc]&amp;lt;br&amp;gt;         (if (up p)&amp;lt;br&amp;gt;           (or (right (up p)) (recur (up p)))&amp;lt;br&amp;gt;           [(node p) :end])))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">next</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;node&lt;/b&gt; ([loc])&lt;br&gt; Returns the node at loc&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn node&amp;lt;br&amp;gt;  &amp;quot;Returns the node at loc&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc] (loc 0))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">node</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;path&lt;/b&gt; ([loc])&lt;br&gt; Returns a seq of nodes leading to this loc&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn path&amp;lt;br&amp;gt;  &amp;quot;Returns a seq of nodes leading to this loc&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (:pnodes (loc 1)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">path</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;prev&lt;/b&gt; ([loc])&lt;br&gt; Moves to the previous loc in the hierarchy, depth-first. If already&lt;br&gt;  at the root, returns nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn prev&amp;lt;br&amp;gt;  &amp;quot;Moves to the previous loc in the hierarchy, depth-first. If already&amp;lt;br&amp;gt;  at the root, returns nil.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (if-let [lloc (left loc)]&amp;lt;br&amp;gt;      (loop [loc lloc]&amp;lt;br&amp;gt;        (if-let [child (and (branch? loc) (down loc))]&amp;lt;br&amp;gt;          (recur (rightmost child))&amp;lt;br&amp;gt;          loc))&amp;lt;br&amp;gt;      (up loc)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">prev</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;remove&lt;/b&gt; ([loc])&lt;br&gt; Removes the node at loc, returning the loc that would have preceded&lt;br&gt;  it in a depth-first walk.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove&amp;lt;br&amp;gt;  &amp;quot;Removes the node at loc, returning the loc that would have preceded&amp;lt;br&amp;gt;  it in a depth-first walk.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]&amp;lt;br&amp;gt;      (if (nil? path)&amp;lt;br&amp;gt;        (throw (new Exception &amp;quot;Remove at top&amp;quot;))&amp;lt;br&amp;gt;        (if (pos? (count l))&amp;lt;br&amp;gt;          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]&amp;lt;br&amp;gt;            (if-let [child (and (branch? loc) (down loc))]&amp;lt;br&amp;gt;              (recur (rightmost child))&amp;lt;br&amp;gt;              loc))&amp;lt;br&amp;gt;          (with-meta [(make-node loc (peek pnodes) rs) &amp;lt;br&amp;gt;                      (and ppath (assoc ppath :changed? true))]&amp;lt;br&amp;gt;                     (meta loc))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;replace&lt;/b&gt; ([loc node])&lt;br&gt; Replaces the node at this loc, without moving&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn replace&amp;lt;br&amp;gt;  &amp;quot;Replaces the node at this loc, without moving&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc node]&amp;lt;br&amp;gt;    (let [[_ path] loc]&amp;lt;br&amp;gt;      (with-meta [node (assoc path :changed? true)] (meta loc))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">replace</a>[loc node]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;right&lt;/b&gt; ([loc])&lt;br&gt; Returns the loc of the right sibling of the node at this loc, or nil&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn right&amp;lt;br&amp;gt;  &amp;quot;Returns the loc of the right sibling of the node at this loc, or nil&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (let [[node {l :l  [r &amp;amp; rnext :as rs] :r :as path}] loc]&amp;lt;br&amp;gt;      (when (and path rs)&amp;lt;br&amp;gt;        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">right</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;rightmost&lt;/b&gt; ([loc])&lt;br&gt; Returns the loc of the rightmost sibling of the node at this loc, or self&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rightmost&amp;lt;br&amp;gt;  &amp;quot;Returns the loc of the rightmost sibling of the node at this loc, or self&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (let [[node {l :l r :r :as path}] loc]&amp;lt;br&amp;gt;      (if (and path r)&amp;lt;br&amp;gt;        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))&amp;lt;br&amp;gt;        loc)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rightmost</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;rights&lt;/b&gt; ([loc])&lt;br&gt; Returns a seq of the right siblings of this loc&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rights&amp;lt;br&amp;gt;  &amp;quot;Returns a seq of the right siblings of this loc&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (:r (loc 1)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rights</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;root&lt;/b&gt; ([loc])&lt;br&gt; zips all the way up and returns the root node, reflecting any&lt;br&gt; changes.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn root&amp;lt;br&amp;gt;  &amp;quot;zips all the way up and returns the root node, reflecting any&amp;lt;br&amp;gt; changes.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (if (= :end (loc 1))&amp;lt;br&amp;gt;      (node loc)&amp;lt;br&amp;gt;      (let [p (up loc)]&amp;lt;br&amp;gt;        (if p&amp;lt;br&amp;gt;          (recur p)&amp;lt;br&amp;gt;          (node loc)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">root</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;seq-zip&lt;/b&gt; ([root])&lt;br&gt; Returns a zipper for nested sequences, given a root sequence&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn seq-zip&amp;lt;br&amp;gt;  &amp;quot;Returns a zipper for nested sequences, given a root sequence&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [root]&amp;lt;br&amp;gt;    (zipper seq?&amp;lt;br&amp;gt;            identity&amp;lt;br&amp;gt;            (fn [node children] (with-meta children (meta node)))&amp;lt;br&amp;gt;            root))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">seq-zip</a>[root]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;up&lt;/b&gt; ([loc])&lt;br&gt; Returns the loc of the parent of the node at this loc, or nil if at&lt;br&gt;  the top&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn up&amp;lt;br&amp;gt;  &amp;quot;Returns the loc of the parent of the node at this loc, or nil if at&amp;lt;br&amp;gt;  the top&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [loc]&amp;lt;br&amp;gt;    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]&amp;lt;br&amp;gt;      (when pnodes&amp;lt;br&amp;gt;        (let [pnode (peek pnodes)]&amp;lt;br&amp;gt;          (with-meta (if changed?&amp;lt;br&amp;gt;                       [(make-node loc pnode (concat l (cons node r))) &amp;lt;br&amp;gt;                        (and ppath (assoc ppath :changed? true))]&amp;lt;br&amp;gt;                       [pnode ppath])&amp;lt;br&amp;gt;                     (meta loc))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">up</a>[loc]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;vector-zip&lt;/b&gt; ([root])&lt;br&gt; Returns a zipper for nested vectors, given a root vector&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn vector-zip&amp;lt;br&amp;gt;  &amp;quot;Returns a zipper for nested vectors, given a root vector&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [root]&amp;lt;br&amp;gt;    (zipper vector?&amp;lt;br&amp;gt;            seq&amp;lt;br&amp;gt;            (fn [node children] (with-meta (vec children) (meta node)))&amp;lt;br&amp;gt;            root))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">vector-zip</a>[root]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;xml-zip&lt;/b&gt; ([root])&lt;br&gt; Returns a zipper for xml elements (as from xml/parse),&lt;br&gt;  given a root element&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn xml-zip&amp;lt;br&amp;gt;  &amp;quot;Returns a zipper for xml elements (as from xml/parse),&amp;lt;br&amp;gt;  given a root element&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [root]&amp;lt;br&amp;gt;    (zipper (complement string?) &amp;lt;br&amp;gt;            (comp seq :content)&amp;lt;br&amp;gt;            (fn [node children]&amp;lt;br&amp;gt;              (assoc node :content (and children (apply vector children))))&amp;lt;br&amp;gt;            root))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">xml-zip</a>[root]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojure.zip&lt;/i&gt;&lt;b&gt;zipper&lt;/b&gt; ([branch? children make-node root])&lt;br&gt; Creates a new zipper structure. &lt;br&gt;&lt;br&gt;  branch? is a fn that, given a node, returns true if can have&lt;br&gt;  children, even if it currently doesn't.&lt;br&gt;&lt;br&gt;  children is a fn that, given a branch node, returns a seq of its&lt;br&gt;  children.&lt;br&gt;&lt;br&gt;  make-node is a fn that, given an existing node and a seq of&lt;br&gt;  children, returns a new branch node with the supplied children.&lt;br&gt;  root is the root node.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn zipper&amp;lt;br&amp;gt;  &amp;quot;Creates a new zipper structure. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  branch? is a fn that, given a node, returns true if can have&amp;lt;br&amp;gt;  children, even if it currently doesn't.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  children is a fn that, given a branch node, returns a seq of its&amp;lt;br&amp;gt;  children.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  make-node is a fn that, given an existing node and a seq of&amp;lt;br&amp;gt;  children, returns a new branch node with the supplied children.&amp;lt;br&amp;gt;  root is the root node.&amp;quot;&amp;lt;br&amp;gt;  {:added &amp;quot;1.0&amp;quot;}&amp;lt;br&amp;gt;  [branch? children make-node root]&amp;lt;br&amp;gt;    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}&amp;lt;br&amp;gt;    [root nil])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">zipper</a>[branch? children make-node root]</div></div></div><div class="row"><div class="namespace"><h4>clojureref.handler</h4></div></div><div class="row"><div class="namespace"><h4>clojureref.layout</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojureref.layout&lt;/i&gt;&lt;b&gt;build-fn-div&lt;/b&gt; ([nmsp [symb doc forms source]])&lt;br&gt; Helper method to build the entries and popovers for various symbols tags.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn build-fn-div&amp;lt;br&amp;gt;  &amp;quot;Helper method to build the entries and popovers for various symbols tags.&amp;quot;&amp;lt;br&amp;gt;  [nmsp [symb doc forms source]]&amp;lt;br&amp;gt;  [:div.fn&amp;lt;br&amp;gt;   [:a {:data-html &amp;quot;true&amp;quot;&amp;lt;br&amp;gt;        :data-original-title (html [:div.doc [:i.right nmsp] [:b symb] &amp;quot; &amp;quot; (util/replace-nl-with-br doc)])&amp;lt;br&amp;gt;        :data-placement &amp;quot;right&amp;quot;&amp;lt;br&amp;gt;        :source (when-let [source (util/replace-nl-with-br source)]&amp;lt;br&amp;gt;                  (html [:a.fn-source {:data-html &amp;quot;true&amp;quot;&amp;lt;br&amp;gt;                                       :data-original-title (html [:pre source])&amp;lt;br&amp;gt;                                       :data-placement &amp;quot;right&amp;quot;}&amp;lt;br&amp;gt;                         &amp;quot;source&amp;quot;]))}&amp;lt;br&amp;gt;    symb]&amp;lt;br&amp;gt;   forms])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">build-fn-div</a>[nmsp [symb doc forms source]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojureref.layout&lt;/i&gt;&lt;b&gt;make-footer&lt;/b&gt; ([])&lt;br&gt; Helper method to build the page's footer.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-footer&amp;lt;br&amp;gt;  &amp;quot;Helper method to build the page's footer.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  [:footer&amp;lt;br&amp;gt;   [:div.container&amp;lt;br&amp;gt;    [:div.row&amp;lt;br&amp;gt;     [:h4 [:a {:href &amp;quot;http://www.camsaul.com&amp;quot;} &amp;quot;2013 Cam Saul&amp;quot;]]]]])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-footer</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojureref.layout&lt;/i&gt;&lt;b&gt;make-header&lt;/b&gt; ([title])&lt;br&gt; Helper method to build the page's header.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-header&amp;lt;br&amp;gt;  &amp;quot;Helper method to build the page's header.&amp;quot;&amp;lt;br&amp;gt;  [title]&amp;lt;br&amp;gt;  [:div.row&amp;lt;br&amp;gt;   [:span.span9&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    [:div.navbar&amp;lt;br&amp;gt;     [:div.navbar-inner&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;      [:div.container&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;       [:div.nav-collapse.collapse&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;        [:ul.nav&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;         [:li [:a title]]]]]]]]&amp;lt;br&amp;gt;   [:input#filter.span10 {:type &amp;quot;text&amp;quot; :placeholder &amp;quot;filter&amp;quot;}]]&amp;lt;br&amp;gt;)&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-header</a>[title]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojureref.layout&lt;/i&gt;&lt;b&gt;page&lt;/b&gt; ([title body])&lt;br&gt; Takes a page title and hiccup HMTL elements and wraps it with common stylesheet references etc.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn page&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  &amp;quot;Takes a page title and hiccup HMTL elements and wraps it with common stylesheet references etc.&amp;quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  [title body]&amp;lt;br&amp;gt;  (html5&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   [:head&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    [:meta {:charset &amp;quot;utf-8&amp;quot;}]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    [:meta {:name &amp;quot;viewport&amp;quot; :content &amp;quot;width=device-width, initial-scale=1.0&amp;quot;}]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    [:title title]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (include-css &amp;quot;css/bootstrap.min.css&amp;quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;                 &amp;quot;css/application.css&amp;quot;)]&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;   [:body&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    [:div.container&amp;lt;br&amp;gt;     (make-header title)&amp;lt;br&amp;gt;     body]&amp;lt;br&amp;gt;    (make-footer)&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    ;; JS is placed at the end so the pages load faster&amp;lt;br&amp;gt;    (include-js &amp;quot;http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js&amp;quot;&amp;lt;br&amp;gt;                &amp;quot;js/bootstrap-tooltip.min.js&amp;quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;                &amp;quot;js/application.js&amp;quot;)]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">page</a>[title body]</div></div></div><div class="row"><div class="namespace"><h4>clojureref.test.handler</h4></div></div><div class="row"><div class="namespace"><h4>clojureref.util</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojureref.util&lt;/i&gt;&lt;b&gt;doc-for-ns&lt;/b&gt; ([n])&lt;br&gt; Returns a seq of [symbol-name doc forms source] for each public function/macro/special form in the namespace.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn doc-for-ns&amp;lt;br&amp;gt;  &amp;quot;Returns a seq of [symbol-name doc forms source] for each public function/macro/special form in the namespace.&amp;quot;&amp;lt;br&amp;gt;  [n]&amp;lt;br&amp;gt;  (sort-by first (filter not-empty (map (fn [[symb varr]]&amp;lt;br&amp;gt;                                          (let [metta (meta varr)]&amp;lt;br&amp;gt;                                            (when-let [forms (get-forms metta)]&amp;lt;br&amp;gt;                                              [(name symb) (get-doc metta) forms (get-source n symb)])))&amp;lt;br&amp;gt;                                        (ns-publics (symbol n))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">doc-for-ns</a>[n]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojureref.util&lt;/i&gt;&lt;b&gt;get-doc&lt;/b&gt; ([m])&lt;br&gt; Gets and formats docstrings from function/macro/special form metadata.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-doc&amp;lt;br&amp;gt;  &amp;quot;Gets and formats docstrings from function/macro/special form metadata.&amp;quot;&amp;lt;br&amp;gt;  [m]&amp;lt;br&amp;gt;  (str&amp;lt;br&amp;gt;   (cond&amp;lt;br&amp;gt;    (:forms m) (format &amp;quot;(%s)\n&amp;quot; (apply str (interpose &amp;quot; &amp;quot; (:forms m))))&amp;lt;br&amp;gt;    (:arglists m) (format &amp;quot;(%s)\n&amp;quot;(apply str (interpose &amp;quot; &amp;quot; (:arglists m)))))&amp;lt;br&amp;gt;   (if (:special-form m)&amp;lt;br&amp;gt;     (str&amp;lt;br&amp;gt;      &amp;quot;&amp;lt;i&amp;gt;Special Form&amp;lt;/i&amp;gt;&amp;quot;&amp;lt;br&amp;gt;      (str-nl &amp;quot; &amp;quot; (:doc m)) &amp;lt;br&amp;gt;      (if (contains? m :url)&amp;lt;br&amp;gt;        (when (:url m)&amp;lt;br&amp;gt;          (str-nl &amp;quot;\n  Please see http://clojure.org/&amp;quot; (:url m)))&amp;lt;br&amp;gt;        (str-nl &amp;quot;\n  Please see http://clojure.org/special_forms#&amp;quot;&amp;lt;br&amp;gt;                (:name m))))&amp;lt;br&amp;gt;     (str&amp;lt;br&amp;gt;      (when (:macro m)&amp;lt;br&amp;gt;        &amp;quot;&amp;lt;i&amp;gt;Macro&amp;lt;/i&amp;gt;\n&amp;quot;) &amp;lt;br&amp;gt;      (str &amp;quot; &amp;quot; (:doc m))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-doc</a>[m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojureref.util&lt;/i&gt;&lt;b&gt;get-forms&lt;/b&gt; ([m])&lt;br&gt; Gets and formats forms/arglists from function/macro/special form metadata.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-forms&amp;lt;br&amp;gt;  &amp;quot;Gets and formats forms/arglists from function/macro/special form metadata.&amp;quot;&amp;lt;br&amp;gt;  [m]&amp;lt;br&amp;gt;  (cond&amp;lt;br&amp;gt;   (:forms m) (apply str (interpose &amp;quot; &amp;quot; (:forms m)))&amp;lt;br&amp;gt;   (:arglists m) (apply str (interpose &amp;quot; &amp;quot; (:arglists m)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-forms</a>[m]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojureref.util&lt;/i&gt;&lt;b&gt;get-source&lt;/b&gt; ([nmsp symb])&lt;br&gt; Gets source from function/macro/special form var.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-source&amp;lt;br&amp;gt;  &amp;quot;Gets source from function/macro/special form var.&amp;quot;&amp;lt;br&amp;gt;  [nmsp symb]&amp;lt;br&amp;gt;  (clojure.repl/source-fn (symbol (str nmsp) (str symb))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-source</a>[nmsp symb]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojureref.util&lt;/i&gt;&lt;b&gt;replace-nl-with-br&lt;/b&gt; ([text])&lt;br&gt; Helper method to replace newlines with &lt;br /&gt;.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn replace-nl-with-br&amp;lt;br&amp;gt;  &amp;quot;Helper method to replace newlines with &amp;lt;br /&amp;gt;.&amp;quot;&amp;lt;br&amp;gt;  [text]&amp;lt;br&amp;gt;  (when text (interpose [:br] (str/split text #&amp;quot;\n&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">replace-nl-with-br</a>[text]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clojureref.util&lt;/i&gt;&lt;b&gt;str-nl&lt;/b&gt; ([&amp; args])&lt;br&gt; Helper version of &quot;str&quot; that adds a newline at the end.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn str-nl&amp;lt;br&amp;gt;  &amp;quot;Helper version of \&amp;quot;str\&amp;quot; that adds a newline at the end.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  (str (apply str args) &amp;quot;\n&amp;quot;))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">str-nl</a>[& args]</div></div></div><div class="row"><div class="namespace"><h4>clout.core</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clout.core&lt;/i&gt;&lt;b&gt;-&gt;CompiledRoute&lt;/b&gt; ([re keys absolute?])&lt;br&gt; Positional factory function for class clout.core.CompiledRoute.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord CompiledRoute [re keys absolute?]&amp;lt;br&amp;gt;  Route&amp;lt;br&amp;gt;  (route-matches [route request]&amp;lt;br&amp;gt;    (let [path-info (if absolute?&amp;lt;br&amp;gt;                      (request-url request)&amp;lt;br&amp;gt;                      (path-info request))&amp;lt;br&amp;gt;          matcher   (re-matcher re path-info)]&amp;lt;br&amp;gt;      (if (.matches matcher)&amp;lt;br&amp;gt;        (assoc-keys-with-groups&amp;lt;br&amp;gt;          (map path-decode (re-groups* matcher))&amp;lt;br&amp;gt;          keys)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->CompiledRoute</a>[re keys absolute?]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clout.core&lt;/i&gt;&lt;b&gt;map-&gt;CompiledRoute&lt;/b&gt; ([m__5818__auto__])&lt;br&gt; Factory function for class clout.core.CompiledRoute, taking a map of keywords to field values.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defrecord CompiledRoute [re keys absolute?]&amp;lt;br&amp;gt;  Route&amp;lt;br&amp;gt;  (route-matches [route request]&amp;lt;br&amp;gt;    (let [path-info (if absolute?&amp;lt;br&amp;gt;                      (request-url request)&amp;lt;br&amp;gt;                      (path-info request))&amp;lt;br&amp;gt;          matcher   (re-matcher re path-info)]&amp;lt;br&amp;gt;      (if (.matches matcher)&amp;lt;br&amp;gt;        (assoc-keys-with-groups&amp;lt;br&amp;gt;          (map path-decode (re-groups* matcher))&amp;lt;br&amp;gt;          keys)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">map->CompiledRoute</a>[m__5818__auto__]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clout.core&lt;/i&gt;&lt;b&gt;path-decode&lt;/b&gt; ([path] [path encoding])&lt;br&gt; Decode a path segment in a URI. Defaults to using UTF-8 encoding.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn path-decode&amp;lt;br&amp;gt;  &amp;quot;Decode a path segment in a URI. Defaults to using UTF-8 encoding.&amp;quot;&amp;lt;br&amp;gt;  ([path]&amp;lt;br&amp;gt;     (path-decode path &amp;quot;UTF-8&amp;quot;))&amp;lt;br&amp;gt;  ([path encoding]&amp;lt;br&amp;gt;     (-&amp;gt; (string/replace path &amp;quot;+&amp;quot; (URLEncoder/encode &amp;quot;+&amp;quot; encoding))&amp;lt;br&amp;gt;         (URLDecoder/decode encoding))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">path-decode</a>[path] [path encoding]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clout.core&lt;/i&gt;&lt;b&gt;re-groups*&lt;/b&gt; ([matcher])&lt;br&gt; More consistant re-groups that always returns a vector of groups, even if&lt;br&gt;  there is only one group.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn re-groups*&amp;lt;br&amp;gt;  &amp;quot;More consistant re-groups that always returns a vector of groups, even if&amp;lt;br&amp;gt;  there is only one group.&amp;quot;&amp;lt;br&amp;gt;  [matcher]&amp;lt;br&amp;gt;  (for [i (range (.groupCount matcher))]&amp;lt;br&amp;gt;    (.group matcher (inc i))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">re-groups*</a>[matcher]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clout.core&lt;/i&gt;&lt;b&gt;route-compile&lt;/b&gt; ([path] [path regexs])&lt;br&gt; Compile a path string using the routes syntax into a uri-matcher struct.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn route-compile&amp;lt;br&amp;gt;  &amp;quot;Compile a path string using the routes syntax into a uri-matcher struct.&amp;quot;&amp;lt;br&amp;gt;  ([path]&amp;lt;br&amp;gt;    (route-compile path {}))&amp;lt;br&amp;gt;  ([path regexs]&amp;lt;br&amp;gt;    (let [splat   #&amp;quot;\*&amp;quot;&amp;lt;br&amp;gt;          word    #&amp;quot;:([\p{L}_][\p{L}_0-9-]*)&amp;quot;&amp;lt;br&amp;gt;          literal #&amp;quot;(:[^\p{L}_*]|[^:*])+&amp;quot;&amp;lt;br&amp;gt;          word-group #(keyword (.group % 1))&amp;lt;br&amp;gt;          word-regex #(regexs (word-group %) &amp;quot;[^/,;?]+&amp;quot;)]&amp;lt;br&amp;gt;      (CompiledRoute.&amp;lt;br&amp;gt;        (re-pattern&amp;lt;br&amp;gt;          (apply str&amp;lt;br&amp;gt;            (lex path&amp;lt;br&amp;gt;              splat   &amp;quot;(.*?)&amp;quot;&amp;lt;br&amp;gt;              word    #(str &amp;quot;(&amp;quot; (word-regex %) &amp;quot;)&amp;quot;)&amp;lt;br&amp;gt;              literal #(re-escape (.group %)))))&amp;lt;br&amp;gt;        (remove nil?&amp;lt;br&amp;gt;          (lex path&amp;lt;br&amp;gt;            splat   :*&amp;lt;br&amp;gt;            word    word-group&amp;lt;br&amp;gt;            literal nil))&amp;lt;br&amp;gt;        (absolute-url? path)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">route-compile</a>[path] [path regexs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;clout.core&lt;/i&gt;&lt;b&gt;route-matches&lt;/b&gt; ([route request])&lt;br&gt; If the route matches the supplied request, the matched keywords are&lt;br&gt;    returned as a map. Otherwise, nil is returned.&lt;/div&gt;" data-placement="right">route-matches</a>[route request]</div></div></div><div class="row"><div class="namespace"><h4>compojure.core</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;ANY&lt;/b&gt; ([path args &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Generate a route that matches any method.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro ANY &amp;quot;Generate a route that matches any method.&amp;quot;&amp;lt;br&amp;gt;  [path args &amp;amp; body]&amp;lt;br&amp;gt;  (compile-route nil path args body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ANY</a>[path args & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;DELETE&lt;/b&gt; ([path args &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Generate a DELETE route.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro DELETE &amp;quot;Generate a DELETE route.&amp;quot;&amp;lt;br&amp;gt;  [path args &amp;amp; body]&amp;lt;br&amp;gt;  (compile-route :delete path args body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">DELETE</a>[path args & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;GET&lt;/b&gt; ([path args &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Generate a GET route.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro GET &amp;quot;Generate a GET route.&amp;quot;&amp;lt;br&amp;gt;  [path args &amp;amp; body]&amp;lt;br&amp;gt;  (compile-route :get path args body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">GET</a>[path args & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;HEAD&lt;/b&gt; ([path args &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Generate a HEAD route.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro HEAD &amp;quot;Generate a HEAD route.&amp;quot;&amp;lt;br&amp;gt;  [path args &amp;amp; body]&amp;lt;br&amp;gt;  (compile-route :head path args body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">HEAD</a>[path args & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;OPTIONS&lt;/b&gt; ([path args &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Generate an OPTIONS route.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro OPTIONS &amp;quot;Generate an OPTIONS route.&amp;quot;&amp;lt;br&amp;gt;  [path args &amp;amp; body]&amp;lt;br&amp;gt;  (compile-route :options path args body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">OPTIONS</a>[path args & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;PATCH&lt;/b&gt; ([path args &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Generate a PATCH route.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro PATCH &amp;quot;Generate a PATCH route.&amp;quot;&amp;lt;br&amp;gt;  [path args &amp;amp; body]&amp;lt;br&amp;gt;  (compile-route :patch path args body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">PATCH</a>[path args & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;POST&lt;/b&gt; ([path args &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Generate a POST route.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro POST &amp;quot;Generate a POST route.&amp;quot;&amp;lt;br&amp;gt;  [path args &amp;amp; body]&amp;lt;br&amp;gt;  (compile-route :post path args body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">POST</a>[path args & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;PUT&lt;/b&gt; ([path args &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Generate a PUT route.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro PUT &amp;quot;Generate a PUT route.&amp;quot;&amp;lt;br&amp;gt;  [path args &amp;amp; body]&amp;lt;br&amp;gt;  (compile-route :put path args body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">PUT</a>[path args & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;context&lt;/b&gt; ([path args &amp; routes])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Give all routes in the form a common path prefix and set of bindings.&lt;br&gt;&lt;br&gt;  The following example demonstrates defining two routes with a common&lt;br&gt;  path prefix ('/user/:id') and a common binding ('id'):&lt;br&gt;&lt;br&gt;    (context &quot;/user/:id&quot; [id]&lt;br&gt;      (GET &quot;/profile&quot; [] ...)&lt;br&gt;      (GET &quot;/settings&quot; [] ...))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro context&amp;lt;br&amp;gt;  &amp;quot;Give all routes in the form a common path prefix and set of bindings.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The following example demonstrates defining two routes with a common&amp;lt;br&amp;gt;  path prefix ('/user/:id') and a common binding ('id'):&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    (context \&amp;quot;/user/:id\&amp;quot; [id]&amp;lt;br&amp;gt;      (GET \&amp;quot;/profile\&amp;quot; [] ...)&amp;lt;br&amp;gt;      (GET \&amp;quot;/settings\&amp;quot; [] ...))&amp;quot;&amp;lt;br&amp;gt;  [path args &amp;amp; routes]&amp;lt;br&amp;gt;  `(#'if-route ~(context-route path)&amp;lt;br&amp;gt;     (#'wrap-context&amp;lt;br&amp;gt;       (fn [request#]&amp;lt;br&amp;gt;         (let-request [~args request#]&amp;lt;br&amp;gt;           (routing request# ~@routes))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">context</a>[path args & routes]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;defroutes&lt;/b&gt; ([name &amp; routes])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a Ring handler function from a sequence of routes. The name may&lt;br&gt;  optionally be followed by a doc-string and metadata map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defroutes&amp;lt;br&amp;gt;  &amp;quot;Define a Ring handler function from a sequence of routes. The name may&amp;lt;br&amp;gt;  optionally be followed by a doc-string and metadata map.&amp;quot;&amp;lt;br&amp;gt;  [name &amp;amp; routes]&amp;lt;br&amp;gt;  (let [[name routes] (name-with-attributes name routes)]&amp;lt;br&amp;gt;   `(def ~name (routes ~@routes))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defroutes</a>[name & routes]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;let-request&lt;/b&gt; ([[bindings request] &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro let-request [[bindings request] &amp;amp; body]&amp;lt;br&amp;gt;  (if (vector? bindings)&amp;lt;br&amp;gt;    `(let [~@(vector-bindings bindings request)] ~@body)&amp;lt;br&amp;gt;    `(let [~bindings ~request] ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">let-request</a>[[bindings request] & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;let-routes&lt;/b&gt; ([bindings &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Takes a vector of bindings and a body of routes. Equivalent to:&lt;br&gt;  (let [...] (routes ...))&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro let-routes&amp;lt;br&amp;gt;  &amp;quot;Takes a vector of bindings and a body of routes. Equivalent to:&amp;lt;br&amp;gt;  (let [...] (routes ...))&amp;quot;&amp;lt;br&amp;gt;  [bindings &amp;amp; body]&amp;lt;br&amp;gt;  `(let ~bindings (routes ~@body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">let-routes</a>[bindings & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;make-route&lt;/b&gt; ([method route handler])&lt;br&gt; Returns a function that will only call the handler if the method and Clout&lt;br&gt;  route match the request.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-route&amp;lt;br&amp;gt;  &amp;quot;Returns a function that will only call the handler if the method and Clout&amp;lt;br&amp;gt;  route match the request.&amp;quot;&amp;lt;br&amp;gt;  [method route handler]&amp;lt;br&amp;gt;  (if-method method&amp;lt;br&amp;gt;    (if-route route&amp;lt;br&amp;gt;      (fn [request]&amp;lt;br&amp;gt;        (render (handler request) request)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-route</a>[method route handler]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;routes&lt;/b&gt; ([&amp; handlers])&lt;br&gt; Create a Ring handler by combining several handlers into one.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn routes&amp;lt;br&amp;gt;  &amp;quot;Create a Ring handler by combining several handlers into one.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; handlers]&amp;lt;br&amp;gt;  #(apply routing % handlers))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">routes</a>[& handlers]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.core&lt;/i&gt;&lt;b&gt;routing&lt;/b&gt; ([request &amp; handlers])&lt;br&gt; Apply a list of routes to a Ring request map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn routing&amp;lt;br&amp;gt;  &amp;quot;Apply a list of routes to a Ring request map.&amp;quot;&amp;lt;br&amp;gt;  [request &amp;amp; handlers]&amp;lt;br&amp;gt;  (some #(% request) handlers))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">routing</a>[request & handlers]</div></div></div><div class="row"><div class="namespace"><h4>compojure.handler</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.handler&lt;/i&gt;&lt;b&gt;api&lt;/b&gt; ([routes])&lt;br&gt; Create a handler suitable for a web API. This adds the following&lt;br&gt;  middleware to your routes:&lt;br&gt;    - wrap-params&lt;br&gt;    - wrap-nested-params&lt;br&gt;    - wrap-keyword-params&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn api&amp;lt;br&amp;gt;  &amp;quot;Create a handler suitable for a web API. This adds the following&amp;lt;br&amp;gt;  middleware to your routes:&amp;lt;br&amp;gt;    - wrap-params&amp;lt;br&amp;gt;    - wrap-nested-params&amp;lt;br&amp;gt;    - wrap-keyword-params&amp;quot;&amp;lt;br&amp;gt;  [routes]&amp;lt;br&amp;gt;  (-&amp;gt; routes&amp;lt;br&amp;gt;      wrap-keyword-params&amp;lt;br&amp;gt;      wrap-nested-params&amp;lt;br&amp;gt;      wrap-params))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">api</a>[routes]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.handler&lt;/i&gt;&lt;b&gt;site&lt;/b&gt; ([routes &amp; [opts]])&lt;br&gt; Create a handler suitable for a standard website. This adds the&lt;br&gt;  following middleware to your routes:&lt;br&gt;    - wrap-session&lt;br&gt;    - wrap-flash&lt;br&gt;    - wrap-cookies&lt;br&gt;    - wrap-multipart-params&lt;br&gt;    - wrap-params&lt;br&gt;    - wrap-nested-params&lt;br&gt;    - wrap-keyword-params&lt;br&gt;&lt;br&gt;  A map of options may also be provided. These keys are provided:&lt;br&gt;    :session   - a map of session middleware options&lt;br&gt;    :multipart - a map of multipart-params middleware options&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn site&amp;lt;br&amp;gt;  &amp;quot;Create a handler suitable for a standard website. This adds the&amp;lt;br&amp;gt;  following middleware to your routes:&amp;lt;br&amp;gt;    - wrap-session&amp;lt;br&amp;gt;    - wrap-flash&amp;lt;br&amp;gt;    - wrap-cookies&amp;lt;br&amp;gt;    - wrap-multipart-params&amp;lt;br&amp;gt;    - wrap-params&amp;lt;br&amp;gt;    - wrap-nested-params&amp;lt;br&amp;gt;    - wrap-keyword-params&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  A map of options may also be provided. These keys are provided:&amp;lt;br&amp;gt;    :session   - a map of session middleware options&amp;lt;br&amp;gt;    :multipart - a map of multipart-params middleware options&amp;quot;&amp;lt;br&amp;gt;  [routes &amp;amp; [opts]]&amp;lt;br&amp;gt;  (-&amp;gt; (api routes)&amp;lt;br&amp;gt;      (with-opts wrap-multipart-params (:multipart opts))&amp;lt;br&amp;gt;      (wrap-flash)&amp;lt;br&amp;gt;      (with-opts wrap-session (:session opts))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">site</a>[routes & [opts]]</div></div></div><div class="row"><div class="namespace"><h4>compojure.response</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.response&lt;/i&gt;&lt;b&gt;render&lt;/b&gt; ([this request])&lt;br&gt; Render the object into a form suitable for the given request map.&lt;/div&gt;" data-placement="right">render</a>[this request]</div></div></div><div class="row"><div class="namespace"><h4>compojure.route</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.route&lt;/i&gt;&lt;b&gt;files&lt;/b&gt; ([path &amp; [options]])&lt;br&gt; A route for serving static files from a directory. Accepts the following&lt;br&gt;  keys:&lt;br&gt;    :root - the root path where the files are stored. Defaults to 'public'.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn files&amp;lt;br&amp;gt;  &amp;quot;A route for serving static files from a directory. Accepts the following&amp;lt;br&amp;gt;  keys:&amp;lt;br&amp;gt;    :root - the root path where the files are stored. Defaults to 'public'.&amp;quot;&amp;lt;br&amp;gt;  [path &amp;amp; [options]]&amp;lt;br&amp;gt;  (-&amp;gt; (GET (add-wildcard path) {{file-path :*} :route-params}&amp;lt;br&amp;gt;        (let [options (merge {:root &amp;quot;public&amp;quot;} options)]&amp;lt;br&amp;gt;          (file-response file-path options)))&amp;lt;br&amp;gt;      (wrap-file-info (:mime-types options))&amp;lt;br&amp;gt;      (wrap-head)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">files</a>[path & [options]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.route&lt;/i&gt;&lt;b&gt;not-found&lt;/b&gt; ([body])&lt;br&gt; A route that returns a 404 not found response, with its argument as the&lt;br&gt;  response body.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn not-found&amp;lt;br&amp;gt;  &amp;quot;A route that returns a 404 not found response, with its argument as the&amp;lt;br&amp;gt;  response body.&amp;quot;&amp;lt;br&amp;gt;  [body]&amp;lt;br&amp;gt;  (wrap-head&amp;lt;br&amp;gt;    (fn [request]&amp;lt;br&amp;gt;      (-&amp;gt; (response/render body request)&amp;lt;br&amp;gt;          (status 404)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">not-found</a>[body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;compojure.route&lt;/i&gt;&lt;b&gt;resources&lt;/b&gt; ([path &amp; [options]])&lt;br&gt; A route for serving resources on the classpath. Accepts the following&lt;br&gt;  keys:&lt;br&gt;    :root - the root prefix to get the resources from. Defaults to 'public'.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resources&amp;lt;br&amp;gt;  &amp;quot;A route for serving resources on the classpath. Accepts the following&amp;lt;br&amp;gt;  keys:&amp;lt;br&amp;gt;    :root - the root prefix to get the resources from. Defaults to 'public'.&amp;quot;&amp;lt;br&amp;gt;  [path &amp;amp; [options]]&amp;lt;br&amp;gt;  (-&amp;gt; (GET (add-wildcard path) {{resource-path :*} :route-params}&amp;lt;br&amp;gt;        (let [root (:root options &amp;quot;public&amp;quot;)]&amp;lt;br&amp;gt;          (resource-response (str root &amp;quot;/&amp;quot; resource-path))))&amp;lt;br&amp;gt;      (wrap-file-info (:mime-types options))&amp;lt;br&amp;gt;      (wrap-content-type options)&amp;lt;br&amp;gt;      (wrap-head)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resources</a>[path & [options]]</div></div></div><div class="row"><div class="namespace"><h4>hiccup.compiler</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.compiler&lt;/i&gt;&lt;b&gt;compile-attr-map&lt;/b&gt; ([attrs])&lt;br&gt; Returns an unevaluated form that will render the supplied map as HTML&lt;br&gt;  attributes.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn compile-attr-map&amp;lt;br&amp;gt;  &amp;quot;Returns an unevaluated form that will render the supplied map as HTML&amp;lt;br&amp;gt;  attributes.&amp;quot;&amp;lt;br&amp;gt;  [attrs]&amp;lt;br&amp;gt;  (if (some unevaluated? (mapcat identity attrs))&amp;lt;br&amp;gt;    `(#'render-attr-map ~attrs)&amp;lt;br&amp;gt;    (render-attr-map attrs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">compile-attr-map</a>[attrs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.compiler&lt;/i&gt;&lt;b&gt;compile-html&lt;/b&gt; ([&amp; content])&lt;br&gt; Pre-compile data structures into HTML where possible.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn compile-html&amp;lt;br&amp;gt;  &amp;quot;Pre-compile data structures into HTML where possible.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; content]&amp;lt;br&amp;gt;  (collapse-strs `(str ~@(compile-seq content))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">compile-html</a>[& content]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.compiler&lt;/i&gt;&lt;b&gt;normalize-element&lt;/b&gt; ([[tag &amp; content]])&lt;br&gt; Ensure an element vector is of the form [tag-name attrs content].&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn normalize-element&amp;lt;br&amp;gt;  &amp;quot;Ensure an element vector is of the form [tag-name attrs content].&amp;quot;&amp;lt;br&amp;gt;  [[tag &amp;amp; content]]&amp;lt;br&amp;gt;  (when (not (or (keyword? tag) (symbol? tag) (string? tag)))&amp;lt;br&amp;gt;    (throw (IllegalArgumentException. (str tag &amp;quot; is not a valid element name.&amp;quot;))))&amp;lt;br&amp;gt;  (let [[_ tag id class] (re-matches re-tag (as-str tag))&amp;lt;br&amp;gt;        tag-attrs        {:id id&amp;lt;br&amp;gt;                          :class (if class (.replace ^String class &amp;quot;.&amp;quot; &amp;quot; &amp;quot;))}&amp;lt;br&amp;gt;        map-attrs        (first content)]&amp;lt;br&amp;gt;    (if (map? map-attrs)&amp;lt;br&amp;gt;      [tag (merge tag-attrs map-attrs) (next content)]&amp;lt;br&amp;gt;      [tag tag-attrs content])))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">normalize-element</a>[[tag & content]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.compiler&lt;/i&gt;&lt;b&gt;render-html&lt;/b&gt; ([this])&lt;br&gt; Turn a Clojure data type into a string of HTML.&lt;/div&gt;" data-placement="right">render-html</a>[this]</div></div></div><div class="row"><div class="namespace"><h4>hiccup.core</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.core&lt;/i&gt;&lt;b&gt;html&lt;/b&gt; ([options &amp; content])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Render Clojure data structures to a string of HTML.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro html&amp;lt;br&amp;gt;  &amp;quot;Render Clojure data structures to a string of HTML.&amp;quot;&amp;lt;br&amp;gt;  [options &amp;amp; content]&amp;lt;br&amp;gt;  (if-let [mode (and (map? options) (:mode options))]&amp;lt;br&amp;gt;    (binding [*html-mode* mode]&amp;lt;br&amp;gt;      `(binding [*html-mode* ~mode]&amp;lt;br&amp;gt;         ~(apply compile-html content)))&amp;lt;br&amp;gt;    (apply compile-html options content)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">html</a>[options & content]</div></div></div><div class="row"><div class="namespace"><h4>hiccup.def</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.def&lt;/i&gt;&lt;b&gt;defelem&lt;/b&gt; ([name &amp; fdecl])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Defines a function that will return a element vector. If the first argument&lt;br&gt;  passed to the resulting function is a map, it merges it with the attribute&lt;br&gt;  map of the returned element value.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defelem&amp;lt;br&amp;gt;  &amp;quot;Defines a function that will return a element vector. If the first argument&amp;lt;br&amp;gt;  passed to the resulting function is a map, it merges it with the attribute&amp;lt;br&amp;gt;  map of the returned element value.&amp;quot;&amp;lt;br&amp;gt;  [name &amp;amp; fdecl]&amp;lt;br&amp;gt;  `(do (defn ~name ~@fdecl)&amp;lt;br&amp;gt;       (alter-meta! (var ~name) update-in [:arglists] #'update-arglists)&amp;lt;br&amp;gt;       (alter-var-root (var ~name) wrap-attrs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defelem</a>[name & fdecl]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.def&lt;/i&gt;&lt;b&gt;defhtml&lt;/b&gt; ([name &amp; fdecl])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Define a function, but wrap its output in an implicit html macro.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defhtml&amp;lt;br&amp;gt;  &amp;quot;Define a function, but wrap its output in an implicit html macro.&amp;quot;&amp;lt;br&amp;gt;  [name &amp;amp; fdecl]&amp;lt;br&amp;gt;  (let [[fhead fbody] (split-with #(not (or (list? %) (vector? %))) fdecl)&amp;lt;br&amp;gt;        wrap-html     (fn [[args &amp;amp; body]] `(~args (html ~@body)))]&amp;lt;br&amp;gt;    `(defn ~name&amp;lt;br&amp;gt;       ~@fhead&amp;lt;br&amp;gt;       ~@(if (vector? (first fbody))&amp;lt;br&amp;gt;           (wrap-html fbody)&amp;lt;br&amp;gt;           (map wrap-html fbody)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defhtml</a>[name & fdecl]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.def&lt;/i&gt;&lt;b&gt;wrap-attrs&lt;/b&gt; ([func])&lt;br&gt; Add an optional attribute argument to a function that returns a element vector.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-attrs&amp;lt;br&amp;gt;  &amp;quot;Add an optional attribute argument to a function that returns a element vector.&amp;quot;&amp;lt;br&amp;gt;  [func]&amp;lt;br&amp;gt;  (fn [&amp;amp; args]&amp;lt;br&amp;gt;    (if (map? (first args))&amp;lt;br&amp;gt;      (let [[tag &amp;amp; body] (apply func (rest args))]&amp;lt;br&amp;gt;        (if (map? (first body))&amp;lt;br&amp;gt;          (apply vector tag (merge (first body) (first args)) (rest body))&amp;lt;br&amp;gt;          (apply vector tag (first args) body)))&amp;lt;br&amp;gt;      (apply func args))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-attrs</a>[func]</div></div></div><div class="row"><div class="namespace"><h4>hiccup.page</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.page&lt;/i&gt;&lt;b&gt;html4&lt;/b&gt; ([&amp; contents])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Create a HTML 4 document with the supplied contents. The first argument&lt;br&gt;  may be an optional attribute map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro html4&amp;lt;br&amp;gt;  &amp;quot;Create a HTML 4 document with the supplied contents. The first argument&amp;lt;br&amp;gt;  may be an optional attribute map.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; contents]&amp;lt;br&amp;gt;  `(html {:mode :sgml}&amp;lt;br&amp;gt;     (doctype :html4)&amp;lt;br&amp;gt;     [:html ~@contents]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">html4</a>[& contents]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.page&lt;/i&gt;&lt;b&gt;html5&lt;/b&gt; ([options &amp; contents])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Create a HTML5 document with the supplied contents.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro html5&amp;lt;br&amp;gt;  &amp;quot;Create a HTML5 document with the supplied contents.&amp;quot;&amp;lt;br&amp;gt;  [options &amp;amp; contents]&amp;lt;br&amp;gt;  (if-not (map? options)&amp;lt;br&amp;gt;    `(html5 {} ~options ~@contents)&amp;lt;br&amp;gt;    (if (options :xml?)&amp;lt;br&amp;gt;      `(let [options# (dissoc ~options :xml?)]&amp;lt;br&amp;gt;         (html {:mode :xml}&amp;lt;br&amp;gt;           (xml-declaration (options# :encoding &amp;quot;UTF-8&amp;quot;))&amp;lt;br&amp;gt;           (doctype :html5)&amp;lt;br&amp;gt;           (xhtml-tag options# (options# :lang) ~@contents)))&amp;lt;br&amp;gt;      `(let [options# (dissoc ~options :xml?)]&amp;lt;br&amp;gt;         (html {:mode :html}&amp;lt;br&amp;gt;           (doctype :html5)&amp;lt;br&amp;gt;           [:html options# ~@contents])))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">html5</a>[options & contents]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.page&lt;/i&gt;&lt;b&gt;include-css&lt;/b&gt; ([&amp; styles])&lt;br&gt; Include a list of external stylesheet files.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn include-css&amp;lt;br&amp;gt;  &amp;quot;Include a list of external stylesheet files.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; styles]&amp;lt;br&amp;gt;  (for [style styles]&amp;lt;br&amp;gt;    [:link {:type &amp;quot;text/css&amp;quot;, :href (to-uri style), :rel &amp;quot;stylesheet&amp;quot;}]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">include-css</a>[& styles]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.page&lt;/i&gt;&lt;b&gt;include-js&lt;/b&gt; ([&amp; scripts])&lt;br&gt; Include a list of external javascript files.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn include-js&amp;lt;br&amp;gt;  &amp;quot;Include a list of external javascript files.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; scripts]&amp;lt;br&amp;gt;  (for [script scripts]&amp;lt;br&amp;gt;    [:script {:type &amp;quot;text/javascript&amp;quot;, :src (to-uri script)}]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">include-js</a>[& scripts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.page&lt;/i&gt;&lt;b&gt;xhtml&lt;/b&gt; ([options &amp; contents])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Create a XHTML 1.0 strict document with the supplied contents. The first&lt;br&gt;  argument may be an optional attribute may. The following attributes are&lt;br&gt;  treated specially:&lt;br&gt;    :lang     - The language of the document&lt;br&gt;    :encoding - The character encoding of the document, defaults to UTF-8.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro xhtml&amp;lt;br&amp;gt;  &amp;quot;Create a XHTML 1.0 strict document with the supplied contents. The first&amp;lt;br&amp;gt;  argument may be an optional attribute may. The following attributes are&amp;lt;br&amp;gt;  treated specially:&amp;lt;br&amp;gt;    :lang     - The language of the document&amp;lt;br&amp;gt;    :encoding - The character encoding of the document, defaults to UTF-8.&amp;quot;&amp;lt;br&amp;gt;  [options &amp;amp; contents]&amp;lt;br&amp;gt;  (if-not (map? options)&amp;lt;br&amp;gt;    `(xhtml {} ~options ~@contents)&amp;lt;br&amp;gt;    `(let [options# ~options]&amp;lt;br&amp;gt;       (html {:mode :xml}&amp;lt;br&amp;gt;         (xml-declaration (options# :encoding &amp;quot;UTF-8&amp;quot;))&amp;lt;br&amp;gt;         (doctype :xhtml-strict)&amp;lt;br&amp;gt;         (xhtml-tag (options# :lang) ~@contents)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">xhtml</a>[options & contents]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.page&lt;/i&gt;&lt;b&gt;xhtml-tag&lt;/b&gt; ([attr-map? lang &amp; contents])&lt;br&gt; Create an XHTML element for the specified language.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defelem xhtml-tag&amp;lt;br&amp;gt;  &amp;quot;Create an XHTML element for the specified language.&amp;quot;&amp;lt;br&amp;gt;  [lang &amp;amp; contents]&amp;lt;br&amp;gt;  [:html {:xmlns &amp;quot;http://www.w3.org/1999/xhtml&amp;quot;&amp;lt;br&amp;gt;          &amp;quot;xml:lang&amp;quot; lang&amp;lt;br&amp;gt;          :lang lang}&amp;lt;br&amp;gt;    contents])&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">xhtml-tag</a>[attr-map? lang & contents]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.page&lt;/i&gt;&lt;b&gt;xml-declaration&lt;/b&gt; ([encoding])&lt;br&gt; Create a standard XML declaration for the following encoding.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn xml-declaration&amp;lt;br&amp;gt;  &amp;quot;Create a standard XML declaration for the following encoding.&amp;quot;&amp;lt;br&amp;gt;  [encoding]&amp;lt;br&amp;gt;  (str &amp;quot;&amp;lt;?xml version=\&amp;quot;1.0\&amp;quot; encoding=\&amp;quot;&amp;quot; encoding &amp;quot;\&amp;quot;?&amp;gt;\n&amp;quot;))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">xml-declaration</a>[encoding]</div></div></div><div class="row"><div class="namespace"><h4>hiccup.util</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.util&lt;/i&gt;&lt;b&gt;as-str&lt;/b&gt; ([&amp; xs])&lt;br&gt; Converts its arguments into a string using to-str.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^String as-str&amp;lt;br&amp;gt;  &amp;quot;Converts its arguments into a string using to-str.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; xs]&amp;lt;br&amp;gt;  (apply str (map to-str xs)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">as-str</a>[& xs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.util&lt;/i&gt;&lt;b&gt;escape-html&lt;/b&gt; ([text])&lt;br&gt; Change special characters into HTML character entities.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn escape-html&amp;lt;br&amp;gt;  &amp;quot;Change special characters into HTML character entities.&amp;quot;&amp;lt;br&amp;gt;  [text]&amp;lt;br&amp;gt;  (.. ^String (as-str text)&amp;lt;br&amp;gt;    (replace &amp;quot;&amp;amp;&amp;quot;  &amp;quot;&amp;amp;amp;&amp;quot;)&amp;lt;br&amp;gt;    (replace &amp;quot;&amp;lt;&amp;quot;  &amp;quot;&amp;amp;lt;&amp;quot;)&amp;lt;br&amp;gt;    (replace &amp;quot;&amp;gt;&amp;quot;  &amp;quot;&amp;amp;gt;&amp;quot;)&amp;lt;br&amp;gt;    (replace &amp;quot;\&amp;quot;&amp;quot; &amp;quot;&amp;amp;quot;&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">escape-html</a>[text]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.util&lt;/i&gt;&lt;b&gt;to-str&lt;/b&gt; ([x])&lt;br&gt; Convert a value into a string.&lt;/div&gt;" data-placement="right">to-str</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.util&lt;/i&gt;&lt;b&gt;to-uri&lt;/b&gt; ([x])&lt;br&gt; Convert a value into a URI.&lt;/div&gt;" data-placement="right">to-uri</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.util&lt;/i&gt;&lt;b&gt;url&lt;/b&gt; ([&amp; args])&lt;br&gt; Creates a URL string from a variable list of arguments and an optional&lt;br&gt;  parameter map as the last argument. For example:&lt;br&gt;    (url &quot;/group/&quot; 4 &quot;/products&quot; {:page 9})&lt;br&gt;    =&gt; &quot;/group/4/products?page=9&quot;&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn url&amp;lt;br&amp;gt;  &amp;quot;Creates a URL string from a variable list of arguments and an optional&amp;lt;br&amp;gt;  parameter map as the last argument. For example:&amp;lt;br&amp;gt;    (url \&amp;quot;/group/\&amp;quot; 4 \&amp;quot;/products\&amp;quot; {:page 9})&amp;lt;br&amp;gt;    =&amp;gt; \&amp;quot;/group/4/products?page=9\&amp;quot;&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; args]&amp;lt;br&amp;gt;  (let [params (last args), args (butlast args)]&amp;lt;br&amp;gt;    (to-uri&amp;lt;br&amp;gt;     (str (apply str args)&amp;lt;br&amp;gt;          (if (map? params)&amp;lt;br&amp;gt;            (str &amp;quot;?&amp;quot; (url-encode params))&amp;lt;br&amp;gt;            params)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">url</a>[& args]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.util&lt;/i&gt;&lt;b&gt;url-encode&lt;/b&gt; ([x])&lt;br&gt; Turn a value into a URL-encoded string.&lt;/div&gt;" data-placement="right">url-encode</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.util&lt;/i&gt;&lt;b&gt;with-base-url&lt;/b&gt; ([base-url &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Sets a base URL that will be prepended onto relative URIs. Note that for this&lt;br&gt;  to work correctly, it needs to be placed outside the html macro.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-base-url&amp;lt;br&amp;gt;  &amp;quot;Sets a base URL that will be prepended onto relative URIs. Note that for this&amp;lt;br&amp;gt;  to work correctly, it needs to be placed outside the html macro.&amp;quot;&amp;lt;br&amp;gt;  [base-url &amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*base-url* ~base-url]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-base-url</a>[base-url & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;hiccup.util&lt;/i&gt;&lt;b&gt;with-encoding&lt;/b&gt; ([encoding &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Sets a default encoding for URL encoding strings. Defaults to UTF-8.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-encoding&amp;lt;br&amp;gt;  &amp;quot;Sets a default encoding for URL encoding strings. Defaults to UTF-8.&amp;quot;&amp;lt;br&amp;gt;  [encoding &amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*encoding* ~encoding]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-encoding</a>[encoding & body]</div></div></div><div class="row"><div class="namespace"><h4>ns-tracker.core</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ns-tracker.core&lt;/i&gt;&lt;b&gt;ns-tracker&lt;/b&gt; ([dirs] [dirs initial-timestamp-map])&lt;br&gt; Returns a no-arg function which, when called, returns a set of&lt;br&gt;  namespaces that need to be reloaded, based on file modification&lt;br&gt;  timestamps and the graph of namespace dependencies.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ns-tracker&amp;lt;br&amp;gt;  &amp;quot;Returns a no-arg function which, when called, returns a set of&amp;lt;br&amp;gt;  namespaces that need to be reloaded, based on file modification&amp;lt;br&amp;gt;  timestamps and the graph of namespace dependencies.&amp;quot;&amp;lt;br&amp;gt;  ([dirs]&amp;lt;br&amp;gt;     (ns-tracker dirs (current-timestamp-map (normalize-dirs dirs))))&amp;lt;br&amp;gt;  ([dirs initial-timestamp-map]&amp;lt;br&amp;gt;     {:pre [(map? initial-timestamp-map)]}&amp;lt;br&amp;gt;     (let [dirs (normalize-dirs dirs)&amp;lt;br&amp;gt;           timestamp-map (atom initial-timestamp-map)&amp;lt;br&amp;gt;           init-decls (newer-namespace-decls {} (keys @timestamp-map))&amp;lt;br&amp;gt;           dependency-graph (atom (update-dependency-graph (graph) init-decls))]&amp;lt;br&amp;gt;       (fn []&amp;lt;br&amp;gt;         (let [then @timestamp-map&amp;lt;br&amp;gt;               now (current-timestamp-map (normalize-dirs dirs))&amp;lt;br&amp;gt;               new-decls (newer-namespace-decls then (keys now))]&amp;lt;br&amp;gt;           (when (seq new-decls)&amp;lt;br&amp;gt;             (let [new-names (map second new-decls)&amp;lt;br&amp;gt;                   affected-names&amp;lt;br&amp;gt;                   (affected-namespaces new-names @dependency-graph)]&amp;lt;br&amp;gt;               (reset! timestamp-map now)&amp;lt;br&amp;gt;               (swap! dependency-graph update-dependency-graph new-decls)&amp;lt;br&amp;gt;               affected-names)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ns-tracker</a>[dirs] [dirs initial-timestamp-map]</div></div></div><div class="row"><div class="namespace"><h4>ns-tracker.dependency</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ns-tracker.dependency&lt;/i&gt;&lt;b&gt;depend&lt;/b&gt; ([graph x] [graph x dep] [graph x dep &amp; more])&lt;br&gt; Adds to the dependency graph that x depends on deps.  Forbids&lt;br&gt;  circular dependencies.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn depend&amp;lt;br&amp;gt;  &amp;quot;Adds to the dependency graph that x depends on deps.  Forbids&amp;lt;br&amp;gt;  circular dependencies.&amp;quot;&amp;lt;br&amp;gt;  ([graph x] graph)&amp;lt;br&amp;gt;  ([graph x dep]&amp;lt;br&amp;gt;     {:pre [(not (depends? graph dep x))]}&amp;lt;br&amp;gt;     (-&amp;gt; graph&amp;lt;br&amp;gt;	 (add-relationship :dependencies x dep)&amp;lt;br&amp;gt;	 (add-relationship :dependents dep x)))&amp;lt;br&amp;gt;  ([graph x dep &amp;amp; more]&amp;lt;br&amp;gt;     (reduce (fn [g d] (depend g x d))&amp;lt;br&amp;gt;	     graph (cons dep more))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">depend</a>[graph x] [graph x dep] [graph x dep & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ns-tracker.dependency&lt;/i&gt;&lt;b&gt;dependencies&lt;/b&gt; ([graph x])&lt;br&gt; Returns the set of all things x depends on, directly or transitively.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dependencies&amp;lt;br&amp;gt;  &amp;quot;Returns the set of all things x depends on, directly or transitively.&amp;quot;&amp;lt;br&amp;gt;  [graph x]&amp;lt;br&amp;gt;  (transitive (:dependencies graph) x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dependencies</a>[graph x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ns-tracker.dependency&lt;/i&gt;&lt;b&gt;dependent&lt;/b&gt; ([graph x y])&lt;br&gt; True if y is a dependent of x.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dependent&amp;lt;br&amp;gt;  &amp;quot;True if y is a dependent of x.&amp;quot;&amp;lt;br&amp;gt;  [graph x y]&amp;lt;br&amp;gt;  (some #(= y %) (dependents graph x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dependent</a>[graph x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ns-tracker.dependency&lt;/i&gt;&lt;b&gt;dependents&lt;/b&gt; ([graph x])&lt;br&gt; Returns the set of all things which depend upon x, directly or&lt;br&gt;  transitively.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn dependents&amp;lt;br&amp;gt;  &amp;quot;Returns the set of all things which depend upon x, directly or&amp;lt;br&amp;gt;  transitively.&amp;quot;&amp;lt;br&amp;gt;  [graph x]&amp;lt;br&amp;gt;  (transitive (:dependents graph) x))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">dependents</a>[graph x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ns-tracker.dependency&lt;/i&gt;&lt;b&gt;depends?&lt;/b&gt; ([graph x y])&lt;br&gt; True if x is directly or transitively dependent on y.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn depends?&amp;lt;br&amp;gt;  &amp;quot;True if x is directly or transitively dependent on y.&amp;quot;&amp;lt;br&amp;gt;  [graph x y]&amp;lt;br&amp;gt;  (some #(= y %) (dependencies graph x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">depends?</a>[graph x y]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ns-tracker.dependency&lt;/i&gt;&lt;b&gt;graph&lt;/b&gt; ([])&lt;br&gt; Returns a new, empty, dependency graph.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn graph &amp;quot;Returns a new, empty, dependency graph.&amp;quot; []&amp;lt;br&amp;gt;  {:dependencies {}&amp;lt;br&amp;gt;   :dependents {}})&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">graph</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ns-tracker.dependency&lt;/i&gt;&lt;b&gt;remove-all&lt;/b&gt; ([graph] [graph x] [graph x &amp; more])&lt;br&gt; Removes all references to x in the dependency graph.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove-all&amp;lt;br&amp;gt;  &amp;quot;Removes all references to x in the dependency graph.&amp;quot;&amp;lt;br&amp;gt;  ([graph] graph)&amp;lt;br&amp;gt;  ([graph x]&amp;lt;br&amp;gt;     (assoc graph&amp;lt;br&amp;gt;       :dependencies (remove-from-map (:dependencies graph) x)&amp;lt;br&amp;gt;       :dependents (remove-from-map (:dependents graph) x)))&amp;lt;br&amp;gt;  ([graph x &amp;amp; more]&amp;lt;br&amp;gt;     (reduce remove-all&amp;lt;br&amp;gt;	     graph (cons x more))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove-all</a>[graph] [graph x] [graph x & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ns-tracker.dependency&lt;/i&gt;&lt;b&gt;remove-key&lt;/b&gt; ([graph] [graph x] [graph x &amp; more])&lt;br&gt; Removes the key x from the dependency graph without removing x as a&lt;br&gt;  depedency of other keys.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn remove-key&amp;lt;br&amp;gt;  &amp;quot;Removes the key x from the dependency graph without removing x as a&amp;lt;br&amp;gt;  depedency of other keys.&amp;quot;&amp;lt;br&amp;gt;  ([graph] graph)&amp;lt;br&amp;gt;  ([graph x]&amp;lt;br&amp;gt;     (assoc graph&amp;lt;br&amp;gt;       :dependencies (dissoc (:dependencies graph) x)))&amp;lt;br&amp;gt;  ([graph x &amp;amp; more]&amp;lt;br&amp;gt;     (reduce remove-key&amp;lt;br&amp;gt;	     graph (cons x more))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">remove-key</a>[graph] [graph x] [graph x & more]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ns-tracker.dependency&lt;/i&gt;&lt;b&gt;seq-union&lt;/b&gt; ([] [s1] [s1 s2] [s1 s2 &amp; sets])&lt;br&gt; A union that preserves order.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn seq-union&amp;lt;br&amp;gt;  &amp;quot;A union that preserves order.&amp;quot;&amp;lt;br&amp;gt;  ([] '())&amp;lt;br&amp;gt;  ([s1] s1)&amp;lt;br&amp;gt;  ([s1 s2] (concat s1 (remove (set s1) s2)))&amp;lt;br&amp;gt;  ([s1 s2 &amp;amp; sets] (reduce seq-union (list* s1 s2 sets))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">seq-union</a>[] [s1] [s1 s2] [s1 s2 & sets]</div></div></div><div class="row"><div class="namespace"><h4>ns-tracker.nsdeps</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ns-tracker.nsdeps&lt;/i&gt;&lt;b&gt;deps-from-ns-decl&lt;/b&gt; ([decl])&lt;br&gt; Given a (quoted) ns declaration, returns a set of symbols naming&lt;br&gt;  the dependencies of that namespace.  Handles :use and :require clauses.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn deps-from-ns-decl&amp;lt;br&amp;gt;  &amp;quot;Given a (quoted) ns declaration, returns a set of symbols naming&amp;lt;br&amp;gt;  the dependencies of that namespace.  Handles :use and :require clauses.&amp;quot;&amp;lt;br&amp;gt;  [decl]&amp;lt;br&amp;gt;  (apply union (map deps-from-ns-form decl)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">deps-from-ns-decl</a>[decl]</div></div></div><div class="row"><div class="namespace"><h4>ring.adapter.jetty</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.adapter.jetty&lt;/i&gt;&lt;b&gt;run-jetty&lt;/b&gt; ([handler options])&lt;br&gt; Start a Jetty webserver to serve the given handler according to the&lt;br&gt;  supplied options:&lt;br&gt;&lt;br&gt;  :configurator - a function called with the Jetty Server instance&lt;br&gt;  :port         - the port to listen on (defaults to 80)&lt;br&gt;  :host         - the hostname to listen on&lt;br&gt;  :join?        - blocks the thread until server ends (defaults to true)&lt;br&gt;  :ssl?         - allow connections over HTTPS&lt;br&gt;  :ssl-port     - the SSL port to listen on (defaults to 443, implies :ssl?)&lt;br&gt;  :keystore     - the keystore to use for SSL connections&lt;br&gt;  :key-password - the password to the keystore&lt;br&gt;  :truststore   - a truststore to use for SSL connections&lt;br&gt;  :trust-password - the password to the truststore&lt;br&gt;  :max-threads  - the maximum number of threads to use (default 50)&lt;br&gt;  :client-auth  - SSL client certificate authenticate, may be set to :need,&lt;br&gt;                  :want or :none (defaults to :none)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^Server run-jetty&amp;lt;br&amp;gt;  &amp;quot;Start a Jetty webserver to serve the given handler according to the&amp;lt;br&amp;gt;  supplied options:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :configurator - a function called with the Jetty Server instance&amp;lt;br&amp;gt;  :port         - the port to listen on (defaults to 80)&amp;lt;br&amp;gt;  :host         - the hostname to listen on&amp;lt;br&amp;gt;  :join?        - blocks the thread until server ends (defaults to true)&amp;lt;br&amp;gt;  :ssl?         - allow connections over HTTPS&amp;lt;br&amp;gt;  :ssl-port     - the SSL port to listen on (defaults to 443, implies :ssl?)&amp;lt;br&amp;gt;  :keystore     - the keystore to use for SSL connections&amp;lt;br&amp;gt;  :key-password - the password to the keystore&amp;lt;br&amp;gt;  :truststore   - a truststore to use for SSL connections&amp;lt;br&amp;gt;  :trust-password - the password to the truststore&amp;lt;br&amp;gt;  :max-threads  - the maximum number of threads to use (default 50)&amp;lt;br&amp;gt;  :client-auth  - SSL client certificate authenticate, may be set to :need,&amp;lt;br&amp;gt;                  :want or :none (defaults to :none)&amp;quot;&amp;lt;br&amp;gt;  [handler options]&amp;lt;br&amp;gt;  (let [^Server s (create-server (dissoc options :configurator))]&amp;lt;br&amp;gt;    (doto s&amp;lt;br&amp;gt;      (.setHandler (proxy-handler handler))&amp;lt;br&amp;gt;      (.setThreadPool (QueuedThreadPool. (options :max-threads 50))))&amp;lt;br&amp;gt;    (when-let [configurator (:configurator options)]&amp;lt;br&amp;gt;      (configurator s))&amp;lt;br&amp;gt;    (.start s)&amp;lt;br&amp;gt;    (when (:join? options true)&amp;lt;br&amp;gt;      (.join s))&amp;lt;br&amp;gt;    s))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">run-jetty</a>[handler options]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.content-type</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.content-type&lt;/i&gt;&lt;b&gt;wrap-content-type&lt;/b&gt; ([handler &amp; [opts]])&lt;br&gt; Middleware that adds a content-type header to the response if one is not&lt;br&gt;  set by the handler. Uses the ring.util.mime-type/ext-mime-type function to&lt;br&gt;  guess the content-type from the file extension in the URI. If no&lt;br&gt;  content-type can be found, it defaults to 'application/octet-stream'.&lt;br&gt;&lt;br&gt;  Accepts the following options:&lt;br&gt;    :mime-types - a map of filename extensions to mime-types that will be&lt;br&gt;                  used in addition to the ones defined in&lt;br&gt;                  ring.util.mime-types/default-mime-types&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-content-type&amp;lt;br&amp;gt;  &amp;quot;Middleware that adds a content-type header to the response if one is not&amp;lt;br&amp;gt;  set by the handler. Uses the ring.util.mime-type/ext-mime-type function to&amp;lt;br&amp;gt;  guess the content-type from the file extension in the URI. If no&amp;lt;br&amp;gt;  content-type can be found, it defaults to 'application/octet-stream'.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Accepts the following options:&amp;lt;br&amp;gt;    :mime-types - a map of filename extensions to mime-types that will be&amp;lt;br&amp;gt;                  used in addition to the ones defined in&amp;lt;br&amp;gt;                  ring.util.mime-types/default-mime-types&amp;quot;&amp;lt;br&amp;gt;  [handler &amp;amp; [opts]]&amp;lt;br&amp;gt;  (fn [req]&amp;lt;br&amp;gt;    (if-let [resp (handler req)]&amp;lt;br&amp;gt;      (if (get-in resp [:headers &amp;quot;Content-Type&amp;quot;])&amp;lt;br&amp;gt;        resp&amp;lt;br&amp;gt;        (let [mime-type (ext-mime-type (:uri req) (:mime-types opts))]&amp;lt;br&amp;gt;          (content-type resp (or mime-type &amp;quot;application/octet-stream&amp;quot;)))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-content-type</a>[handler & [opts]]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.cookies</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.cookies&lt;/i&gt;&lt;b&gt;wrap-cookies&lt;/b&gt; ([handler])&lt;br&gt; Parses the cookies in the request map, then assocs the resulting map&lt;br&gt;  to the :cookies key on the request.&lt;br&gt;&lt;br&gt;  Each cookie is represented as a map, with its value being held in the&lt;br&gt;  :value key. A cookie may optionally contain a :path, :domain or :port&lt;br&gt;  attribute.&lt;br&gt;&lt;br&gt;  To set cookies, add a map to the :cookies key on the response. The values&lt;br&gt;  of the cookie map can either be strings, or maps containing the following&lt;br&gt;  keys:&lt;br&gt;&lt;br&gt;  :value     - the new value of the cookie&lt;br&gt;  :path      - the subpath the cookie is valid for&lt;br&gt;  :domain    - the domain the cookie is valid for&lt;br&gt;  :port      - the port the cookie is valid for&lt;br&gt;  :max-age   - the maximum age in seconds of the cookie&lt;br&gt;  :expires   - a date string at which the cookie will expire&lt;br&gt;  :secure    - set to true if the cookie is valid for HTTPS only&lt;br&gt;  :http-only - set to true if the cookie is valid for HTTP only&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-cookies&amp;lt;br&amp;gt;  &amp;quot;Parses the cookies in the request map, then assocs the resulting map&amp;lt;br&amp;gt;  to the :cookies key on the request.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Each cookie is represented as a map, with its value being held in the&amp;lt;br&amp;gt;  :value key. A cookie may optionally contain a :path, :domain or :port&amp;lt;br&amp;gt;  attribute.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  To set cookies, add a map to the :cookies key on the response. The values&amp;lt;br&amp;gt;  of the cookie map can either be strings, or maps containing the following&amp;lt;br&amp;gt;  keys:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  :value     - the new value of the cookie&amp;lt;br&amp;gt;  :path      - the subpath the cookie is valid for&amp;lt;br&amp;gt;  :domain    - the domain the cookie is valid for&amp;lt;br&amp;gt;  :port      - the port the cookie is valid for&amp;lt;br&amp;gt;  :max-age   - the maximum age in seconds of the cookie&amp;lt;br&amp;gt;  :expires   - a date string at which the cookie will expire&amp;lt;br&amp;gt;  :secure    - set to true if the cookie is valid for HTTPS only&amp;lt;br&amp;gt;  :http-only - set to true if the cookie is valid for HTTP only&amp;quot;&amp;lt;br&amp;gt;  [handler]&amp;lt;br&amp;gt;  (fn [request]&amp;lt;br&amp;gt;    (let [request (if (request :cookies)&amp;lt;br&amp;gt;                    request&amp;lt;br&amp;gt;                    (assoc request :cookies (parse-cookies request)))]&amp;lt;br&amp;gt;      (-&amp;gt; (handler request)&amp;lt;br&amp;gt;        (set-cookies)&amp;lt;br&amp;gt;        (dissoc :cookies)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-cookies</a>[handler]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.file-info</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.file-info&lt;/i&gt;&lt;b&gt;make-http-format&lt;/b&gt; ([])&lt;br&gt; Formats or parses dates into HTTP date format (RFC 822/1123).&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ^SimpleDateFormat make-http-format&amp;lt;br&amp;gt;  &amp;quot;Formats or parses dates into HTTP date format (RFC 822/1123).&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  ;; SimpleDateFormat is not threadsafe, so return a new instance each time&amp;lt;br&amp;gt;  (doto (SimpleDateFormat. &amp;quot;EEE, dd MMM yyyy HH:mm:ss ZZZ&amp;quot; Locale/US)&amp;lt;br&amp;gt;    (.setTimeZone (TimeZone/getTimeZone &amp;quot;UTC&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-http-format</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.file-info&lt;/i&gt;&lt;b&gt;wrap-file-info&lt;/b&gt; ([app &amp; [mime-types]])&lt;br&gt; Wrap an app such that responses with a file a body will have corresponding&lt;br&gt;  Content-Type, Content-Length, and Last Modified headers added if they can be&lt;br&gt;  determined from the file.&lt;br&gt;  If the request specifies a If-Modified-Since header that matches the last&lt;br&gt;  modification date of the file, a 304 Not Modified response is returned.&lt;br&gt;  If two arguments are given, the second is taken to be a map of file extensions&lt;br&gt;  to content types that will supplement the default, built-in map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-file-info&amp;lt;br&amp;gt;  &amp;quot;Wrap an app such that responses with a file a body will have corresponding&amp;lt;br&amp;gt;  Content-Type, Content-Length, and Last Modified headers added if they can be&amp;lt;br&amp;gt;  determined from the file.&amp;lt;br&amp;gt;  If the request specifies a If-Modified-Since header that matches the last&amp;lt;br&amp;gt;  modification date of the file, a 304 Not Modified response is returned.&amp;lt;br&amp;gt;  If two arguments are given, the second is taken to be a map of file extensions&amp;lt;br&amp;gt;  to content types that will supplement the default, built-in map.&amp;quot;&amp;lt;br&amp;gt;  [app &amp;amp; [mime-types]]&amp;lt;br&amp;gt;  (fn [req]&amp;lt;br&amp;gt;    (let [{:keys [headers body] :as response} (app req)]&amp;lt;br&amp;gt;      (if (instance? File body)&amp;lt;br&amp;gt;        (let [file-type   (guess-mime-type body mime-types)&amp;lt;br&amp;gt;              file-length (.length ^File body)&amp;lt;br&amp;gt;              lmodified   (Date. (.lastModified ^File body))&amp;lt;br&amp;gt;              response    (-&amp;gt; response&amp;lt;br&amp;gt;                              (res/content-type file-type)&amp;lt;br&amp;gt;                              (res/header&amp;lt;br&amp;gt;                                &amp;quot;Last-Modified&amp;quot;&amp;lt;br&amp;gt;                                (.format (make-http-format) lmodified)))]&amp;lt;br&amp;gt;          (if (not-modified-since? req lmodified)&amp;lt;br&amp;gt;            (-&amp;gt; response (res/status 304)&amp;lt;br&amp;gt;                (res/header &amp;quot;Content-Length&amp;quot; 0)&amp;lt;br&amp;gt;                (assoc :body &amp;quot;&amp;quot;))&amp;lt;br&amp;gt;            (-&amp;gt; response (res/header &amp;quot;Content-Length&amp;quot; file-length))))&amp;lt;br&amp;gt;        response))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-file-info</a>[app & [mime-types]]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.flash</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.flash&lt;/i&gt;&lt;b&gt;wrap-flash&lt;/b&gt; ([handler])&lt;br&gt; If a :flash key is set on the response by the handler, a :flash key with&lt;br&gt;  the same value will be set on the next request that shares the same session.&lt;br&gt;  This is useful for small messages that persist across redirects.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-flash&amp;lt;br&amp;gt;  &amp;quot;If a :flash key is set on the response by the handler, a :flash key with&amp;lt;br&amp;gt;  the same value will be set on the next request that shares the same session.&amp;lt;br&amp;gt;  This is useful for small messages that persist across redirects.&amp;quot;&amp;lt;br&amp;gt;  [handler]&amp;lt;br&amp;gt;  (fn [request]&amp;lt;br&amp;gt;    (let [session (:session request)&amp;lt;br&amp;gt;          flash   (:_flash session)&amp;lt;br&amp;gt;          session (dissoc session :_flash)&amp;lt;br&amp;gt;          request (assoc request :session session, :flash flash)]&amp;lt;br&amp;gt;      (if-let [response (handler request)]&amp;lt;br&amp;gt;        (let [session (if (contains? response :session)&amp;lt;br&amp;gt;                        (response :session)&amp;lt;br&amp;gt;                        session)&amp;lt;br&amp;gt;              session (if-let [flash (response :flash)]&amp;lt;br&amp;gt;                        (assoc (response :session session) :_flash flash)&amp;lt;br&amp;gt;                        session)]&amp;lt;br&amp;gt;          (if (or flash (response :flash) (contains? response :session))&amp;lt;br&amp;gt;            (assoc response :session session)&amp;lt;br&amp;gt;            response))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-flash</a>[handler]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.head</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.head&lt;/i&gt;&lt;b&gt;wrap-head&lt;/b&gt; ([handler])&lt;br&gt; Middleware that turns any HEAD request into a GET, and then sets the response&lt;br&gt;  body to nil.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-head&amp;lt;br&amp;gt;  &amp;quot;Middleware that turns any HEAD request into a GET, and then sets the response&amp;lt;br&amp;gt;  body to nil.&amp;quot;&amp;lt;br&amp;gt;  [handler]&amp;lt;br&amp;gt;  (fn [request]&amp;lt;br&amp;gt;    (if (= :head (:request-method request))&amp;lt;br&amp;gt;      (-&amp;gt; request&amp;lt;br&amp;gt;          (assoc :request-method :get)&amp;lt;br&amp;gt;          (handler)&amp;lt;br&amp;gt;          (assoc :body nil))&amp;lt;br&amp;gt;      (handler request))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-head</a>[handler]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.keyword-params</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.keyword-params&lt;/i&gt;&lt;b&gt;wrap-keyword-params&lt;/b&gt; ([handler])&lt;br&gt; Middleware that converts the string-keyed :params map to one with keyword&lt;br&gt;  keys before forwarding the request to the given handler.&lt;br&gt;  Does not alter the maps under :*-params keys; these are left with strings.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-keyword-params&amp;lt;br&amp;gt;  &amp;quot;Middleware that converts the string-keyed :params map to one with keyword&amp;lt;br&amp;gt;  keys before forwarding the request to the given handler.&amp;lt;br&amp;gt;  Does not alter the maps under :*-params keys; these are left with strings.&amp;quot;&amp;lt;br&amp;gt;  [handler]&amp;lt;br&amp;gt;  (fn [req]&amp;lt;br&amp;gt;    (handler (update-in req [:params] keyify-params))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-keyword-params</a>[handler]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.multipart-params</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.multipart-params&lt;/i&gt;&lt;b&gt;default-store&lt;/b&gt; ([])&lt;br&gt; Loads and returns a temporary file store.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn default-store&amp;lt;br&amp;gt;  &amp;quot;Loads and returns a temporary file store.&amp;quot;&amp;lt;br&amp;gt;  []&amp;lt;br&amp;gt;  (let [store 'ring.middleware.multipart-params.temp-file/temp-file-store&amp;lt;br&amp;gt;        func  (load-var store)]&amp;lt;br&amp;gt;    (func)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">default-store</a>[]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.multipart-params&lt;/i&gt;&lt;b&gt;wrap-multipart-params&lt;/b&gt; ([handler &amp; [opts]])&lt;br&gt; Middleware to parse multipart parameters from a request. Adds the&lt;br&gt;  following keys to the request map:&lt;br&gt;    :multipart-params - a map of multipart parameters&lt;br&gt;    :params           - a merged map of all types of parameter&lt;br&gt;&lt;br&gt;  This middleware takes an optional configuration map. Recognized keys are:&lt;br&gt;&lt;br&gt;    :encoding - character encoding to use for multipart parsing. If not&lt;br&gt;                specified, uses the request character encoding, or &quot;UTF-8&quot;&lt;br&gt;                if no request character encoding is set.&lt;br&gt;&lt;br&gt;    :store    - a function that stores a file upload. The function should&lt;br&gt;                expect a map with :filename, content-type and :stream keys,&lt;br&gt;                and its return value will be used as the value for the&lt;br&gt;                parameter in the multipart parameter map. The default storage&lt;br&gt;                function is the temp-file-store.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-multipart-params&amp;lt;br&amp;gt;  &amp;quot;Middleware to parse multipart parameters from a request. Adds the&amp;lt;br&amp;gt;  following keys to the request map:&amp;lt;br&amp;gt;    :multipart-params - a map of multipart parameters&amp;lt;br&amp;gt;    :params           - a merged map of all types of parameter&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  This middleware takes an optional configuration map. Recognized keys are:&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    :encoding - character encoding to use for multipart parsing. If not&amp;lt;br&amp;gt;                specified, uses the request character encoding, or \&amp;quot;UTF-8\&amp;quot;&amp;lt;br&amp;gt;                if no request character encoding is set.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    :store    - a function that stores a file upload. The function should&amp;lt;br&amp;gt;                expect a map with :filename, content-type and :stream keys,&amp;lt;br&amp;gt;                and its return value will be used as the value for the&amp;lt;br&amp;gt;                parameter in the multipart parameter map. The default storage&amp;lt;br&amp;gt;                function is the temp-file-store.&amp;quot;&amp;lt;br&amp;gt;  [handler &amp;amp; [opts]]&amp;lt;br&amp;gt;  (let [store (or (:store opts)&amp;lt;br&amp;gt;                  (default-store))]&amp;lt;br&amp;gt;    (fn [request]&amp;lt;br&amp;gt;      (let [encoding (or (:encoding opts)&amp;lt;br&amp;gt;                         (:character-encoding request)&amp;lt;br&amp;gt;                         &amp;quot;UTF-8&amp;quot;)&amp;lt;br&amp;gt;            params   (if (multipart-form? request)&amp;lt;br&amp;gt;                       (parse-multipart-params request encoding store)&amp;lt;br&amp;gt;                       {})&amp;lt;br&amp;gt;            request  (merge-with merge request&amp;lt;br&amp;gt;                                 {:multipart-params params}&amp;lt;br&amp;gt;                                 {:params params})]&amp;lt;br&amp;gt;        (handler request)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-multipart-params</a>[handler & [opts]]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.multipart-params.temp-file</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.multipart-params.temp-file&lt;/i&gt;&lt;b&gt;temp-file-store&lt;/b&gt; ([] [{:keys [expires-in]}])&lt;br&gt; Returns a function that stores multipart file parameters as temporary files.&lt;br&gt;  Accepts the following options:&lt;br&gt;    :expires-in - delete temporary files older than this many seconds&lt;br&gt;                  (defaults to 3600 - 1 hour)&lt;br&gt;  The multipart parameters will be stored as maps with the following keys:&lt;br&gt;    :filename     - the name of the uploaded file&lt;br&gt;    :content-type - the content type of the upload file&lt;br&gt;    :tempfile     - a File object that points to the temporary file containing&lt;br&gt;                    the uploaded data.&lt;br&gt;    :size         - the size in bytes of the uploaded data&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn temp-file-store&amp;lt;br&amp;gt;  &amp;quot;Returns a function that stores multipart file parameters as temporary files.&amp;lt;br&amp;gt;  Accepts the following options:&amp;lt;br&amp;gt;    :expires-in - delete temporary files older than this many seconds&amp;lt;br&amp;gt;                  (defaults to 3600 - 1 hour)&amp;lt;br&amp;gt;  The multipart parameters will be stored as maps with the following keys:&amp;lt;br&amp;gt;    :filename     - the name of the uploaded file&amp;lt;br&amp;gt;    :content-type - the content type of the upload file&amp;lt;br&amp;gt;    :tempfile     - a File object that points to the temporary file containing&amp;lt;br&amp;gt;                    the uploaded data.&amp;lt;br&amp;gt;    :size         - the size in bytes of the uploaded data&amp;quot;&amp;lt;br&amp;gt;  ([] (temp-file-store {:expires-in 3600}))&amp;lt;br&amp;gt;  ([{:keys [expires-in]}]&amp;lt;br&amp;gt;     (let [file-set (atom #{})&amp;lt;br&amp;gt;           clean-up (delay (start-clean-up file-set expires-in))]&amp;lt;br&amp;gt;       (fn [item]&amp;lt;br&amp;gt;         (force clean-up)&amp;lt;br&amp;gt;         (let [temp-file (make-temp-file file-set)]&amp;lt;br&amp;gt;           (io/copy (:stream item) temp-file)&amp;lt;br&amp;gt;           (-&amp;gt; (select-keys item [:filename :content-type])&amp;lt;br&amp;gt;               (assoc :tempfile temp-file&amp;lt;br&amp;gt;                      :size (.length temp-file))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">temp-file-store</a>[] [{:keys [expires-in]}]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.nested-params</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.nested-params&lt;/i&gt;&lt;b&gt;parse-nested-keys&lt;/b&gt; ([param-name])&lt;br&gt; Parse a parameter name into a list of keys using a 'C'-like index&lt;br&gt;  notation. e.g.&lt;br&gt;    &quot;foo[bar][][baz]&quot;&lt;br&gt;    =&gt; [&quot;foo&quot; &quot;bar&quot; &quot;&quot; &quot;baz&quot;]&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn parse-nested-keys&amp;lt;br&amp;gt;  &amp;quot;Parse a parameter name into a list of keys using a 'C'-like index&amp;lt;br&amp;gt;  notation. e.g.&amp;lt;br&amp;gt;    \&amp;quot;foo[bar][][baz]\&amp;quot;&amp;lt;br&amp;gt;    =&amp;gt; [\&amp;quot;foo\&amp;quot; \&amp;quot;bar\&amp;quot; \&amp;quot;\&amp;quot; \&amp;quot;baz\&amp;quot;]&amp;quot;&amp;lt;br&amp;gt;  [param-name]&amp;lt;br&amp;gt;  (let [[_ k ks] (re-matches #&amp;quot;(.*?)((?:\[.*?\])*)&amp;quot; (name param-name))&amp;lt;br&amp;gt;        keys     (if ks (map second (re-seq #&amp;quot;\[(.*?)\]&amp;quot; ks)))]&amp;lt;br&amp;gt;    (cons k keys)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">parse-nested-keys</a>[param-name]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.nested-params&lt;/i&gt;&lt;b&gt;wrap-nested-params&lt;/b&gt; ([handler &amp; [opts]])&lt;br&gt; Middleware to converts a flat map of parameters into a nested map.&lt;br&gt;&lt;br&gt;  Uses the function in the :key-parser option to convert parameter names&lt;br&gt;  to a list of keys. Values in keys that are empty strings are treated&lt;br&gt;  as elements in a list. Defaults to using the parse-nested-keys function.&lt;br&gt;&lt;br&gt;  e.g.&lt;br&gt;    {&quot;foo[bar]&quot; &quot;baz&quot;}&lt;br&gt;    =&gt; {&quot;foo&quot; {&quot;bar&quot; &quot;baz&quot;}}&lt;br&gt;&lt;br&gt;    {&quot;foo[]&quot; &quot;bar&quot;}&lt;br&gt;    =&gt; {&quot;foo&quot; [&quot;bar&quot;]}&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-nested-params&amp;lt;br&amp;gt;  &amp;quot;Middleware to converts a flat map of parameters into a nested map.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Uses the function in the :key-parser option to convert parameter names&amp;lt;br&amp;gt;  to a list of keys. Values in keys that are empty strings are treated&amp;lt;br&amp;gt;  as elements in a list. Defaults to using the parse-nested-keys function.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  e.g.&amp;lt;br&amp;gt;    {\&amp;quot;foo[bar]\&amp;quot; \&amp;quot;baz\&amp;quot;}&amp;lt;br&amp;gt;    =&amp;gt; {\&amp;quot;foo\&amp;quot; {\&amp;quot;bar\&amp;quot; \&amp;quot;baz\&amp;quot;}}&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;    {\&amp;quot;foo[]\&amp;quot; \&amp;quot;bar\&amp;quot;}&amp;lt;br&amp;gt;    =&amp;gt; {\&amp;quot;foo\&amp;quot; [\&amp;quot;bar\&amp;quot;]}&amp;quot;&amp;lt;br&amp;gt;  [handler &amp;amp; [opts]]&amp;lt;br&amp;gt;  (fn [request]&amp;lt;br&amp;gt;    (let [parse   (:key-parser opts parse-nested-keys)&amp;lt;br&amp;gt;          request (update-in request [:params] nest-params parse)]&amp;lt;br&amp;gt;      (handler request))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-nested-params</a>[handler & [opts]]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.params</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.params&lt;/i&gt;&lt;b&gt;wrap-params&lt;/b&gt; ([handler &amp; [opts]])&lt;br&gt; Middleware to parse urlencoded parameters from the query string and form&lt;br&gt;  body (if the request is a urlencoded form). Adds the following keys to&lt;br&gt;  the request map:&lt;br&gt;    :query-params - a map of parameters from the query string&lt;br&gt;    :form-params  - a map of parameters from the body&lt;br&gt;    :params       - a merged map of all types of parameter&lt;br&gt;  Takes an optional configuration map. Recognized keys are:&lt;br&gt;    :encoding - encoding to use for url-decoding. If not specified, uses&lt;br&gt;                the request character encoding, or &quot;UTF-8&quot; if no request&lt;br&gt;                character encoding is set.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-params&amp;lt;br&amp;gt;  &amp;quot;Middleware to parse urlencoded parameters from the query string and form&amp;lt;br&amp;gt;  body (if the request is a urlencoded form). Adds the following keys to&amp;lt;br&amp;gt;  the request map:&amp;lt;br&amp;gt;    :query-params - a map of parameters from the query string&amp;lt;br&amp;gt;    :form-params  - a map of parameters from the body&amp;lt;br&amp;gt;    :params       - a merged map of all types of parameter&amp;lt;br&amp;gt;  Takes an optional configuration map. Recognized keys are:&amp;lt;br&amp;gt;    :encoding - encoding to use for url-decoding. If not specified, uses&amp;lt;br&amp;gt;                the request character encoding, or \&amp;quot;UTF-8\&amp;quot; if no request&amp;lt;br&amp;gt;                character encoding is set.&amp;quot;&amp;lt;br&amp;gt;  [handler &amp;amp; [opts]]&amp;lt;br&amp;gt;  (fn [request]&amp;lt;br&amp;gt;    (let [encoding (or (:encoding opts)&amp;lt;br&amp;gt;                       (:character-encoding request)&amp;lt;br&amp;gt;                       &amp;quot;UTF-8&amp;quot;)&amp;lt;br&amp;gt;          request  (if (:form-params request)&amp;lt;br&amp;gt;                     request&amp;lt;br&amp;gt;                     (assoc-form-params request encoding))&amp;lt;br&amp;gt;          request  (if (:query-params request)&amp;lt;br&amp;gt;                     request&amp;lt;br&amp;gt;                     (assoc-query-params request encoding))]&amp;lt;br&amp;gt;      (handler request))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-params</a>[handler & [opts]]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.refresh</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.refresh&lt;/i&gt;&lt;b&gt;as-str&lt;/b&gt; ([x])&lt;br&gt; &lt;/div&gt;" data-placement="right">as-str</a>[x]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.refresh&lt;/i&gt;&lt;b&gt;wrap-refresh&lt;/b&gt; ([handler] [handler dirs])&lt;br&gt; Injects Javascript into HTML responses which automatically refreshes the&lt;br&gt;  browser when any file in the supplied directories is modified. Only successful&lt;br&gt;  responses from GET requests are affected. The default directories are 'src'&lt;br&gt;  and 'resources'.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-refresh&amp;lt;br&amp;gt;  &amp;quot;Injects Javascript into HTML responses which automatically refreshes the&amp;lt;br&amp;gt;  browser when any file in the supplied directories is modified. Only successful&amp;lt;br&amp;gt;  responses from GET requests are affected. The default directories are 'src'&amp;lt;br&amp;gt;  and 'resources'.&amp;quot;&amp;lt;br&amp;gt;  ([handler]&amp;lt;br&amp;gt;     (wrap-refresh handler [&amp;quot;src&amp;quot; &amp;quot;resources&amp;quot;]))&amp;lt;br&amp;gt;  ([handler dirs]&amp;lt;br&amp;gt;     (watch-dirs! dirs)&amp;lt;br&amp;gt;     (wrap-params&amp;lt;br&amp;gt;      (routes&amp;lt;br&amp;gt;       source-changed-route&amp;lt;br&amp;gt;       (wrap-with-script handler refresh-script)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-refresh</a>[handler] [handler dirs]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.reload</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.reload&lt;/i&gt;&lt;b&gt;wrap-reload&lt;/b&gt; ([handler &amp; [options]])&lt;br&gt; Reload namespaces of modified files before the request is passed to the&lt;br&gt;  supplied handler.&lt;br&gt;&lt;br&gt;  Takes the following options:&lt;br&gt;    :dirs - A list of directories that contain the source files.&lt;br&gt;            Defaults to [&quot;src&quot;].&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-reload&amp;lt;br&amp;gt;  &amp;quot;Reload namespaces of modified files before the request is passed to the&amp;lt;br&amp;gt;  supplied handler.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Takes the following options:&amp;lt;br&amp;gt;    :dirs - A list of directories that contain the source files.&amp;lt;br&amp;gt;            Defaults to [\&amp;quot;src\&amp;quot;].&amp;quot;&amp;lt;br&amp;gt;  [handler &amp;amp; [options]]&amp;lt;br&amp;gt;  (let [source-dirs (:dirs options [&amp;quot;src&amp;quot;])&amp;lt;br&amp;gt;        modified-namespaces (ns-tracker source-dirs)]&amp;lt;br&amp;gt;    (fn [request]&amp;lt;br&amp;gt;      (doseq [ns-sym (modified-namespaces)]&amp;lt;br&amp;gt;        (require ns-sym :reload))&amp;lt;br&amp;gt;      (handler request))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-reload</a>[handler & [options]]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.session</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.session&lt;/i&gt;&lt;b&gt;wrap-session&lt;/b&gt; ([handler] [handler options])&lt;br&gt; Reads in the current HTTP session map, and adds it to the :session key on&lt;br&gt;  the request. If a :session key is added to the response by the handler, the&lt;br&gt;  session is updated with the new value. If the value is nil, the session is&lt;br&gt;  deleted.&lt;br&gt;&lt;br&gt;  The following options are available:&lt;br&gt;    :store&lt;br&gt;      An implementation of the SessionStore protocol in the&lt;br&gt;      ring.middleware.session.store namespace. This determines how the&lt;br&gt;      session is stored. Defaults to in-memory storage&lt;br&gt;      (ring.middleware.session.store.MemoryStore).&lt;br&gt;    :root&lt;br&gt;      The root path of the session. Any path above this will not be able to&lt;br&gt;      see this session. Equivalent to setting the cookie's path attribute.&lt;br&gt;      Defaults to &quot;/&quot;.&lt;br&gt;    :cookie-name&lt;br&gt;      The name of the cookie that holds the session key. Defaults to&lt;br&gt;      &quot;ring-session&quot;&lt;br&gt;    :cookie-attrs&lt;br&gt;      A map of attributes to associate with the session cookie. Defaults&lt;br&gt;      to {}.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-session&amp;lt;br&amp;gt;  &amp;quot;Reads in the current HTTP session map, and adds it to the :session key on&amp;lt;br&amp;gt;  the request. If a :session key is added to the response by the handler, the&amp;lt;br&amp;gt;  session is updated with the new value. If the value is nil, the session is&amp;lt;br&amp;gt;  deleted.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  The following options are available:&amp;lt;br&amp;gt;    :store&amp;lt;br&amp;gt;      An implementation of the SessionStore protocol in the&amp;lt;br&amp;gt;      ring.middleware.session.store namespace. This determines how the&amp;lt;br&amp;gt;      session is stored. Defaults to in-memory storage&amp;lt;br&amp;gt;      (ring.middleware.session.store.MemoryStore).&amp;lt;br&amp;gt;    :root&amp;lt;br&amp;gt;      The root path of the session. Any path above this will not be able to&amp;lt;br&amp;gt;      see this session. Equivalent to setting the cookie's path attribute.&amp;lt;br&amp;gt;      Defaults to \&amp;quot;/\&amp;quot;.&amp;lt;br&amp;gt;    :cookie-name&amp;lt;br&amp;gt;      The name of the cookie that holds the session key. Defaults to&amp;lt;br&amp;gt;      \&amp;quot;ring-session\&amp;quot;&amp;lt;br&amp;gt;    :cookie-attrs&amp;lt;br&amp;gt;      A map of attributes to associate with the session cookie. Defaults&amp;lt;br&amp;gt;      to {}.&amp;quot;&amp;lt;br&amp;gt;  ([handler]&amp;lt;br&amp;gt;    (wrap-session handler {}))&amp;lt;br&amp;gt;  ([handler options]&amp;lt;br&amp;gt;     (let [store        (options :store (memory-store))&amp;lt;br&amp;gt;           cookie-name  (options :cookie-name &amp;quot;ring-session&amp;quot;)&amp;lt;br&amp;gt;           cookie-attrs (merge {:path &amp;quot;/&amp;quot;}&amp;lt;br&amp;gt;                               (options :cookie-attrs)&amp;lt;br&amp;gt;                               (if-let [root (options :root)]&amp;lt;br&amp;gt;                                 {:path root}))]&amp;lt;br&amp;gt;      (wrap-cookies&amp;lt;br&amp;gt;        (fn [request]&amp;lt;br&amp;gt;          (let [req-key  (get-in request [:cookies cookie-name :value])&amp;lt;br&amp;gt;                session  (read-session store req-key)&amp;lt;br&amp;gt;                sess-key (if session req-key)&amp;lt;br&amp;gt;                request  (assoc request :session (or session {}))]&amp;lt;br&amp;gt;            (if-let [response (handler request)]&amp;lt;br&amp;gt;              (let [sess-key* (if (contains? response :session)&amp;lt;br&amp;gt;                                (if-let [session (response :session)]&amp;lt;br&amp;gt;                                  (write-session store sess-key session)&amp;lt;br&amp;gt;                                  (if sess-key&amp;lt;br&amp;gt;                                    (delete-session store sess-key))))&amp;lt;br&amp;gt;                    response (dissoc response :session)&amp;lt;br&amp;gt;                    cookie   {cookie-name&amp;lt;br&amp;gt;                              (merge cookie-attrs&amp;lt;br&amp;gt;                                     (response :session-cookie-attrs)&amp;lt;br&amp;gt;                                     {:value sess-key*})}]&amp;lt;br&amp;gt;                (if (and sess-key* (not= sess-key sess-key*))&amp;lt;br&amp;gt;                  (assoc response :cookies (merge (response :cookies) cookie))&amp;lt;br&amp;gt;                  response)))))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-session</a>[handler] [handler options]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.session.memory</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.session.memory&lt;/i&gt;&lt;b&gt;-&gt;MemoryStore&lt;/b&gt; ([session-map])&lt;br&gt; Positional factory function for class ring.middleware.session.memory.MemoryStore.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(deftype MemoryStore [session-map]&amp;lt;br&amp;gt;  SessionStore&amp;lt;br&amp;gt;  (read-session [_ key]&amp;lt;br&amp;gt;    (@session-map key))&amp;lt;br&amp;gt;  (write-session [_ key data]&amp;lt;br&amp;gt;    (let [key (or key (str (UUID/randomUUID)))]&amp;lt;br&amp;gt;      (swap! session-map assoc key data)&amp;lt;br&amp;gt;      key))&amp;lt;br&amp;gt;  (delete-session [_ key]&amp;lt;br&amp;gt;    (swap! session-map dissoc key)&amp;lt;br&amp;gt;    nil))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">->MemoryStore</a>[session-map]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.session.memory&lt;/i&gt;&lt;b&gt;memory-store&lt;/b&gt; ([] [session-atom])&lt;br&gt; Creates an in-memory session storage engine.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn memory-store&amp;lt;br&amp;gt;  &amp;quot;Creates an in-memory session storage engine.&amp;quot;&amp;lt;br&amp;gt;  ([] (memory-store (atom {})))&amp;lt;br&amp;gt;  ([session-atom] (MemoryStore. session-atom)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">memory-store</a>[] [session-atom]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.session.store</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.session.store&lt;/i&gt;&lt;b&gt;delete-session&lt;/b&gt; ([store key])&lt;br&gt; Delete a session map from the store, and returns the session key. If the&lt;br&gt;    returned key is nil, the session cookie will be removed.&lt;/div&gt;" data-placement="right">delete-session</a>[store key]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.session.store&lt;/i&gt;&lt;b&gt;read-session&lt;/b&gt; ([store key])&lt;br&gt; Read a session map from the store. If the key is not found, an empty map&lt;br&gt;    is returned.&lt;/div&gt;" data-placement="right">read-session</a>[store key]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.session.store&lt;/i&gt;&lt;b&gt;write-session&lt;/b&gt; ([store key data])&lt;br&gt; Write a session map to the store. Returns the (possibly changed) key under&lt;br&gt;    which the data was stored. If the key is nil, the session is considered&lt;br&gt;    to be new, and a fresh key should be generated.&lt;/div&gt;" data-placement="right">write-session</a>[store key data]</div></div></div><div class="row"><div class="namespace"><h4>ring.middleware.stacktrace</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.stacktrace&lt;/i&gt;&lt;b&gt;wrap-stacktrace&lt;/b&gt; ([handler])&lt;br&gt; Wrap a handler such that exceptions are caught, a corresponding stacktrace is&lt;br&gt;  logged to *err*, and a helpful debugging web response is returned.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-stacktrace&amp;lt;br&amp;gt;  &amp;quot;Wrap a handler such that exceptions are caught, a corresponding stacktrace is&amp;lt;br&amp;gt;  logged to *err*, and a helpful debugging web response is returned.&amp;quot;&amp;lt;br&amp;gt;  [handler]&amp;lt;br&amp;gt;  (-&amp;gt; handler&amp;lt;br&amp;gt;      wrap-stacktrace-log&amp;lt;br&amp;gt;      wrap-stacktrace-web))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-stacktrace</a>[handler]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.stacktrace&lt;/i&gt;&lt;b&gt;wrap-stacktrace-log&lt;/b&gt; ([handler])&lt;br&gt; Wrap a handler such that exceptions are logged to *err* and then rethrown.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-stacktrace-log&amp;lt;br&amp;gt;  &amp;quot;Wrap a handler such that exceptions are logged to *err* and then rethrown.&amp;quot;&amp;lt;br&amp;gt;  [handler]&amp;lt;br&amp;gt;  (fn [request]&amp;lt;br&amp;gt;    (try&amp;lt;br&amp;gt;      (handler request)&amp;lt;br&amp;gt;      (catch Exception ex&amp;lt;br&amp;gt;        (let [msg (str &amp;quot;Exception: &amp;quot; (pst-str ex))]&amp;lt;br&amp;gt;          (.println *err* msg)&amp;lt;br&amp;gt;          (throw ex))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-stacktrace-log</a>[handler]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.middleware.stacktrace&lt;/i&gt;&lt;b&gt;wrap-stacktrace-web&lt;/b&gt; ([handler])&lt;br&gt; Wrap a handler such that exceptions are caught and a helpful debugging&lt;br&gt;   response is returned.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn wrap-stacktrace-web&amp;lt;br&amp;gt;  &amp;quot;Wrap a handler such that exceptions are caught and a helpful debugging&amp;lt;br&amp;gt;   response is returned.&amp;quot;&amp;lt;br&amp;gt;  [handler]&amp;lt;br&amp;gt;  (fn [request]&amp;lt;br&amp;gt;    (try&amp;lt;br&amp;gt;      (handler request)&amp;lt;br&amp;gt;      (catch Exception ex&amp;lt;br&amp;gt;        (ex-response request ex)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">wrap-stacktrace-web</a>[handler]</div></div></div><div class="row"><div class="namespace"><h4>ring.mock.request</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.mock.request&lt;/i&gt;&lt;b&gt;body&lt;/b&gt; ([request body-value])&lt;br&gt; Set the body of the request. The supplied body value can be a string or&lt;br&gt;  a map of parameters to be url-encoded.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmulti body&amp;lt;br&amp;gt;  &amp;quot;Set the body of the request. The supplied body value can be a string or&amp;lt;br&amp;gt;  a map of parameters to be url-encoded.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([request body-value])}&amp;lt;br&amp;gt;  (fn [request x] (type x)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">body</a>[request body-value]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.mock.request&lt;/i&gt;&lt;b&gt;content-length&lt;/b&gt; ([request length])&lt;br&gt; Set the content length of the request map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn content-length&amp;lt;br&amp;gt;  &amp;quot;Set the content length of the request map.&amp;quot;&amp;lt;br&amp;gt;  [request length]&amp;lt;br&amp;gt;  (-&amp;gt; request&amp;lt;br&amp;gt;      (assoc :content-length length)&amp;lt;br&amp;gt;      (header :content-length length)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">content-length</a>[request length]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.mock.request&lt;/i&gt;&lt;b&gt;content-type&lt;/b&gt; ([request mime-type])&lt;br&gt; Set the content type of the request map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn content-type&amp;lt;br&amp;gt;  &amp;quot;Set the content type of the request map.&amp;quot;&amp;lt;br&amp;gt;  [request mime-type]&amp;lt;br&amp;gt;  (-&amp;gt; request&amp;lt;br&amp;gt;      (assoc :content-type mime-type)&amp;lt;br&amp;gt;      (header :content-type mime-type)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">content-type</a>[request mime-type]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.mock.request&lt;/i&gt;&lt;b&gt;header&lt;/b&gt; ([request header value])&lt;br&gt; Add a HTTP header to the request map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn header&amp;lt;br&amp;gt;  &amp;quot;Add a HTTP header to the request map.&amp;quot;&amp;lt;br&amp;gt;  [request header value]&amp;lt;br&amp;gt;  (let [header (string/lower-case (name header))]&amp;lt;br&amp;gt;    (assoc-in request [:headers header] (str value))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">header</a>[request header value]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.mock.request&lt;/i&gt;&lt;b&gt;query-string&lt;/b&gt; ([request params])&lt;br&gt; Set the query string of the request to a string or a map of parameters.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn query-string&amp;lt;br&amp;gt;  &amp;quot;Set the query string of the request to a string or a map of parameters.&amp;quot;&amp;lt;br&amp;gt;  [request params]&amp;lt;br&amp;gt;  (if (map? params)&amp;lt;br&amp;gt;    (assoc request :query-string (encode-params params))&amp;lt;br&amp;gt;    (assoc request :query-string params)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">query-string</a>[request params]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.mock.request&lt;/i&gt;&lt;b&gt;request&lt;/b&gt; ([method uri] [method uri params])&lt;br&gt; Create a minimal valid request map from a HTTP method keyword, a string&lt;br&gt;  containing a URI, and an optional map of parameters that will be added to&lt;br&gt;  the query string of the URI. The URI can be relative or absolute. Relative&lt;br&gt;  URIs are assumed to go to http://localhost.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn request&amp;lt;br&amp;gt;  &amp;quot;Create a minimal valid request map from a HTTP method keyword, a string&amp;lt;br&amp;gt;  containing a URI, and an optional map of parameters that will be added to&amp;lt;br&amp;gt;  the query string of the URI. The URI can be relative or absolute. Relative&amp;lt;br&amp;gt;  URIs are assumed to go to http://localhost.&amp;quot;&amp;lt;br&amp;gt;  ([method uri]&amp;lt;br&amp;gt;     (request method uri nil))&amp;lt;br&amp;gt;  ([method uri params]&amp;lt;br&amp;gt;     (let [uri    (URI. uri)&amp;lt;br&amp;gt;           host   (or (.getHost uri) &amp;quot;localhost&amp;quot;)&amp;lt;br&amp;gt;           port   (if (not= (.getPort uri) -1) (.getPort uri))&amp;lt;br&amp;gt;           scheme (.getScheme uri)&amp;lt;br&amp;gt;           path   (.getRawPath uri)&amp;lt;br&amp;gt;           query  (.getRawQuery uri)&amp;lt;br&amp;gt;           request {:server-port    (or port 80)&amp;lt;br&amp;gt;                    :server-name    host&amp;lt;br&amp;gt;                    :remote-addr    &amp;quot;localhost&amp;quot;&amp;lt;br&amp;gt;                    :uri            (if (string/blank? path) &amp;quot;/&amp;quot; path)&amp;lt;br&amp;gt;                    :query-string   query&amp;lt;br&amp;gt;                    :scheme         (or (keyword scheme) :http)&amp;lt;br&amp;gt;                    :request-method method&amp;lt;br&amp;gt;                    :headers        {&amp;quot;host&amp;quot; (if port&amp;lt;br&amp;gt;                                              (str host &amp;quot;:&amp;quot; port)&amp;lt;br&amp;gt;                                              host)}}]&amp;lt;br&amp;gt;       (if (#{:get :head} method)&amp;lt;br&amp;gt;         (merge-query request params)&amp;lt;br&amp;gt;         (body request params)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">request</a>[method uri] [method uri params]</div></div></div><div class="row"><div class="namespace"><h4>ring.server.leiningen</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.server.leiningen&lt;/i&gt;&lt;b&gt;serve&lt;/b&gt; ([project])&lt;br&gt; Start a server from a Leiningen project map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn serve&amp;lt;br&amp;gt;  &amp;quot;Start a server from a Leiningen project map.&amp;quot;&amp;lt;br&amp;gt;  [project]&amp;lt;br&amp;gt;  (standalone/serve&amp;lt;br&amp;gt;   (load-var (-&amp;gt; project :ring :handler))&amp;lt;br&amp;gt;   (merge&amp;lt;br&amp;gt;    {:join? true}&amp;lt;br&amp;gt;    (:ring project)&amp;lt;br&amp;gt;    (-&amp;gt; project :ring :adapter)&amp;lt;br&amp;gt;    {:init    (load-var (-&amp;gt; project :ring :init))&amp;lt;br&amp;gt;     :destroy (load-var (-&amp;gt; project :ring :destroy))})))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">serve</a>[project]</div></div></div><div class="row"><div class="namespace"><h4>ring.server.options</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.server.options&lt;/i&gt;&lt;b&gt;auto-reload?&lt;/b&gt; ([options])&lt;br&gt; True if the source files should be automatically reloaded.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn auto-reload?&amp;lt;br&amp;gt;  &amp;quot;True if the source files should be automatically reloaded.&amp;quot;&amp;lt;br&amp;gt;  [options]&amp;lt;br&amp;gt;  (:auto-reload? options dev-env?))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">auto-reload?</a>[options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.server.options&lt;/i&gt;&lt;b&gt;browser-uri&lt;/b&gt; ([options])&lt;br&gt; The path to browse to when opening a browser&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn browser-uri&amp;lt;br&amp;gt;  &amp;quot;The path to browse to when opening a browser&amp;quot;&amp;lt;br&amp;gt;  [options]&amp;lt;br&amp;gt;  (-&amp;gt; (str &amp;quot;/&amp;quot; (:browser-uri options))&amp;lt;br&amp;gt;      (str/replace #&amp;quot;^/+&amp;quot; &amp;quot;/&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">browser-uri</a>[options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.server.options&lt;/i&gt;&lt;b&gt;open-browser?&lt;/b&gt; ([options])&lt;br&gt; True if a browser should be opened to view the web server. By default&lt;br&gt;  a browser is opened unless the LEIN_NO_DEV environment variable is set.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn open-browser?&amp;lt;br&amp;gt;  &amp;quot;True if a browser should be opened to view the web server. By default&amp;lt;br&amp;gt;  a browser is opened unless the LEIN_NO_DEV environment variable is set.&amp;quot;&amp;lt;br&amp;gt;  [options]&amp;lt;br&amp;gt;  (:open-browser? options dev-env?))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">open-browser?</a>[options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.server.options&lt;/i&gt;&lt;b&gt;port&lt;/b&gt; ([options])&lt;br&gt; Find the port or list of ports specified in the options or environment.&lt;br&gt;  Defaults to a range of ports from 3000 to 3010.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn port&amp;lt;br&amp;gt;  &amp;quot;Find the port or list of ports specified in the options or environment.&amp;lt;br&amp;gt;  Defaults to a range of ports from 3000 to 3010.&amp;quot;&amp;lt;br&amp;gt;  [options]&amp;lt;br&amp;gt;  (or (:port options)&amp;lt;br&amp;gt;      (-?&amp;gt; (*env* &amp;quot;PORT&amp;quot;) Integer.)&amp;lt;br&amp;gt;      (range 3000 3010)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">port</a>[options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.server.options&lt;/i&gt;&lt;b&gt;reload-paths&lt;/b&gt; ([options])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn reload-paths &amp;lt;br&amp;gt;  [options]&amp;lt;br&amp;gt;  (:reload-paths options [&amp;quot;src&amp;quot;]))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">reload-paths</a>[options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.server.options&lt;/i&gt;&lt;b&gt;stacktraces?&lt;/b&gt; ([options])&lt;br&gt; True if stacktraces should be shown for exceptions raised by the handler.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn stacktraces?&amp;lt;br&amp;gt;  &amp;quot;True if stacktraces should be shown for exceptions raised by the handler.&amp;quot;&amp;lt;br&amp;gt;  [options]&amp;lt;br&amp;gt;  (:stacktraces? options dev-env?))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">stacktraces?</a>[options]</div></div></div><div class="row"><div class="namespace"><h4>ring.server.standalone</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.server.standalone&lt;/i&gt;&lt;b&gt;serve&lt;/b&gt; ([handler] [handler options])&lt;br&gt; Start a web server to run a handler. Takes the following options:&lt;br&gt;    :port          - the port to run the server on&lt;br&gt;    :join?         - if true, wait for the server to stop&lt;br&gt;    :init          - a function to run before the server starts&lt;br&gt;    :destroy       - a function to run after the server stops&lt;br&gt;    :open-browser? - if true, open a web browser after the server starts&lt;br&gt;    :browser-uri   - the path to browse to when opening a browser&lt;br&gt;    :stacktraces?  - if true, display stacktraces when an exception is thrown&lt;br&gt;    :auto-reload?  - if true, automatically reload source files&lt;br&gt;    :reload-paths  - seq of src-paths to reload on change - defaults to [&quot;src&quot;]    &lt;br&gt;    :auto-refresh? - if true, automatically refresh browser when source changes&lt;br&gt;&lt;br&gt;  If join? is false, a Server object is returned.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn serve&amp;lt;br&amp;gt;  &amp;quot;Start a web server to run a handler. Takes the following options:&amp;lt;br&amp;gt;    :port          - the port to run the server on&amp;lt;br&amp;gt;    :join?         - if true, wait for the server to stop&amp;lt;br&amp;gt;    :init          - a function to run before the server starts&amp;lt;br&amp;gt;    :destroy       - a function to run after the server stops&amp;lt;br&amp;gt;    :open-browser? - if true, open a web browser after the server starts&amp;lt;br&amp;gt;    :browser-uri   - the path to browse to when opening a browser&amp;lt;br&amp;gt;    :stacktraces?  - if true, display stacktraces when an exception is thrown&amp;lt;br&amp;gt;    :auto-reload?  - if true, automatically reload source files&amp;lt;br&amp;gt;    :reload-paths  - seq of src-paths to reload on change - defaults to [\&amp;quot;src\&amp;quot;]    &amp;lt;br&amp;gt;    :auto-refresh? - if true, automatically refresh browser when source changes&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  If join? is false, a Server object is returned.&amp;quot;&amp;lt;br&amp;gt;  {:arglists '([handler] [handler options])}&amp;lt;br&amp;gt;  [handler &amp;amp; [{:keys [init destroy join?] :as options}]]&amp;lt;br&amp;gt;  (let [options (assoc options :join? false)&amp;lt;br&amp;gt;        destroy (if destroy (memoize destroy))&amp;lt;br&amp;gt;        handler (add-middleware handler options)]&amp;lt;br&amp;gt;    (if init (init))&amp;lt;br&amp;gt;    (if destroy&amp;lt;br&amp;gt;      (. (Runtime/getRuntime)&amp;lt;br&amp;gt;         (addShutdownHook (Thread. destroy))))&amp;lt;br&amp;gt;    (try-port (port options)&amp;lt;br&amp;gt;      (fn [port]&amp;lt;br&amp;gt;        (let [options (merge {:port port} options)&amp;lt;br&amp;gt;              server  (run-jetty handler options)&amp;lt;br&amp;gt;              thread  (add-destroy-hook server destroy)]&amp;lt;br&amp;gt;          (println &amp;quot;Started server on port&amp;quot; (server-port server))&amp;lt;br&amp;gt;          (if (open-browser? options)&amp;lt;br&amp;gt;            (open-browser-to server options))&amp;lt;br&amp;gt;          (if join?&amp;lt;br&amp;gt;            (.join thread))&amp;lt;br&amp;gt;          server)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">serve</a>[handler] [handler options]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.server.standalone&lt;/i&gt;&lt;b&gt;server-host&lt;/b&gt; ([server])&lt;br&gt; Get the host the server is bound to.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn server-host&amp;lt;br&amp;gt;  &amp;quot;Get the host the server is bound to.&amp;quot;&amp;lt;br&amp;gt;  [server]&amp;lt;br&amp;gt;  (-&amp;gt; (.getConnectors server)&amp;lt;br&amp;gt;      (first)&amp;lt;br&amp;gt;      (.getHost)&amp;lt;br&amp;gt;      (or &amp;quot;localhost&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">server-host</a>[server]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.server.standalone&lt;/i&gt;&lt;b&gt;server-port&lt;/b&gt; ([server])&lt;br&gt; Get the port the server is listening on.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn server-port&amp;lt;br&amp;gt;  &amp;quot;Get the port the server is listening on.&amp;quot;&amp;lt;br&amp;gt;  [server]&amp;lt;br&amp;gt;  (-&amp;gt; (.getConnectors server)&amp;lt;br&amp;gt;      (first)&amp;lt;br&amp;gt;      (.getPort)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">server-port</a>[server]</div></div></div><div class="row"><div class="namespace"><h4>ring.util.codec</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.codec&lt;/i&gt;&lt;b&gt;base64-decode&lt;/b&gt; ([encoded])&lt;br&gt; Decode a base64 encoded string into an array of bytes.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn base64-decode&amp;lt;br&amp;gt;  &amp;quot;Decode a base64 encoded string into an array of bytes.&amp;quot;&amp;lt;br&amp;gt;  [^String encoded]&amp;lt;br&amp;gt;  (Base64/decodeBase64 (.getBytes encoded)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">base64-decode</a>[encoded]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.codec&lt;/i&gt;&lt;b&gt;base64-encode&lt;/b&gt; ([unencoded])&lt;br&gt; Encode an array of bytes into a base64 encoded string.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn base64-encode&amp;lt;br&amp;gt;  &amp;quot;Encode an array of bytes into a base64 encoded string.&amp;quot;&amp;lt;br&amp;gt;  [unencoded]&amp;lt;br&amp;gt;  (String. (Base64/encodeBase64 unencoded)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">base64-encode</a>[unencoded]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.codec&lt;/i&gt;&lt;b&gt;form-decode&lt;/b&gt; ([encoded &amp; [encoding]])&lt;br&gt; Decode the supplied www-form-urlencoded string using the specified encoding,&lt;br&gt;  or UTF-8 by default. If the encoded value is a string, a string is returned.&lt;br&gt;  If the encoded value is a map of parameters, a map is returned.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn form-decode&amp;lt;br&amp;gt;  &amp;quot;Decode the supplied www-form-urlencoded string using the specified encoding,&amp;lt;br&amp;gt;  or UTF-8 by default. If the encoded value is a string, a string is returned.&amp;lt;br&amp;gt;  If the encoded value is a map of parameters, a map is returned.&amp;quot;&amp;lt;br&amp;gt;  [encoded &amp;amp; [encoding]]&amp;lt;br&amp;gt;  (if-not (.contains encoded &amp;quot;=&amp;quot;)&amp;lt;br&amp;gt;    (form-decode-str encoded encoding)&amp;lt;br&amp;gt;    (reduce&amp;lt;br&amp;gt;     (fn [m param]&amp;lt;br&amp;gt;       (if-let [[k v] (str/split param #&amp;quot;=&amp;quot; 2)]&amp;lt;br&amp;gt;         (assoc-conj m (form-decode-str k encoding) (form-decode-str v encoding))&amp;lt;br&amp;gt;         m))&amp;lt;br&amp;gt;     {}&amp;lt;br&amp;gt;     (str/split encoded #&amp;quot;&amp;amp;&amp;quot;))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">form-decode</a>[encoded & [encoding]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.codec&lt;/i&gt;&lt;b&gt;form-decode-str&lt;/b&gt; ([encoded &amp; [encoding]])&lt;br&gt; Decode the supplied www-form-urlencoded string using the specified encoding,&lt;br&gt;  or UTF-8 by default.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn form-decode-str&amp;lt;br&amp;gt;  &amp;quot;Decode the supplied www-form-urlencoded string using the specified encoding,&amp;lt;br&amp;gt;  or UTF-8 by default.&amp;quot;&amp;lt;br&amp;gt;  [^String encoded &amp;amp; [encoding]]&amp;lt;br&amp;gt;  (try&amp;lt;br&amp;gt;    (URLDecoder/decode encoded (or encoding &amp;quot;UTF-8&amp;quot;))&amp;lt;br&amp;gt;    (catch Exception _ nil)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">form-decode-str</a>[encoded & [encoding]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.codec&lt;/i&gt;&lt;b&gt;form-encode&lt;/b&gt; ([x &amp; [encoding]])&lt;br&gt; Encode the supplied value into www-form-urlencoded format, often used in&lt;br&gt;  URL query strings and POST request bodies, using the specified encoding.&lt;br&gt;  If the encoding is not specified, it defaults to UTF-8&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn form-encode&amp;lt;br&amp;gt;  &amp;quot;Encode the supplied value into www-form-urlencoded format, often used in&amp;lt;br&amp;gt;  URL query strings and POST request bodies, using the specified encoding.&amp;lt;br&amp;gt;  If the encoding is not specified, it defaults to UTF-8&amp;quot;&amp;lt;br&amp;gt;  [x &amp;amp; [encoding]]&amp;lt;br&amp;gt;  (form-encode* x (or encoding &amp;quot;UTF-8&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">form-encode</a>[x & [encoding]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.codec&lt;/i&gt;&lt;b&gt;form-encode*&lt;/b&gt; ([x encoding])&lt;br&gt; &lt;/div&gt;" data-placement="right">form-encode*</a>[x encoding]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.codec&lt;/i&gt;&lt;b&gt;percent-decode&lt;/b&gt; ([encoded &amp; [encoding]])&lt;br&gt; Decode every percent-encoded character in the given string using the&lt;br&gt;  specified encoding, or UTF-8 by default.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn percent-decode&amp;lt;br&amp;gt;  &amp;quot;Decode every percent-encoded character in the given string using the&amp;lt;br&amp;gt;  specified encoding, or UTF-8 by default.&amp;quot;&amp;lt;br&amp;gt;  [encoded &amp;amp; [encoding]]&amp;lt;br&amp;gt;  (str/replace encoded&amp;lt;br&amp;gt;               #&amp;quot;(?:%..)+&amp;quot;&amp;lt;br&amp;gt;               (fn [chars]&amp;lt;br&amp;gt;                 (-&amp;gt; (parse-bytes chars)&amp;lt;br&amp;gt;                     (String. (or encoding &amp;quot;UTF-8&amp;quot;))&amp;lt;br&amp;gt;                     (double-escape)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">percent-decode</a>[encoded & [encoding]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.codec&lt;/i&gt;&lt;b&gt;percent-encode&lt;/b&gt; ([unencoded &amp; [encoding]])&lt;br&gt; Percent-encode every character in the given string using either the specified&lt;br&gt;  encoding, or UTF-8 by default.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn percent-encode&amp;lt;br&amp;gt;  &amp;quot;Percent-encode every character in the given string using either the specified&amp;lt;br&amp;gt;  encoding, or UTF-8 by default.&amp;quot;&amp;lt;br&amp;gt;  [unencoded &amp;amp; [encoding]]&amp;lt;br&amp;gt;  (-&amp;gt;&amp;gt; (.getBytes unencoded (or encoding &amp;quot;UTF-8&amp;quot;))&amp;lt;br&amp;gt;       (map (partial format &amp;quot;%%%02X&amp;quot;))&amp;lt;br&amp;gt;       (str/join)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">percent-encode</a>[unencoded & [encoding]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.codec&lt;/i&gt;&lt;b&gt;url-decode&lt;/b&gt; ([encoded &amp; [encoding]])&lt;br&gt; Returns the url-decoded version of the given string, using either a specified&lt;br&gt;  encoding or UTF-8 by default. If the encoding is invalid, nil is returned.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn url-decode&amp;lt;br&amp;gt;  &amp;quot;Returns the url-decoded version of the given string, using either a specified&amp;lt;br&amp;gt;  encoding or UTF-8 by default. If the encoding is invalid, nil is returned.&amp;quot;&amp;lt;br&amp;gt;  [encoded &amp;amp; [encoding]]&amp;lt;br&amp;gt;  (percent-decode encoded encoding))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">url-decode</a>[encoded & [encoding]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.codec&lt;/i&gt;&lt;b&gt;url-encode&lt;/b&gt; ([unencoded &amp; [encoding]])&lt;br&gt; Returns the url-encoded version of the given string, using either a specified&lt;br&gt;  encoding or UTF-8 by default.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn url-encode&amp;lt;br&amp;gt;  &amp;quot;Returns the url-encoded version of the given string, using either a specified&amp;lt;br&amp;gt;  encoding or UTF-8 by default.&amp;quot;&amp;lt;br&amp;gt;  [unencoded &amp;amp; [encoding]]&amp;lt;br&amp;gt;  (str/replace&amp;lt;br&amp;gt;    unencoded&amp;lt;br&amp;gt;    #&amp;quot;[^A-Za-z0-9_~.+-]+&amp;quot;&amp;lt;br&amp;gt;    #(double-escape (percent-encode % encoding))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">url-encode</a>[unencoded & [encoding]]</div></div></div><div class="row"><div class="namespace"><h4>ring.util.data</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.data&lt;/i&gt;&lt;b&gt;assoc-conj&lt;/b&gt; ([map key val])&lt;br&gt; Associate a key with a value in a map. If the key already exists in the map,&lt;br&gt;  a vector of values is associated with the key.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn assoc-conj&amp;lt;br&amp;gt;  &amp;quot;Associate a key with a value in a map. If the key already exists in the map,&amp;lt;br&amp;gt;  a vector of values is associated with the key.&amp;quot;&amp;lt;br&amp;gt;  [map key val]&amp;lt;br&amp;gt;  (assoc map key&amp;lt;br&amp;gt;    (if-let [cur (get map key)]&amp;lt;br&amp;gt;      (if (vector? cur)&amp;lt;br&amp;gt;        (conj cur val)&amp;lt;br&amp;gt;        [cur val])&amp;lt;br&amp;gt;      val)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">assoc-conj</a>[map key val]</div></div></div><div class="row"><div class="namespace"><h4>ring.util.environment</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.environment&lt;/i&gt;&lt;b&gt;with-env&lt;/b&gt; ([env-map &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Merges the supplied map of environment variable into *env*.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro with-env&amp;lt;br&amp;gt;  &amp;quot;Merges the supplied map of environment variable into *env*.&amp;quot;&amp;lt;br&amp;gt;  [env-map &amp;amp; body]&amp;lt;br&amp;gt;  `(binding [*env* (merge *env* ~env-map)]&amp;lt;br&amp;gt;     ~@body))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">with-env</a>[env-map & body]</div></div></div><div class="row"><div class="namespace"><h4>ring.util.mime-type</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.mime-type&lt;/i&gt;&lt;b&gt;ext-mime-type&lt;/b&gt; ([filename &amp; [mime-types]])&lt;br&gt; Get the mimetype from the filename extension. Takes an optional map of&lt;br&gt;  extensions to mimetypes that overrides values in the default-mime-types map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ext-mime-type&amp;lt;br&amp;gt;  &amp;quot;Get the mimetype from the filename extension. Takes an optional map of&amp;lt;br&amp;gt;  extensions to mimetypes that overrides values in the default-mime-types map.&amp;quot;&amp;lt;br&amp;gt;  [filename &amp;amp; [mime-types]]&amp;lt;br&amp;gt;  (let [mime-types (merge default-mime-types mime-types)]&amp;lt;br&amp;gt;    (mime-types (filename-ext filename))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ext-mime-type</a>[filename & [mime-types]]</div></div></div><div class="row"><div class="namespace"><h4>ring.util.response</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.response&lt;/i&gt;&lt;b&gt;charset&lt;/b&gt; ([resp charset])&lt;br&gt; Returns an updated Ring response with the supplied charset added to the&lt;br&gt;  Content-Type header.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn charset&amp;lt;br&amp;gt;  &amp;quot;Returns an updated Ring response with the supplied charset added to the&amp;lt;br&amp;gt;  Content-Type header.&amp;quot;&amp;lt;br&amp;gt;  [resp charset]&amp;lt;br&amp;gt;  (update-in resp [:headers &amp;quot;Content-Type&amp;quot;]&amp;lt;br&amp;gt;    (fn [content-type]&amp;lt;br&amp;gt;      (-&amp;gt; (or content-type &amp;quot;text/plain&amp;quot;)&amp;lt;br&amp;gt;          (str/replace #&amp;quot;;\s*charset=[^;]*&amp;quot; &amp;quot;&amp;quot;)&amp;lt;br&amp;gt;          (str &amp;quot;; charset=&amp;quot; charset)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">charset</a>[resp charset]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.response&lt;/i&gt;&lt;b&gt;content-type&lt;/b&gt; ([resp content-type])&lt;br&gt; Returns an updated Ring response with the a Content-Type header corresponding&lt;br&gt;  to the given content-type.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn content-type&amp;lt;br&amp;gt;  &amp;quot;Returns an updated Ring response with the a Content-Type header corresponding&amp;lt;br&amp;gt;  to the given content-type.&amp;quot;&amp;lt;br&amp;gt;  [resp content-type]&amp;lt;br&amp;gt;  (header resp &amp;quot;Content-Type&amp;quot; content-type))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">content-type</a>[resp content-type]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.response&lt;/i&gt;&lt;b&gt;file-response&lt;/b&gt; ([filepath &amp; [opts]])&lt;br&gt; Returns a Ring response to serve a static file, or nil if an appropriate&lt;br&gt;  file does not exist.&lt;br&gt;  Options:&lt;br&gt;    :root            - take the filepath relative to this root path&lt;br&gt;    :index-files?    - look for index.* files in directories, defaults to true&lt;br&gt;    :allow-symlinks? - serve files through symbolic links, defaults to false&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn file-response&amp;lt;br&amp;gt;  &amp;quot;Returns a Ring response to serve a static file, or nil if an appropriate&amp;lt;br&amp;gt;  file does not exist.&amp;lt;br&amp;gt;  Options:&amp;lt;br&amp;gt;    :root            - take the filepath relative to this root path&amp;lt;br&amp;gt;    :index-files?    - look for index.* files in directories, defaults to true&amp;lt;br&amp;gt;    :allow-symlinks? - serve files through symbolic links, defaults to false&amp;quot;&amp;lt;br&amp;gt;  [filepath &amp;amp; [opts]]&amp;lt;br&amp;gt;  (if-let [file (get-file filepath opts)]&amp;lt;br&amp;gt;    (response file)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">file-response</a>[filepath & [opts]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.response&lt;/i&gt;&lt;b&gt;header&lt;/b&gt; ([resp name value])&lt;br&gt; Returns an updated Ring response with the specified header added.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn header&amp;lt;br&amp;gt;  &amp;quot;Returns an updated Ring response with the specified header added.&amp;quot;&amp;lt;br&amp;gt;  [resp name value]&amp;lt;br&amp;gt;  (assoc-in resp [:headers name] (str value)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">header</a>[resp name value]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.response&lt;/i&gt;&lt;b&gt;not-found&lt;/b&gt; ([body])&lt;br&gt; Returns a 404 'not found' response.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn not-found&amp;lt;br&amp;gt;  &amp;quot;Returns a 404 'not found' response.&amp;quot;&amp;lt;br&amp;gt;  [body]&amp;lt;br&amp;gt;  {:status  404&amp;lt;br&amp;gt;   :headers {}&amp;lt;br&amp;gt;   :body    body})&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">not-found</a>[body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.response&lt;/i&gt;&lt;b&gt;redirect&lt;/b&gt; ([url])&lt;br&gt; Returns a Ring response for an HTTP 302 redirect.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn redirect&amp;lt;br&amp;gt;  &amp;quot;Returns a Ring response for an HTTP 302 redirect.&amp;quot;&amp;lt;br&amp;gt;  [url]&amp;lt;br&amp;gt;  {:status  302&amp;lt;br&amp;gt;   :headers {&amp;quot;Location&amp;quot; url}&amp;lt;br&amp;gt;   :body    &amp;quot;&amp;quot;})&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">redirect</a>[url]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.response&lt;/i&gt;&lt;b&gt;redirect-after-post&lt;/b&gt; ([url])&lt;br&gt; Returns a Ring response for an HTTP 303 redirect.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn redirect-after-post&amp;lt;br&amp;gt;  &amp;quot;Returns a Ring response for an HTTP 303 redirect.&amp;quot;&amp;lt;br&amp;gt;  [url]&amp;lt;br&amp;gt;  {:status  303&amp;lt;br&amp;gt;   :headers {&amp;quot;Location&amp;quot; url}&amp;lt;br&amp;gt;   :body    &amp;quot;&amp;quot;})&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">redirect-after-post</a>[url]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.response&lt;/i&gt;&lt;b&gt;resource-response&lt;/b&gt; ([path &amp; [opts]])&lt;br&gt; Returns a Ring response to serve a packaged resource, or nil if the&lt;br&gt;  resource does not exist.&lt;br&gt;  Options:&lt;br&gt;    :root - take the resource relative to this root&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn resource-response&amp;lt;br&amp;gt;  &amp;quot;Returns a Ring response to serve a packaged resource, or nil if the&amp;lt;br&amp;gt;  resource does not exist.&amp;lt;br&amp;gt;  Options:&amp;lt;br&amp;gt;    :root - take the resource relative to this root&amp;quot;&amp;lt;br&amp;gt;  [path &amp;amp; [opts]]&amp;lt;br&amp;gt;  (let [path (-&amp;gt; (str (:root opts &amp;quot;&amp;quot;) &amp;quot;/&amp;quot; path)&amp;lt;br&amp;gt;                 (.replace &amp;quot;//&amp;quot; &amp;quot;/&amp;quot;)&amp;lt;br&amp;gt;                 (.replaceAll &amp;quot;^/&amp;quot; &amp;quot;&amp;quot;))]&amp;lt;br&amp;gt;    (if-let [resource (io/resource path)]&amp;lt;br&amp;gt;      (if (= &amp;quot;file&amp;quot; (.getProtocol resource))&amp;lt;br&amp;gt;        (let [file (url-as-file resource)]&amp;lt;br&amp;gt;          (if-not (.isDirectory file)&amp;lt;br&amp;gt;            (response file)))&amp;lt;br&amp;gt;        (response (io/input-stream resource))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">resource-response</a>[path & [opts]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.response&lt;/i&gt;&lt;b&gt;response&lt;/b&gt; ([body])&lt;br&gt; Returns a skeletal Ring response with the given body, status of 200, and no&lt;br&gt;  headers.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn response&amp;lt;br&amp;gt;  &amp;quot;Returns a skeletal Ring response with the given body, status of 200, and no&amp;lt;br&amp;gt;  headers.&amp;quot;&amp;lt;br&amp;gt;  [body]&amp;lt;br&amp;gt;  {:status  200&amp;lt;br&amp;gt;   :headers {}&amp;lt;br&amp;gt;   :body    body})&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">response</a>[body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.response&lt;/i&gt;&lt;b&gt;response?&lt;/b&gt; ([resp])&lt;br&gt; True if the supplied value is a valid response map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn response?&amp;lt;br&amp;gt;  &amp;quot;True if the supplied value is a valid response map.&amp;quot;&amp;lt;br&amp;gt;  [resp]&amp;lt;br&amp;gt;  (and (map? resp)&amp;lt;br&amp;gt;       (integer? (:status resp))&amp;lt;br&amp;gt;       (map? (:headers resp))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">response?</a>[resp]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.response&lt;/i&gt;&lt;b&gt;set-cookie&lt;/b&gt; ([resp name value &amp; [opts]])&lt;br&gt; Sets a cookie on the response. Requires the handler to be wrapped in the&lt;br&gt;  wrap-cookies middleware.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-cookie&amp;lt;br&amp;gt;  &amp;quot;Sets a cookie on the response. Requires the handler to be wrapped in the&amp;lt;br&amp;gt;  wrap-cookies middleware.&amp;quot;&amp;lt;br&amp;gt;  [resp name value &amp;amp; [opts]]&amp;lt;br&amp;gt;  (assoc-in resp [:cookies name] (merge {:value value} opts)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-cookie</a>[resp name value & [opts]]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.response&lt;/i&gt;&lt;b&gt;status&lt;/b&gt; ([resp status])&lt;br&gt; Returns an updated Ring response with the given status.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn status&amp;lt;br&amp;gt;  &amp;quot;Returns an updated Ring response with the given status.&amp;quot;&amp;lt;br&amp;gt;  [resp status]&amp;lt;br&amp;gt;  (assoc resp :status status))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">status</a>[resp status]</div></div></div><div class="row"><div class="namespace"><h4>ring.util.servlet</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.servlet&lt;/i&gt;&lt;b&gt;build-request-map&lt;/b&gt; ([request])&lt;br&gt; Create the request map from the HttpServletRequest object.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn build-request-map&amp;lt;br&amp;gt;  &amp;quot;Create the request map from the HttpServletRequest object.&amp;quot;&amp;lt;br&amp;gt;  [^HttpServletRequest request]&amp;lt;br&amp;gt;  {:server-port        (.getServerPort request)&amp;lt;br&amp;gt;   :server-name        (.getServerName request)&amp;lt;br&amp;gt;   :remote-addr        (.getRemoteAddr request)&amp;lt;br&amp;gt;   :uri                (.getRequestURI request)&amp;lt;br&amp;gt;   :query-string       (.getQueryString request)&amp;lt;br&amp;gt;   :scheme             (keyword (.getScheme request))&amp;lt;br&amp;gt;   :request-method     (keyword (.toLowerCase (.getMethod request)))&amp;lt;br&amp;gt;   :headers            (get-headers request)&amp;lt;br&amp;gt;   :content-type       (.getContentType request)&amp;lt;br&amp;gt;   :content-length     (get-content-length request)&amp;lt;br&amp;gt;   :character-encoding (.getCharacterEncoding request)&amp;lt;br&amp;gt;   :ssl-client-cert    (get-client-cert request)&amp;lt;br&amp;gt;   :body               (.getInputStream request)})&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">build-request-map</a>[request]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.servlet&lt;/i&gt;&lt;b&gt;defservice&lt;/b&gt; ([handler] [prefix handler])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Defines a service method with an optional prefix suitable for being used by&lt;br&gt;  genclass to compile a HttpServlet class.&lt;br&gt;  e.g. (defservice my-handler)&lt;br&gt;       (defservice &quot;my-prefix-&quot; my-handler)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro defservice&amp;lt;br&amp;gt;  &amp;quot;Defines a service method with an optional prefix suitable for being used by&amp;lt;br&amp;gt;  genclass to compile a HttpServlet class.&amp;lt;br&amp;gt;  e.g. (defservice my-handler)&amp;lt;br&amp;gt;       (defservice \&amp;quot;my-prefix-\&amp;quot; my-handler)&amp;quot;&amp;lt;br&amp;gt;  ([handler]&amp;lt;br&amp;gt;   `(defservice &amp;quot;-&amp;quot; ~handler))&amp;lt;br&amp;gt;  ([prefix handler]&amp;lt;br&amp;gt;   `(defn ~(symbol (str prefix &amp;quot;service&amp;quot;))&amp;lt;br&amp;gt;      [servlet# request# response#]&amp;lt;br&amp;gt;      ((make-service-method ~handler)&amp;lt;br&amp;gt;         servlet# request# response#))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">defservice</a>[handler] [prefix handler]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.servlet&lt;/i&gt;&lt;b&gt;get-client-cert&lt;/b&gt; ([request])&lt;br&gt; Returns the SSL client certificate of the reqest, if one exists.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-client-cert&amp;lt;br&amp;gt;  &amp;quot;Returns the SSL client certificate of the reqest, if one exists.&amp;quot;&amp;lt;br&amp;gt;  [^HttpServletRequest request]&amp;lt;br&amp;gt;  (first (.getAttribute request &amp;quot;javax.servlet.request.X509Certificate&amp;quot;)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-client-cert</a>[request]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.servlet&lt;/i&gt;&lt;b&gt;make-service-method&lt;/b&gt; ([handler])&lt;br&gt; Turns a handler into a function that takes the same arguments and has the&lt;br&gt;  same return value as the service method in the HttpServlet class.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn make-service-method&amp;lt;br&amp;gt;  &amp;quot;Turns a handler into a function that takes the same arguments and has the&amp;lt;br&amp;gt;  same return value as the service method in the HttpServlet class.&amp;quot;&amp;lt;br&amp;gt;  [handler]&amp;lt;br&amp;gt;  (fn [^HttpServlet servlet&amp;lt;br&amp;gt;       ^HttpServletRequest request&amp;lt;br&amp;gt;       ^HttpServletResponse response]&amp;lt;br&amp;gt;    (let [request-map (-&amp;gt; request&amp;lt;br&amp;gt;                        (build-request-map)&amp;lt;br&amp;gt;                        (merge-servlet-keys servlet request response))]&amp;lt;br&amp;gt;      (if-let [response-map (handler request-map)]&amp;lt;br&amp;gt;        (update-servlet-response response response-map)&amp;lt;br&amp;gt;        (throw (NullPointerException. &amp;quot;Handler returned nil&amp;quot;))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">make-service-method</a>[handler]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.servlet&lt;/i&gt;&lt;b&gt;merge-servlet-keys&lt;/b&gt; ([request-map servlet request response])&lt;br&gt; Associate servlet-specific keys with the request map for use with legacy&lt;br&gt;  systems.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn merge-servlet-keys&amp;lt;br&amp;gt;  &amp;quot;Associate servlet-specific keys with the request map for use with legacy&amp;lt;br&amp;gt;  systems.&amp;quot;&amp;lt;br&amp;gt;  [request-map&amp;lt;br&amp;gt;   ^HttpServlet servlet&amp;lt;br&amp;gt;   ^HttpServletRequest request&amp;lt;br&amp;gt;   ^HttpServletResponse response]&amp;lt;br&amp;gt;  (merge request-map&amp;lt;br&amp;gt;    {:servlet          servlet&amp;lt;br&amp;gt;     :servlet-request  request&amp;lt;br&amp;gt;     :servlet-response response&amp;lt;br&amp;gt;     :servlet-context  (.getServletContext servlet)}))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">merge-servlet-keys</a>[request-map servlet request response]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.servlet&lt;/i&gt;&lt;b&gt;servlet&lt;/b&gt; ([handler])&lt;br&gt; Create a servlet from a Ring handler..&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn servlet&amp;lt;br&amp;gt;  &amp;quot;Create a servlet from a Ring handler..&amp;quot;&amp;lt;br&amp;gt;  [handler]&amp;lt;br&amp;gt;  (proxy [HttpServlet] []&amp;lt;br&amp;gt;    (service [request response]&amp;lt;br&amp;gt;      ((make-service-method handler)&amp;lt;br&amp;gt;         this request response))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">servlet</a>[handler]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.servlet&lt;/i&gt;&lt;b&gt;set-headers&lt;/b&gt; ([response headers])&lt;br&gt; Update a HttpServletResponse with a map of headers.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-headers&amp;lt;br&amp;gt;  &amp;quot;Update a HttpServletResponse with a map of headers.&amp;quot;&amp;lt;br&amp;gt;  [^HttpServletResponse response, headers]&amp;lt;br&amp;gt;  (doseq [[key val-or-vals] headers]&amp;lt;br&amp;gt;    (if (string? val-or-vals)&amp;lt;br&amp;gt;      (.setHeader response key val-or-vals)&amp;lt;br&amp;gt;      (doseq [val val-or-vals]&amp;lt;br&amp;gt;        (.addHeader response key val))))&amp;lt;br&amp;gt;  ; Some headers must be set through specific methods&amp;lt;br&amp;gt;  (when-let [content-type (get headers &amp;quot;Content-Type&amp;quot;)]&amp;lt;br&amp;gt;    (.setContentType response content-type)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-headers</a>[response headers]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.servlet&lt;/i&gt;&lt;b&gt;set-status&lt;/b&gt; ([response status])&lt;br&gt; Update a HttpServletResponse with a status code.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn set-status&amp;lt;br&amp;gt;  &amp;quot;Update a HttpServletResponse with a status code.&amp;quot;&amp;lt;br&amp;gt;  [^HttpServletResponse response, status]&amp;lt;br&amp;gt;  (.setStatus response status))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">set-status</a>[response status]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;ring.util.servlet&lt;/i&gt;&lt;b&gt;update-servlet-response&lt;/b&gt; ([response {:keys [status headers body]}])&lt;br&gt; Update the HttpServletResponse using a response map.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn update-servlet-response&amp;lt;br&amp;gt;  &amp;quot;Update the HttpServletResponse using a response map.&amp;quot;&amp;lt;br&amp;gt;  [^HttpServletResponse response, {:keys [status headers body]}]&amp;lt;br&amp;gt;  (when-not response&amp;lt;br&amp;gt;    (throw (Exception. &amp;quot;Null response given.&amp;quot;)))&amp;lt;br&amp;gt;  (when status&amp;lt;br&amp;gt;    (set-status response status))&amp;lt;br&amp;gt;  (doto response&amp;lt;br&amp;gt;    (set-headers headers)&amp;lt;br&amp;gt;    (set-body body)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">update-servlet-response</a>[response {:keys [status headers body]}]</div></div></div><div class="row"><div class="namespace"><h4>user</h4></div></div><div class="row"><div class="namespace"><h4>watchtower.core</h4><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;changed-fn&lt;/b&gt; ([funcs])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn changed-fn [funcs]&amp;lt;br&amp;gt;  (fn [files]&amp;lt;br&amp;gt;    (doseq [f funcs]&amp;lt;br&amp;gt;      (f files))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">changed-fn</a>[funcs]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;compile-watcher&lt;/b&gt; ([{:keys [filters rate dirs on-change]}])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn compile-watcher [{:keys [filters rate dirs on-change]}]&amp;lt;br&amp;gt;  {:rate rate&amp;lt;br&amp;gt;   :updated? (updated?-fn dirs filters)&amp;lt;br&amp;gt;   :changed (changed-fn on-change)})&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">compile-watcher</a>[{:keys [filters rate dirs on-change]}]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;default-filter&lt;/b&gt; ([f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn default-filter [f] &amp;lt;br&amp;gt;  (.isFile f))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">default-filter</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;extensions&lt;/b&gt; ([&amp; exts])&lt;br&gt; Create a file-filter for the given extensions.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn extensions &amp;lt;br&amp;gt;  &amp;quot;Create a file-filter for the given extensions.&amp;quot;&amp;lt;br&amp;gt;  [&amp;amp; exts]&amp;lt;br&amp;gt;  (let [exts-set (set (map name exts))]&amp;lt;br&amp;gt;    (fn [f]&amp;lt;br&amp;gt;      (let [fname (.getName f)&amp;lt;br&amp;gt;            idx (.lastIndexOf fname &amp;quot;.&amp;quot;)&amp;lt;br&amp;gt;            cur (if-not (neg? idx) (subs fname (inc idx)))]&amp;lt;br&amp;gt;        (exts-set cur)))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">extensions</a>[& exts]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;file-filter&lt;/b&gt; ([w filt])&lt;br&gt; Add a filter to a watcher. A filter is just a function that takes in a&lt;br&gt;  java.io.File and returns truthy about whether or not it should be included.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn file-filter &amp;lt;br&amp;gt;  &amp;quot;Add a filter to a watcher. A filter is just a function that takes in a&amp;lt;br&amp;gt;  java.io.File and returns truthy about whether or not it should be included.&amp;quot;&amp;lt;br&amp;gt;  [w filt]&amp;lt;br&amp;gt;  (update-in w [:filters] conj filt))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">file-filter</a>[w filt]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;get-files&lt;/b&gt; ([dirs filters])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn get-files [dirs filters]&amp;lt;br&amp;gt;  (let [dir-files (mapcat #(-&amp;gt; % io/file file-seq) dirs)]&amp;lt;br&amp;gt;    (filter filters dir-files)))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">get-files</a>[dirs filters]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;ignore-dotfiles&lt;/b&gt; ([f])&lt;br&gt; A file-filter that removes any file that starts with a dot.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn ignore-dotfiles &amp;lt;br&amp;gt;  &amp;quot;A file-filter that removes any file that starts with a dot.&amp;quot;&amp;lt;br&amp;gt;  [f]&amp;lt;br&amp;gt;  (not= \. (first (.getName f))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">ignore-dotfiles</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;modified?&lt;/b&gt; ([f])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn modified? [f]&amp;lt;br&amp;gt;  (&amp;gt; (.lastModified f) @*last-pass*))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">modified?</a>[f]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;on-change&lt;/b&gt; ([w func])&lt;br&gt; When files are changed, execute a function that takes in a seq of the changed&lt;br&gt;  file objects.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn on-change &amp;lt;br&amp;gt;  &amp;quot;When files are changed, execute a function that takes in a seq of the changed&amp;lt;br&amp;gt;  file objects.&amp;quot;&amp;lt;br&amp;gt;  [w func]&amp;lt;br&amp;gt;  (update-in w [:on-change] conj func))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">on-change</a>[w func]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;rate&lt;/b&gt; ([w r])&lt;br&gt; Set the rate of polling.&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn rate &amp;lt;br&amp;gt;  &amp;quot;Set the rate of polling.&amp;quot;&amp;lt;br&amp;gt;  [w r]&amp;lt;br&amp;gt;  (assoc w :rate r))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">rate</a>[w r]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;updated?-fn&lt;/b&gt; ([dirs filters])&lt;br&gt; &lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn updated?-fn [dirs filters]&amp;lt;br&amp;gt;  (let [filters (conj filters default-filter)&amp;lt;br&amp;gt;        final-filter #(every? (fn [func] (func %)) filters)]&amp;lt;br&amp;gt;    (fn []&amp;lt;br&amp;gt;      (let [files (get-files dirs final-filter)&amp;lt;br&amp;gt;            results (seq (doall (filter modified? files)))]&amp;lt;br&amp;gt;        (when results &amp;lt;br&amp;gt;          (reset! *last-pass* (System/currentTimeMillis)))&amp;lt;br&amp;gt;        results))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">updated?-fn</a>[dirs filters]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;watch&lt;/b&gt; ([w])&lt;br&gt; Execute a watcher map&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn watch &amp;lt;br&amp;gt;  &amp;quot;Execute a watcher map&amp;quot;&amp;lt;br&amp;gt;  [w]&amp;lt;br&amp;gt;  (let [{:keys [updated? rate changed]} (compile-watcher w)]&amp;lt;br&amp;gt;    (binding [*last-pass* (atom 0)]&amp;lt;br&amp;gt;      (while true&amp;lt;br&amp;gt;        (Thread/sleep rate)&amp;lt;br&amp;gt;        (when-let [changes (updated?)] &amp;lt;br&amp;gt;          (changed changes))))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">watch</a>[w]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;watcher&lt;/b&gt; ([dirs &amp; body])&lt;br&gt;&lt;i&gt;Macro&lt;/i&gt;&lt;br&gt; Create a watcher for the given dirs (either a string or coll of strings), applying&lt;br&gt;  the given transformations.&lt;br&gt;&lt;br&gt;  Transformations available: (rate) (file-filter) (on-change)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defmacro watcher &amp;lt;br&amp;gt;  &amp;quot;Create a watcher for the given dirs (either a string or coll of strings), applying&amp;lt;br&amp;gt;  the given transformations.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;  Transformations available: (rate) (file-filter) (on-change)&amp;quot;&amp;lt;br&amp;gt;  [dirs &amp;amp; body]&amp;lt;br&amp;gt;  `(let [w# (-&amp;gt; ~dirs&amp;lt;br&amp;gt;                (watcher*)&amp;lt;br&amp;gt;                ~@body)]&amp;lt;br&amp;gt;     (future (watch w#))))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">watcher</a>[dirs & body]</div><div class="fn"><a data-html="true" data-original-title="&lt;div class=&quot;doc&quot;&gt;&lt;i class=&quot;right&quot;&gt;watchtower.core&lt;/i&gt;&lt;b&gt;watcher*&lt;/b&gt; ([dirs])&lt;br&gt; Create a watcher map that can later be passed to (watch)&lt;/div&gt;" data-placement="right" source="&lt;a class=&quot;fn-source&quot; data-html=&quot;true&quot; data-original-title=&quot;&amp;lt;pre&amp;gt;(defn watcher* &amp;lt;br&amp;gt;  &amp;quot;Create a watcher map that can later be passed to (watch)&amp;quot;&amp;lt;br&amp;gt;  [dirs]&amp;lt;br&amp;gt;  (let [dirs (if (string? dirs)&amp;lt;br&amp;gt;               [dirs]&amp;lt;br&amp;gt;               dirs)]  &amp;lt;br&amp;gt;    {:dirs dirs&amp;lt;br&amp;gt;     :filters []}))&amp;lt;/pre&amp;gt;&quot; data-placement=&quot;right&quot;&gt;source&lt;/a&gt;">watcher*</a>[dirs]</div></div></div></div></div><div class="span6" id="source"></div></div></div><footer><div class="container"><div class="row"><h4><a href="http://www.camsaul.com">2013 Cam Saul</a></h4></div></div></footer><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js" type="text/javascript"></script><script src="js/bootstrap-tooltip.min.js" type="text/javascript"></script><script src="js/application.js" type="text/javascript"></script></body></html>